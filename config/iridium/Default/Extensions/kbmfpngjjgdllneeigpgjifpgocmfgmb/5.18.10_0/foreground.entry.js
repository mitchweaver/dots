/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 242);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(global,factory){"use strict";if( true&&typeof module.exports==="object"){module.exports=global.document?factory(global,true):function(w){if(!w.document){throw new Error("jQuery requires a window with a document");}return factory(w);};}else{factory(global);}})(typeof window!=="undefined"?window:this,function(window,noGlobal){"use strict";var arr=[];var document=window.document;var getProto=Object.getPrototypeOf;var slice=arr.slice;var concat=arr.concat;var push=arr.push;var indexOf=arr.indexOf;var class2type={};var toString=class2type.toString;var hasOwn=class2type.hasOwnProperty;var fnToString=hasOwn.toString;var ObjectFunctionString=fnToString.call(Object);var support={};var isFunction=function(obj){return typeof obj==="function"&&typeof obj.nodeType!=="number";};var isWindow=function(obj){return obj!=null&&obj===obj.window;};var preservedScriptAttributes={type:true,src:true,nonce:true,noModule:true};function DOMEval(code,node,doc){doc=doc||document;var i,val,script=doc.createElement("script");script.text=code;if(node){for(i in preservedScriptAttributes){val=node[i]||node.getAttribute&&node.getAttribute(i);if(val){script.setAttribute(i,val);}}}doc.head.appendChild(script).parentNode.removeChild(script);}function toType(obj){if(obj==null){return obj+"";}return typeof obj==="object"||typeof obj==="function"?class2type[toString.call(obj)]||"object":typeof obj;}var version="3.4.1",jQuery=function(selector,context){return new jQuery.fn.init(selector,context);},rtrim=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;jQuery.fn=jQuery.prototype={jquery:version,constructor:jQuery,length:0,toArray:function(){return slice.call(this);},get:function(num){if(num==null){return slice.call(this);}return num<0?this[num+this.length]:this[num];},pushStack:function(elems){var ret=jQuery.merge(this.constructor(),elems);ret.prevObject=this;return ret;},each:function(callback){return jQuery.each(this,callback);},map:function(callback){return this.pushStack(jQuery.map(this,function(elem,i){return callback.call(elem,i,elem);}));},slice:function(){return this.pushStack(slice.apply(this,arguments));},first:function(){return this.eq(0);},last:function(){return this.eq(-1);},eq:function(i){var len=this.length,j=+i+(i<0?len:0);return this.pushStack(j>=0&&j<len?[this[j]]:[]);},end:function(){return this.prevObject||this.constructor();},push:push,sort:arr.sort,splice:arr.splice};jQuery.extend=jQuery.fn.extend=function(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length,deep=false;if(typeof target==="boolean"){deep=target;target=arguments[i]||{};i++;}if(typeof target!=="object"&&!isFunction(target)){target={};}if(i===length){target=this;i--;}for(;i<length;i++){if((options=arguments[i])!=null){for(name in options){copy=options[name];if(name==="__proto__"||target===copy){continue;}if(deep&&copy&&(jQuery.isPlainObject(copy)||(copyIsArray=Array.isArray(copy)))){src=target[name];if(copyIsArray&&!Array.isArray(src)){clone=[];}else if(!copyIsArray&&!jQuery.isPlainObject(src)){clone={};}else{clone=src;}copyIsArray=false;target[name]=jQuery.extend(deep,clone,copy);}else if(copy!==undefined){target[name]=copy;}}}}return target;};jQuery.extend({expando:"jQuery"+(version+Math.random()).replace(/\D/g,""),isReady:true,error:function(msg){throw new Error(msg);},noop:function(){},isPlainObject:function(obj){var proto,Ctor;if(!obj||toString.call(obj)!=="[object Object]"){return false;}proto=getProto(obj);if(!proto){return true;}Ctor=hasOwn.call(proto,"constructor")&&proto.constructor;return typeof Ctor==="function"&&fnToString.call(Ctor)===ObjectFunctionString;},isEmptyObject:function(obj){for(var name in obj){return false;}return true;},globalEval:function(code,options){DOMEval(code,{nonce:options&&options.nonce});},each:function(obj,callback){var length,i=0;if(isArrayLike(obj)){length=obj.length;for(;i<length;i++){if(callback.call(obj[i],i,obj[i])===false){break;}}}else{for(i in obj){if(callback.call(obj[i],i,obj[i])===false){break;}}}return obj;},trim:function(text){return text==null?"":(text+"").replace(rtrim,"");},makeArray:function(arr,results){var ret=results||[];if(arr!=null){if(isArrayLike(Object(arr))){jQuery.merge(ret,typeof arr==="string"?[arr]:arr);}else{push.call(ret,arr);}}return ret;},inArray:function(elem,arr,i){return arr==null?-1:indexOf.call(arr,elem,i);},merge:function(first,second){var len=+second.length,j=0,i=first.length;for(;j<len;j++){first[i++]=second[j];}first.length=i;return first;},grep:function(elems,callback,invert){var callbackInverse,matches=[],i=0,length=elems.length;for(;i<length;i++){callbackInverse=!callback(elems[i],i);if(callbackInverse!==!invert){matches.push(elems[i]);}}return matches;},map:function(elems,callback,arg){var length,value,i=0,ret=[];if(isArrayLike(elems)){length=elems.length;for(;i<length;i++){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}else{for(i in elems){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}return concat.apply([],ret);},guid:1,support:support});if(typeof Symbol==="function"){jQuery.fn[Symbol.iterator]=arr[Symbol.iterator];}jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(i,name){class2type["[object "+name+"]"]=name.toLowerCase();});function isArrayLike(obj){var length=!!obj&&"length"in obj&&obj.length,type=toType(obj);if(isFunction(obj)||isWindow(obj)){return false;}return type==="array"||length===0||typeof length==="number"&&length>0&&length-1 in obj;}var Sizzle=function(window){var i,support,Expr,getText,isXML,tokenize,compile,select,outermostContext,sortInput,hasDuplicate,setDocument,document,docElem,documentIsHTML,rbuggyQSA,rbuggyMatches,matches,contains,expando="sizzle"+1*new Date(),preferredDoc=window.document,dirruns=0,done=0,classCache=createCache(),tokenCache=createCache(),compilerCache=createCache(),nonnativeSelectorCache=createCache(),sortOrder=function(a,b){if(a===b){hasDuplicate=true;}return 0;},hasOwn={}.hasOwnProperty,arr=[],pop=arr.pop,push_native=arr.push,push=arr.push,slice=arr.slice,indexOf=function(list,elem){var i=0,len=list.length;for(;i<len;i++){if(list[i]===elem){return i;}}return-1;},booleans="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",whitespace="[\\x20\\t\\r\\n\\f]",identifier="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",attributes="\\["+whitespace+"*("+identifier+")(?:"+whitespace+"*([*^$|!~]?=)"+whitespace+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+identifier+"))|)"+whitespace+"*\\]",pseudos=":("+identifier+")(?:\\(("+"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"+"((?:\\\\.|[^\\\\()[\\]]|"+attributes+")*)|"+".*"+")\\)|)",rwhitespace=new RegExp(whitespace+"+","g"),rtrim=new RegExp("^"+whitespace+"+|((?:^|[^\\\\])(?:\\\\.)*)"+whitespace+"+$","g"),rcomma=new RegExp("^"+whitespace+"*,"+whitespace+"*"),rcombinators=new RegExp("^"+whitespace+"*([>+~]|"+whitespace+")"+whitespace+"*"),rdescend=new RegExp(whitespace+"|>"),rpseudo=new RegExp(pseudos),ridentifier=new RegExp("^"+identifier+"$"),matchExpr={"ID":new RegExp("^#("+identifier+")"),"CLASS":new RegExp("^\\.("+identifier+")"),"TAG":new RegExp("^("+identifier+"|[*])"),"ATTR":new RegExp("^"+attributes),"PSEUDO":new RegExp("^"+pseudos),"CHILD":new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+whitespace+"*(even|odd|(([+-]|)(\\d*)n|)"+whitespace+"*(?:([+-]|)"+whitespace+"*(\\d+)|))"+whitespace+"*\\)|)","i"),"bool":new RegExp("^(?:"+booleans+")$","i"),"needsContext":new RegExp("^"+whitespace+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+whitespace+"*((?:-\\d)?\\d*)"+whitespace+"*\\)|)(?=[^-]|$)","i")},rhtml=/HTML$/i,rinputs=/^(?:input|select|textarea|button)$/i,rheader=/^h\d$/i,rnative=/^[^{]+\{\s*\[native \w/,rquickExpr=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rsibling=/[+~]/,runescape=new RegExp("\\\\([\\da-f]{1,6}"+whitespace+"?|("+whitespace+")|.)","ig"),funescape=function(_,escaped,escapedWhitespace){var high="0x"+escaped-0x10000;return high!==high||escapedWhitespace?escaped:high<0?String.fromCharCode(high+0x10000):String.fromCharCode(high>>10|0xD800,high&0x3FF|0xDC00);},rcssescape=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,fcssescape=function(ch,asCodePoint){if(asCodePoint){if(ch==="\0"){return"\uFFFD";}return ch.slice(0,-1)+"\\"+ch.charCodeAt(ch.length-1).toString(16)+" ";}return"\\"+ch;},unloadHandler=function(){setDocument();},inDisabledFieldset=addCombinator(function(elem){return elem.disabled===true&&elem.nodeName.toLowerCase()==="fieldset";},{dir:"parentNode",next:"legend"});try{push.apply(arr=slice.call(preferredDoc.childNodes),preferredDoc.childNodes);arr[preferredDoc.childNodes.length].nodeType;}catch(e){push={apply:arr.length?function(target,els){push_native.apply(target,slice.call(els));}:function(target,els){var j=target.length,i=0;while(target[j++]=els[i++]){}target.length=j-1;}};}function Sizzle(selector,context,results,seed){var m,i,elem,nid,match,groups,newSelector,newContext=context&&context.ownerDocument,nodeType=context?context.nodeType:9;results=results||[];if(typeof selector!=="string"||!selector||nodeType!==1&&nodeType!==9&&nodeType!==11){return results;}if(!seed){if((context?context.ownerDocument||context:preferredDoc)!==document){setDocument(context);}context=context||document;if(documentIsHTML){if(nodeType!==11&&(match=rquickExpr.exec(selector))){if(m=match[1]){if(nodeType===9){if(elem=context.getElementById(m)){if(elem.id===m){results.push(elem);return results;}}else{return results;}}else{if(newContext&&(elem=newContext.getElementById(m))&&contains(context,elem)&&elem.id===m){results.push(elem);return results;}}}else if(match[2]){push.apply(results,context.getElementsByTagName(selector));return results;}else if((m=match[3])&&support.getElementsByClassName&&context.getElementsByClassName){push.apply(results,context.getElementsByClassName(m));return results;}}if(support.qsa&&!nonnativeSelectorCache[selector+" "]&&(!rbuggyQSA||!rbuggyQSA.test(selector))&&(nodeType!==1||context.nodeName.toLowerCase()!=="object")){newSelector=selector;newContext=context;if(nodeType===1&&rdescend.test(selector)){if(nid=context.getAttribute("id")){nid=nid.replace(rcssescape,fcssescape);}else{context.setAttribute("id",nid=expando);}groups=tokenize(selector);i=groups.length;while(i--){groups[i]="#"+nid+" "+toSelector(groups[i]);}newSelector=groups.join(",");newContext=rsibling.test(selector)&&testContext(context.parentNode)||context;}try{push.apply(results,newContext.querySelectorAll(newSelector));return results;}catch(qsaError){nonnativeSelectorCache(selector,true);}finally{if(nid===expando){context.removeAttribute("id");}}}}}return select(selector.replace(rtrim,"$1"),context,results,seed);}function createCache(){var keys=[];function cache(key,value){if(keys.push(key+" ")>Expr.cacheLength){delete cache[keys.shift()];}return cache[key+" "]=value;}return cache;}function markFunction(fn){fn[expando]=true;return fn;}function assert(fn){var el=document.createElement("fieldset");try{return!!fn(el);}catch(e){return false;}finally{if(el.parentNode){el.parentNode.removeChild(el);}el=null;}}function addHandle(attrs,handler){var arr=attrs.split("|"),i=arr.length;while(i--){Expr.attrHandle[arr[i]]=handler;}}function siblingCheck(a,b){var cur=b&&a,diff=cur&&a.nodeType===1&&b.nodeType===1&&a.sourceIndex-b.sourceIndex;if(diff){return diff;}if(cur){while(cur=cur.nextSibling){if(cur===b){return-1;}}}return a?1:-1;}function createInputPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type===type;};}function createButtonPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return(name==="input"||name==="button")&&elem.type===type;};}function createDisabledPseudo(disabled){return function(elem){if("form"in elem){if(elem.parentNode&&elem.disabled===false){if("label"in elem){if("label"in elem.parentNode){return elem.parentNode.disabled===disabled;}else{return elem.disabled===disabled;}}return elem.isDisabled===disabled||elem.isDisabled!==!disabled&&inDisabledFieldset(elem)===disabled;}return elem.disabled===disabled;}else if("label"in elem){return elem.disabled===disabled;}return false;};}function createPositionalPseudo(fn){return markFunction(function(argument){argument=+argument;return markFunction(function(seed,matches){var j,matchIndexes=fn([],seed.length,argument),i=matchIndexes.length;while(i--){if(seed[j=matchIndexes[i]]){seed[j]=!(matches[j]=seed[j]);}}});});}function testContext(context){return context&&typeof context.getElementsByTagName!=="undefined"&&context;}support=Sizzle.support={};isXML=Sizzle.isXML=function(elem){var namespace=elem.namespaceURI,docElem=(elem.ownerDocument||elem).documentElement;return!rhtml.test(namespace||docElem&&docElem.nodeName||"HTML");};setDocument=Sizzle.setDocument=function(node){var hasCompare,subWindow,doc=node?node.ownerDocument||node:preferredDoc;if(doc===document||doc.nodeType!==9||!doc.documentElement){return document;}document=doc;docElem=document.documentElement;documentIsHTML=!isXML(document);if(preferredDoc!==document&&(subWindow=document.defaultView)&&subWindow.top!==subWindow){if(subWindow.addEventListener){subWindow.addEventListener("unload",unloadHandler,false);}else if(subWindow.attachEvent){subWindow.attachEvent("onunload",unloadHandler);}}support.attributes=assert(function(el){el.className="i";return!el.getAttribute("className");});support.getElementsByTagName=assert(function(el){el.appendChild(document.createComment(""));return!el.getElementsByTagName("*").length;});support.getElementsByClassName=rnative.test(document.getElementsByClassName);support.getById=assert(function(el){docElem.appendChild(el).id=expando;return!document.getElementsByName||!document.getElementsByName(expando).length;});if(support.getById){Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){return elem.getAttribute("id")===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var elem=context.getElementById(id);return elem?[elem]:[];}};}else{Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){var node=typeof elem.getAttributeNode!=="undefined"&&elem.getAttributeNode("id");return node&&node.value===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var node,i,elems,elem=context.getElementById(id);if(elem){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}elems=context.getElementsByName(id);i=0;while(elem=elems[i++]){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}}}return[];}};}Expr.find["TAG"]=support.getElementsByTagName?function(tag,context){if(typeof context.getElementsByTagName!=="undefined"){return context.getElementsByTagName(tag);}else if(support.qsa){return context.querySelectorAll(tag);}}:function(tag,context){var elem,tmp=[],i=0,results=context.getElementsByTagName(tag);if(tag==="*"){while(elem=results[i++]){if(elem.nodeType===1){tmp.push(elem);}}return tmp;}return results;};Expr.find["CLASS"]=support.getElementsByClassName&&function(className,context){if(typeof context.getElementsByClassName!=="undefined"&&documentIsHTML){return context.getElementsByClassName(className);}};rbuggyMatches=[];rbuggyQSA=[];if(support.qsa=rnative.test(document.querySelectorAll)){assert(function(el){docElem.appendChild(el).innerHTML="<a id='"+expando+"'></a>"+"<select id='"+expando+"-\r\\' msallowcapture=''>"+"<option selected=''></option></select>";if(el.querySelectorAll("[msallowcapture^='']").length){rbuggyQSA.push("[*^$]="+whitespace+"*(?:''|\"\")");}if(!el.querySelectorAll("[selected]").length){rbuggyQSA.push("\\["+whitespace+"*(?:value|"+booleans+")");}if(!el.querySelectorAll("[id~="+expando+"-]").length){rbuggyQSA.push("~=");}if(!el.querySelectorAll(":checked").length){rbuggyQSA.push(":checked");}if(!el.querySelectorAll("a#"+expando+"+*").length){rbuggyQSA.push(".#.+[+~]");}});assert(function(el){el.innerHTML="<a href='' disabled='disabled'></a>"+"<select disabled='disabled'><option/></select>";var input=document.createElement("input");input.setAttribute("type","hidden");el.appendChild(input).setAttribute("name","D");if(el.querySelectorAll("[name=d]").length){rbuggyQSA.push("name"+whitespace+"*[*^$|!~]?=");}if(el.querySelectorAll(":enabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}docElem.appendChild(el).disabled=true;if(el.querySelectorAll(":disabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}el.querySelectorAll("*,:x");rbuggyQSA.push(",.*:");});}if(support.matchesSelector=rnative.test(matches=docElem.matches||docElem.webkitMatchesSelector||docElem.mozMatchesSelector||docElem.oMatchesSelector||docElem.msMatchesSelector)){assert(function(el){support.disconnectedMatch=matches.call(el,"*");matches.call(el,"[s!='']:x");rbuggyMatches.push("!=",pseudos);});}rbuggyQSA=rbuggyQSA.length&&new RegExp(rbuggyQSA.join("|"));rbuggyMatches=rbuggyMatches.length&&new RegExp(rbuggyMatches.join("|"));hasCompare=rnative.test(docElem.compareDocumentPosition);contains=hasCompare||rnative.test(docElem.contains)?function(a,b){var adown=a.nodeType===9?a.documentElement:a,bup=b&&b.parentNode;return a===bup||!!(bup&&bup.nodeType===1&&(adown.contains?adown.contains(bup):a.compareDocumentPosition&&a.compareDocumentPosition(bup)&16));}:function(a,b){if(b){while(b=b.parentNode){if(b===a){return true;}}}return false;};sortOrder=hasCompare?function(a,b){if(a===b){hasDuplicate=true;return 0;}var compare=!a.compareDocumentPosition-!b.compareDocumentPosition;if(compare){return compare;}compare=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1;if(compare&1||!support.sortDetached&&b.compareDocumentPosition(a)===compare){if(a===document||a.ownerDocument===preferredDoc&&contains(preferredDoc,a)){return-1;}if(b===document||b.ownerDocument===preferredDoc&&contains(preferredDoc,b)){return 1;}return sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}return compare&4?-1:1;}:function(a,b){if(a===b){hasDuplicate=true;return 0;}var cur,i=0,aup=a.parentNode,bup=b.parentNode,ap=[a],bp=[b];if(!aup||!bup){return a===document?-1:b===document?1:aup?-1:bup?1:sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}else if(aup===bup){return siblingCheck(a,b);}cur=a;while(cur=cur.parentNode){ap.unshift(cur);}cur=b;while(cur=cur.parentNode){bp.unshift(cur);}while(ap[i]===bp[i]){i++;}return i?siblingCheck(ap[i],bp[i]):ap[i]===preferredDoc?-1:bp[i]===preferredDoc?1:0;};return document;};Sizzle.matches=function(expr,elements){return Sizzle(expr,null,null,elements);};Sizzle.matchesSelector=function(elem,expr){if((elem.ownerDocument||elem)!==document){setDocument(elem);}if(support.matchesSelector&&documentIsHTML&&!nonnativeSelectorCache[expr+" "]&&(!rbuggyMatches||!rbuggyMatches.test(expr))&&(!rbuggyQSA||!rbuggyQSA.test(expr))){try{var ret=matches.call(elem,expr);if(ret||support.disconnectedMatch||elem.document&&elem.document.nodeType!==11){return ret;}}catch(e){nonnativeSelectorCache(expr,true);}}return Sizzle(expr,document,null,[elem]).length>0;};Sizzle.contains=function(context,elem){if((context.ownerDocument||context)!==document){setDocument(context);}return contains(context,elem);};Sizzle.attr=function(elem,name){if((elem.ownerDocument||elem)!==document){setDocument(elem);}var fn=Expr.attrHandle[name.toLowerCase()],val=fn&&hasOwn.call(Expr.attrHandle,name.toLowerCase())?fn(elem,name,!documentIsHTML):undefined;return val!==undefined?val:support.attributes||!documentIsHTML?elem.getAttribute(name):(val=elem.getAttributeNode(name))&&val.specified?val.value:null;};Sizzle.escape=function(sel){return(sel+"").replace(rcssescape,fcssescape);};Sizzle.error=function(msg){throw new Error("Syntax error, unrecognized expression: "+msg);};Sizzle.uniqueSort=function(results){var elem,duplicates=[],j=0,i=0;hasDuplicate=!support.detectDuplicates;sortInput=!support.sortStable&&results.slice(0);results.sort(sortOrder);if(hasDuplicate){while(elem=results[i++]){if(elem===results[i]){j=duplicates.push(i);}}while(j--){results.splice(duplicates[j],1);}}sortInput=null;return results;};getText=Sizzle.getText=function(elem){var node,ret="",i=0,nodeType=elem.nodeType;if(!nodeType){while(node=elem[i++]){ret+=getText(node);}}else if(nodeType===1||nodeType===9||nodeType===11){if(typeof elem.textContent==="string"){return elem.textContent;}else{for(elem=elem.firstChild;elem;elem=elem.nextSibling){ret+=getText(elem);}}}else if(nodeType===3||nodeType===4){return elem.nodeValue;}return ret;};Expr=Sizzle.selectors={cacheLength:50,createPseudo:markFunction,match:matchExpr,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:true}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:true},"~":{dir:"previousSibling"}},preFilter:{"ATTR":function(match){match[1]=match[1].replace(runescape,funescape);match[3]=(match[3]||match[4]||match[5]||"").replace(runescape,funescape);if(match[2]==="~="){match[3]=" "+match[3]+" ";}return match.slice(0,4);},"CHILD":function(match){match[1]=match[1].toLowerCase();if(match[1].slice(0,3)==="nth"){if(!match[3]){Sizzle.error(match[0]);}match[4]=+(match[4]?match[5]+(match[6]||1):2*(match[3]==="even"||match[3]==="odd"));match[5]=+(match[7]+match[8]||match[3]==="odd");}else if(match[3]){Sizzle.error(match[0]);}return match;},"PSEUDO":function(match){var excess,unquoted=!match[6]&&match[2];if(matchExpr["CHILD"].test(match[0])){return null;}if(match[3]){match[2]=match[4]||match[5]||"";}else if(unquoted&&rpseudo.test(unquoted)&&(excess=tokenize(unquoted,true))&&(excess=unquoted.indexOf(")",unquoted.length-excess)-unquoted.length)){match[0]=match[0].slice(0,excess);match[2]=unquoted.slice(0,excess);}return match.slice(0,3);}},filter:{"TAG":function(nodeNameSelector){var nodeName=nodeNameSelector.replace(runescape,funescape).toLowerCase();return nodeNameSelector==="*"?function(){return true;}:function(elem){return elem.nodeName&&elem.nodeName.toLowerCase()===nodeName;};},"CLASS":function(className){var pattern=classCache[className+" "];return pattern||(pattern=new RegExp("(^|"+whitespace+")"+className+"("+whitespace+"|$)"))&&classCache(className,function(elem){return pattern.test(typeof elem.className==="string"&&elem.className||typeof elem.getAttribute!=="undefined"&&elem.getAttribute("class")||"");});},"ATTR":function(name,operator,check){return function(elem){var result=Sizzle.attr(elem,name);if(result==null){return operator==="!=";}if(!operator){return true;}result+="";return operator==="="?result===check:operator==="!="?result!==check:operator==="^="?check&&result.indexOf(check)===0:operator==="*="?check&&result.indexOf(check)>-1:operator==="$="?check&&result.slice(-check.length)===check:operator==="~="?(" "+result.replace(rwhitespace," ")+" ").indexOf(check)>-1:operator==="|="?result===check||result.slice(0,check.length+1)===check+"-":false;};},"CHILD":function(type,what,argument,first,last){var simple=type.slice(0,3)!=="nth",forward=type.slice(-4)!=="last",ofType=what==="of-type";return first===1&&last===0?function(elem){return!!elem.parentNode;}:function(elem,context,xml){var cache,uniqueCache,outerCache,node,nodeIndex,start,dir=simple!==forward?"nextSibling":"previousSibling",parent=elem.parentNode,name=ofType&&elem.nodeName.toLowerCase(),useCache=!xml&&!ofType,diff=false;if(parent){if(simple){while(dir){node=elem;while(node=node[dir]){if(ofType?node.nodeName.toLowerCase()===name:node.nodeType===1){return false;}}start=dir=type==="only"&&!start&&"nextSibling";}return true;}start=[forward?parent.firstChild:parent.lastChild];if(forward&&useCache){node=parent;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex&&cache[2];node=nodeIndex&&parent.childNodes[nodeIndex];while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if(node.nodeType===1&&++diff&&node===elem){uniqueCache[type]=[dirruns,nodeIndex,diff];break;}}}else{if(useCache){node=elem;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex;}if(diff===false){while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if((ofType?node.nodeName.toLowerCase()===name:node.nodeType===1)&&++diff){if(useCache){outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});uniqueCache[type]=[dirruns,diff];}if(node===elem){break;}}}}}diff-=last;return diff===first||diff%first===0&&diff/first>=0;}};},"PSEUDO":function(pseudo,argument){var args,fn=Expr.pseudos[pseudo]||Expr.setFilters[pseudo.toLowerCase()]||Sizzle.error("unsupported pseudo: "+pseudo);if(fn[expando]){return fn(argument);}if(fn.length>1){args=[pseudo,pseudo,"",argument];return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())?markFunction(function(seed,matches){var idx,matched=fn(seed,argument),i=matched.length;while(i--){idx=indexOf(seed,matched[i]);seed[idx]=!(matches[idx]=matched[i]);}}):function(elem){return fn(elem,0,args);};}return fn;}},pseudos:{"not":markFunction(function(selector){var input=[],results=[],matcher=compile(selector.replace(rtrim,"$1"));return matcher[expando]?markFunction(function(seed,matches,context,xml){var elem,unmatched=matcher(seed,null,xml,[]),i=seed.length;while(i--){if(elem=unmatched[i]){seed[i]=!(matches[i]=elem);}}}):function(elem,context,xml){input[0]=elem;matcher(input,null,xml,results);input[0]=null;return!results.pop();};}),"has":markFunction(function(selector){return function(elem){return Sizzle(selector,elem).length>0;};}),"contains":markFunction(function(text){text=text.replace(runescape,funescape);return function(elem){return(elem.textContent||getText(elem)).indexOf(text)>-1;};}),"lang":markFunction(function(lang){if(!ridentifier.test(lang||"")){Sizzle.error("unsupported lang: "+lang);}lang=lang.replace(runescape,funescape).toLowerCase();return function(elem){var elemLang;do{if(elemLang=documentIsHTML?elem.lang:elem.getAttribute("xml:lang")||elem.getAttribute("lang")){elemLang=elemLang.toLowerCase();return elemLang===lang||elemLang.indexOf(lang+"-")===0;}}while((elem=elem.parentNode)&&elem.nodeType===1);return false;};}),"target":function(elem){var hash=window.location&&window.location.hash;return hash&&hash.slice(1)===elem.id;},"root":function(elem){return elem===docElem;},"focus":function(elem){return elem===document.activeElement&&(!document.hasFocus||document.hasFocus())&&!!(elem.type||elem.href||~elem.tabIndex);},"enabled":createDisabledPseudo(false),"disabled":createDisabledPseudo(true),"checked":function(elem){var nodeName=elem.nodeName.toLowerCase();return nodeName==="input"&&!!elem.checked||nodeName==="option"&&!!elem.selected;},"selected":function(elem){if(elem.parentNode){elem.parentNode.selectedIndex;}return elem.selected===true;},"empty":function(elem){for(elem=elem.firstChild;elem;elem=elem.nextSibling){if(elem.nodeType<6){return false;}}return true;},"parent":function(elem){return!Expr.pseudos["empty"](elem);},"header":function(elem){return rheader.test(elem.nodeName);},"input":function(elem){return rinputs.test(elem.nodeName);},"button":function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type==="button"||name==="button";},"text":function(elem){var attr;return elem.nodeName.toLowerCase()==="input"&&elem.type==="text"&&((attr=elem.getAttribute("type"))==null||attr.toLowerCase()==="text");},"first":createPositionalPseudo(function(){return[0];}),"last":createPositionalPseudo(function(matchIndexes,length){return[length-1];}),"eq":createPositionalPseudo(function(matchIndexes,length,argument){return[argument<0?argument+length:argument];}),"even":createPositionalPseudo(function(matchIndexes,length){var i=0;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"odd":createPositionalPseudo(function(matchIndexes,length){var i=1;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"lt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument>length?length:argument;for(;--i>=0;){matchIndexes.push(i);}return matchIndexes;}),"gt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument;for(;++i<length;){matchIndexes.push(i);}return matchIndexes;})}};Expr.pseudos["nth"]=Expr.pseudos["eq"];for(i in{radio:true,checkbox:true,file:true,password:true,image:true}){Expr.pseudos[i]=createInputPseudo(i);}for(i in{submit:true,reset:true}){Expr.pseudos[i]=createButtonPseudo(i);}function setFilters(){}setFilters.prototype=Expr.filters=Expr.pseudos;Expr.setFilters=new setFilters();tokenize=Sizzle.tokenize=function(selector,parseOnly){var matched,match,tokens,type,soFar,groups,preFilters,cached=tokenCache[selector+" "];if(cached){return parseOnly?0:cached.slice(0);}soFar=selector;groups=[];preFilters=Expr.preFilter;while(soFar){if(!matched||(match=rcomma.exec(soFar))){if(match){soFar=soFar.slice(match[0].length)||soFar;}groups.push(tokens=[]);}matched=false;if(match=rcombinators.exec(soFar)){matched=match.shift();tokens.push({value:matched,type:match[0].replace(rtrim," ")});soFar=soFar.slice(matched.length);}for(type in Expr.filter){if((match=matchExpr[type].exec(soFar))&&(!preFilters[type]||(match=preFilters[type](match)))){matched=match.shift();tokens.push({value:matched,type:type,matches:match});soFar=soFar.slice(matched.length);}}if(!matched){break;}}return parseOnly?soFar.length:soFar?Sizzle.error(selector):tokenCache(selector,groups).slice(0);};function toSelector(tokens){var i=0,len=tokens.length,selector="";for(;i<len;i++){selector+=tokens[i].value;}return selector;}function addCombinator(matcher,combinator,base){var dir=combinator.dir,skip=combinator.next,key=skip||dir,checkNonElements=base&&key==="parentNode",doneName=done++;return combinator.first?function(elem,context,xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){return matcher(elem,context,xml);}}return false;}:function(elem,context,xml){var oldCache,uniqueCache,outerCache,newCache=[dirruns,doneName];if(xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){if(matcher(elem,context,xml)){return true;}}}}else{while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){outerCache=elem[expando]||(elem[expando]={});uniqueCache=outerCache[elem.uniqueID]||(outerCache[elem.uniqueID]={});if(skip&&skip===elem.nodeName.toLowerCase()){elem=elem[dir]||elem;}else if((oldCache=uniqueCache[key])&&oldCache[0]===dirruns&&oldCache[1]===doneName){return newCache[2]=oldCache[2];}else{uniqueCache[key]=newCache;if(newCache[2]=matcher(elem,context,xml)){return true;}}}}}return false;};}function elementMatcher(matchers){return matchers.length>1?function(elem,context,xml){var i=matchers.length;while(i--){if(!matchers[i](elem,context,xml)){return false;}}return true;}:matchers[0];}function multipleContexts(selector,contexts,results){var i=0,len=contexts.length;for(;i<len;i++){Sizzle(selector,contexts[i],results);}return results;}function condense(unmatched,map,filter,context,xml){var elem,newUnmatched=[],i=0,len=unmatched.length;for(;i<len;i++){if(elem=unmatched[i]){if(!filter||filter(elem,context,xml)){newUnmatched.push(elem);if(map!=null){map.push(i);}}}}return newUnmatched;}function setMatcher(preFilter,selector,matcher,postFilter,postFinder,postSelector){if(postFilter&&!postFilter[expando]){postFilter=setMatcher(postFilter);}if(postFinder&&!postFinder[expando]){postFinder=setMatcher(postFinder,postSelector);}return markFunction(function(seed,results,context,xml){var temp,i,elem,preMap=[],postMap=[],preexisting=results.length,elems=seed||multipleContexts(selector||"*",context.nodeType?[context]:context,[]),matcherIn=preFilter&&(seed||!selector)?condense(elems,preMap,preFilter,context,xml):elems,matcherOut=matcher?postFinder||(seed?preFilter:preexisting||postFilter)?[]:results:matcherIn;if(matcher){matcher(matcherIn,matcherOut,context,xml);}if(postFilter){temp=condense(matcherOut,postMap);postFilter(temp,[],context,xml);i=temp.length;while(i--){if(elem=temp[i]){matcherOut[postMap[i]]=!(matcherIn[postMap[i]]=elem);}}}if(seed){if(postFinder||preFilter){if(postFinder){temp=[];i=matcherOut.length;while(i--){if(elem=matcherOut[i]){temp.push(matcherIn[i]=elem);}}postFinder(null,matcherOut=[],temp,xml);}i=matcherOut.length;while(i--){if((elem=matcherOut[i])&&(temp=postFinder?indexOf(seed,elem):preMap[i])>-1){seed[temp]=!(results[temp]=elem);}}}}else{matcherOut=condense(matcherOut===results?matcherOut.splice(preexisting,matcherOut.length):matcherOut);if(postFinder){postFinder(null,results,matcherOut,xml);}else{push.apply(results,matcherOut);}}});}function matcherFromTokens(tokens){var checkContext,matcher,j,len=tokens.length,leadingRelative=Expr.relative[tokens[0].type],implicitRelative=leadingRelative||Expr.relative[" "],i=leadingRelative?1:0,matchContext=addCombinator(function(elem){return elem===checkContext;},implicitRelative,true),matchAnyContext=addCombinator(function(elem){return indexOf(checkContext,elem)>-1;},implicitRelative,true),matchers=[function(elem,context,xml){var ret=!leadingRelative&&(xml||context!==outermostContext)||((checkContext=context).nodeType?matchContext(elem,context,xml):matchAnyContext(elem,context,xml));checkContext=null;return ret;}];for(;i<len;i++){if(matcher=Expr.relative[tokens[i].type]){matchers=[addCombinator(elementMatcher(matchers),matcher)];}else{matcher=Expr.filter[tokens[i].type].apply(null,tokens[i].matches);if(matcher[expando]){j=++i;for(;j<len;j++){if(Expr.relative[tokens[j].type]){break;}}return setMatcher(i>1&&elementMatcher(matchers),i>1&&toSelector(tokens.slice(0,i-1).concat({value:tokens[i-2].type===" "?"*":""})).replace(rtrim,"$1"),matcher,i<j&&matcherFromTokens(tokens.slice(i,j)),j<len&&matcherFromTokens(tokens=tokens.slice(j)),j<len&&toSelector(tokens));}matchers.push(matcher);}}return elementMatcher(matchers);}function matcherFromGroupMatchers(elementMatchers,setMatchers){var bySet=setMatchers.length>0,byElement=elementMatchers.length>0,superMatcher=function(seed,context,xml,results,outermost){var elem,j,matcher,matchedCount=0,i="0",unmatched=seed&&[],setMatched=[],contextBackup=outermostContext,elems=seed||byElement&&Expr.find["TAG"]("*",outermost),dirrunsUnique=dirruns+=contextBackup==null?1:Math.random()||0.1,len=elems.length;if(outermost){outermostContext=context===document||context||outermost;}for(;i!==len&&(elem=elems[i])!=null;i++){if(byElement&&elem){j=0;if(!context&&elem.ownerDocument!==document){setDocument(elem);xml=!documentIsHTML;}while(matcher=elementMatchers[j++]){if(matcher(elem,context||document,xml)){results.push(elem);break;}}if(outermost){dirruns=dirrunsUnique;}}if(bySet){if(elem=!matcher&&elem){matchedCount--;}if(seed){unmatched.push(elem);}}}matchedCount+=i;if(bySet&&i!==matchedCount){j=0;while(matcher=setMatchers[j++]){matcher(unmatched,setMatched,context,xml);}if(seed){if(matchedCount>0){while(i--){if(!(unmatched[i]||setMatched[i])){setMatched[i]=pop.call(results);}}}setMatched=condense(setMatched);}push.apply(results,setMatched);if(outermost&&!seed&&setMatched.length>0&&matchedCount+setMatchers.length>1){Sizzle.uniqueSort(results);}}if(outermost){dirruns=dirrunsUnique;outermostContext=contextBackup;}return unmatched;};return bySet?markFunction(superMatcher):superMatcher;}compile=Sizzle.compile=function(selector,match){var i,setMatchers=[],elementMatchers=[],cached=compilerCache[selector+" "];if(!cached){if(!match){match=tokenize(selector);}i=match.length;while(i--){cached=matcherFromTokens(match[i]);if(cached[expando]){setMatchers.push(cached);}else{elementMatchers.push(cached);}}cached=compilerCache(selector,matcherFromGroupMatchers(elementMatchers,setMatchers));cached.selector=selector;}return cached;};select=Sizzle.select=function(selector,context,results,seed){var i,tokens,token,type,find,compiled=typeof selector==="function"&&selector,match=!seed&&tokenize(selector=compiled.selector||selector);results=results||[];if(match.length===1){tokens=match[0]=match[0].slice(0);if(tokens.length>2&&(token=tokens[0]).type==="ID"&&context.nodeType===9&&documentIsHTML&&Expr.relative[tokens[1].type]){context=(Expr.find["ID"](token.matches[0].replace(runescape,funescape),context)||[])[0];if(!context){return results;}else if(compiled){context=context.parentNode;}selector=selector.slice(tokens.shift().value.length);}i=matchExpr["needsContext"].test(selector)?0:tokens.length;while(i--){token=tokens[i];if(Expr.relative[type=token.type]){break;}if(find=Expr.find[type]){if(seed=find(token.matches[0].replace(runescape,funescape),rsibling.test(tokens[0].type)&&testContext(context.parentNode)||context)){tokens.splice(i,1);selector=seed.length&&toSelector(tokens);if(!selector){push.apply(results,seed);return results;}break;}}}}(compiled||compile(selector,match))(seed,context,!documentIsHTML,results,!context||rsibling.test(selector)&&testContext(context.parentNode)||context);return results;};support.sortStable=expando.split("").sort(sortOrder).join("")===expando;support.detectDuplicates=!!hasDuplicate;setDocument();support.sortDetached=assert(function(el){return el.compareDocumentPosition(document.createElement("fieldset"))&1;});if(!assert(function(el){el.innerHTML="<a href='#'></a>";return el.firstChild.getAttribute("href")==="#";})){addHandle("type|href|height|width",function(elem,name,isXML){if(!isXML){return elem.getAttribute(name,name.toLowerCase()==="type"?1:2);}});}if(!support.attributes||!assert(function(el){el.innerHTML="<input/>";el.firstChild.setAttribute("value","");return el.firstChild.getAttribute("value")==="";})){addHandle("value",function(elem,name,isXML){if(!isXML&&elem.nodeName.toLowerCase()==="input"){return elem.defaultValue;}});}if(!assert(function(el){return el.getAttribute("disabled")==null;})){addHandle(booleans,function(elem,name,isXML){var val;if(!isXML){return elem[name]===true?name.toLowerCase():(val=elem.getAttributeNode(name))&&val.specified?val.value:null;}});}return Sizzle;}(window);jQuery.find=Sizzle;jQuery.expr=Sizzle.selectors;jQuery.expr[":"]=jQuery.expr.pseudos;jQuery.uniqueSort=jQuery.unique=Sizzle.uniqueSort;jQuery.text=Sizzle.getText;jQuery.isXMLDoc=Sizzle.isXML;jQuery.contains=Sizzle.contains;jQuery.escapeSelector=Sizzle.escape;var dir=function(elem,dir,until){var matched=[],truncate=until!==undefined;while((elem=elem[dir])&&elem.nodeType!==9){if(elem.nodeType===1){if(truncate&&jQuery(elem).is(until)){break;}matched.push(elem);}}return matched;};var siblings=function(n,elem){var matched=[];for(;n;n=n.nextSibling){if(n.nodeType===1&&n!==elem){matched.push(n);}}return matched;};var rneedsContext=jQuery.expr.match.needsContext;function nodeName(elem,name){return elem.nodeName&&elem.nodeName.toLowerCase()===name.toLowerCase();}var rsingleTag=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function winnow(elements,qualifier,not){if(isFunction(qualifier)){return jQuery.grep(elements,function(elem,i){return!!qualifier.call(elem,i,elem)!==not;});}if(qualifier.nodeType){return jQuery.grep(elements,function(elem){return elem===qualifier!==not;});}if(typeof qualifier!=="string"){return jQuery.grep(elements,function(elem){return indexOf.call(qualifier,elem)>-1!==not;});}return jQuery.filter(qualifier,elements,not);}jQuery.filter=function(expr,elems,not){var elem=elems[0];if(not){expr=":not("+expr+")";}if(elems.length===1&&elem.nodeType===1){return jQuery.find.matchesSelector(elem,expr)?[elem]:[];}return jQuery.find.matches(expr,jQuery.grep(elems,function(elem){return elem.nodeType===1;}));};jQuery.fn.extend({find:function(selector){var i,ret,len=this.length,self=this;if(typeof selector!=="string"){return this.pushStack(jQuery(selector).filter(function(){for(i=0;i<len;i++){if(jQuery.contains(self[i],this)){return true;}}}));}ret=this.pushStack([]);for(i=0;i<len;i++){jQuery.find(selector,self[i],ret);}return len>1?jQuery.uniqueSort(ret):ret;},filter:function(selector){return this.pushStack(winnow(this,selector||[],false));},not:function(selector){return this.pushStack(winnow(this,selector||[],true));},is:function(selector){return!!winnow(this,typeof selector==="string"&&rneedsContext.test(selector)?jQuery(selector):selector||[],false).length;}});var rootjQuery,rquickExpr=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,init=jQuery.fn.init=function(selector,context,root){var match,elem;if(!selector){return this;}root=root||rootjQuery;if(typeof selector==="string"){if(selector[0]==="<"&&selector[selector.length-1]===">"&&selector.length>=3){match=[null,selector,null];}else{match=rquickExpr.exec(selector);}if(match&&(match[1]||!context)){if(match[1]){context=context instanceof jQuery?context[0]:context;jQuery.merge(this,jQuery.parseHTML(match[1],context&&context.nodeType?context.ownerDocument||context:document,true));if(rsingleTag.test(match[1])&&jQuery.isPlainObject(context)){for(match in context){if(isFunction(this[match])){this[match](context[match]);}else{this.attr(match,context[match]);}}}return this;}else{elem=document.getElementById(match[2]);if(elem){this[0]=elem;this.length=1;}return this;}}else if(!context||context.jquery){return(context||root).find(selector);}else{return this.constructor(context).find(selector);}}else if(selector.nodeType){this[0]=selector;this.length=1;return this;}else if(isFunction(selector)){return root.ready!==undefined?root.ready(selector):selector(jQuery);}return jQuery.makeArray(selector,this);};init.prototype=jQuery.fn;rootjQuery=jQuery(document);var rparentsprev=/^(?:parents|prev(?:Until|All))/,guaranteedUnique={children:true,contents:true,next:true,prev:true};jQuery.fn.extend({has:function(target){var targets=jQuery(target,this),l=targets.length;return this.filter(function(){var i=0;for(;i<l;i++){if(jQuery.contains(this,targets[i])){return true;}}});},closest:function(selectors,context){var cur,i=0,l=this.length,matched=[],targets=typeof selectors!=="string"&&jQuery(selectors);if(!rneedsContext.test(selectors)){for(;i<l;i++){for(cur=this[i];cur&&cur!==context;cur=cur.parentNode){if(cur.nodeType<11&&(targets?targets.index(cur)>-1:cur.nodeType===1&&jQuery.find.matchesSelector(cur,selectors))){matched.push(cur);break;}}}}return this.pushStack(matched.length>1?jQuery.uniqueSort(matched):matched);},index:function(elem){if(!elem){return this[0]&&this[0].parentNode?this.first().prevAll().length:-1;}if(typeof elem==="string"){return indexOf.call(jQuery(elem),this[0]);}return indexOf.call(this,elem.jquery?elem[0]:elem);},add:function(selector,context){return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(),jQuery(selector,context))));},addBack:function(selector){return this.add(selector==null?this.prevObject:this.prevObject.filter(selector));}});function sibling(cur,dir){while((cur=cur[dir])&&cur.nodeType!==1){}return cur;}jQuery.each({parent:function(elem){var parent=elem.parentNode;return parent&&parent.nodeType!==11?parent:null;},parents:function(elem){return dir(elem,"parentNode");},parentsUntil:function(elem,i,until){return dir(elem,"parentNode",until);},next:function(elem){return sibling(elem,"nextSibling");},prev:function(elem){return sibling(elem,"previousSibling");},nextAll:function(elem){return dir(elem,"nextSibling");},prevAll:function(elem){return dir(elem,"previousSibling");},nextUntil:function(elem,i,until){return dir(elem,"nextSibling",until);},prevUntil:function(elem,i,until){return dir(elem,"previousSibling",until);},siblings:function(elem){return siblings((elem.parentNode||{}).firstChild,elem);},children:function(elem){return siblings(elem.firstChild);},contents:function(elem){if(typeof elem.contentDocument!=="undefined"){return elem.contentDocument;}if(nodeName(elem,"template")){elem=elem.content||elem;}return jQuery.merge([],elem.childNodes);}},function(name,fn){jQuery.fn[name]=function(until,selector){var matched=jQuery.map(this,fn,until);if(name.slice(-5)!=="Until"){selector=until;}if(selector&&typeof selector==="string"){matched=jQuery.filter(selector,matched);}if(this.length>1){if(!guaranteedUnique[name]){jQuery.uniqueSort(matched);}if(rparentsprev.test(name)){matched.reverse();}}return this.pushStack(matched);};});var rnothtmlwhite=/[^\x20\t\r\n\f]+/g;function createOptions(options){var object={};jQuery.each(options.match(rnothtmlwhite)||[],function(_,flag){object[flag]=true;});return object;}jQuery.Callbacks=function(options){options=typeof options==="string"?createOptions(options):jQuery.extend({},options);var firing,memory,fired,locked,list=[],queue=[],firingIndex=-1,fire=function(){locked=locked||options.once;fired=firing=true;for(;queue.length;firingIndex=-1){memory=queue.shift();while(++firingIndex<list.length){if(list[firingIndex].apply(memory[0],memory[1])===false&&options.stopOnFalse){firingIndex=list.length;memory=false;}}}if(!options.memory){memory=false;}firing=false;if(locked){if(memory){list=[];}else{list="";}}},self={add:function(){if(list){if(memory&&!firing){firingIndex=list.length-1;queue.push(memory);}(function add(args){jQuery.each(args,function(_,arg){if(isFunction(arg)){if(!options.unique||!self.has(arg)){list.push(arg);}}else if(arg&&arg.length&&toType(arg)!=="string"){add(arg);}});})(arguments);if(memory&&!firing){fire();}}return this;},remove:function(){jQuery.each(arguments,function(_,arg){var index;while((index=jQuery.inArray(arg,list,index))>-1){list.splice(index,1);if(index<=firingIndex){firingIndex--;}}});return this;},has:function(fn){return fn?jQuery.inArray(fn,list)>-1:list.length>0;},empty:function(){if(list){list=[];}return this;},disable:function(){locked=queue=[];list=memory="";return this;},disabled:function(){return!list;},lock:function(){locked=queue=[];if(!memory&&!firing){list=memory="";}return this;},locked:function(){return!!locked;},fireWith:function(context,args){if(!locked){args=args||[];args=[context,args.slice?args.slice():args];queue.push(args);if(!firing){fire();}}return this;},fire:function(){self.fireWith(this,arguments);return this;},fired:function(){return!!fired;}};return self;};function Identity(v){return v;}function Thrower(ex){throw ex;}function adoptValue(value,resolve,reject,noValue){var method;try{if(value&&isFunction(method=value.promise)){method.call(value).done(resolve).fail(reject);}else if(value&&isFunction(method=value.then)){method.call(value,resolve,reject);}else{resolve.apply(undefined,[value].slice(noValue));}}catch(value){reject.apply(undefined,[value]);}}jQuery.extend({Deferred:function(func){var tuples=[["notify","progress",jQuery.Callbacks("memory"),jQuery.Callbacks("memory"),2],["resolve","done",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),0,"resolved"],["reject","fail",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),1,"rejected"]],state="pending",promise={state:function(){return state;},always:function(){deferred.done(arguments).fail(arguments);return this;},"catch":function(fn){return promise.then(null,fn);},pipe:function(){var fns=arguments;return jQuery.Deferred(function(newDefer){jQuery.each(tuples,function(i,tuple){var fn=isFunction(fns[tuple[4]])&&fns[tuple[4]];deferred[tuple[1]](function(){var returned=fn&&fn.apply(this,arguments);if(returned&&isFunction(returned.promise)){returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);}else{newDefer[tuple[0]+"With"](this,fn?[returned]:arguments);}});});fns=null;}).promise();},then:function(onFulfilled,onRejected,onProgress){var maxDepth=0;function resolve(depth,deferred,handler,special){return function(){var that=this,args=arguments,mightThrow=function(){var returned,then;if(depth<maxDepth){return;}returned=handler.apply(that,args);if(returned===deferred.promise()){throw new TypeError("Thenable self-resolution");}then=returned&&(typeof returned==="object"||typeof returned==="function")&&returned.then;if(isFunction(then)){if(special){then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special));}else{maxDepth++;then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special),resolve(maxDepth,deferred,Identity,deferred.notifyWith));}}else{if(handler!==Identity){that=undefined;args=[returned];}(special||deferred.resolveWith)(that,args);}},process=special?mightThrow:function(){try{mightThrow();}catch(e){if(jQuery.Deferred.exceptionHook){jQuery.Deferred.exceptionHook(e,process.stackTrace);}if(depth+1>=maxDepth){if(handler!==Thrower){that=undefined;args=[e];}deferred.rejectWith(that,args);}}};if(depth){process();}else{if(jQuery.Deferred.getStackHook){process.stackTrace=jQuery.Deferred.getStackHook();}window.setTimeout(process);}};}return jQuery.Deferred(function(newDefer){tuples[0][3].add(resolve(0,newDefer,isFunction(onProgress)?onProgress:Identity,newDefer.notifyWith));tuples[1][3].add(resolve(0,newDefer,isFunction(onFulfilled)?onFulfilled:Identity));tuples[2][3].add(resolve(0,newDefer,isFunction(onRejected)?onRejected:Thrower));}).promise();},promise:function(obj){return obj!=null?jQuery.extend(obj,promise):promise;}},deferred={};jQuery.each(tuples,function(i,tuple){var list=tuple[2],stateString=tuple[5];promise[tuple[1]]=list.add;if(stateString){list.add(function(){state=stateString;},tuples[3-i][2].disable,tuples[3-i][3].disable,tuples[0][2].lock,tuples[0][3].lock);}list.add(tuple[3].fire);deferred[tuple[0]]=function(){deferred[tuple[0]+"With"](this===deferred?undefined:this,arguments);return this;};deferred[tuple[0]+"With"]=list.fireWith;});promise.promise(deferred);if(func){func.call(deferred,deferred);}return deferred;},when:function(singleValue){var remaining=arguments.length,i=remaining,resolveContexts=Array(i),resolveValues=slice.call(arguments),master=jQuery.Deferred(),updateFunc=function(i){return function(value){resolveContexts[i]=this;resolveValues[i]=arguments.length>1?slice.call(arguments):value;if(! --remaining){master.resolveWith(resolveContexts,resolveValues);}};};if(remaining<=1){adoptValue(singleValue,master.done(updateFunc(i)).resolve,master.reject,!remaining);if(master.state()==="pending"||isFunction(resolveValues[i]&&resolveValues[i].then)){return master.then();}}while(i--){adoptValue(resolveValues[i],updateFunc(i),master.reject);}return master.promise();}});var rerrorNames=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;jQuery.Deferred.exceptionHook=function(error,stack){if(window.console&&window.console.warn&&error&&rerrorNames.test(error.name)){window.console.warn("jQuery.Deferred exception: "+error.message,error.stack,stack);}};jQuery.readyException=function(error){window.setTimeout(function(){throw error;});};var readyList=jQuery.Deferred();jQuery.fn.ready=function(fn){readyList.then(fn).catch(function(error){jQuery.readyException(error);});return this;};jQuery.extend({isReady:false,readyWait:1,ready:function(wait){if(wait===true?--jQuery.readyWait:jQuery.isReady){return;}jQuery.isReady=true;if(wait!==true&&--jQuery.readyWait>0){return;}readyList.resolveWith(document,[jQuery]);}});jQuery.ready.then=readyList.then;function completed(){document.removeEventListener("DOMContentLoaded",completed);window.removeEventListener("load",completed);jQuery.ready();}if(document.readyState==="complete"||document.readyState!=="loading"&&!document.documentElement.doScroll){window.setTimeout(jQuery.ready);}else{document.addEventListener("DOMContentLoaded",completed);window.addEventListener("load",completed);}var access=function(elems,fn,key,value,chainable,emptyGet,raw){var i=0,len=elems.length,bulk=key==null;if(toType(key)==="object"){chainable=true;for(i in key){access(elems,fn,i,key[i],true,emptyGet,raw);}}else if(value!==undefined){chainable=true;if(!isFunction(value)){raw=true;}if(bulk){if(raw){fn.call(elems,value);fn=null;}else{bulk=fn;fn=function(elem,key,value){return bulk.call(jQuery(elem),value);};}}if(fn){for(;i<len;i++){fn(elems[i],key,raw?value:value.call(elems[i],i,fn(elems[i],key)));}}}if(chainable){return elems;}if(bulk){return fn.call(elems);}return len?fn(elems[0],key):emptyGet;};var rmsPrefix=/^-ms-/,rdashAlpha=/-([a-z])/g;function fcamelCase(all,letter){return letter.toUpperCase();}function camelCase(string){return string.replace(rmsPrefix,"ms-").replace(rdashAlpha,fcamelCase);}var acceptData=function(owner){return owner.nodeType===1||owner.nodeType===9||!+owner.nodeType;};function Data(){this.expando=jQuery.expando+Data.uid++;}Data.uid=1;Data.prototype={cache:function(owner){var value=owner[this.expando];if(!value){value={};if(acceptData(owner)){if(owner.nodeType){owner[this.expando]=value;}else{Object.defineProperty(owner,this.expando,{value:value,configurable:true});}}}return value;},set:function(owner,data,value){var prop,cache=this.cache(owner);if(typeof data==="string"){cache[camelCase(data)]=value;}else{for(prop in data){cache[camelCase(prop)]=data[prop];}}return cache;},get:function(owner,key){return key===undefined?this.cache(owner):owner[this.expando]&&owner[this.expando][camelCase(key)];},access:function(owner,key,value){if(key===undefined||key&&typeof key==="string"&&value===undefined){return this.get(owner,key);}this.set(owner,key,value);return value!==undefined?value:key;},remove:function(owner,key){var i,cache=owner[this.expando];if(cache===undefined){return;}if(key!==undefined){if(Array.isArray(key)){key=key.map(camelCase);}else{key=camelCase(key);key=key in cache?[key]:key.match(rnothtmlwhite)||[];}i=key.length;while(i--){delete cache[key[i]];}}if(key===undefined||jQuery.isEmptyObject(cache)){if(owner.nodeType){owner[this.expando]=undefined;}else{delete owner[this.expando];}}},hasData:function(owner){var cache=owner[this.expando];return cache!==undefined&&!jQuery.isEmptyObject(cache);}};var dataPriv=new Data();var dataUser=new Data();var rbrace=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,rmultiDash=/[A-Z]/g;function getData(data){if(data==="true"){return true;}if(data==="false"){return false;}if(data==="null"){return null;}if(data===+data+""){return+data;}if(rbrace.test(data)){return JSON.parse(data);}return data;}function dataAttr(elem,key,data){var name;if(data===undefined&&elem.nodeType===1){name="data-"+key.replace(rmultiDash,"-$&").toLowerCase();data=elem.getAttribute(name);if(typeof data==="string"){try{data=getData(data);}catch(e){}dataUser.set(elem,key,data);}else{data=undefined;}}return data;}jQuery.extend({hasData:function(elem){return dataUser.hasData(elem)||dataPriv.hasData(elem);},data:function(elem,name,data){return dataUser.access(elem,name,data);},removeData:function(elem,name){dataUser.remove(elem,name);},_data:function(elem,name,data){return dataPriv.access(elem,name,data);},_removeData:function(elem,name){dataPriv.remove(elem,name);}});jQuery.fn.extend({data:function(key,value){var i,name,data,elem=this[0],attrs=elem&&elem.attributes;if(key===undefined){if(this.length){data=dataUser.get(elem);if(elem.nodeType===1&&!dataPriv.get(elem,"hasDataAttrs")){i=attrs.length;while(i--){if(attrs[i]){name=attrs[i].name;if(name.indexOf("data-")===0){name=camelCase(name.slice(5));dataAttr(elem,name,data[name]);}}}dataPriv.set(elem,"hasDataAttrs",true);}}return data;}if(typeof key==="object"){return this.each(function(){dataUser.set(this,key);});}return access(this,function(value){var data;if(elem&&value===undefined){data=dataUser.get(elem,key);if(data!==undefined){return data;}data=dataAttr(elem,key);if(data!==undefined){return data;}return;}this.each(function(){dataUser.set(this,key,value);});},null,value,arguments.length>1,null,true);},removeData:function(key){return this.each(function(){dataUser.remove(this,key);});}});jQuery.extend({queue:function(elem,type,data){var queue;if(elem){type=(type||"fx")+"queue";queue=dataPriv.get(elem,type);if(data){if(!queue||Array.isArray(data)){queue=dataPriv.access(elem,type,jQuery.makeArray(data));}else{queue.push(data);}}return queue||[];}},dequeue:function(elem,type){type=type||"fx";var queue=jQuery.queue(elem,type),startLength=queue.length,fn=queue.shift(),hooks=jQuery._queueHooks(elem,type),next=function(){jQuery.dequeue(elem,type);};if(fn==="inprogress"){fn=queue.shift();startLength--;}if(fn){if(type==="fx"){queue.unshift("inprogress");}delete hooks.stop;fn.call(elem,next,hooks);}if(!startLength&&hooks){hooks.empty.fire();}},_queueHooks:function(elem,type){var key=type+"queueHooks";return dataPriv.get(elem,key)||dataPriv.access(elem,key,{empty:jQuery.Callbacks("once memory").add(function(){dataPriv.remove(elem,[type+"queue",key]);})});}});jQuery.fn.extend({queue:function(type,data){var setter=2;if(typeof type!=="string"){data=type;type="fx";setter--;}if(arguments.length<setter){return jQuery.queue(this[0],type);}return data===undefined?this:this.each(function(){var queue=jQuery.queue(this,type,data);jQuery._queueHooks(this,type);if(type==="fx"&&queue[0]!=="inprogress"){jQuery.dequeue(this,type);}});},dequeue:function(type){return this.each(function(){jQuery.dequeue(this,type);});},clearQueue:function(type){return this.queue(type||"fx",[]);},promise:function(type,obj){var tmp,count=1,defer=jQuery.Deferred(),elements=this,i=this.length,resolve=function(){if(! --count){defer.resolveWith(elements,[elements]);}};if(typeof type!=="string"){obj=type;type=undefined;}type=type||"fx";while(i--){tmp=dataPriv.get(elements[i],type+"queueHooks");if(tmp&&tmp.empty){count++;tmp.empty.add(resolve);}}resolve();return defer.promise(obj);}});var pnum=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;var rcssNum=new RegExp("^(?:([+-])=|)("+pnum+")([a-z%]*)$","i");var cssExpand=["Top","Right","Bottom","Left"];var documentElement=document.documentElement;var isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem);},composed={composed:true};if(documentElement.getRootNode){isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem)||elem.getRootNode(composed)===elem.ownerDocument;};}var isHiddenWithinTree=function(elem,el){elem=el||elem;return elem.style.display==="none"||elem.style.display===""&&isAttached(elem)&&jQuery.css(elem,"display")==="none";};var swap=function(elem,options,callback,args){var ret,name,old={};for(name in options){old[name]=elem.style[name];elem.style[name]=options[name];}ret=callback.apply(elem,args||[]);for(name in options){elem.style[name]=old[name];}return ret;};function adjustCSS(elem,prop,valueParts,tween){var adjusted,scale,maxIterations=20,currentValue=tween?function(){return tween.cur();}:function(){return jQuery.css(elem,prop,"");},initial=currentValue(),unit=valueParts&&valueParts[3]||(jQuery.cssNumber[prop]?"":"px"),initialInUnit=elem.nodeType&&(jQuery.cssNumber[prop]||unit!=="px"&&+initial)&&rcssNum.exec(jQuery.css(elem,prop));if(initialInUnit&&initialInUnit[3]!==unit){initial=initial/2;unit=unit||initialInUnit[3];initialInUnit=+initial||1;while(maxIterations--){jQuery.style(elem,prop,initialInUnit+unit);if((1-scale)*(1-(scale=currentValue()/initial||0.5))<=0){maxIterations=0;}initialInUnit=initialInUnit/scale;}initialInUnit=initialInUnit*2;jQuery.style(elem,prop,initialInUnit+unit);valueParts=valueParts||[];}if(valueParts){initialInUnit=+initialInUnit||+initial||0;adjusted=valueParts[1]?initialInUnit+(valueParts[1]+1)*valueParts[2]:+valueParts[2];if(tween){tween.unit=unit;tween.start=initialInUnit;tween.end=adjusted;}}return adjusted;}var defaultDisplayMap={};function getDefaultDisplay(elem){var temp,doc=elem.ownerDocument,nodeName=elem.nodeName,display=defaultDisplayMap[nodeName];if(display){return display;}temp=doc.body.appendChild(doc.createElement(nodeName));display=jQuery.css(temp,"display");temp.parentNode.removeChild(temp);if(display==="none"){display="block";}defaultDisplayMap[nodeName]=display;return display;}function showHide(elements,show){var display,elem,values=[],index=0,length=elements.length;for(;index<length;index++){elem=elements[index];if(!elem.style){continue;}display=elem.style.display;if(show){if(display==="none"){values[index]=dataPriv.get(elem,"display")||null;if(!values[index]){elem.style.display="";}}if(elem.style.display===""&&isHiddenWithinTree(elem)){values[index]=getDefaultDisplay(elem);}}else{if(display!=="none"){values[index]="none";dataPriv.set(elem,"display",display);}}}for(index=0;index<length;index++){if(values[index]!=null){elements[index].style.display=values[index];}}return elements;}jQuery.fn.extend({show:function(){return showHide(this,true);},hide:function(){return showHide(this);},toggle:function(state){if(typeof state==="boolean"){return state?this.show():this.hide();}return this.each(function(){if(isHiddenWithinTree(this)){jQuery(this).show();}else{jQuery(this).hide();}});}});var rcheckableType=/^(?:checkbox|radio)$/i;var rtagName=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i;var rscriptType=/^$|^module$|\/(?:java|ecma)script/i;var wrapMap={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};wrapMap.optgroup=wrapMap.option;wrapMap.tbody=wrapMap.tfoot=wrapMap.colgroup=wrapMap.caption=wrapMap.thead;wrapMap.th=wrapMap.td;function getAll(context,tag){var ret;if(typeof context.getElementsByTagName!=="undefined"){ret=context.getElementsByTagName(tag||"*");}else if(typeof context.querySelectorAll!=="undefined"){ret=context.querySelectorAll(tag||"*");}else{ret=[];}if(tag===undefined||tag&&nodeName(context,tag)){return jQuery.merge([context],ret);}return ret;}function setGlobalEval(elems,refElements){var i=0,l=elems.length;for(;i<l;i++){dataPriv.set(elems[i],"globalEval",!refElements||dataPriv.get(refElements[i],"globalEval"));}}var rhtml=/<|&#?\w+;/;function buildFragment(elems,context,scripts,selection,ignored){var elem,tmp,tag,wrap,attached,j,fragment=context.createDocumentFragment(),nodes=[],i=0,l=elems.length;for(;i<l;i++){elem=elems[i];if(elem||elem===0){if(toType(elem)==="object"){jQuery.merge(nodes,elem.nodeType?[elem]:elem);}else if(!rhtml.test(elem)){nodes.push(context.createTextNode(elem));}else{tmp=tmp||fragment.appendChild(context.createElement("div"));tag=(rtagName.exec(elem)||["",""])[1].toLowerCase();wrap=wrapMap[tag]||wrapMap._default;tmp.innerHTML=wrap[1]+jQuery.htmlPrefilter(elem)+wrap[2];j=wrap[0];while(j--){tmp=tmp.lastChild;}jQuery.merge(nodes,tmp.childNodes);tmp=fragment.firstChild;tmp.textContent="";}}}fragment.textContent="";i=0;while(elem=nodes[i++]){if(selection&&jQuery.inArray(elem,selection)>-1){if(ignored){ignored.push(elem);}continue;}attached=isAttached(elem);tmp=getAll(fragment.appendChild(elem),"script");if(attached){setGlobalEval(tmp);}if(scripts){j=0;while(elem=tmp[j++]){if(rscriptType.test(elem.type||"")){scripts.push(elem);}}}}return fragment;}(function(){var fragment=document.createDocumentFragment(),div=fragment.appendChild(document.createElement("div")),input=document.createElement("input");input.setAttribute("type","radio");input.setAttribute("checked","checked");input.setAttribute("name","t");div.appendChild(input);support.checkClone=div.cloneNode(true).cloneNode(true).lastChild.checked;div.innerHTML="<textarea>x</textarea>";support.noCloneChecked=!!div.cloneNode(true).lastChild.defaultValue;})();var rkeyEvent=/^key/,rmouseEvent=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,rtypenamespace=/^([^.]*)(?:\.(.+)|)/;function returnTrue(){return true;}function returnFalse(){return false;}function expectSync(elem,type){return elem===safeActiveElement()===(type==="focus");}function safeActiveElement(){try{return document.activeElement;}catch(err){}}function on(elem,types,selector,data,fn,one){var origFn,type;if(typeof types==="object"){if(typeof selector!=="string"){data=data||selector;selector=undefined;}for(type in types){on(elem,type,selector,data,types[type],one);}return elem;}if(data==null&&fn==null){fn=selector;data=selector=undefined;}else if(fn==null){if(typeof selector==="string"){fn=data;data=undefined;}else{fn=data;data=selector;selector=undefined;}}if(fn===false){fn=returnFalse;}else if(!fn){return elem;}if(one===1){origFn=fn;fn=function(event){jQuery().off(event);return origFn.apply(this,arguments);};fn.guid=origFn.guid||(origFn.guid=jQuery.guid++);}return elem.each(function(){jQuery.event.add(this,types,fn,data,selector);});}jQuery.event={global:{},add:function(elem,types,handler,data,selector){var handleObjIn,eventHandle,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.get(elem);if(!elemData){return;}if(handler.handler){handleObjIn=handler;handler=handleObjIn.handler;selector=handleObjIn.selector;}if(selector){jQuery.find.matchesSelector(documentElement,selector);}if(!handler.guid){handler.guid=jQuery.guid++;}if(!(events=elemData.events)){events=elemData.events={};}if(!(eventHandle=elemData.handle)){eventHandle=elemData.handle=function(e){return typeof jQuery!=="undefined"&&jQuery.event.triggered!==e.type?jQuery.event.dispatch.apply(elem,arguments):undefined;};}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;special=jQuery.event.special[type]||{};handleObj=jQuery.extend({type:type,origType:origType,data:data,handler:handler,guid:handler.guid,selector:selector,needsContext:selector&&jQuery.expr.match.needsContext.test(selector),namespace:namespaces.join(".")},handleObjIn);if(!(handlers=events[type])){handlers=events[type]=[];handlers.delegateCount=0;if(!special.setup||special.setup.call(elem,data,namespaces,eventHandle)===false){if(elem.addEventListener){elem.addEventListener(type,eventHandle);}}}if(special.add){special.add.call(elem,handleObj);if(!handleObj.handler.guid){handleObj.handler.guid=handler.guid;}}if(selector){handlers.splice(handlers.delegateCount++,0,handleObj);}else{handlers.push(handleObj);}jQuery.event.global[type]=true;}},remove:function(elem,types,handler,selector,mappedTypes){var j,origCount,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.hasData(elem)&&dataPriv.get(elem);if(!elemData||!(events=elemData.events)){return;}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){for(type in events){jQuery.event.remove(elem,type+types[t],handler,selector,true);}continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;handlers=events[type]||[];tmp=tmp[2]&&new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)");origCount=j=handlers.length;while(j--){handleObj=handlers[j];if((mappedTypes||origType===handleObj.origType)&&(!handler||handler.guid===handleObj.guid)&&(!tmp||tmp.test(handleObj.namespace))&&(!selector||selector===handleObj.selector||selector==="**"&&handleObj.selector)){handlers.splice(j,1);if(handleObj.selector){handlers.delegateCount--;}if(special.remove){special.remove.call(elem,handleObj);}}}if(origCount&&!handlers.length){if(!special.teardown||special.teardown.call(elem,namespaces,elemData.handle)===false){jQuery.removeEvent(elem,type,elemData.handle);}delete events[type];}}if(jQuery.isEmptyObject(events)){dataPriv.remove(elem,"handle events");}},dispatch:function(nativeEvent){var event=jQuery.event.fix(nativeEvent);var i,j,ret,matched,handleObj,handlerQueue,args=new Array(arguments.length),handlers=(dataPriv.get(this,"events")||{})[event.type]||[],special=jQuery.event.special[event.type]||{};args[0]=event;for(i=1;i<arguments.length;i++){args[i]=arguments[i];}event.delegateTarget=this;if(special.preDispatch&&special.preDispatch.call(this,event)===false){return;}handlerQueue=jQuery.event.handlers.call(this,event,handlers);i=0;while((matched=handlerQueue[i++])&&!event.isPropagationStopped()){event.currentTarget=matched.elem;j=0;while((handleObj=matched.handlers[j++])&&!event.isImmediatePropagationStopped()){if(!event.rnamespace||handleObj.namespace===false||event.rnamespace.test(handleObj.namespace)){event.handleObj=handleObj;event.data=handleObj.data;ret=((jQuery.event.special[handleObj.origType]||{}).handle||handleObj.handler).apply(matched.elem,args);if(ret!==undefined){if((event.result=ret)===false){event.preventDefault();event.stopPropagation();}}}}}if(special.postDispatch){special.postDispatch.call(this,event);}return event.result;},handlers:function(event,handlers){var i,handleObj,sel,matchedHandlers,matchedSelectors,handlerQueue=[],delegateCount=handlers.delegateCount,cur=event.target;if(delegateCount&&cur.nodeType&&!(event.type==="click"&&event.button>=1)){for(;cur!==this;cur=cur.parentNode||this){if(cur.nodeType===1&&!(event.type==="click"&&cur.disabled===true)){matchedHandlers=[];matchedSelectors={};for(i=0;i<delegateCount;i++){handleObj=handlers[i];sel=handleObj.selector+" ";if(matchedSelectors[sel]===undefined){matchedSelectors[sel]=handleObj.needsContext?jQuery(sel,this).index(cur)>-1:jQuery.find(sel,this,null,[cur]).length;}if(matchedSelectors[sel]){matchedHandlers.push(handleObj);}}if(matchedHandlers.length){handlerQueue.push({elem:cur,handlers:matchedHandlers});}}}}cur=this;if(delegateCount<handlers.length){handlerQueue.push({elem:cur,handlers:handlers.slice(delegateCount)});}return handlerQueue;},addProp:function(name,hook){Object.defineProperty(jQuery.Event.prototype,name,{enumerable:true,configurable:true,get:isFunction(hook)?function(){if(this.originalEvent){return hook(this.originalEvent);}}:function(){if(this.originalEvent){return this.originalEvent[name];}},set:function(value){Object.defineProperty(this,name,{enumerable:true,configurable:true,writable:true,value:value});}});},fix:function(originalEvent){return originalEvent[jQuery.expando]?originalEvent:new jQuery.Event(originalEvent);},special:{load:{noBubble:true},click:{setup:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")){leverageNative(el,"click",returnTrue);}return false;},trigger:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")){leverageNative(el,"click");}return true;},_default:function(event){var target=event.target;return rcheckableType.test(target.type)&&target.click&&nodeName(target,"input")&&dataPriv.get(target,"click")||nodeName(target,"a");}},beforeunload:{postDispatch:function(event){if(event.result!==undefined&&event.originalEvent){event.originalEvent.returnValue=event.result;}}}}};function leverageNative(el,type,expectSync){if(!expectSync){if(dataPriv.get(el,type)===undefined){jQuery.event.add(el,type,returnTrue);}return;}dataPriv.set(el,type,false);jQuery.event.add(el,type,{namespace:false,handler:function(event){var notAsync,result,saved=dataPriv.get(this,type);if(event.isTrigger&1&&this[type]){if(!saved.length){saved=slice.call(arguments);dataPriv.set(this,type,saved);notAsync=expectSync(this,type);this[type]();result=dataPriv.get(this,type);if(saved!==result||notAsync){dataPriv.set(this,type,false);}else{result={};}if(saved!==result){event.stopImmediatePropagation();event.preventDefault();return result.value;}}else if((jQuery.event.special[type]||{}).delegateType){event.stopPropagation();}}else if(saved.length){dataPriv.set(this,type,{value:jQuery.event.trigger(jQuery.extend(saved[0],jQuery.Event.prototype),saved.slice(1),this)});event.stopImmediatePropagation();}}});}jQuery.removeEvent=function(elem,type,handle){if(elem.removeEventListener){elem.removeEventListener(type,handle);}};jQuery.Event=function(src,props){if(!(this instanceof jQuery.Event)){return new jQuery.Event(src,props);}if(src&&src.type){this.originalEvent=src;this.type=src.type;this.isDefaultPrevented=src.defaultPrevented||src.defaultPrevented===undefined&&src.returnValue===false?returnTrue:returnFalse;this.target=src.target&&src.target.nodeType===3?src.target.parentNode:src.target;this.currentTarget=src.currentTarget;this.relatedTarget=src.relatedTarget;}else{this.type=src;}if(props){jQuery.extend(this,props);}this.timeStamp=src&&src.timeStamp||Date.now();this[jQuery.expando]=true;};jQuery.Event.prototype={constructor:jQuery.Event,isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,isSimulated:false,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue;if(e&&!this.isSimulated){e.preventDefault();}},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopPropagation();}},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopImmediatePropagation();}this.stopPropagation();}};jQuery.each({altKey:true,bubbles:true,cancelable:true,changedTouches:true,ctrlKey:true,detail:true,eventPhase:true,metaKey:true,pageX:true,pageY:true,shiftKey:true,view:true,"char":true,code:true,charCode:true,key:true,keyCode:true,button:true,buttons:true,clientX:true,clientY:true,offsetX:true,offsetY:true,pointerId:true,pointerType:true,screenX:true,screenY:true,targetTouches:true,toElement:true,touches:true,which:function(event){var button=event.button;if(event.which==null&&rkeyEvent.test(event.type)){return event.charCode!=null?event.charCode:event.keyCode;}if(!event.which&&button!==undefined&&rmouseEvent.test(event.type)){if(button&1){return 1;}if(button&2){return 3;}if(button&4){return 2;}return 0;}return event.which;}},jQuery.event.addProp);jQuery.each({focus:"focusin",blur:"focusout"},function(type,delegateType){jQuery.event.special[type]={setup:function(){leverageNative(this,type,expectSync);return false;},trigger:function(){leverageNative(this,type);return true;},delegateType:delegateType};});jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(orig,fix){jQuery.event.special[orig]={delegateType:fix,bindType:fix,handle:function(event){var ret,target=this,related=event.relatedTarget,handleObj=event.handleObj;if(!related||related!==target&&!jQuery.contains(target,related)){event.type=handleObj.origType;ret=handleObj.handler.apply(this,arguments);event.type=fix;}return ret;}};});jQuery.fn.extend({on:function(types,selector,data,fn){return on(this,types,selector,data,fn);},one:function(types,selector,data,fn){return on(this,types,selector,data,fn,1);},off:function(types,selector,fn){var handleObj,type;if(types&&types.preventDefault&&types.handleObj){handleObj=types.handleObj;jQuery(types.delegateTarget).off(handleObj.namespace?handleObj.origType+"."+handleObj.namespace:handleObj.origType,handleObj.selector,handleObj.handler);return this;}if(typeof types==="object"){for(type in types){this.off(type,selector,types[type]);}return this;}if(selector===false||typeof selector==="function"){fn=selector;selector=undefined;}if(fn===false){fn=returnFalse;}return this.each(function(){jQuery.event.remove(this,types,fn,selector);});}});var rxhtmlTag=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,rnoInnerhtml=/<script|<style|<link/i,rchecked=/checked\s*(?:[^=]|=\s*.checked.)/i,rcleanScript=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function manipulationTarget(elem,content){if(nodeName(elem,"table")&&nodeName(content.nodeType!==11?content:content.firstChild,"tr")){return jQuery(elem).children("tbody")[0]||elem;}return elem;}function disableScript(elem){elem.type=(elem.getAttribute("type")!==null)+"/"+elem.type;return elem;}function restoreScript(elem){if((elem.type||"").slice(0,5)==="true/"){elem.type=elem.type.slice(5);}else{elem.removeAttribute("type");}return elem;}function cloneCopyEvent(src,dest){var i,l,type,pdataOld,pdataCur,udataOld,udataCur,events;if(dest.nodeType!==1){return;}if(dataPriv.hasData(src)){pdataOld=dataPriv.access(src);pdataCur=dataPriv.set(dest,pdataOld);events=pdataOld.events;if(events){delete pdataCur.handle;pdataCur.events={};for(type in events){for(i=0,l=events[type].length;i<l;i++){jQuery.event.add(dest,type,events[type][i]);}}}}if(dataUser.hasData(src)){udataOld=dataUser.access(src);udataCur=jQuery.extend({},udataOld);dataUser.set(dest,udataCur);}}function fixInput(src,dest){var nodeName=dest.nodeName.toLowerCase();if(nodeName==="input"&&rcheckableType.test(src.type)){dest.checked=src.checked;}else if(nodeName==="input"||nodeName==="textarea"){dest.defaultValue=src.defaultValue;}}function domManip(collection,args,callback,ignored){args=concat.apply([],args);var fragment,first,scripts,hasScripts,node,doc,i=0,l=collection.length,value=args[0],valueIsFunction=isFunction(value);if(valueIsFunction||l>1&&typeof value==="string"&&!support.checkClone&&rchecked.test(value)){return collection.each(function(index){var self=collection.eq(index);if(valueIsFunction){args[0]=value.call(this,index,self.html());}domManip(self,args,callback,ignored);});}if(l){fragment=buildFragment(args,collection[0].ownerDocument,false,collection,ignored);first=fragment.firstChild;if(fragment.childNodes.length===1){fragment=first;}if(first||ignored){scripts=jQuery.map(getAll(fragment,"script"),disableScript);hasScripts=scripts.length;for(;i<l;i++){node=fragment;if(i!==l-1){node=jQuery.clone(node,true,true);if(hasScripts){jQuery.merge(scripts,getAll(node,"script"));}}callback.call(collection[i],node,i);}if(hasScripts){doc=scripts[scripts.length-1].ownerDocument;jQuery.map(scripts,restoreScript);for(i=0;i<hasScripts;i++){node=scripts[i];if(rscriptType.test(node.type||"")&&!dataPriv.access(node,"globalEval")&&jQuery.contains(doc,node)){if(node.src&&(node.type||"").toLowerCase()!=="module"){if(jQuery._evalUrl&&!node.noModule){jQuery._evalUrl(node.src,{nonce:node.nonce||node.getAttribute("nonce")});}}else{DOMEval(node.textContent.replace(rcleanScript,""),node,doc);}}}}}}return collection;}function remove(elem,selector,keepData){var node,nodes=selector?jQuery.filter(selector,elem):elem,i=0;for(;(node=nodes[i])!=null;i++){if(!keepData&&node.nodeType===1){jQuery.cleanData(getAll(node));}if(node.parentNode){if(keepData&&isAttached(node)){setGlobalEval(getAll(node,"script"));}node.parentNode.removeChild(node);}}return elem;}jQuery.extend({htmlPrefilter:function(html){return html.replace(rxhtmlTag,"<$1></$2>");},clone:function(elem,dataAndEvents,deepDataAndEvents){var i,l,srcElements,destElements,clone=elem.cloneNode(true),inPage=isAttached(elem);if(!support.noCloneChecked&&(elem.nodeType===1||elem.nodeType===11)&&!jQuery.isXMLDoc(elem)){destElements=getAll(clone);srcElements=getAll(elem);for(i=0,l=srcElements.length;i<l;i++){fixInput(srcElements[i],destElements[i]);}}if(dataAndEvents){if(deepDataAndEvents){srcElements=srcElements||getAll(elem);destElements=destElements||getAll(clone);for(i=0,l=srcElements.length;i<l;i++){cloneCopyEvent(srcElements[i],destElements[i]);}}else{cloneCopyEvent(elem,clone);}}destElements=getAll(clone,"script");if(destElements.length>0){setGlobalEval(destElements,!inPage&&getAll(elem,"script"));}return clone;},cleanData:function(elems){var data,elem,type,special=jQuery.event.special,i=0;for(;(elem=elems[i])!==undefined;i++){if(acceptData(elem)){if(data=elem[dataPriv.expando]){if(data.events){for(type in data.events){if(special[type]){jQuery.event.remove(elem,type);}else{jQuery.removeEvent(elem,type,data.handle);}}}elem[dataPriv.expando]=undefined;}if(elem[dataUser.expando]){elem[dataUser.expando]=undefined;}}}}});jQuery.fn.extend({detach:function(selector){return remove(this,selector,true);},remove:function(selector){return remove(this,selector);},text:function(value){return access(this,function(value){return value===undefined?jQuery.text(this):this.empty().each(function(){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){this.textContent=value;}});},null,value,arguments.length);},append:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.appendChild(elem);}});},prepend:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.insertBefore(elem,target.firstChild);}});},before:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this);}});},after:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this.nextSibling);}});},empty:function(){var elem,i=0;for(;(elem=this[i])!=null;i++){if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.textContent="";}}return this;},clone:function(dataAndEvents,deepDataAndEvents){dataAndEvents=dataAndEvents==null?false:dataAndEvents;deepDataAndEvents=deepDataAndEvents==null?dataAndEvents:deepDataAndEvents;return this.map(function(){return jQuery.clone(this,dataAndEvents,deepDataAndEvents);});},html:function(value){return access(this,function(value){var elem=this[0]||{},i=0,l=this.length;if(value===undefined&&elem.nodeType===1){return elem.innerHTML;}if(typeof value==="string"&&!rnoInnerhtml.test(value)&&!wrapMap[(rtagName.exec(value)||["",""])[1].toLowerCase()]){value=jQuery.htmlPrefilter(value);try{for(;i<l;i++){elem=this[i]||{};if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.innerHTML=value;}}elem=0;}catch(e){}}if(elem){this.empty().append(value);}},null,value,arguments.length);},replaceWith:function(){var ignored=[];return domManip(this,arguments,function(elem){var parent=this.parentNode;if(jQuery.inArray(this,ignored)<0){jQuery.cleanData(getAll(this));if(parent){parent.replaceChild(elem,this);}}},ignored);}});jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(name,original){jQuery.fn[name]=function(selector){var elems,ret=[],insert=jQuery(selector),last=insert.length-1,i=0;for(;i<=last;i++){elems=i===last?this:this.clone(true);jQuery(insert[i])[original](elems);push.apply(ret,elems.get());}return this.pushStack(ret);};});var rnumnonpx=new RegExp("^("+pnum+")(?!px)[a-z%]+$","i");var getStyles=function(elem){var view=elem.ownerDocument.defaultView;if(!view||!view.opener){view=window;}return view.getComputedStyle(elem);};var rboxStyle=new RegExp(cssExpand.join("|"),"i");(function(){function computeStyleTests(){if(!div){return;}container.style.cssText="position:absolute;left:-11111px;width:60px;"+"margin-top:1px;padding:0;border:0";div.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;"+"margin:auto;border:1px;padding:1px;"+"width:60%;top:1%";documentElement.appendChild(container).appendChild(div);var divStyle=window.getComputedStyle(div);pixelPositionVal=divStyle.top!=="1%";reliableMarginLeftVal=roundPixelMeasures(divStyle.marginLeft)===12;div.style.right="60%";pixelBoxStylesVal=roundPixelMeasures(divStyle.right)===36;boxSizingReliableVal=roundPixelMeasures(divStyle.width)===36;div.style.position="absolute";scrollboxSizeVal=roundPixelMeasures(div.offsetWidth/3)===12;documentElement.removeChild(container);div=null;}function roundPixelMeasures(measure){return Math.round(parseFloat(measure));}var pixelPositionVal,boxSizingReliableVal,scrollboxSizeVal,pixelBoxStylesVal,reliableMarginLeftVal,container=document.createElement("div"),div=document.createElement("div");if(!div.style){return;}div.style.backgroundClip="content-box";div.cloneNode(true).style.backgroundClip="";support.clearCloneStyle=div.style.backgroundClip==="content-box";jQuery.extend(support,{boxSizingReliable:function(){computeStyleTests();return boxSizingReliableVal;},pixelBoxStyles:function(){computeStyleTests();return pixelBoxStylesVal;},pixelPosition:function(){computeStyleTests();return pixelPositionVal;},reliableMarginLeft:function(){computeStyleTests();return reliableMarginLeftVal;},scrollboxSize:function(){computeStyleTests();return scrollboxSizeVal;}});})();function curCSS(elem,name,computed){var width,minWidth,maxWidth,ret,style=elem.style;computed=computed||getStyles(elem);if(computed){ret=computed.getPropertyValue(name)||computed[name];if(ret===""&&!isAttached(elem)){ret=jQuery.style(elem,name);}if(!support.pixelBoxStyles()&&rnumnonpx.test(ret)&&rboxStyle.test(name)){width=style.width;minWidth=style.minWidth;maxWidth=style.maxWidth;style.minWidth=style.maxWidth=style.width=ret;ret=computed.width;style.width=width;style.minWidth=minWidth;style.maxWidth=maxWidth;}}return ret!==undefined?ret+"":ret;}function addGetHookIf(conditionFn,hookFn){return{get:function(){if(conditionFn()){delete this.get;return;}return(this.get=hookFn).apply(this,arguments);}};}var cssPrefixes=["Webkit","Moz","ms"],emptyStyle=document.createElement("div").style,vendorProps={};function vendorPropName(name){var capName=name[0].toUpperCase()+name.slice(1),i=cssPrefixes.length;while(i--){name=cssPrefixes[i]+capName;if(name in emptyStyle){return name;}}}function finalPropName(name){var final=jQuery.cssProps[name]||vendorProps[name];if(final){return final;}if(name in emptyStyle){return name;}return vendorProps[name]=vendorPropName(name)||name;}var rdisplayswap=/^(none|table(?!-c[ea]).+)/,rcustomProp=/^--/,cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:"0",fontWeight:"400"};function setPositiveNumber(elem,value,subtract){var matches=rcssNum.exec(value);return matches?Math.max(0,matches[2]-(subtract||0))+(matches[3]||"px"):value;}function boxModelAdjustment(elem,dimension,box,isBorderBox,styles,computedVal){var i=dimension==="width"?1:0,extra=0,delta=0;if(box===(isBorderBox?"border":"content")){return 0;}for(;i<4;i+=2){if(box==="margin"){delta+=jQuery.css(elem,box+cssExpand[i],true,styles);}if(!isBorderBox){delta+=jQuery.css(elem,"padding"+cssExpand[i],true,styles);if(box!=="padding"){delta+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}else{extra+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}else{if(box==="content"){delta-=jQuery.css(elem,"padding"+cssExpand[i],true,styles);}if(box!=="margin"){delta-=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}}if(!isBorderBox&&computedVal>=0){delta+=Math.max(0,Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-computedVal-delta-extra-0.5))||0;}return delta;}function getWidthOrHeight(elem,dimension,extra){var styles=getStyles(elem),boxSizingNeeded=!support.boxSizingReliable()||extra,isBorderBox=boxSizingNeeded&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",valueIsBorderBox=isBorderBox,val=curCSS(elem,dimension,styles),offsetProp="offset"+dimension[0].toUpperCase()+dimension.slice(1);if(rnumnonpx.test(val)){if(!extra){return val;}val="auto";}if((!support.boxSizingReliable()&&isBorderBox||val==="auto"||!parseFloat(val)&&jQuery.css(elem,"display",false,styles)==="inline")&&elem.getClientRects().length){isBorderBox=jQuery.css(elem,"boxSizing",false,styles)==="border-box";valueIsBorderBox=offsetProp in elem;if(valueIsBorderBox){val=elem[offsetProp];}}val=parseFloat(val)||0;return val+boxModelAdjustment(elem,dimension,extra||(isBorderBox?"border":"content"),valueIsBorderBox,styles,val)+"px";}jQuery.extend({cssHooks:{opacity:{get:function(elem,computed){if(computed){var ret=curCSS(elem,"opacity");return ret===""?"1":ret;}}}},cssNumber:{"animationIterationCount":true,"columnCount":true,"fillOpacity":true,"flexGrow":true,"flexShrink":true,"fontWeight":true,"gridArea":true,"gridColumn":true,"gridColumnEnd":true,"gridColumnStart":true,"gridRow":true,"gridRowEnd":true,"gridRowStart":true,"lineHeight":true,"opacity":true,"order":true,"orphans":true,"widows":true,"zIndex":true,"zoom":true},cssProps:{},style:function(elem,name,value,extra){if(!elem||elem.nodeType===3||elem.nodeType===8||!elem.style){return;}var ret,type,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name),style=elem.style;if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(value!==undefined){type=typeof value;if(type==="string"&&(ret=rcssNum.exec(value))&&ret[1]){value=adjustCSS(elem,name,ret);type="number";}if(value==null||value!==value){return;}if(type==="number"&&!isCustomProp){value+=ret&&ret[3]||(jQuery.cssNumber[origName]?"":"px");}if(!support.clearCloneStyle&&value===""&&name.indexOf("background")===0){style[name]="inherit";}if(!hooks||!("set"in hooks)||(value=hooks.set(elem,value,extra))!==undefined){if(isCustomProp){style.setProperty(name,value);}else{style[name]=value;}}}else{if(hooks&&"get"in hooks&&(ret=hooks.get(elem,false,extra))!==undefined){return ret;}return style[name];}},css:function(elem,name,extra,styles){var val,num,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name);if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(hooks&&"get"in hooks){val=hooks.get(elem,true,extra);}if(val===undefined){val=curCSS(elem,name,styles);}if(val==="normal"&&name in cssNormalTransform){val=cssNormalTransform[name];}if(extra===""||extra){num=parseFloat(val);return extra===true||isFinite(num)?num||0:val;}return val;}});jQuery.each(["height","width"],function(i,dimension){jQuery.cssHooks[dimension]={get:function(elem,computed,extra){if(computed){return rdisplayswap.test(jQuery.css(elem,"display"))&&(!elem.getClientRects().length||!elem.getBoundingClientRect().width)?swap(elem,cssShow,function(){return getWidthOrHeight(elem,dimension,extra);}):getWidthOrHeight(elem,dimension,extra);}},set:function(elem,value,extra){var matches,styles=getStyles(elem),scrollboxSizeBuggy=!support.scrollboxSize()&&styles.position==="absolute",isBorderBox=(scrollboxSizeBuggy||extra)&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",subtract=extra?boxModelAdjustment(elem,dimension,extra,isBorderBox,styles):0;if(isBorderBox&&scrollboxSizeBuggy){subtract-=Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-parseFloat(styles[dimension])-boxModelAdjustment(elem,dimension,"border",false,styles)-0.5);}if(subtract&&(matches=rcssNum.exec(value))&&(matches[3]||"px")!=="px"){elem.style[dimension]=value;value=jQuery.css(elem,dimension);}return setPositiveNumber(elem,value,subtract);}};});jQuery.cssHooks.marginLeft=addGetHookIf(support.reliableMarginLeft,function(elem,computed){if(computed){return(parseFloat(curCSS(elem,"marginLeft"))||elem.getBoundingClientRect().left-swap(elem,{marginLeft:0},function(){return elem.getBoundingClientRect().left;}))+"px";}});jQuery.each({margin:"",padding:"",border:"Width"},function(prefix,suffix){jQuery.cssHooks[prefix+suffix]={expand:function(value){var i=0,expanded={},parts=typeof value==="string"?value.split(" "):[value];for(;i<4;i++){expanded[prefix+cssExpand[i]+suffix]=parts[i]||parts[i-2]||parts[0];}return expanded;}};if(prefix!=="margin"){jQuery.cssHooks[prefix+suffix].set=setPositiveNumber;}});jQuery.fn.extend({css:function(name,value){return access(this,function(elem,name,value){var styles,len,map={},i=0;if(Array.isArray(name)){styles=getStyles(elem);len=name.length;for(;i<len;i++){map[name[i]]=jQuery.css(elem,name[i],false,styles);}return map;}return value!==undefined?jQuery.style(elem,name,value):jQuery.css(elem,name);},name,value,arguments.length>1);}});function Tween(elem,options,prop,end,easing){return new Tween.prototype.init(elem,options,prop,end,easing);}jQuery.Tween=Tween;Tween.prototype={constructor:Tween,init:function(elem,options,prop,end,easing,unit){this.elem=elem;this.prop=prop;this.easing=easing||jQuery.easing._default;this.options=options;this.start=this.now=this.cur();this.end=end;this.unit=unit||(jQuery.cssNumber[prop]?"":"px");},cur:function(){var hooks=Tween.propHooks[this.prop];return hooks&&hooks.get?hooks.get(this):Tween.propHooks._default.get(this);},run:function(percent){var eased,hooks=Tween.propHooks[this.prop];if(this.options.duration){this.pos=eased=jQuery.easing[this.easing](percent,this.options.duration*percent,0,1,this.options.duration);}else{this.pos=eased=percent;}this.now=(this.end-this.start)*eased+this.start;if(this.options.step){this.options.step.call(this.elem,this.now,this);}if(hooks&&hooks.set){hooks.set(this);}else{Tween.propHooks._default.set(this);}return this;}};Tween.prototype.init.prototype=Tween.prototype;Tween.propHooks={_default:{get:function(tween){var result;if(tween.elem.nodeType!==1||tween.elem[tween.prop]!=null&&tween.elem.style[tween.prop]==null){return tween.elem[tween.prop];}result=jQuery.css(tween.elem,tween.prop,"");return!result||result==="auto"?0:result;},set:function(tween){if(jQuery.fx.step[tween.prop]){jQuery.fx.step[tween.prop](tween);}else if(tween.elem.nodeType===1&&(jQuery.cssHooks[tween.prop]||tween.elem.style[finalPropName(tween.prop)]!=null)){jQuery.style(tween.elem,tween.prop,tween.now+tween.unit);}else{tween.elem[tween.prop]=tween.now;}}}};Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(tween){if(tween.elem.nodeType&&tween.elem.parentNode){tween.elem[tween.prop]=tween.now;}}};jQuery.easing={linear:function(p){return p;},swing:function(p){return 0.5-Math.cos(p*Math.PI)/2;},_default:"swing"};jQuery.fx=Tween.prototype.init;jQuery.fx.step={};var fxNow,inProgress,rfxtypes=/^(?:toggle|show|hide)$/,rrun=/queueHooks$/;function schedule(){if(inProgress){if(document.hidden===false&&window.requestAnimationFrame){window.requestAnimationFrame(schedule);}else{window.setTimeout(schedule,jQuery.fx.interval);}jQuery.fx.tick();}}function createFxNow(){window.setTimeout(function(){fxNow=undefined;});return fxNow=Date.now();}function genFx(type,includeWidth){var which,i=0,attrs={height:type};includeWidth=includeWidth?1:0;for(;i<4;i+=2-includeWidth){which=cssExpand[i];attrs["margin"+which]=attrs["padding"+which]=type;}if(includeWidth){attrs.opacity=attrs.width=type;}return attrs;}function createTween(value,prop,animation){var tween,collection=(Animation.tweeners[prop]||[]).concat(Animation.tweeners["*"]),index=0,length=collection.length;for(;index<length;index++){if(tween=collection[index].call(animation,prop,value)){return tween;}}}function defaultPrefilter(elem,props,opts){var prop,value,toggle,hooks,oldfire,propTween,restoreDisplay,display,isBox="width"in props||"height"in props,anim=this,orig={},style=elem.style,hidden=elem.nodeType&&isHiddenWithinTree(elem),dataShow=dataPriv.get(elem,"fxshow");if(!opts.queue){hooks=jQuery._queueHooks(elem,"fx");if(hooks.unqueued==null){hooks.unqueued=0;oldfire=hooks.empty.fire;hooks.empty.fire=function(){if(!hooks.unqueued){oldfire();}};}hooks.unqueued++;anim.always(function(){anim.always(function(){hooks.unqueued--;if(!jQuery.queue(elem,"fx").length){hooks.empty.fire();}});});}for(prop in props){value=props[prop];if(rfxtypes.test(value)){delete props[prop];toggle=toggle||value==="toggle";if(value===(hidden?"hide":"show")){if(value==="show"&&dataShow&&dataShow[prop]!==undefined){hidden=true;}else{continue;}}orig[prop]=dataShow&&dataShow[prop]||jQuery.style(elem,prop);}}propTween=!jQuery.isEmptyObject(props);if(!propTween&&jQuery.isEmptyObject(orig)){return;}if(isBox&&elem.nodeType===1){opts.overflow=[style.overflow,style.overflowX,style.overflowY];restoreDisplay=dataShow&&dataShow.display;if(restoreDisplay==null){restoreDisplay=dataPriv.get(elem,"display");}display=jQuery.css(elem,"display");if(display==="none"){if(restoreDisplay){display=restoreDisplay;}else{showHide([elem],true);restoreDisplay=elem.style.display||restoreDisplay;display=jQuery.css(elem,"display");showHide([elem]);}}if(display==="inline"||display==="inline-block"&&restoreDisplay!=null){if(jQuery.css(elem,"float")==="none"){if(!propTween){anim.done(function(){style.display=restoreDisplay;});if(restoreDisplay==null){display=style.display;restoreDisplay=display==="none"?"":display;}}style.display="inline-block";}}}if(opts.overflow){style.overflow="hidden";anim.always(function(){style.overflow=opts.overflow[0];style.overflowX=opts.overflow[1];style.overflowY=opts.overflow[2];});}propTween=false;for(prop in orig){if(!propTween){if(dataShow){if("hidden"in dataShow){hidden=dataShow.hidden;}}else{dataShow=dataPriv.access(elem,"fxshow",{display:restoreDisplay});}if(toggle){dataShow.hidden=!hidden;}if(hidden){showHide([elem],true);}anim.done(function(){if(!hidden){showHide([elem]);}dataPriv.remove(elem,"fxshow");for(prop in orig){jQuery.style(elem,prop,orig[prop]);}});}propTween=createTween(hidden?dataShow[prop]:0,prop,anim);if(!(prop in dataShow)){dataShow[prop]=propTween.start;if(hidden){propTween.end=propTween.start;propTween.start=0;}}}}function propFilter(props,specialEasing){var index,name,easing,value,hooks;for(index in props){name=camelCase(index);easing=specialEasing[name];value=props[index];if(Array.isArray(value)){easing=value[1];value=props[index]=value[0];}if(index!==name){props[name]=value;delete props[index];}hooks=jQuery.cssHooks[name];if(hooks&&"expand"in hooks){value=hooks.expand(value);delete props[name];for(index in value){if(!(index in props)){props[index]=value[index];specialEasing[index]=easing;}}}else{specialEasing[name]=easing;}}}function Animation(elem,properties,options){var result,stopped,index=0,length=Animation.prefilters.length,deferred=jQuery.Deferred().always(function(){delete tick.elem;}),tick=function(){if(stopped){return false;}var currentTime=fxNow||createFxNow(),remaining=Math.max(0,animation.startTime+animation.duration-currentTime),temp=remaining/animation.duration||0,percent=1-temp,index=0,length=animation.tweens.length;for(;index<length;index++){animation.tweens[index].run(percent);}deferred.notifyWith(elem,[animation,percent,remaining]);if(percent<1&&length){return remaining;}if(!length){deferred.notifyWith(elem,[animation,1,0]);}deferred.resolveWith(elem,[animation]);return false;},animation=deferred.promise({elem:elem,props:jQuery.extend({},properties),opts:jQuery.extend(true,{specialEasing:{},easing:jQuery.easing._default},options),originalProperties:properties,originalOptions:options,startTime:fxNow||createFxNow(),duration:options.duration,tweens:[],createTween:function(prop,end){var tween=jQuery.Tween(elem,animation.opts,prop,end,animation.opts.specialEasing[prop]||animation.opts.easing);animation.tweens.push(tween);return tween;},stop:function(gotoEnd){var index=0,length=gotoEnd?animation.tweens.length:0;if(stopped){return this;}stopped=true;for(;index<length;index++){animation.tweens[index].run(1);}if(gotoEnd){deferred.notifyWith(elem,[animation,1,0]);deferred.resolveWith(elem,[animation,gotoEnd]);}else{deferred.rejectWith(elem,[animation,gotoEnd]);}return this;}}),props=animation.props;propFilter(props,animation.opts.specialEasing);for(;index<length;index++){result=Animation.prefilters[index].call(animation,elem,props,animation.opts);if(result){if(isFunction(result.stop)){jQuery._queueHooks(animation.elem,animation.opts.queue).stop=result.stop.bind(result);}return result;}}jQuery.map(props,createTween,animation);if(isFunction(animation.opts.start)){animation.opts.start.call(elem,animation);}animation.progress(animation.opts.progress).done(animation.opts.done,animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);jQuery.fx.timer(jQuery.extend(tick,{elem:elem,anim:animation,queue:animation.opts.queue}));return animation;}jQuery.Animation=jQuery.extend(Animation,{tweeners:{"*":[function(prop,value){var tween=this.createTween(prop,value);adjustCSS(tween.elem,prop,rcssNum.exec(value),tween);return tween;}]},tweener:function(props,callback){if(isFunction(props)){callback=props;props=["*"];}else{props=props.match(rnothtmlwhite);}var prop,index=0,length=props.length;for(;index<length;index++){prop=props[index];Animation.tweeners[prop]=Animation.tweeners[prop]||[];Animation.tweeners[prop].unshift(callback);}},prefilters:[defaultPrefilter],prefilter:function(callback,prepend){if(prepend){Animation.prefilters.unshift(callback);}else{Animation.prefilters.push(callback);}}});jQuery.speed=function(speed,easing,fn){var opt=speed&&typeof speed==="object"?jQuery.extend({},speed):{complete:fn||!fn&&easing||isFunction(speed)&&speed,duration:speed,easing:fn&&easing||easing&&!isFunction(easing)&&easing};if(jQuery.fx.off){opt.duration=0;}else{if(typeof opt.duration!=="number"){if(opt.duration in jQuery.fx.speeds){opt.duration=jQuery.fx.speeds[opt.duration];}else{opt.duration=jQuery.fx.speeds._default;}}}if(opt.queue==null||opt.queue===true){opt.queue="fx";}opt.old=opt.complete;opt.complete=function(){if(isFunction(opt.old)){opt.old.call(this);}if(opt.queue){jQuery.dequeue(this,opt.queue);}};return opt;};jQuery.fn.extend({fadeTo:function(speed,to,easing,callback){return this.filter(isHiddenWithinTree).css("opacity",0).show().end().animate({opacity:to},speed,easing,callback);},animate:function(prop,speed,easing,callback){var empty=jQuery.isEmptyObject(prop),optall=jQuery.speed(speed,easing,callback),doAnimation=function(){var anim=Animation(this,jQuery.extend({},prop),optall);if(empty||dataPriv.get(this,"finish")){anim.stop(true);}};doAnimation.finish=doAnimation;return empty||optall.queue===false?this.each(doAnimation):this.queue(optall.queue,doAnimation);},stop:function(type,clearQueue,gotoEnd){var stopQueue=function(hooks){var stop=hooks.stop;delete hooks.stop;stop(gotoEnd);};if(typeof type!=="string"){gotoEnd=clearQueue;clearQueue=type;type=undefined;}if(clearQueue&&type!==false){this.queue(type||"fx",[]);}return this.each(function(){var dequeue=true,index=type!=null&&type+"queueHooks",timers=jQuery.timers,data=dataPriv.get(this);if(index){if(data[index]&&data[index].stop){stopQueue(data[index]);}}else{for(index in data){if(data[index]&&data[index].stop&&rrun.test(index)){stopQueue(data[index]);}}}for(index=timers.length;index--;){if(timers[index].elem===this&&(type==null||timers[index].queue===type)){timers[index].anim.stop(gotoEnd);dequeue=false;timers.splice(index,1);}}if(dequeue||!gotoEnd){jQuery.dequeue(this,type);}});},finish:function(type){if(type!==false){type=type||"fx";}return this.each(function(){var index,data=dataPriv.get(this),queue=data[type+"queue"],hooks=data[type+"queueHooks"],timers=jQuery.timers,length=queue?queue.length:0;data.finish=true;jQuery.queue(this,type,[]);if(hooks&&hooks.stop){hooks.stop.call(this,true);}for(index=timers.length;index--;){if(timers[index].elem===this&&timers[index].queue===type){timers[index].anim.stop(true);timers.splice(index,1);}}for(index=0;index<length;index++){if(queue[index]&&queue[index].finish){queue[index].finish.call(this);}}delete data.finish;});}});jQuery.each(["toggle","show","hide"],function(i,name){var cssFn=jQuery.fn[name];jQuery.fn[name]=function(speed,easing,callback){return speed==null||typeof speed==="boolean"?cssFn.apply(this,arguments):this.animate(genFx(name,true),speed,easing,callback);};});jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(name,props){jQuery.fn[name]=function(speed,easing,callback){return this.animate(props,speed,easing,callback);};});jQuery.timers=[];jQuery.fx.tick=function(){var timer,i=0,timers=jQuery.timers;fxNow=Date.now();for(;i<timers.length;i++){timer=timers[i];if(!timer()&&timers[i]===timer){timers.splice(i--,1);}}if(!timers.length){jQuery.fx.stop();}fxNow=undefined;};jQuery.fx.timer=function(timer){jQuery.timers.push(timer);jQuery.fx.start();};jQuery.fx.interval=13;jQuery.fx.start=function(){if(inProgress){return;}inProgress=true;schedule();};jQuery.fx.stop=function(){inProgress=null;};jQuery.fx.speeds={slow:600,fast:200,_default:400};jQuery.fn.delay=function(time,type){time=jQuery.fx?jQuery.fx.speeds[time]||time:time;type=type||"fx";return this.queue(type,function(next,hooks){var timeout=window.setTimeout(next,time);hooks.stop=function(){window.clearTimeout(timeout);};});};(function(){var input=document.createElement("input"),select=document.createElement("select"),opt=select.appendChild(document.createElement("option"));input.type="checkbox";support.checkOn=input.value!=="";support.optSelected=opt.selected;input=document.createElement("input");input.value="t";input.type="radio";support.radioValue=input.value==="t";})();var boolHook,attrHandle=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(name,value){return access(this,jQuery.attr,name,value,arguments.length>1);},removeAttr:function(name){return this.each(function(){jQuery.removeAttr(this,name);});}});jQuery.extend({attr:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(typeof elem.getAttribute==="undefined"){return jQuery.prop(elem,name,value);}if(nType!==1||!jQuery.isXMLDoc(elem)){hooks=jQuery.attrHooks[name.toLowerCase()]||(jQuery.expr.match.bool.test(name)?boolHook:undefined);}if(value!==undefined){if(value===null){jQuery.removeAttr(elem,name);return;}if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}elem.setAttribute(name,value+"");return value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}ret=jQuery.find.attr(elem,name);return ret==null?undefined:ret;},attrHooks:{type:{set:function(elem,value){if(!support.radioValue&&value==="radio"&&nodeName(elem,"input")){var val=elem.value;elem.setAttribute("type",value);if(val){elem.value=val;}return value;}}}},removeAttr:function(elem,value){var name,i=0,attrNames=value&&value.match(rnothtmlwhite);if(attrNames&&elem.nodeType===1){while(name=attrNames[i++]){elem.removeAttribute(name);}}}});boolHook={set:function(elem,value,name){if(value===false){jQuery.removeAttr(elem,name);}else{elem.setAttribute(name,name);}return name;}};jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),function(i,name){var getter=attrHandle[name]||jQuery.find.attr;attrHandle[name]=function(elem,name,isXML){var ret,handle,lowercaseName=name.toLowerCase();if(!isXML){handle=attrHandle[lowercaseName];attrHandle[lowercaseName]=ret;ret=getter(elem,name,isXML)!=null?lowercaseName:null;attrHandle[lowercaseName]=handle;}return ret;};});var rfocusable=/^(?:input|select|textarea|button)$/i,rclickable=/^(?:a|area)$/i;jQuery.fn.extend({prop:function(name,value){return access(this,jQuery.prop,name,value,arguments.length>1);},removeProp:function(name){return this.each(function(){delete this[jQuery.propFix[name]||name];});}});jQuery.extend({prop:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(nType!==1||!jQuery.isXMLDoc(elem)){name=jQuery.propFix[name]||name;hooks=jQuery.propHooks[name];}if(value!==undefined){if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}return elem[name]=value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}return elem[name];},propHooks:{tabIndex:{get:function(elem){var tabindex=jQuery.find.attr(elem,"tabindex");if(tabindex){return parseInt(tabindex,10);}if(rfocusable.test(elem.nodeName)||rclickable.test(elem.nodeName)&&elem.href){return 0;}return-1;}}},propFix:{"for":"htmlFor","class":"className"}});if(!support.optSelected){jQuery.propHooks.selected={get:function(elem){var parent=elem.parentNode;if(parent&&parent.parentNode){parent.parentNode.selectedIndex;}return null;},set:function(elem){var parent=elem.parentNode;if(parent){parent.selectedIndex;if(parent.parentNode){parent.parentNode.selectedIndex;}}}};}jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){jQuery.propFix[this.toLowerCase()]=this;});function stripAndCollapse(value){var tokens=value.match(rnothtmlwhite)||[];return tokens.join(" ");}function getClass(elem){return elem.getAttribute&&elem.getAttribute("class")||"";}function classesToArray(value){if(Array.isArray(value)){return value;}if(typeof value==="string"){return value.match(rnothtmlwhite)||[];}return[];}jQuery.fn.extend({addClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).addClass(value.call(this,j,getClass(this)));});}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){if(cur.indexOf(" "+clazz+" ")<0){cur+=clazz+" ";}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},removeClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).removeClass(value.call(this,j,getClass(this)));});}if(!arguments.length){return this.attr("class","");}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){while(cur.indexOf(" "+clazz+" ")>-1){cur=cur.replace(" "+clazz+" "," ");}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},toggleClass:function(value,stateVal){var type=typeof value,isValidValue=type==="string"||Array.isArray(value);if(typeof stateVal==="boolean"&&isValidValue){return stateVal?this.addClass(value):this.removeClass(value);}if(isFunction(value)){return this.each(function(i){jQuery(this).toggleClass(value.call(this,i,getClass(this),stateVal),stateVal);});}return this.each(function(){var className,i,self,classNames;if(isValidValue){i=0;self=jQuery(this);classNames=classesToArray(value);while(className=classNames[i++]){if(self.hasClass(className)){self.removeClass(className);}else{self.addClass(className);}}}else if(value===undefined||type==="boolean"){className=getClass(this);if(className){dataPriv.set(this,"__className__",className);}if(this.setAttribute){this.setAttribute("class",className||value===false?"":dataPriv.get(this,"__className__")||"");}}});},hasClass:function(selector){var className,elem,i=0;className=" "+selector+" ";while(elem=this[i++]){if(elem.nodeType===1&&(" "+stripAndCollapse(getClass(elem))+" ").indexOf(className)>-1){return true;}}return false;}});var rreturn=/\r/g;jQuery.fn.extend({val:function(value){var hooks,ret,valueIsFunction,elem=this[0];if(!arguments.length){if(elem){hooks=jQuery.valHooks[elem.type]||jQuery.valHooks[elem.nodeName.toLowerCase()];if(hooks&&"get"in hooks&&(ret=hooks.get(elem,"value"))!==undefined){return ret;}ret=elem.value;if(typeof ret==="string"){return ret.replace(rreturn,"");}return ret==null?"":ret;}return;}valueIsFunction=isFunction(value);return this.each(function(i){var val;if(this.nodeType!==1){return;}if(valueIsFunction){val=value.call(this,i,jQuery(this).val());}else{val=value;}if(val==null){val="";}else if(typeof val==="number"){val+="";}else if(Array.isArray(val)){val=jQuery.map(val,function(value){return value==null?"":value+"";});}hooks=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()];if(!hooks||!("set"in hooks)||hooks.set(this,val,"value")===undefined){this.value=val;}});}});jQuery.extend({valHooks:{option:{get:function(elem){var val=jQuery.find.attr(elem,"value");return val!=null?val:stripAndCollapse(jQuery.text(elem));}},select:{get:function(elem){var value,option,i,options=elem.options,index=elem.selectedIndex,one=elem.type==="select-one",values=one?null:[],max=one?index+1:options.length;if(index<0){i=max;}else{i=one?index:0;}for(;i<max;i++){option=options[i];if((option.selected||i===index)&&!option.disabled&&(!option.parentNode.disabled||!nodeName(option.parentNode,"optgroup"))){value=jQuery(option).val();if(one){return value;}values.push(value);}}return values;},set:function(elem,value){var optionSet,option,options=elem.options,values=jQuery.makeArray(value),i=options.length;while(i--){option=options[i];if(option.selected=jQuery.inArray(jQuery.valHooks.option.get(option),values)>-1){optionSet=true;}}if(!optionSet){elem.selectedIndex=-1;}return values;}}}});jQuery.each(["radio","checkbox"],function(){jQuery.valHooks[this]={set:function(elem,value){if(Array.isArray(value)){return elem.checked=jQuery.inArray(jQuery(elem).val(),value)>-1;}}};if(!support.checkOn){jQuery.valHooks[this].get=function(elem){return elem.getAttribute("value")===null?"on":elem.value;};}});support.focusin="onfocusin"in window;var rfocusMorph=/^(?:focusinfocus|focusoutblur)$/,stopPropagationCallback=function(e){e.stopPropagation();};jQuery.extend(jQuery.event,{trigger:function(event,data,elem,onlyHandlers){var i,cur,tmp,bubbleType,ontype,handle,special,lastElement,eventPath=[elem||document],type=hasOwn.call(event,"type")?event.type:event,namespaces=hasOwn.call(event,"namespace")?event.namespace.split("."):[];cur=lastElement=tmp=elem=elem||document;if(elem.nodeType===3||elem.nodeType===8){return;}if(rfocusMorph.test(type+jQuery.event.triggered)){return;}if(type.indexOf(".")>-1){namespaces=type.split(".");type=namespaces.shift();namespaces.sort();}ontype=type.indexOf(":")<0&&"on"+type;event=event[jQuery.expando]?event:new jQuery.Event(type,typeof event==="object"&&event);event.isTrigger=onlyHandlers?2:3;event.namespace=namespaces.join(".");event.rnamespace=event.namespace?new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"):null;event.result=undefined;if(!event.target){event.target=elem;}data=data==null?[event]:jQuery.makeArray(data,[event]);special=jQuery.event.special[type]||{};if(!onlyHandlers&&special.trigger&&special.trigger.apply(elem,data)===false){return;}if(!onlyHandlers&&!special.noBubble&&!isWindow(elem)){bubbleType=special.delegateType||type;if(!rfocusMorph.test(bubbleType+type)){cur=cur.parentNode;}for(;cur;cur=cur.parentNode){eventPath.push(cur);tmp=cur;}if(tmp===(elem.ownerDocument||document)){eventPath.push(tmp.defaultView||tmp.parentWindow||window);}}i=0;while((cur=eventPath[i++])&&!event.isPropagationStopped()){lastElement=cur;event.type=i>1?bubbleType:special.bindType||type;handle=(dataPriv.get(cur,"events")||{})[event.type]&&dataPriv.get(cur,"handle");if(handle){handle.apply(cur,data);}handle=ontype&&cur[ontype];if(handle&&handle.apply&&acceptData(cur)){event.result=handle.apply(cur,data);if(event.result===false){event.preventDefault();}}}event.type=type;if(!onlyHandlers&&!event.isDefaultPrevented()){if((!special._default||special._default.apply(eventPath.pop(),data)===false)&&acceptData(elem)){if(ontype&&isFunction(elem[type])&&!isWindow(elem)){tmp=elem[ontype];if(tmp){elem[ontype]=null;}jQuery.event.triggered=type;if(event.isPropagationStopped()){lastElement.addEventListener(type,stopPropagationCallback);}elem[type]();if(event.isPropagationStopped()){lastElement.removeEventListener(type,stopPropagationCallback);}jQuery.event.triggered=undefined;if(tmp){elem[ontype]=tmp;}}}}return event.result;},simulate:function(type,elem,event){var e=jQuery.extend(new jQuery.Event(),event,{type:type,isSimulated:true});jQuery.event.trigger(e,null,elem);}});jQuery.fn.extend({trigger:function(type,data){return this.each(function(){jQuery.event.trigger(type,data,this);});},triggerHandler:function(type,data){var elem=this[0];if(elem){return jQuery.event.trigger(type,data,elem,true);}}});if(!support.focusin){jQuery.each({focus:"focusin",blur:"focusout"},function(orig,fix){var handler=function(event){jQuery.event.simulate(fix,event.target,jQuery.event.fix(event));};jQuery.event.special[fix]={setup:function(){var doc=this.ownerDocument||this,attaches=dataPriv.access(doc,fix);if(!attaches){doc.addEventListener(orig,handler,true);}dataPriv.access(doc,fix,(attaches||0)+1);},teardown:function(){var doc=this.ownerDocument||this,attaches=dataPriv.access(doc,fix)-1;if(!attaches){doc.removeEventListener(orig,handler,true);dataPriv.remove(doc,fix);}else{dataPriv.access(doc,fix,attaches);}}};});}var location=window.location;var nonce=Date.now();var rquery=/\?/;jQuery.parseXML=function(data){var xml;if(!data||typeof data!=="string"){return null;}try{xml=new window.DOMParser().parseFromString(data,"text/xml");}catch(e){xml=undefined;}if(!xml||xml.getElementsByTagName("parsererror").length){jQuery.error("Invalid XML: "+data);}return xml;};var rbracket=/\[\]$/,rCRLF=/\r?\n/g,rsubmitterTypes=/^(?:submit|button|image|reset|file)$/i,rsubmittable=/^(?:input|select|textarea|keygen)/i;function buildParams(prefix,obj,traditional,add){if(Array.isArray(obj)){jQuery.each(obj,function(i,v){if(traditional||rbracket.test(prefix)){add(prefix,v);}else{buildParams(prefix+"["+(typeof v==="object"&&v!=null?i:"")+"]",v,traditional,add);}});}else if(!traditional&&toType(obj)==="object"){for(var name in obj){buildParams(prefix+"["+name+"]",obj[name],traditional,add);}}else{add(prefix,obj);}}jQuery.param=function(a,traditional){var prefix,s=[],add=function(key,valueOrFunction){var value=isFunction(valueOrFunction)?valueOrFunction():valueOrFunction;s[s.length]=encodeURIComponent(key)+"="+encodeURIComponent(value==null?"":value);};if(a==null){return"";}if(Array.isArray(a)||a.jquery&&!jQuery.isPlainObject(a)){jQuery.each(a,function(){add(this.name,this.value);});}else{for(prefix in a){buildParams(prefix,a[prefix],traditional,add);}}return s.join("&");};jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray());},serializeArray:function(){return this.map(function(){var elements=jQuery.prop(this,"elements");return elements?jQuery.makeArray(elements):this;}).filter(function(){var type=this.type;return this.name&&!jQuery(this).is(":disabled")&&rsubmittable.test(this.nodeName)&&!rsubmitterTypes.test(type)&&(this.checked||!rcheckableType.test(type));}).map(function(i,elem){var val=jQuery(this).val();if(val==null){return null;}if(Array.isArray(val)){return jQuery.map(val,function(val){return{name:elem.name,value:val.replace(rCRLF,"\r\n")};});}return{name:elem.name,value:val.replace(rCRLF,"\r\n")};}).get();}});var r20=/%20/g,rhash=/#.*$/,rantiCache=/([?&])_=[^&]*/,rheaders=/^(.*?):[ \t]*([^\r\n]*)$/mg,rlocalProtocol=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,rnoContent=/^(?:GET|HEAD)$/,rprotocol=/^\/\//,prefilters={},transports={},allTypes="*/".concat("*"),originAnchor=document.createElement("a");originAnchor.href=location.href;function addToPrefiltersOrTransports(structure){return function(dataTypeExpression,func){if(typeof dataTypeExpression!=="string"){func=dataTypeExpression;dataTypeExpression="*";}var dataType,i=0,dataTypes=dataTypeExpression.toLowerCase().match(rnothtmlwhite)||[];if(isFunction(func)){while(dataType=dataTypes[i++]){if(dataType[0]==="+"){dataType=dataType.slice(1)||"*";(structure[dataType]=structure[dataType]||[]).unshift(func);}else{(structure[dataType]=structure[dataType]||[]).push(func);}}}};}function inspectPrefiltersOrTransports(structure,options,originalOptions,jqXHR){var inspected={},seekingTransport=structure===transports;function inspect(dataType){var selected;inspected[dataType]=true;jQuery.each(structure[dataType]||[],function(_,prefilterOrFactory){var dataTypeOrTransport=prefilterOrFactory(options,originalOptions,jqXHR);if(typeof dataTypeOrTransport==="string"&&!seekingTransport&&!inspected[dataTypeOrTransport]){options.dataTypes.unshift(dataTypeOrTransport);inspect(dataTypeOrTransport);return false;}else if(seekingTransport){return!(selected=dataTypeOrTransport);}});return selected;}return inspect(options.dataTypes[0])||!inspected["*"]&&inspect("*");}function ajaxExtend(target,src){var key,deep,flatOptions=jQuery.ajaxSettings.flatOptions||{};for(key in src){if(src[key]!==undefined){(flatOptions[key]?target:deep||(deep={}))[key]=src[key];}}if(deep){jQuery.extend(true,target,deep);}return target;}function ajaxHandleResponses(s,jqXHR,responses){var ct,type,finalDataType,firstDataType,contents=s.contents,dataTypes=s.dataTypes;while(dataTypes[0]==="*"){dataTypes.shift();if(ct===undefined){ct=s.mimeType||jqXHR.getResponseHeader("Content-Type");}}if(ct){for(type in contents){if(contents[type]&&contents[type].test(ct)){dataTypes.unshift(type);break;}}}if(dataTypes[0]in responses){finalDataType=dataTypes[0];}else{for(type in responses){if(!dataTypes[0]||s.converters[type+" "+dataTypes[0]]){finalDataType=type;break;}if(!firstDataType){firstDataType=type;}}finalDataType=finalDataType||firstDataType;}if(finalDataType){if(finalDataType!==dataTypes[0]){dataTypes.unshift(finalDataType);}return responses[finalDataType];}}function ajaxConvert(s,response,jqXHR,isSuccess){var conv2,current,conv,tmp,prev,converters={},dataTypes=s.dataTypes.slice();if(dataTypes[1]){for(conv in s.converters){converters[conv.toLowerCase()]=s.converters[conv];}}current=dataTypes.shift();while(current){if(s.responseFields[current]){jqXHR[s.responseFields[current]]=response;}if(!prev&&isSuccess&&s.dataFilter){response=s.dataFilter(response,s.dataType);}prev=current;current=dataTypes.shift();if(current){if(current==="*"){current=prev;}else if(prev!=="*"&&prev!==current){conv=converters[prev+" "+current]||converters["* "+current];if(!conv){for(conv2 in converters){tmp=conv2.split(" ");if(tmp[1]===current){conv=converters[prev+" "+tmp[0]]||converters["* "+tmp[0]];if(conv){if(conv===true){conv=converters[conv2];}else if(converters[conv2]!==true){current=tmp[0];dataTypes.unshift(tmp[1]);}break;}}}}if(conv!==true){if(conv&&s.throws){response=conv(response);}else{try{response=conv(response);}catch(e){return{state:"parsererror",error:conv?e:"No conversion from "+prev+" to "+current};}}}}}}return{state:"success",data:response};}jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:location.href,type:"GET",isLocal:rlocalProtocol.test(location.protocol),global:true,processData:true,async:true,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":true,"text json":JSON.parse,"text xml":jQuery.parseXML},flatOptions:{url:true,context:true}},ajaxSetup:function(target,settings){return settings?ajaxExtend(ajaxExtend(target,jQuery.ajaxSettings),settings):ajaxExtend(jQuery.ajaxSettings,target);},ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports),ajax:function(url,options){if(typeof url==="object"){options=url;url=undefined;}options=options||{};var transport,cacheURL,responseHeadersString,responseHeaders,timeoutTimer,urlAnchor,completed,fireGlobals,i,uncached,s=jQuery.ajaxSetup({},options),callbackContext=s.context||s,globalEventContext=s.context&&(callbackContext.nodeType||callbackContext.jquery)?jQuery(callbackContext):jQuery.event,deferred=jQuery.Deferred(),completeDeferred=jQuery.Callbacks("once memory"),statusCode=s.statusCode||{},requestHeaders={},requestHeadersNames={},strAbort="canceled",jqXHR={readyState:0,getResponseHeader:function(key){var match;if(completed){if(!responseHeaders){responseHeaders={};while(match=rheaders.exec(responseHeadersString)){responseHeaders[match[1].toLowerCase()+" "]=(responseHeaders[match[1].toLowerCase()+" "]||[]).concat(match[2]);}}match=responseHeaders[key.toLowerCase()+" "];}return match==null?null:match.join(", ");},getAllResponseHeaders:function(){return completed?responseHeadersString:null;},setRequestHeader:function(name,value){if(completed==null){name=requestHeadersNames[name.toLowerCase()]=requestHeadersNames[name.toLowerCase()]||name;requestHeaders[name]=value;}return this;},overrideMimeType:function(type){if(completed==null){s.mimeType=type;}return this;},statusCode:function(map){if(map){if(completed){jqXHR.always(map[jqXHR.status]);}else{for(var code in map){statusCode[code]=[statusCode[code],map[code]];}}}return this;},abort:function(statusText){var finalText=statusText||strAbort;if(transport){transport.abort(finalText);}done(0,finalText);return this;}};deferred.promise(jqXHR);s.url=((url||s.url||location.href)+"").replace(rprotocol,location.protocol+"//");s.type=options.method||options.type||s.method||s.type;s.dataTypes=(s.dataType||"*").toLowerCase().match(rnothtmlwhite)||[""];if(s.crossDomain==null){urlAnchor=document.createElement("a");try{urlAnchor.href=s.url;urlAnchor.href=urlAnchor.href;s.crossDomain=originAnchor.protocol+"//"+originAnchor.host!==urlAnchor.protocol+"//"+urlAnchor.host;}catch(e){s.crossDomain=true;}}if(s.data&&s.processData&&typeof s.data!=="string"){s.data=jQuery.param(s.data,s.traditional);}inspectPrefiltersOrTransports(prefilters,s,options,jqXHR);if(completed){return jqXHR;}fireGlobals=jQuery.event&&s.global;if(fireGlobals&&jQuery.active++===0){jQuery.event.trigger("ajaxStart");}s.type=s.type.toUpperCase();s.hasContent=!rnoContent.test(s.type);cacheURL=s.url.replace(rhash,"");if(!s.hasContent){uncached=s.url.slice(cacheURL.length);if(s.data&&(s.processData||typeof s.data==="string")){cacheURL+=(rquery.test(cacheURL)?"&":"?")+s.data;delete s.data;}if(s.cache===false){cacheURL=cacheURL.replace(rantiCache,"$1");uncached=(rquery.test(cacheURL)?"&":"?")+"_="+nonce++ +uncached;}s.url=cacheURL+uncached;}else if(s.data&&s.processData&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0){s.data=s.data.replace(r20,"+");}if(s.ifModified){if(jQuery.lastModified[cacheURL]){jqXHR.setRequestHeader("If-Modified-Since",jQuery.lastModified[cacheURL]);}if(jQuery.etag[cacheURL]){jqXHR.setRequestHeader("If-None-Match",jQuery.etag[cacheURL]);}}if(s.data&&s.hasContent&&s.contentType!==false||options.contentType){jqXHR.setRequestHeader("Content-Type",s.contentType);}jqXHR.setRequestHeader("Accept",s.dataTypes[0]&&s.accepts[s.dataTypes[0]]?s.accepts[s.dataTypes[0]]+(s.dataTypes[0]!=="*"?", "+allTypes+"; q=0.01":""):s.accepts["*"]);for(i in s.headers){jqXHR.setRequestHeader(i,s.headers[i]);}if(s.beforeSend&&(s.beforeSend.call(callbackContext,jqXHR,s)===false||completed)){return jqXHR.abort();}strAbort="abort";completeDeferred.add(s.complete);jqXHR.done(s.success);jqXHR.fail(s.error);transport=inspectPrefiltersOrTransports(transports,s,options,jqXHR);if(!transport){done(-1,"No Transport");}else{jqXHR.readyState=1;if(fireGlobals){globalEventContext.trigger("ajaxSend",[jqXHR,s]);}if(completed){return jqXHR;}if(s.async&&s.timeout>0){timeoutTimer=window.setTimeout(function(){jqXHR.abort("timeout");},s.timeout);}try{completed=false;transport.send(requestHeaders,done);}catch(e){if(completed){throw e;}done(-1,e);}}function done(status,nativeStatusText,responses,headers){var isSuccess,success,error,response,modified,statusText=nativeStatusText;if(completed){return;}completed=true;if(timeoutTimer){window.clearTimeout(timeoutTimer);}transport=undefined;responseHeadersString=headers||"";jqXHR.readyState=status>0?4:0;isSuccess=status>=200&&status<300||status===304;if(responses){response=ajaxHandleResponses(s,jqXHR,responses);}response=ajaxConvert(s,response,jqXHR,isSuccess);if(isSuccess){if(s.ifModified){modified=jqXHR.getResponseHeader("Last-Modified");if(modified){jQuery.lastModified[cacheURL]=modified;}modified=jqXHR.getResponseHeader("etag");if(modified){jQuery.etag[cacheURL]=modified;}}if(status===204||s.type==="HEAD"){statusText="nocontent";}else if(status===304){statusText="notmodified";}else{statusText=response.state;success=response.data;error=response.error;isSuccess=!error;}}else{error=statusText;if(status||!statusText){statusText="error";if(status<0){status=0;}}}jqXHR.status=status;jqXHR.statusText=(nativeStatusText||statusText)+"";if(isSuccess){deferred.resolveWith(callbackContext,[success,statusText,jqXHR]);}else{deferred.rejectWith(callbackContext,[jqXHR,statusText,error]);}jqXHR.statusCode(statusCode);statusCode=undefined;if(fireGlobals){globalEventContext.trigger(isSuccess?"ajaxSuccess":"ajaxError",[jqXHR,s,isSuccess?success:error]);}completeDeferred.fireWith(callbackContext,[jqXHR,statusText]);if(fireGlobals){globalEventContext.trigger("ajaxComplete",[jqXHR,s]);if(! --jQuery.active){jQuery.event.trigger("ajaxStop");}}}return jqXHR;},getJSON:function(url,data,callback){return jQuery.get(url,data,callback,"json");},getScript:function(url,callback){return jQuery.get(url,undefined,callback,"script");}});jQuery.each(["get","post"],function(i,method){jQuery[method]=function(url,data,callback,type){if(isFunction(data)){type=type||callback;callback=data;data=undefined;}return jQuery.ajax(jQuery.extend({url:url,type:method,dataType:type,data:data,success:callback},jQuery.isPlainObject(url)&&url));};});jQuery._evalUrl=function(url,options){return jQuery.ajax({url:url,type:"GET",dataType:"script",cache:true,async:false,global:false,converters:{"text script":function(){}},dataFilter:function(response){jQuery.globalEval(response,options);}});};jQuery.fn.extend({wrapAll:function(html){var wrap;if(this[0]){if(isFunction(html)){html=html.call(this[0]);}wrap=jQuery(html,this[0].ownerDocument).eq(0).clone(true);if(this[0].parentNode){wrap.insertBefore(this[0]);}wrap.map(function(){var elem=this;while(elem.firstElementChild){elem=elem.firstElementChild;}return elem;}).append(this);}return this;},wrapInner:function(html){if(isFunction(html)){return this.each(function(i){jQuery(this).wrapInner(html.call(this,i));});}return this.each(function(){var self=jQuery(this),contents=self.contents();if(contents.length){contents.wrapAll(html);}else{self.append(html);}});},wrap:function(html){var htmlIsFunction=isFunction(html);return this.each(function(i){jQuery(this).wrapAll(htmlIsFunction?html.call(this,i):html);});},unwrap:function(selector){this.parent(selector).not("body").each(function(){jQuery(this).replaceWith(this.childNodes);});return this;}});jQuery.expr.pseudos.hidden=function(elem){return!jQuery.expr.pseudos.visible(elem);};jQuery.expr.pseudos.visible=function(elem){return!!(elem.offsetWidth||elem.offsetHeight||elem.getClientRects().length);};jQuery.ajaxSettings.xhr=function(){try{return new window.XMLHttpRequest();}catch(e){}};var xhrSuccessStatus={0:200,1223:204},xhrSupported=jQuery.ajaxSettings.xhr();support.cors=!!xhrSupported&&"withCredentials"in xhrSupported;support.ajax=xhrSupported=!!xhrSupported;jQuery.ajaxTransport(function(options){var callback,errorCallback;if(support.cors||xhrSupported&&!options.crossDomain){return{send:function(headers,complete){var i,xhr=options.xhr();xhr.open(options.type,options.url,options.async,options.username,options.password);if(options.xhrFields){for(i in options.xhrFields){xhr[i]=options.xhrFields[i];}}if(options.mimeType&&xhr.overrideMimeType){xhr.overrideMimeType(options.mimeType);}if(!options.crossDomain&&!headers["X-Requested-With"]){headers["X-Requested-With"]="XMLHttpRequest";}for(i in headers){xhr.setRequestHeader(i,headers[i]);}callback=function(type){return function(){if(callback){callback=errorCallback=xhr.onload=xhr.onerror=xhr.onabort=xhr.ontimeout=xhr.onreadystatechange=null;if(type==="abort"){xhr.abort();}else if(type==="error"){if(typeof xhr.status!=="number"){complete(0,"error");}else{complete(xhr.status,xhr.statusText);}}else{complete(xhrSuccessStatus[xhr.status]||xhr.status,xhr.statusText,(xhr.responseType||"text")!=="text"||typeof xhr.responseText!=="string"?{binary:xhr.response}:{text:xhr.responseText},xhr.getAllResponseHeaders());}}};};xhr.onload=callback();errorCallback=xhr.onerror=xhr.ontimeout=callback("error");if(xhr.onabort!==undefined){xhr.onabort=errorCallback;}else{xhr.onreadystatechange=function(){if(xhr.readyState===4){window.setTimeout(function(){if(callback){errorCallback();}});}};}callback=callback("abort");try{xhr.send(options.hasContent&&options.data||null);}catch(e){if(callback){throw e;}}},abort:function(){if(callback){callback();}}};}});jQuery.ajaxPrefilter(function(s){if(s.crossDomain){s.contents.script=false;}});jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, "+"application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(text){jQuery.globalEval(text);return text;}}});jQuery.ajaxPrefilter("script",function(s){if(s.cache===undefined){s.cache=false;}if(s.crossDomain){s.type="GET";}});jQuery.ajaxTransport("script",function(s){if(s.crossDomain||s.scriptAttrs){var script,callback;return{send:function(_,complete){script=jQuery("<script>").attr(s.scriptAttrs||{}).prop({charset:s.scriptCharset,src:s.url}).on("load error",callback=function(evt){script.remove();callback=null;if(evt){complete(evt.type==="error"?404:200,evt.type);}});document.head.appendChild(script[0]);},abort:function(){if(callback){callback();}}};}});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var callback=oldCallbacks.pop()||jQuery.expando+"_"+nonce++;this[callback]=true;return callback;}});jQuery.ajaxPrefilter("json jsonp",function(s,originalSettings,jqXHR){var callbackName,overwritten,responseContainer,jsonProp=s.jsonp!==false&&(rjsonp.test(s.url)?"url":typeof s.data==="string"&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0&&rjsonp.test(s.data)&&"data");if(jsonProp||s.dataTypes[0]==="jsonp"){callbackName=s.jsonpCallback=isFunction(s.jsonpCallback)?s.jsonpCallback():s.jsonpCallback;if(jsonProp){s[jsonProp]=s[jsonProp].replace(rjsonp,"$1"+callbackName);}else if(s.jsonp!==false){s.url+=(rquery.test(s.url)?"&":"?")+s.jsonp+"="+callbackName;}s.converters["script json"]=function(){if(!responseContainer){jQuery.error(callbackName+" was not called");}return responseContainer[0];};s.dataTypes[0]="json";overwritten=window[callbackName];window[callbackName]=function(){responseContainer=arguments;};jqXHR.always(function(){if(overwritten===undefined){jQuery(window).removeProp(callbackName);}else{window[callbackName]=overwritten;}if(s[callbackName]){s.jsonpCallback=originalSettings.jsonpCallback;oldCallbacks.push(callbackName);}if(responseContainer&&isFunction(overwritten)){overwritten(responseContainer[0]);}responseContainer=overwritten=undefined;});return"script";}});support.createHTMLDocument=function(){var body=document.implementation.createHTMLDocument("").body;body.innerHTML="<form></form><form></form>";return body.childNodes.length===2;}();jQuery.parseHTML=function(data,context,keepScripts){if(typeof data!=="string"){return[];}if(typeof context==="boolean"){keepScripts=context;context=false;}var base,parsed,scripts;if(!context){if(support.createHTMLDocument){context=document.implementation.createHTMLDocument("");base=context.createElement("base");base.href=document.location.href;context.head.appendChild(base);}else{context=document;}}parsed=rsingleTag.exec(data);scripts=!keepScripts&&[];if(parsed){return[context.createElement(parsed[1])];}parsed=buildFragment([data],context,scripts);if(scripts&&scripts.length){jQuery(scripts).remove();}return jQuery.merge([],parsed.childNodes);};jQuery.fn.load=function(url,params,callback){var selector,type,response,self=this,off=url.indexOf(" ");if(off>-1){selector=stripAndCollapse(url.slice(off));url=url.slice(0,off);}if(isFunction(params)){callback=params;params=undefined;}else if(params&&typeof params==="object"){type="POST";}if(self.length>0){jQuery.ajax({url:url,type:type||"GET",dataType:"html",data:params}).done(function(responseText){response=arguments;self.html(selector?jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector):responseText);}).always(callback&&function(jqXHR,status){self.each(function(){callback.apply(this,response||[jqXHR.responseText,status,jqXHR]);});});}return this;};jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(i,type){jQuery.fn[type]=function(fn){return this.on(type,fn);};});jQuery.expr.pseudos.animated=function(elem){return jQuery.grep(jQuery.timers,function(fn){return elem===fn.elem;}).length;};jQuery.offset={setOffset:function(elem,options,i){var curPosition,curLeft,curCSSTop,curTop,curOffset,curCSSLeft,calculatePosition,position=jQuery.css(elem,"position"),curElem=jQuery(elem),props={};if(position==="static"){elem.style.position="relative";}curOffset=curElem.offset();curCSSTop=jQuery.css(elem,"top");curCSSLeft=jQuery.css(elem,"left");calculatePosition=(position==="absolute"||position==="fixed")&&(curCSSTop+curCSSLeft).indexOf("auto")>-1;if(calculatePosition){curPosition=curElem.position();curTop=curPosition.top;curLeft=curPosition.left;}else{curTop=parseFloat(curCSSTop)||0;curLeft=parseFloat(curCSSLeft)||0;}if(isFunction(options)){options=options.call(elem,i,jQuery.extend({},curOffset));}if(options.top!=null){props.top=options.top-curOffset.top+curTop;}if(options.left!=null){props.left=options.left-curOffset.left+curLeft;}if("using"in options){options.using.call(elem,props);}else{curElem.css(props);}}};jQuery.fn.extend({offset:function(options){if(arguments.length){return options===undefined?this:this.each(function(i){jQuery.offset.setOffset(this,options,i);});}var rect,win,elem=this[0];if(!elem){return;}if(!elem.getClientRects().length){return{top:0,left:0};}rect=elem.getBoundingClientRect();win=elem.ownerDocument.defaultView;return{top:rect.top+win.pageYOffset,left:rect.left+win.pageXOffset};},position:function(){if(!this[0]){return;}var offsetParent,offset,doc,elem=this[0],parentOffset={top:0,left:0};if(jQuery.css(elem,"position")==="fixed"){offset=elem.getBoundingClientRect();}else{offset=this.offset();doc=elem.ownerDocument;offsetParent=elem.offsetParent||doc.documentElement;while(offsetParent&&(offsetParent===doc.body||offsetParent===doc.documentElement)&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.parentNode;}if(offsetParent&&offsetParent!==elem&&offsetParent.nodeType===1){parentOffset=jQuery(offsetParent).offset();parentOffset.top+=jQuery.css(offsetParent,"borderTopWidth",true);parentOffset.left+=jQuery.css(offsetParent,"borderLeftWidth",true);}}return{top:offset.top-parentOffset.top-jQuery.css(elem,"marginTop",true),left:offset.left-parentOffset.left-jQuery.css(elem,"marginLeft",true)};},offsetParent:function(){return this.map(function(){var offsetParent=this.offsetParent;while(offsetParent&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.offsetParent;}return offsetParent||documentElement;});}});jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(method,prop){var top="pageYOffset"===prop;jQuery.fn[method]=function(val){return access(this,function(elem,method,val){var win;if(isWindow(elem)){win=elem;}else if(elem.nodeType===9){win=elem.defaultView;}if(val===undefined){return win?win[prop]:elem[method];}if(win){win.scrollTo(!top?val:win.pageXOffset,top?val:win.pageYOffset);}else{elem[method]=val;}},method,val,arguments.length);};});jQuery.each(["top","left"],function(i,prop){jQuery.cssHooks[prop]=addGetHookIf(support.pixelPosition,function(elem,computed){if(computed){computed=curCSS(elem,prop);return rnumnonpx.test(computed)?jQuery(elem).position()[prop]+"px":computed;}});});jQuery.each({Height:"height",Width:"width"},function(name,type){jQuery.each({padding:"inner"+name,content:type,"":"outer"+name},function(defaultExtra,funcName){jQuery.fn[funcName]=function(margin,value){var chainable=arguments.length&&(defaultExtra||typeof margin!=="boolean"),extra=defaultExtra||(margin===true||value===true?"margin":"border");return access(this,function(elem,type,value){var doc;if(isWindow(elem)){return funcName.indexOf("outer")===0?elem["inner"+name]:elem.document.documentElement["client"+name];}if(elem.nodeType===9){doc=elem.documentElement;return Math.max(elem.body["scroll"+name],doc["scroll"+name],elem.body["offset"+name],doc["offset"+name],doc["client"+name]);}return value===undefined?jQuery.css(elem,type,extra):jQuery.style(elem,type,value,extra);},type,chainable?margin:undefined,chainable);};});});jQuery.each(("blur focus focusin focusout resize scroll click dblclick "+"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "+"change select submit keydown keypress keyup contextmenu").split(" "),function(i,name){jQuery.fn[name]=function(data,fn){return arguments.length>0?this.on(name,null,data,fn):this.trigger(name);};});jQuery.fn.extend({hover:function(fnOver,fnOut){return this.mouseenter(fnOver).mouseleave(fnOut||fnOver);}});jQuery.fn.extend({bind:function(types,data,fn){return this.on(types,null,data,fn);},unbind:function(types,fn){return this.off(types,null,fn);},delegate:function(selector,types,data,fn){return this.on(types,selector,data,fn);},undelegate:function(selector,types,fn){return arguments.length===1?this.off(selector,"**"):this.off(types,selector||"**",fn);}});jQuery.proxy=function(fn,context){var tmp,args,proxy;if(typeof context==="string"){tmp=fn[context];context=fn;fn=tmp;}if(!isFunction(fn)){return undefined;}args=slice.call(arguments,2);proxy=function(){return fn.apply(context||this,args.concat(slice.call(arguments)));};proxy.guid=fn.guid=fn.guid||jQuery.guid++;return proxy;};jQuery.holdReady=function(hold){if(hold){jQuery.readyWait++;}else{jQuery.ready(true);}};jQuery.isArray=Array.isArray;jQuery.parseJSON=JSON.parse;jQuery.nodeName=nodeName;jQuery.isFunction=isFunction;jQuery.isWindow=isWindow;jQuery.camelCase=camelCase;jQuery.type=toType;jQuery.now=Date.now;jQuery.isNumeric=function(obj){var type=jQuery.type(obj);return(type==="number"||type==="string")&&!isNaN(obj-parseFloat(obj));};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return jQuery;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}var _jQuery=window.jQuery,_$=window.$;jQuery.noConflict=function(deep){if(window.$===jQuery){window.$=_$;}if(deep&&window.jQuery===jQuery){window.jQuery=_jQuery;}return jQuery;};if(!noGlobal){window.jQuery=window.$=jQuery;}return jQuery;});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var before=__webpack_require__(164);function once(func){return before(2,func);}module.exports=once;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache=__webpack_require__(166);var FUNC_ERROR_TEXT='Expected a function';function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}memoize.Cache=MapCache;module.exports=memoize;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var isObject=__webpack_require__(20),now=__webpack_require__(191),toNumber=__webpack_require__(109);var FUNC_ERROR_TEXT='Expected a function';var nativeMax=Math.max,nativeMin=Math.min;function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){lastInvokeTime=time;timerId=setTimeout(timerExpired,wait);return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}module.exports=debounce;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(12),pullAll=__webpack_require__(188);var pull=baseRest(pullAll);module.exports=pull;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('flow',__webpack_require__(177));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

var isArray=Array.isArray;module.exports=isArray;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(43),baseOrderBy=__webpack_require__(208),baseRest=__webpack_require__(12),isIterateeCall=__webpack_require__(46);var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});module.exports=sortBy;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?module.exports=n():undefined;}(this,function(){"use strict";var t="millisecond",n="second",e="minute",r="hour",i="day",s="week",u="month",o="quarter",a="year",h=/^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,f=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,n,e){var r=String(t);return!r||r.length>=n?t:""+Array(n+1-r.length).join(e)+t;},$={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},l="en",m={};m[l]=$;var y=function(t){return t instanceof v;},M=function(t,n,e){var r;if(!t)return l;if("string"==typeof t)m[t]&&(r=t),n&&(m[t]=n,r=t);else{var i=t.name;m[i]=t,r=i;}return e||(l=r),r;},g=function(t,n,e){if(y(t))return t.clone();var r=n?"string"==typeof n?{format:n,pl:e}:n:{};return r.date=t,new v(r);},D={s:c,z:function(t){var n=-t.utcOffset(),e=Math.abs(n),r=Math.floor(e/60);return(n<=0?"+":"-")+c(r,2,"0")+":"+c(e%60,2,"0");},m:function(t,n){var e=12*(n.year()-t.year())+(n.month()-t.month()),r=t.clone().add(e,u),i=n-r<0,s=t.clone().add(e+(i?-1:1),u);return Number(-(e+(n-r)/(i?r-s:s-r))||0);},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t);},p:function(h){return{M:u,y:a,w:s,d:i,h:r,m:e,s:n,ms:t,Q:o}[h]||String(h||"").toLowerCase().replace(/s$/,"");},u:function(t){return void 0===t;}};D.l=M,D.i=y,D.w=function(t,n){return g(t,{locale:n.$L,utc:n.$u,$offset:n.$offset});};var v=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0),this.parse(t);}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var n=t.date,e=t.utc;if(null===n)return new Date(NaN);if(D.u(n))return new Date();if(n instanceof Date)return new Date(n);if("string"==typeof n&&!/Z$/i.test(n)){var r=n.match(h);if(r)return e?new Date(Date.UTC(r[1],r[2]-1,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)):new Date(r[1],r[2]-1,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0);}return new Date(n);}(t),this.init();},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},d.$utils=function(){return D;},d.isValid=function(){return!("Invalid Date"===this.$d.toString());},d.isSame=function(t,n){var e=g(t);return this.startOf(n)<=e&&e<=this.endOf(n);},d.isAfter=function(t,n){return g(t)<this.startOf(n);},d.isBefore=function(t,n){return this.endOf(n)<g(t);},d.$g=function(t,n,e){return D.u(t)?this[n]:this.set(e,t);},d.year=function(t){return this.$g(t,"$y",a);},d.month=function(t){return this.$g(t,"$M",u);},d.day=function(t){return this.$g(t,"$W",i);},d.date=function(t){return this.$g(t,"$D","date");},d.hour=function(t){return this.$g(t,"$H",r);},d.minute=function(t){return this.$g(t,"$m",e);},d.second=function(t){return this.$g(t,"$s",n);},d.millisecond=function(n){return this.$g(n,"$ms",t);},d.unix=function(){return Math.floor(this.valueOf()/1e3);},d.valueOf=function(){return this.$d.getTime();},d.startOf=function(t,o){var h=this,f=!!D.u(o)||o,c=D.p(t),d=function(t,n){var e=D.w(h.$u?Date.UTC(h.$y,n,t):new Date(h.$y,n,t),h);return f?e:e.endOf(i);},$=function(t,n){return D.w(h.toDate()[t].apply(h.toDate(),(f?[0,0,0,0]:[23,59,59,999]).slice(n)),h);},l=this.$W,m=this.$M,y=this.$D,M="set"+(this.$u?"UTC":"");switch(c){case a:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,v=(l<g?l+7:l)-g;return d(f?y-v:y+(6-v),m);case i:case"date":return $(M+"Hours",0);case r:return $(M+"Minutes",1);case e:return $(M+"Seconds",2);case n:return $(M+"Milliseconds",3);default:return this.clone();}},d.endOf=function(t){return this.startOf(t,!1);},d.$set=function(s,o){var h,f=D.p(s),c="set"+(this.$u?"UTC":""),d=(h={},h[i]=c+"Date",h.date=c+"Date",h[u]=c+"Month",h[a]=c+"FullYear",h[r]=c+"Hours",h[e]=c+"Minutes",h[n]=c+"Seconds",h[t]=c+"Milliseconds",h)[f],$=f===i?this.$D+(o-this.$W):o;if(f===u||f===a){var l=this.clone().set("date",1);l.$d[d]($),l.init(),this.$d=l.set("date",Math.min(this.$D,l.daysInMonth())).toDate();}else d&&this.$d[d]($);return this.init(),this;},d.set=function(t,n){return this.clone().$set(t,n);},d.get=function(t){return this[D.p(t)]();},d.add=function(t,o){var h,f=this;t=Number(t);var c=D.p(o),d=function(n){var e=g(f);return D.w(e.date(e.date()+Math.round(n*t)),f);};if(c===u)return this.set(u,this.$M+t);if(c===a)return this.set(a,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(h={},h[e]=6e4,h[r]=36e5,h[n]=1e3,h)[c]||1,l=this.$d.getTime()+t*$;return D.w(l,this);},d.subtract=function(t,n){return this.add(-1*t,n);},d.format=function(t){var n=this;if(!this.isValid())return"Invalid Date";var e=t||"YYYY-MM-DDTHH:mm:ssZ",r=D.z(this),i=this.$locale(),s=this.$H,u=this.$m,o=this.$M,a=i.weekdays,h=i.months,c=function(t,r,i,s){return t&&(t[r]||t(n,e))||i[r].substr(0,s);},d=function(t){return D.s(s%12||12,t,"0");},$=i.meridiem||function(t,n,e){var r=t<12?"AM":"PM";return e?r.toLowerCase():r;},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:o+1,MM:D.s(o+1,2,"0"),MMM:c(i.monthsShort,o,h,3),MMMM:h[o]||h(this,e),D:this.$D,DD:D.s(this.$D,2,"0"),d:String(this.$W),dd:c(i.weekdaysMin,this.$W,a,2),ddd:c(i.weekdaysShort,this.$W,a,3),dddd:a[this.$W],H:String(s),HH:D.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:D.s(u,2,"0"),s:String(this.$s),ss:D.s(this.$s,2,"0"),SSS:D.s(this.$ms,3,"0"),Z:r};return e.replace(f,function(t,n){return n||l[t]||r.replace(":","");});},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15);},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[a]=y/12,c[u]=y,c[o]=y/3,c[s]=(m-l)/6048e5,c[i]=(m-l)/864e5,c[r]=m/36e5,c[e]=m/6e4,c[n]=m/1e3,c)[d]||m,f?y:D.a(y);},d.daysInMonth=function(){return this.endOf(u).$D;},d.$locale=function(){return m[this.$L];},d.locale=function(t,n){if(!t)return this.$L;var e=this.clone(),r=M(t,n,!0);return r&&(e.$L=r),e;},d.clone=function(){return D.w(this.$d,this);},d.toDate=function(){return new Date(this.valueOf());},d.toJSON=function(){return this.isValid()?this.toISOString():null;},d.toISOString=function(){return this.$d.toISOString();},d.toString=function(){return this.$d.toUTCString();},c;}();return g.prototype=v.prototype,g.extend=function(t,n){return t(n,v,g),g;},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t);},g.en=m[l],g.Ls=m,g;});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference=__webpack_require__(111),baseFlatten=__webpack_require__(43),baseRest=__webpack_require__(12),isArrayLikeObject=__webpack_require__(35);var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});module.exports=difference;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var identity=__webpack_require__(103),overRest=__webpack_require__(95),setToString=__webpack_require__(96);function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}module.exports=baseRest;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}module.exports=last;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual=__webpack_require__(215);function isEqual(value,other){return baseIsEqual(value,other);}module.exports=isEqual;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('map',__webpack_require__(223));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys=__webpack_require__(94),getTag=__webpack_require__(60),isArguments=__webpack_require__(62),isArray=__webpack_require__(6),isArrayLike=__webpack_require__(108),isBuffer=__webpack_require__(67),isPrototype=__webpack_require__(227),isTypedArray=__webpack_require__(68);var mapTag='[object Map]',setTag='[object Set]';var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}module.exports=isEmpty;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports={};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference=__webpack_require__(111),baseRest=__webpack_require__(12),isArrayLikeObject=__webpack_require__(35);var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});module.exports=without;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var baseConvert=__webpack_require__(135),util=__webpack_require__(137);function convert(name,func,options){return baseConvert(util,name,func,options);}module.exports=convert;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}module.exports=isObject;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(43);function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}module.exports=flatten;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(11),baseIteratee=__webpack_require__(7),basePickBy=__webpack_require__(104),getAllKeysIn=__webpack_require__(229);function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=baseIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}module.exports=pickBy;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

(function(global,factory){ true?module.exports=factory():undefined;})(this,function(){'use strict';var freeze$1=Object.freeze||function(x){return x;};var html=freeze$1(['a','abbr','acronym','address','area','article','aside','audio','b','bdi','bdo','big','blink','blockquote','body','br','button','canvas','caption','center','cite','code','col','colgroup','content','data','datalist','dd','decorator','del','details','dfn','dir','div','dl','dt','element','em','fieldset','figcaption','figure','font','footer','form','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i','img','input','ins','kbd','label','legend','li','main','map','mark','marquee','menu','menuitem','meter','nav','nobr','ol','optgroup','option','output','p','pre','progress','q','rp','rt','ruby','s','samp','section','select','shadow','small','source','spacer','span','strike','strong','style','sub','summary','sup','table','tbody','td','template','textarea','tfoot','th','thead','time','tr','track','tt','u','ul','var','video','wbr']);var svg=freeze$1(['svg','a','altglyph','altglyphdef','altglyphitem','animatecolor','animatemotion','animatetransform','audio','canvas','circle','clippath','defs','desc','ellipse','filter','font','g','glyph','glyphref','hkern','image','line','lineargradient','marker','mask','metadata','mpath','path','pattern','polygon','polyline','radialgradient','rect','stop','style','switch','symbol','text','textpath','title','tref','tspan','video','view','vkern']);var svgFilters=freeze$1(['feBlend','feColorMatrix','feComponentTransfer','feComposite','feConvolveMatrix','feDiffuseLighting','feDisplacementMap','feDistantLight','feFlood','feFuncA','feFuncB','feFuncG','feFuncR','feGaussianBlur','feMerge','feMergeNode','feMorphology','feOffset','fePointLight','feSpecularLighting','feSpotLight','feTile','feTurbulence']);var mathMl=freeze$1(['math','menclose','merror','mfenced','mfrac','mglyph','mi','mlabeledtr','mmultiscripts','mn','mo','mover','mpadded','mphantom','mroot','mrow','ms','mspace','msqrt','mstyle','msub','msup','msubsup','mtable','mtd','mtext','mtr','munder','munderover']);var text=freeze$1(['#text']);var freeze$2=Object.freeze||function(x){return x;};var html$1=freeze$2(['accept','action','align','alt','autocomplete','background','bgcolor','border','cellpadding','cellspacing','checked','cite','class','clear','color','cols','colspan','controls','coords','crossorigin','datetime','default','dir','disabled','download','enctype','face','for','headers','height','hidden','high','href','hreflang','id','integrity','ismap','label','lang','list','loop','low','max','maxlength','media','method','min','minlength','multiple','name','noshade','novalidate','nowrap','open','optimum','pattern','placeholder','poster','preload','pubdate','radiogroup','readonly','rel','required','rev','reversed','role','rows','rowspan','spellcheck','scope','selected','shape','size','sizes','span','srclang','start','src','srcset','step','style','summary','tabindex','title','type','usemap','valign','value','width','xmlns']);var svg$1=freeze$2(['accent-height','accumulate','additive','alignment-baseline','ascent','attributename','attributetype','azimuth','basefrequency','baseline-shift','begin','bias','by','class','clip','clip-path','clip-rule','color','color-interpolation','color-interpolation-filters','color-profile','color-rendering','cx','cy','d','dx','dy','diffuseconstant','direction','display','divisor','dur','edgemode','elevation','end','fill','fill-opacity','fill-rule','filter','filterunits','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','fx','fy','g1','g2','glyph-name','glyphref','gradientunits','gradienttransform','height','href','id','image-rendering','in','in2','k','k1','k2','k3','k4','kerning','keypoints','keysplines','keytimes','lang','lengthadjust','letter-spacing','kernelmatrix','kernelunitlength','lighting-color','local','marker-end','marker-mid','marker-start','markerheight','markerunits','markerwidth','maskcontentunits','maskunits','max','mask','media','method','mode','min','name','numoctaves','offset','operator','opacity','order','orient','orientation','origin','overflow','paint-order','path','pathlength','patterncontentunits','patterntransform','patternunits','points','preservealpha','preserveaspectratio','primitiveunits','r','rx','ry','radius','refx','refy','repeatcount','repeatdur','restart','result','rotate','scale','seed','shape-rendering','specularconstant','specularexponent','spreadmethod','stddeviation','stitchtiles','stop-color','stop-opacity','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke','stroke-width','style','surfacescale','tabindex','targetx','targety','transform','text-anchor','text-decoration','text-rendering','textlength','type','u1','u2','unicode','values','viewbox','visibility','version','vert-adv-y','vert-origin-x','vert-origin-y','width','word-spacing','wrap','writing-mode','xchannelselector','ychannelselector','x','x1','x2','xmlns','y','y1','y2','z','zoomandpan']);var mathMl$1=freeze$2(['accent','accentunder','align','bevelled','close','columnsalign','columnlines','columnspan','denomalign','depth','dir','display','displaystyle','encoding','fence','frame','height','href','id','largeop','length','linethickness','lspace','lquote','mathbackground','mathcolor','mathsize','mathvariant','maxsize','minsize','movablelimits','notation','numalign','open','rowalign','rowlines','rowspacing','rowspan','rspace','rquote','scriptlevel','scriptminsize','scriptsizemultiplier','selection','separator','separators','stretchy','subscriptshift','supscriptshift','symmetric','voffset','width','xmlns']);var xml=freeze$2(['xlink:href','xml:id','xlink:title','xml:space','xmlns:xlink']);var hasOwnProperty=Object.hasOwnProperty;var setPrototypeOf=Object.setPrototypeOf;var _ref$1=typeof Reflect!=='undefined'&&Reflect;var apply$1=_ref$1.apply;if(!apply$1){apply$1=function(fun,thisValue,args){return fun.apply(thisValue,args);};}function addToSet(set,array){if(setPrototypeOf){setPrototypeOf(set,null);}var l=array.length;while(l--){var element=array[l];if(typeof element==='string'){var lcElement=element.toLowerCase();if(lcElement!==element){if(!Object.isFrozen(array)){array[l]=lcElement;}element=lcElement;}}set[element]=true;}return set;}function clone(object){var newObject={};var property=void 0;for(property in object){if(apply$1(hasOwnProperty,object,[property])){newObject[property]=object[property];}}return newObject;}var seal=Object.seal||function(x){return x;};var MUSTACHE_EXPR=seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);var ERB_EXPR=seal(/<%[\s\S]*|[\s\S]*%>/gm);var DATA_ATTR=seal(/^data-[\-\w.\u00B7-\uFFFF]/);var ARIA_ATTR=seal(/^aria-[\-\w]+$/);var IS_ALLOWED_URI=seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);var IS_SCRIPT_OR_DATA=seal(/^(?:\w+script|data):/i);var ATTR_WHITESPACE=seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g);var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}var _ref=typeof Reflect!=='undefined'&&Reflect;var apply=_ref.apply;var arraySlice=Array.prototype.slice;var freeze=Object.freeze;var getGlobal=function(){return typeof window==='undefined'?null:window;};if(!apply){apply=function(fun,thisValue,args){return fun.apply(thisValue,args);};}var _createTrustedTypesPolicy=function(trustedTypes,document){if((typeof trustedTypes==='undefined'?'undefined':_typeof(trustedTypes))!=='object'||typeof trustedTypes.createPolicy!=='function'){return null;}var suffix=null;var ATTR_NAME='data-tt-policy-suffix';if(document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)){suffix=document.currentScript.getAttribute(ATTR_NAME);}var policyName='dompurify'+(suffix?'#'+suffix:'');try{return trustedTypes.createPolicy(policyName,{createHTML:function(html$$1){return html$$1;}});}catch(error){console.warn('TrustedTypes policy '+policyName+' could not be created.');return null;}};function createDOMPurify(){var window=arguments.length>0&&arguments[0]!==undefined?arguments[0]:getGlobal();var DOMPurify=function(root){return createDOMPurify(root);};DOMPurify.version='2.0.7';DOMPurify.removed=[];if(!window||!window.document||window.document.nodeType!==9){DOMPurify.isSupported=false;return DOMPurify;}var originalDocument=window.document;var useDOMParser=false;var removeTitle=false;var document=window.document;var DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=_window$NamedNodeMap===undefined?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,Text=window.Text,Comment=window.Comment,DOMParser=window.DOMParser,TrustedTypes=window.TrustedTypes;if(typeof HTMLTemplateElement==='function'){var template=document.createElement('template');if(template.content&&template.content.ownerDocument){document=template.content.ownerDocument;}}var trustedTypesPolicy=_createTrustedTypesPolicy(TrustedTypes,originalDocument);var emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(''):'';var _document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,getElementsByTagName=_document.getElementsByTagName,createDocumentFragment=_document.createDocumentFragment;var importNode=originalDocument.importNode;var hooks={};DOMPurify.isSupported=implementation&&typeof implementation.createHTMLDocument!=='undefined'&&document.documentMode!==9;var MUSTACHE_EXPR$$1=MUSTACHE_EXPR,ERB_EXPR$$1=ERB_EXPR,ATTR_WHITESPACE$$1=ATTR_WHITESPACE;var IS_ALLOWED_URI$$1=IS_ALLOWED_URI;var ALLOWED_TAGS=null;var DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(html),_toConsumableArray(svg),_toConsumableArray(svgFilters),_toConsumableArray(mathMl),_toConsumableArray(text)));var ALLOWED_ATTR=null;var DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray(html$1),_toConsumableArray(svg$1),_toConsumableArray(mathMl$1),_toConsumableArray(xml)));var FORBID_TAGS=null;var FORBID_ATTR=null;var ALLOW_ARIA_ATTR=true;var ALLOW_DATA_ATTR=true;var ALLOW_UNKNOWN_PROTOCOLS=false;var SAFE_FOR_JQUERY=false;var SAFE_FOR_TEMPLATES=false;var WHOLE_DOCUMENT=false;var SET_CONFIG=false;var FORCE_BODY=false;var RETURN_DOM=false;var RETURN_DOM_FRAGMENT=false;var RETURN_DOM_IMPORT=false;var RETURN_TRUSTED_TYPE=false;var SANITIZE_DOM=true;var KEEP_CONTENT=true;var IN_PLACE=false;var USE_PROFILES={};var FORBID_CONTENTS=addToSet({},['annotation-xml','audio','colgroup','desc','foreignobject','head','iframe','math','mi','mn','mo','ms','mtext','noembed','noframes','plaintext','script','style','svg','template','thead','title','video','xmp']);var DATA_URI_TAGS=addToSet({},['audio','video','img','source','image']);var URI_SAFE_ATTRIBUTES=null;var DEFAULT_URI_SAFE_ATTRIBUTES=addToSet({},['alt','class','for','id','label','name','pattern','placeholder','summary','title','value','style','xmlns']);var CONFIG=null;var formElement=document.createElement('form');var _parseConfig=function(cfg){if(CONFIG&&CONFIG===cfg){return;}if(!cfg||(typeof cfg==='undefined'?'undefined':_typeof(cfg))!=='object'){cfg={};}ALLOWED_TAGS='ALLOWED_TAGS'in cfg?addToSet({},cfg.ALLOWED_TAGS):DEFAULT_ALLOWED_TAGS;ALLOWED_ATTR='ALLOWED_ATTR'in cfg?addToSet({},cfg.ALLOWED_ATTR):DEFAULT_ALLOWED_ATTR;URI_SAFE_ATTRIBUTES='ADD_URI_SAFE_ATTR'in cfg?addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),cfg.ADD_URI_SAFE_ATTR):DEFAULT_URI_SAFE_ATTRIBUTES;FORBID_TAGS='FORBID_TAGS'in cfg?addToSet({},cfg.FORBID_TAGS):{};FORBID_ATTR='FORBID_ATTR'in cfg?addToSet({},cfg.FORBID_ATTR):{};USE_PROFILES='USE_PROFILES'in cfg?cfg.USE_PROFILES:false;ALLOW_ARIA_ATTR=cfg.ALLOW_ARIA_ATTR!==false;ALLOW_DATA_ATTR=cfg.ALLOW_DATA_ATTR!==false;ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||false;SAFE_FOR_JQUERY=cfg.SAFE_FOR_JQUERY||false;SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||false;WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||false;RETURN_DOM=cfg.RETURN_DOM||false;RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||false;RETURN_DOM_IMPORT=cfg.RETURN_DOM_IMPORT||false;RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||false;FORCE_BODY=cfg.FORCE_BODY||false;SANITIZE_DOM=cfg.SANITIZE_DOM!==false;KEEP_CONTENT=cfg.KEEP_CONTENT!==false;IN_PLACE=cfg.IN_PLACE||false;IS_ALLOWED_URI$$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$$1;if(SAFE_FOR_TEMPLATES){ALLOW_DATA_ATTR=false;}if(RETURN_DOM_FRAGMENT){RETURN_DOM=true;}if(USE_PROFILES){ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(text)));ALLOWED_ATTR=[];if(USE_PROFILES.html===true){addToSet(ALLOWED_TAGS,html);addToSet(ALLOWED_ATTR,html$1);}if(USE_PROFILES.svg===true){addToSet(ALLOWED_TAGS,svg);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.svgFilters===true){addToSet(ALLOWED_TAGS,svgFilters);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.mathMl===true){addToSet(ALLOWED_TAGS,mathMl);addToSet(ALLOWED_ATTR,mathMl$1);addToSet(ALLOWED_ATTR,xml);}}if(cfg.ADD_TAGS){if(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS){ALLOWED_TAGS=clone(ALLOWED_TAGS);}addToSet(ALLOWED_TAGS,cfg.ADD_TAGS);}if(cfg.ADD_ATTR){if(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR){ALLOWED_ATTR=clone(ALLOWED_ATTR);}addToSet(ALLOWED_ATTR,cfg.ADD_ATTR);}if(cfg.ADD_URI_SAFE_ATTR){addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR);}if(KEEP_CONTENT){ALLOWED_TAGS['#text']=true;}if(WHOLE_DOCUMENT){addToSet(ALLOWED_TAGS,['html','head','body']);}if(ALLOWED_TAGS.table){addToSet(ALLOWED_TAGS,['tbody']);delete FORBID_TAGS.tbody;}if(freeze){freeze(cfg);}CONFIG=cfg;};var _forceRemove=function(node){DOMPurify.removed.push({element:node});try{node.parentNode.removeChild(node);}catch(error){node.outerHTML=emptyHTML;}};var _removeAttribute=function(name,node){try{DOMPurify.removed.push({attribute:node.getAttributeNode(name),from:node});}catch(error){DOMPurify.removed.push({attribute:null,from:node});}node.removeAttribute(name);};var _initDocument=function(dirty){var doc=void 0;var leadingWhitespace=void 0;if(FORCE_BODY){dirty='<remove></remove>'+dirty;}else{var matches=dirty.match(/^[\s]+/);leadingWhitespace=matches&&matches[0];if(leadingWhitespace){dirty=dirty.slice(leadingWhitespace.length);}}if(useDOMParser){try{doc=new DOMParser().parseFromString(dirty,'text/html');}catch(error){}}if(removeTitle){addToSet(FORBID_TAGS,['title']);}if(!doc||!doc.documentElement){doc=implementation.createHTMLDocument('');var _doc=doc,body=_doc.body;body.parentNode.removeChild(body.parentNode.firstElementChild);body.outerHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;}if(dirty&&leadingWhitespace){doc.body.insertBefore(document.createTextNode(leadingWhitespace),doc.body.childNodes[0]||null);}return getElementsByTagName.call(doc,WHOLE_DOCUMENT?'html':'body')[0];};if(DOMPurify.isSupported){(function(){try{var doc=_initDocument('<svg><p><textarea><img src="</textarea><img src=x abc=1//">');if(doc.querySelector('svg img')){useDOMParser=true;}}catch(error){}})();(function(){try{var doc=_initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');if(/<\/title/.test(doc.querySelector('title').innerHTML)){removeTitle=true;}}catch(error){}})();}var _createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,function(){return NodeFilter.FILTER_ACCEPT;},false);};var _isClobbered=function(elm){if(elm instanceof Text||elm instanceof Comment){return false;}if(typeof elm.nodeName!=='string'||typeof elm.textContent!=='string'||typeof elm.removeChild!=='function'||!(elm.attributes instanceof NamedNodeMap)||typeof elm.removeAttribute!=='function'||typeof elm.setAttribute!=='function'||typeof elm.namespaceURI!=='string'){return true;}return false;};var _isNode=function(obj){return(typeof Node==='undefined'?'undefined':_typeof(Node))==='object'?obj instanceof Node:obj&&(typeof obj==='undefined'?'undefined':_typeof(obj))==='object'&&typeof obj.nodeType==='number'&&typeof obj.nodeName==='string';};var _executeHook=function(entryPoint,currentNode,data){if(!hooks[entryPoint]){return;}hooks[entryPoint].forEach(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG);});};var _sanitizeElements=function(currentNode){var content=void 0;_executeHook('beforeSanitizeElements',currentNode,null);if(_isClobbered(currentNode)){_forceRemove(currentNode);return true;}var tagName=currentNode.nodeName.toLowerCase();_executeHook('uponSanitizeElement',currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS});if((tagName==='svg'||tagName==='math')&&currentNode.querySelectorAll('p, br').length!==0){_forceRemove(currentNode);return true;}if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]&&typeof currentNode.insertAdjacentHTML==='function'){try{var htmlToInsert=currentNode.innerHTML;currentNode.insertAdjacentHTML('AfterEnd',trustedTypesPolicy?trustedTypesPolicy.createHTML(htmlToInsert):htmlToInsert);}catch(error){}}_forceRemove(currentNode);return true;}if(tagName==='noscript'&&/<\/noscript/i.test(currentNode.innerHTML)){_forceRemove(currentNode);return true;}if(tagName==='noembed'&&/<\/noembed/i.test(currentNode.innerHTML)){_forceRemove(currentNode);return true;}if(SAFE_FOR_JQUERY&&!currentNode.firstElementChild&&(!currentNode.content||!currentNode.content.firstElementChild)&&/</g.test(currentNode.textContent)){DOMPurify.removed.push({element:currentNode.cloneNode()});if(currentNode.innerHTML){currentNode.innerHTML=currentNode.innerHTML.replace(/</g,'&lt;');}else{currentNode.innerHTML=currentNode.textContent.replace(/</g,'&lt;');}}if(SAFE_FOR_TEMPLATES&&currentNode.nodeType===3){content=currentNode.textContent;content=content.replace(MUSTACHE_EXPR$$1,' ');content=content.replace(ERB_EXPR$$1,' ');if(currentNode.textContent!==content){DOMPurify.removed.push({element:currentNode.cloneNode()});currentNode.textContent=content;}}_executeHook('afterSanitizeElements',currentNode,null);return false;};var _isValidAttribute=function(lcTag,lcName,value){if(SANITIZE_DOM&&(lcName==='id'||lcName==='name')&&(value in document||value in formElement)){return false;}if(ALLOW_DATA_ATTR&&DATA_ATTR.test(lcName)){}else if(ALLOW_ARIA_ATTR&&ARIA_ATTR.test(lcName)){}else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){return false;}else if(URI_SAFE_ATTRIBUTES[lcName]){}else if(IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1,''))){}else if((lcName==='src'||lcName==='xlink:href'||lcName==='href')&&lcTag!=='script'&&value.indexOf('data:')===0&&DATA_URI_TAGS[lcTag]){}else if(ALLOW_UNKNOWN_PROTOCOLS&&!IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE$$1,''))){}else if(!!value){return false;}return true;};var _sanitizeAttributes=function(currentNode){var attr=void 0;var value=void 0;var lcName=void 0;var idAttr=void 0;var l=void 0;_executeHook('beforeSanitizeAttributes',currentNode,null);var attributes=currentNode.attributes;if(!attributes){return;}var hookEvent={attrName:'',attrValue:'',keepAttr:true,allowedAttributes:ALLOWED_ATTR};l=attributes.length;while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;value=attr.value.trim();lcName=name.toLowerCase();hookEvent.attrName=lcName;hookEvent.attrValue=value;hookEvent.keepAttr=true;_executeHook('uponSanitizeAttribute',currentNode,hookEvent);value=hookEvent.attrValue;if(lcName==='name'&&currentNode.nodeName==='IMG'&&attributes.id){idAttr=attributes.id;attributes=apply(arraySlice,attributes,[]);_removeAttribute('id',currentNode);_removeAttribute(name,currentNode);if(attributes.indexOf(idAttr)>l){currentNode.setAttribute('id',idAttr.value);}}else if(currentNode.nodeName==='INPUT'&&lcName==='type'&&value==='file'&&hookEvent.keepAttr&&(ALLOWED_ATTR[lcName]||!FORBID_ATTR[lcName])){continue;}else{if(name==='id'){currentNode.setAttribute(name,'');}_removeAttribute(name,currentNode);}if(!hookEvent.keepAttr){continue;}if(/svg|math/i.test(currentNode.namespaceURI)&&new RegExp('</('+Object.keys(FORBID_CONTENTS).join('|')+')','i').test(value)){_removeAttribute(name,currentNode);continue;}if(SAFE_FOR_TEMPLATES){value=value.replace(MUSTACHE_EXPR$$1,' ');value=value.replace(ERB_EXPR$$1,' ');}var lcTag=currentNode.nodeName.toLowerCase();if(!_isValidAttribute(lcTag,lcName,value)){continue;}try{if(namespaceURI){currentNode.setAttributeNS(namespaceURI,name,value);}else{currentNode.setAttribute(name,value);}DOMPurify.removed.pop();}catch(error){}}_executeHook('afterSanitizeAttributes',currentNode,null);};var _sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode=void 0;var shadowIterator=_createIterator(fragment);_executeHook('beforeSanitizeShadowDOM',fragment,null);while(shadowNode=shadowIterator.nextNode()){_executeHook('uponSanitizeShadowNode',shadowNode,null);if(_sanitizeElements(shadowNode)){continue;}if(shadowNode.content instanceof DocumentFragment){_sanitizeShadowDOM(shadowNode.content);}_sanitizeAttributes(shadowNode);}_executeHook('afterSanitizeShadowDOM',fragment,null);};DOMPurify.sanitize=function(dirty,cfg){var body=void 0;var importedNode=void 0;var currentNode=void 0;var oldNode=void 0;var returnNode=void 0;if(!dirty){dirty='<!-->';}if(typeof dirty!=='string'&&!_isNode(dirty)){if(typeof dirty.toString!=='function'){throw new TypeError('toString is not a function');}else{dirty=dirty.toString();if(typeof dirty!=='string'){throw new TypeError('dirty is not a string, aborting');}}}if(!DOMPurify.isSupported){if(_typeof(window.toStaticHTML)==='object'||typeof window.toStaticHTML==='function'){if(typeof dirty==='string'){return window.toStaticHTML(dirty);}if(_isNode(dirty)){return window.toStaticHTML(dirty.outerHTML);}}return dirty;}if(!SET_CONFIG){_parseConfig(cfg);}DOMPurify.removed=[];if(IN_PLACE){}else if(dirty instanceof Node){body=_initDocument('<!-->');importedNode=body.ownerDocument.importNode(dirty,true);if(importedNode.nodeType===1&&importedNode.nodeName==='BODY'){body=importedNode;}else if(importedNode.nodeName==='HTML'){body=importedNode;}else{body.appendChild(importedNode);}}else{if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&RETURN_TRUSTED_TYPE&&dirty.indexOf('<')===-1){return trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;}body=_initDocument(dirty);if(!body){return RETURN_DOM?null:emptyHTML;}}if(body&&FORCE_BODY){_forceRemove(body.firstChild);}var nodeIterator=_createIterator(IN_PLACE?dirty:body);while(currentNode=nodeIterator.nextNode()){if(currentNode.nodeType===3&&currentNode===oldNode){continue;}if(_sanitizeElements(currentNode)){continue;}if(currentNode.content instanceof DocumentFragment){_sanitizeShadowDOM(currentNode.content);}_sanitizeAttributes(currentNode);oldNode=currentNode;}oldNode=null;if(IN_PLACE){return dirty;}if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild){returnNode.appendChild(body.firstChild);}}else{returnNode=body;}if(RETURN_DOM_IMPORT){returnNode=importNode.call(originalDocument,returnNode,true);}return returnNode;}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;if(SAFE_FOR_TEMPLATES){serializedHTML=serializedHTML.replace(MUSTACHE_EXPR$$1,' ');serializedHTML=serializedHTML.replace(ERB_EXPR$$1,' ');}return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML;};DOMPurify.setConfig=function(cfg){_parseConfig(cfg);SET_CONFIG=true;};DOMPurify.clearConfig=function(){CONFIG=null;SET_CONFIG=false;};DOMPurify.isValidAttribute=function(tag,attr,value){if(!CONFIG){_parseConfig({});}var lcTag=tag.toLowerCase();var lcName=attr.toLowerCase();return _isValidAttribute(lcTag,lcName,value);};DOMPurify.addHook=function(entryPoint,hookFunction){if(typeof hookFunction!=='function'){return;}hooks[entryPoint]=hooks[entryPoint]||[];hooks[entryPoint].push(hookFunction);};DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint]){hooks[entryPoint].pop();}};DOMPurify.removeHooks=function(entryPoint){if(hooks[entryPoint]){hooks[entryPoint]=[];}};DOMPurify.removeAllHooks=function(){hooks={};};return DOMPurify;}var purify=createDOMPurify();return purify;});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal=__webpack_require__(141);var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;var root=freeGlobal||freeSelf||Function('return this')();module.exports=root;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(12),unzipWith=__webpack_require__(181);var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});module.exports=zipWith;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(31),createAggregator=__webpack_require__(64);var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});module.exports=groupBy;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var debounce=__webpack_require__(3),isObject=__webpack_require__(20);var FUNC_ERROR_TEXT='Expected a function';function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}module.exports=throttle;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('keyBy',__webpack_require__(73));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var baseClamp=__webpack_require__(226),toNumber=__webpack_require__(109);function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}module.exports=clamp;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach=__webpack_require__(92),baseCreate=__webpack_require__(79),baseForOwn=__webpack_require__(110),baseIteratee=__webpack_require__(7),getPrototype=__webpack_require__(93),isArray=__webpack_require__(6),isBuffer=__webpack_require__(67),isFunction=__webpack_require__(59),isObject=__webpack_require__(20),isTypedArray=__webpack_require__(68);function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=baseIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}module.exports=transform;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty=__webpack_require__(150);function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}module.exports=baseAssignValue;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

function isObjectLike(value){return value!=null&&typeof value=='object';}module.exports=isObjectLike;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(6),isKey=__webpack_require__(172),stringToPath=__webpack_require__(97),toString=__webpack_require__(63);function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}module.exports=castPath;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike=__webpack_require__(108),isObjectLike=__webpack_require__(32);function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}module.exports=isArrayLikeObject;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var toString=__webpack_require__(63);var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}module.exports=escapeRegExp;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetData=__webpack_require__(139),createBind=__webpack_require__(140),createCurry=__webpack_require__(142),createHybrid=__webpack_require__(80),createPartial=__webpack_require__(147),getData=__webpack_require__(87),mergeData=__webpack_require__(148),setData=__webpack_require__(83),setWrapToString=__webpack_require__(84),toInteger=__webpack_require__(41);var FUNC_ERROR_TEXT='Expected a function';var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64;var nativeMax=Math.max;function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}module.exports=createWrap;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate=__webpack_require__(79),isObject=__webpack_require__(20);function createCtor(Ctor){return function(){var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);return isObject(result)?result:thisBinding;};}module.exports=createCtor;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}module.exports=apply;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

var MAX_SAFE_INTEGER=9007199254740991;var reIsUint=/^(?:0|[1-9]\d*)$/;function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}module.exports=isIndex;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

function overArg(func,transform){return function(arg){return func(transform(arg));};}module.exports=overArg;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush=__webpack_require__(159),isFlattenable=__webpack_require__(160);function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}module.exports=baseFlatten;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var eq=__webpack_require__(90);function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}module.exports=assocIndexOf;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

function baseUnary(func){return function(value){return func(value);};}module.exports=baseUnary;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(6);function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}module.exports=castArray;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf=__webpack_require__(65);function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}module.exports=arrayIncludes;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(37);var WRAP_CURRY_RIGHT_FLAG=16;function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}curryRight.placeholder={};module.exports=curryRight;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(7),basePullAt=__webpack_require__(192);function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=baseIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}module.exports=remove;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum=__webpack_require__(213),baseGt=__webpack_require__(214),baseIteratee=__webpack_require__(7);function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,baseIteratee(iteratee,2),baseGt):undefined;}module.exports=maxBy;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}module.exports=compact;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(11),baseIntersection=__webpack_require__(232),baseRest=__webpack_require__(12),castArrayLikeObject=__webpack_require__(233);var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});module.exports=intersection;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('filter',__webpack_require__(236));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}module.exports=copyArray;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

var objectProto=Object.prototype;var nativeObjectToString=objectProto.toString;function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(58),isObject=__webpack_require__(20);var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';function isFunction(value){if(!isObject(value)){return false;}var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}module.exports=isFunction;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

var objectProto=Object.prototype;var nativeObjectToString=objectProto.toString;function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var flatten=__webpack_require__(21),overRest=__webpack_require__(95),setToString=__webpack_require__(96);function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}module.exports=flatRest;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var arrayAggregator=__webpack_require__(167),baseAggregator=__webpack_require__(168),baseIteratee=__webpack_require__(7),isArray=__webpack_require__(6);function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,baseIteratee(iteratee,2),accumulator);};}module.exports=createAggregator;

/***/ }),
/* 65 */
/***/ (function(module, exports) {

function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}module.exports=strictIndexOf;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}module.exports=baseSlice;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf=__webpack_require__(65);function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}module.exports=arrayIncludes;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}module.exports=arrayIncludesWith;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(48),arrayIncludes=__webpack_require__(69),arrayIncludesWith=__webpack_require__(70),cacheHas=__webpack_require__(49),createSet=__webpack_require__(230),setToArray=__webpack_require__(231);var LARGE_ARRAY_SIZE=200;function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}module.exports=baseUniq;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

const SEMVER_SPEC_VERSION='2.0.0';const MAX_LENGTH=256;const MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||9007199254740991;const MAX_SAFE_COMPONENT_LENGTH=16;module.exports={SEMVER_SPEC_VERSION,MAX_LENGTH,MAX_SAFE_INTEGER,MAX_SAFE_COMPONENT_LENGTH};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(31),createAggregator=__webpack_require__(64);var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});module.exports=keyBy;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

function head(array){return array&&array.length?array[0]:undefined;}module.exports=head;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(31),baseForOwn=__webpack_require__(110),baseIteratee=__webpack_require__(7);function mapValues(object,iteratee){var result={};iteratee=baseIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}module.exports=mapValues;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var createAggregator=__webpack_require__(64);var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});module.exports=partition;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function(Math){var trimLeft=/^\s+/,trimRight=/\s+$/,tinyCounter=0,mathRound=Math.round,mathMin=Math.min,mathMax=Math.max,mathRandom=Math.random;function tinycolor(color,opts){color=color?color:'';opts=opts||{};if(color instanceof tinycolor){return color;}if(!(this instanceof tinycolor)){return new tinycolor(color,opts);}var rgb=inputToRGB(color);this._originalInput=color,this._r=rgb.r,this._g=rgb.g,this._b=rgb.b,this._a=rgb.a,this._roundA=mathRound(100*this._a)/100,this._format=opts.format||rgb.format;this._gradientType=opts.gradientType;if(this._r<1){this._r=mathRound(this._r);}if(this._g<1){this._g=mathRound(this._g);}if(this._b<1){this._b=mathRound(this._b);}this._ok=rgb.ok;this._tc_id=tinyCounter++;}tinycolor.prototype={isDark:function(){return this.getBrightness()<128;},isLight:function(){return!this.isDark();},isValid:function(){return this._ok;},getOriginalInput:function(){return this._originalInput;},getFormat:function(){return this._format;},getAlpha:function(){return this._a;},getBrightness:function(){var rgb=this.toRgb();return(rgb.r*299+rgb.g*587+rgb.b*114)/1000;},getLuminance:function(){var rgb=this.toRgb();var RsRGB,GsRGB,BsRGB,R,G,B;RsRGB=rgb.r/255;GsRGB=rgb.g/255;BsRGB=rgb.b/255;if(RsRGB<=0.03928){R=RsRGB/12.92;}else{R=Math.pow((RsRGB+0.055)/1.055,2.4);}if(GsRGB<=0.03928){G=GsRGB/12.92;}else{G=Math.pow((GsRGB+0.055)/1.055,2.4);}if(BsRGB<=0.03928){B=BsRGB/12.92;}else{B=Math.pow((BsRGB+0.055)/1.055,2.4);}return 0.2126*R+0.7152*G+0.0722*B;},setAlpha:function(value){this._a=boundAlpha(value);this._roundA=mathRound(100*this._a)/100;return this;},toHsv:function(){var hsv=rgbToHsv(this._r,this._g,this._b);return{h:hsv.h*360,s:hsv.s,v:hsv.v,a:this._a};},toHsvString:function(){var hsv=rgbToHsv(this._r,this._g,this._b);var h=mathRound(hsv.h*360),s=mathRound(hsv.s*100),v=mathRound(hsv.v*100);return this._a==1?"hsv("+h+", "+s+"%, "+v+"%)":"hsva("+h+", "+s+"%, "+v+"%, "+this._roundA+")";},toHsl:function(){var hsl=rgbToHsl(this._r,this._g,this._b);return{h:hsl.h*360,s:hsl.s,l:hsl.l,a:this._a};},toHslString:function(){var hsl=rgbToHsl(this._r,this._g,this._b);var h=mathRound(hsl.h*360),s=mathRound(hsl.s*100),l=mathRound(hsl.l*100);return this._a==1?"hsl("+h+", "+s+"%, "+l+"%)":"hsla("+h+", "+s+"%, "+l+"%, "+this._roundA+")";},toHex:function(allow3Char){return rgbToHex(this._r,this._g,this._b,allow3Char);},toHexString:function(allow3Char){return'#'+this.toHex(allow3Char);},toHex8:function(allow4Char){return rgbaToHex(this._r,this._g,this._b,this._a,allow4Char);},toHex8String:function(allow4Char){return'#'+this.toHex8(allow4Char);},toRgb:function(){return{r:mathRound(this._r),g:mathRound(this._g),b:mathRound(this._b),a:this._a};},toRgbString:function(){return this._a==1?"rgb("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+")":"rgba("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+", "+this._roundA+")";},toPercentageRgb:function(){return{r:mathRound(bound01(this._r,255)*100)+"%",g:mathRound(bound01(this._g,255)*100)+"%",b:mathRound(bound01(this._b,255)*100)+"%",a:this._a};},toPercentageRgbString:function(){return this._a==1?"rgb("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%)":"rgba("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%, "+this._roundA+")";},toName:function(){if(this._a===0){return"transparent";}if(this._a<1){return false;}return hexNames[rgbToHex(this._r,this._g,this._b,true)]||false;},toFilter:function(secondColor){var hex8String='#'+rgbaToArgbHex(this._r,this._g,this._b,this._a);var secondHex8String=hex8String;var gradientType=this._gradientType?"GradientType = 1, ":"";if(secondColor){var s=tinycolor(secondColor);secondHex8String='#'+rgbaToArgbHex(s._r,s._g,s._b,s._a);}return"progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";},toString:function(format){var formatSet=!!format;format=format||this._format;var formattedString=false;var hasAlpha=this._a<1&&this._a>=0;var needsAlphaFormat=!formatSet&&hasAlpha&&(format==="hex"||format==="hex6"||format==="hex3"||format==="hex4"||format==="hex8"||format==="name");if(needsAlphaFormat){if(format==="name"&&this._a===0){return this.toName();}return this.toRgbString();}if(format==="rgb"){formattedString=this.toRgbString();}if(format==="prgb"){formattedString=this.toPercentageRgbString();}if(format==="hex"||format==="hex6"){formattedString=this.toHexString();}if(format==="hex3"){formattedString=this.toHexString(true);}if(format==="hex4"){formattedString=this.toHex8String(true);}if(format==="hex8"){formattedString=this.toHex8String();}if(format==="name"){formattedString=this.toName();}if(format==="hsl"){formattedString=this.toHslString();}if(format==="hsv"){formattedString=this.toHsvString();}return formattedString||this.toHexString();},clone:function(){return tinycolor(this.toString());},_applyModification:function(fn,args){var color=fn.apply(null,[this].concat([].slice.call(args)));this._r=color._r;this._g=color._g;this._b=color._b;this.setAlpha(color._a);return this;},lighten:function(){return this._applyModification(lighten,arguments);},brighten:function(){return this._applyModification(brighten,arguments);},darken:function(){return this._applyModification(darken,arguments);},desaturate:function(){return this._applyModification(desaturate,arguments);},saturate:function(){return this._applyModification(saturate,arguments);},greyscale:function(){return this._applyModification(greyscale,arguments);},spin:function(){return this._applyModification(spin,arguments);},_applyCombination:function(fn,args){return fn.apply(null,[this].concat([].slice.call(args)));},analogous:function(){return this._applyCombination(analogous,arguments);},complement:function(){return this._applyCombination(complement,arguments);},monochromatic:function(){return this._applyCombination(monochromatic,arguments);},splitcomplement:function(){return this._applyCombination(splitcomplement,arguments);},triad:function(){return this._applyCombination(triad,arguments);},tetrad:function(){return this._applyCombination(tetrad,arguments);}};tinycolor.fromRatio=function(color,opts){if(typeof color=="object"){var newColor={};for(var i in color){if(color.hasOwnProperty(i)){if(i==="a"){newColor[i]=color[i];}else{newColor[i]=convertToPercentage(color[i]);}}}color=newColor;}return tinycolor(color,opts);};function inputToRGB(color){var rgb={r:0,g:0,b:0};var a=1;var s=null;var v=null;var l=null;var ok=false;var format=false;if(typeof color=="string"){color=stringInputToObject(color);}if(typeof color=="object"){if(isValidCSSUnit(color.r)&&isValidCSSUnit(color.g)&&isValidCSSUnit(color.b)){rgb=rgbToRgb(color.r,color.g,color.b);ok=true;format=String(color.r).substr(-1)==="%"?"prgb":"rgb";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.v)){s=convertToPercentage(color.s);v=convertToPercentage(color.v);rgb=hsvToRgb(color.h,s,v);ok=true;format="hsv";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.l)){s=convertToPercentage(color.s);l=convertToPercentage(color.l);rgb=hslToRgb(color.h,s,l);ok=true;format="hsl";}if(color.hasOwnProperty("a")){a=color.a;}}a=boundAlpha(a);return{ok:ok,format:color.format||format,r:mathMin(255,mathMax(rgb.r,0)),g:mathMin(255,mathMax(rgb.g,0)),b:mathMin(255,mathMax(rgb.b,0)),a:a};}function rgbToRgb(r,g,b){return{r:bound01(r,255)*255,g:bound01(g,255)*255,b:bound01(b,255)*255};}function rgbToHsl(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s,l=(max+min)/2;if(max==min){h=s=0;}else{var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,l:l};}function hslToRgb(h,s,l){var r,g,b;h=bound01(h,360);s=bound01(s,100);l=bound01(l,100);function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}if(s===0){r=g=b=l;}else{var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return{r:r*255,g:g*255,b:b*255};}function rgbToHsv(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s;var d=max-min;s=max===0?0:d/max;if(max==min){h=0;}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,v:max};}function hsvToRgb(h,s,v){h=bound01(h,360)*6;s=bound01(s,100);v=bound01(v,100);var i=Math.floor(h),f=h-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s),mod=i%6,r=[v,q,p,p,t,v][mod],g=[t,v,v,q,p,p][mod],b=[p,p,t,v,v,q][mod];return{r:r*255,g:g*255,b:b*255};}function rgbToHex(r,g,b,allow3Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];if(allow3Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0);}return hex.join("");}function rgbaToHex(r,g,b,a,allow4Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16)),pad2(convertDecimalToHex(a))];if(allow4Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)&&hex[3].charAt(0)==hex[3].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0)+hex[3].charAt(0);}return hex.join("");}function rgbaToArgbHex(r,g,b,a){var hex=[pad2(convertDecimalToHex(a)),pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return hex.join("");}tinycolor.equals=function(color1,color2){if(!color1||!color2){return false;}return tinycolor(color1).toRgbString()==tinycolor(color2).toRgbString();};tinycolor.random=function(){return tinycolor.fromRatio({r:mathRandom(),g:mathRandom(),b:mathRandom()});};function desaturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s-=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function saturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s+=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function greyscale(color){return tinycolor(color).desaturate(100);}function lighten(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l+=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function brighten(color,amount){amount=amount===0?0:amount||10;var rgb=tinycolor(color).toRgb();rgb.r=mathMax(0,mathMin(255,rgb.r-mathRound(255*-(amount/100))));rgb.g=mathMax(0,mathMin(255,rgb.g-mathRound(255*-(amount/100))));rgb.b=mathMax(0,mathMin(255,rgb.b-mathRound(255*-(amount/100))));return tinycolor(rgb);}function darken(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l-=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function spin(color,amount){var hsl=tinycolor(color).toHsl();var hue=(hsl.h+amount)%360;hsl.h=hue<0?360+hue:hue;return tinycolor(hsl);}function complement(color){var hsl=tinycolor(color).toHsl();hsl.h=(hsl.h+180)%360;return tinycolor(hsl);}function triad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+120)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+240)%360,s:hsl.s,l:hsl.l})];}function tetrad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+90)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+180)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+270)%360,s:hsl.s,l:hsl.l})];}function splitcomplement(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+72)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+216)%360,s:hsl.s,l:hsl.l})];}function analogous(color,results,slices){results=results||6;slices=slices||30;var hsl=tinycolor(color).toHsl();var part=360/slices;var ret=[tinycolor(color)];for(hsl.h=(hsl.h-(part*results>>1)+720)%360;--results;){hsl.h=(hsl.h+part)%360;ret.push(tinycolor(hsl));}return ret;}function monochromatic(color,results){results=results||6;var hsv=tinycolor(color).toHsv();var h=hsv.h,s=hsv.s,v=hsv.v;var ret=[];var modification=1/results;while(results--){ret.push(tinycolor({h:h,s:s,v:v}));v=(v+modification)%1;}return ret;}tinycolor.mix=function(color1,color2,amount){amount=amount===0?0:amount||50;var rgb1=tinycolor(color1).toRgb();var rgb2=tinycolor(color2).toRgb();var p=amount/100;var rgba={r:(rgb2.r-rgb1.r)*p+rgb1.r,g:(rgb2.g-rgb1.g)*p+rgb1.g,b:(rgb2.b-rgb1.b)*p+rgb1.b,a:(rgb2.a-rgb1.a)*p+rgb1.a};return tinycolor(rgba);};tinycolor.readability=function(color1,color2){var c1=tinycolor(color1);var c2=tinycolor(color2);return(Math.max(c1.getLuminance(),c2.getLuminance())+0.05)/(Math.min(c1.getLuminance(),c2.getLuminance())+0.05);};tinycolor.isReadable=function(color1,color2,wcag2){var readability=tinycolor.readability(color1,color2);var wcag2Parms,out;out=false;wcag2Parms=validateWCAG2Parms(wcag2);switch(wcag2Parms.level+wcag2Parms.size){case"AAsmall":case"AAAlarge":out=readability>=4.5;break;case"AAlarge":out=readability>=3;break;case"AAAsmall":out=readability>=7;break;}return out;};tinycolor.mostReadable=function(baseColor,colorList,args){var bestColor=null;var bestScore=0;var readability;var includeFallbackColors,level,size;args=args||{};includeFallbackColors=args.includeFallbackColors;level=args.level;size=args.size;for(var i=0;i<colorList.length;i++){readability=tinycolor.readability(baseColor,colorList[i]);if(readability>bestScore){bestScore=readability;bestColor=tinycolor(colorList[i]);}}if(tinycolor.isReadable(baseColor,bestColor,{"level":level,"size":size})||!includeFallbackColors){return bestColor;}else{args.includeFallbackColors=false;return tinycolor.mostReadable(baseColor,["#fff","#000"],args);}};var names=tinycolor.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"};var hexNames=tinycolor.hexNames=function(o){var flipped={};for(var i in o){if(o.hasOwnProperty(i)){flipped[o[i]]=i;}}return flipped;}(names);function boundAlpha(a){a=parseFloat(a);if(isNaN(a)||a<0||a>1){a=1;}return a;}function bound01(n,max){if(isOnePointZero(n)){n="100%";}var processPercent=isPercentage(n);n=mathMin(max,mathMax(0,parseFloat(n)));if(processPercent){n=parseInt(n*max,10)/100;}if(Math.abs(n-max)<0.000001){return 1;}return n%max/parseFloat(max);}function clamp01(val){return mathMin(1,mathMax(0,val));}function parseIntFromHex(val){return parseInt(val,16);}function isOnePointZero(n){return typeof n=="string"&&n.indexOf('.')!=-1&&parseFloat(n)===1;}function isPercentage(n){return typeof n==="string"&&n.indexOf('%')!=-1;}function pad2(c){return c.length==1?'0'+c:''+c;}function convertToPercentage(n){if(n<=1){n=n*100+"%";}return n;}function convertDecimalToHex(d){return Math.round(parseFloat(d)*255).toString(16);}function convertHexToDecimal(h){return parseIntFromHex(h)/255;}var matchers=function(){var CSS_UNIT="(?:"+"[-\\+]?\\d*\\.\\d+%?"+")|(?:"+"[-\\+]?\\d+%?"+")";var PERMISSIVE_MATCH3="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";var PERMISSIVE_MATCH4="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";return{CSS_UNIT:new RegExp(CSS_UNIT),rgb:new RegExp("rgb"+PERMISSIVE_MATCH3),rgba:new RegExp("rgba"+PERMISSIVE_MATCH4),hsl:new RegExp("hsl"+PERMISSIVE_MATCH3),hsla:new RegExp("hsla"+PERMISSIVE_MATCH4),hsv:new RegExp("hsv"+PERMISSIVE_MATCH3),hsva:new RegExp("hsva"+PERMISSIVE_MATCH4),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};}();function isValidCSSUnit(color){return!!matchers.CSS_UNIT.exec(color);}function stringInputToObject(color){color=color.replace(trimLeft,'').replace(trimRight,'').toLowerCase();var named=false;if(names[color]){color=names[color];named=true;}else if(color=='transparent'){return{r:0,g:0,b:0,a:0,format:"name"};}var match;if(match=matchers.rgb.exec(color)){return{r:match[1],g:match[2],b:match[3]};}if(match=matchers.rgba.exec(color)){return{r:match[1],g:match[2],b:match[3],a:match[4]};}if(match=matchers.hsl.exec(color)){return{h:match[1],s:match[2],l:match[3]};}if(match=matchers.hsla.exec(color)){return{h:match[1],s:match[2],l:match[3],a:match[4]};}if(match=matchers.hsv.exec(color)){return{h:match[1],s:match[2],v:match[3]};}if(match=matchers.hsva.exec(color)){return{h:match[1],s:match[2],v:match[3],a:match[4]};}if(match=matchers.hex8.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),a:convertHexToDecimal(match[4]),format:named?"name":"hex8"};}if(match=matchers.hex6.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),format:named?"name":"hex"};}if(match=matchers.hex4.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),a:convertHexToDecimal(match[4]+''+match[4]),format:named?"name":"hex8"};}if(match=matchers.hex3.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),format:named?"name":"hex"};}return false;}function validateWCAG2Parms(parms){var level,size;parms=parms||{"level":"AA","size":"small"};level=(parms.level||"AA").toUpperCase();size=(parms.size||"small").toLowerCase();if(level!=="AA"&&level!=="AAA"){level="AA";}if(size!=="small"&&size!=="large"){size="small";}return{"level":level,"size":size};}if( true&&module.exports){module.exports=tinycolor;}else if(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{}})(Math);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq=__webpack_require__(71);function uniq(array){return array&&array.length?baseUniq(array):[];}module.exports=uniq;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isObject=__webpack_require__(20);var objectCreate=Object.create;var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();module.exports=baseCreate;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var composeArgs=__webpack_require__(143),composeArgsRight=__webpack_require__(144),countHolders=__webpack_require__(145),createCtor=__webpack_require__(38),createRecurry=__webpack_require__(81),getHolder=__webpack_require__(85),reorder=__webpack_require__(146),replaceHolders=__webpack_require__(86),root=__webpack_require__(24);var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_ARY_FLAG=128,WRAP_FLIP_FLAG=512;function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=bitmask&WRAP_BIND_FLAG?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(bitmask&WRAP_FLIP_FLAG&&length>1){args.reverse();}if(bitmask&WRAP_ARY_FLAG&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}module.exports=createHybrid;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var isLaziable=__webpack_require__(82),setData=__webpack_require__(83),setWrapToString=__webpack_require__(84);var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64;function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}module.exports=createRecurry;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 83 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 85 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

function stubArray(){return[];}module.exports=stubArray;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue=__webpack_require__(89),baseAssignValue=__webpack_require__(31);function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}module.exports=copyObject;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue=__webpack_require__(31),eq=__webpack_require__(90);var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}module.exports=assignValue;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(42);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}module.exports=arrayEach;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(42);var getPrototype=overArg(Object.getPrototypeOf,Object);module.exports=getPrototype;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(42);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39);var nativeMax=Math.max;function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}module.exports=overRest;

/***/ }),
/* 96 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped=__webpack_require__(163);var rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;var reEscapeChar=/\\(\\)?/g;var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});module.exports=stringToPath;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

function listCacheClear(){this.__data__=[];this.size=0;}module.exports=listCacheClear;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(45);var arrayProto=Array.prototype;var splice=arrayProto.splice;function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}module.exports=listCacheDelete;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(45);function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}module.exports=listCacheGet;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(45);function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}module.exports=listCacheHas;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf=__webpack_require__(45);function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}module.exports=listCacheSet;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet=__webpack_require__(105),baseSet=__webpack_require__(173),castPath=__webpack_require__(34);function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}module.exports=basePickBy;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(34),toKey=__webpack_require__(33);function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}module.exports=baseGet;

/***/ }),
/* 106 */
/***/ (function(module, exports) {

var MAX_SAFE_INTEGER=9007199254740991;function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}module.exports=isLength;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter=__webpack_require__(182),arrayMap=__webpack_require__(11),baseProperty=__webpack_require__(183),baseTimes=__webpack_require__(184),isArrayLikeObject=__webpack_require__(35);var nativeMax=Math.max;function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}module.exports=unzip;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction=__webpack_require__(59),isLength=__webpack_require__(106);function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}module.exports=isArrayLike;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor=__webpack_require__(195),keys=__webpack_require__(91);function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}module.exports=baseForOwn;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(48),arrayIncludes=__webpack_require__(69),arrayIncludesWith=__webpack_require__(70),arrayMap=__webpack_require__(11),baseUnary=__webpack_require__(47),cacheHas=__webpack_require__(49);var LARGE_ARRAY_SIZE=200;function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}module.exports=baseDifference;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer=__webpack_require__(113);const compare=(a,b,loose)=>new SemVer(a,loose).compare(new SemVer(b,loose));module.exports=compare;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

const debug=__webpack_require__(114);const{MAX_LENGTH,MAX_SAFE_INTEGER}=__webpack_require__(72);const{re,t}=__webpack_require__(115);const{compareIdentifiers}=__webpack_require__(238);class SemVer{constructor(version,options){if(!options||typeof options!=='object'){options={loose:!!options,includePrerelease:false};}if(version instanceof SemVer){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease){return version;}else{version=version.version;}}else if(typeof version!=='string'){throw new TypeError(`Invalid Version: ${version}`);}if(version.length>MAX_LENGTH){throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);}debug('SemVer',version,options);this.options=options;this.loose=!!options.loose;this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re[t.LOOSE]:re[t.FULL]);if(!m){throw new TypeError(`Invalid Version: ${version}`);}this.raw=version;this.major=+m[1];this.minor=+m[2];this.patch=+m[3];if(this.major>MAX_SAFE_INTEGER||this.major<0){throw new TypeError('Invalid major version');}if(this.minor>MAX_SAFE_INTEGER||this.minor<0){throw new TypeError('Invalid minor version');}if(this.patch>MAX_SAFE_INTEGER||this.patch<0){throw new TypeError('Invalid patch version');}if(!m[4]){this.prerelease=[];}else{this.prerelease=m[4].split('.').map(id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER){return num;}}return id;});}this.build=m[5]?m[5].split('.'):[];this.format();}format(){this.version=`${this.major}.${this.minor}.${this.patch}`;if(this.prerelease.length){this.version+=`-${this.prerelease.join('.')}`;}return this.version;}toString(){return this.version;}compare(other){debug('SemVer.compare',this.version,this.options,other);if(!(other instanceof SemVer)){if(typeof other==='string'&&other===this.version){return 0;}other=new SemVer(other,this.options);}if(other.version===this.version){return 0;}return this.compareMain(other)||this.comparePre(other);}compareMain(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}return compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch);}comparePre(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}if(this.prerelease.length&&!other.prerelease.length){return-1;}else if(!this.prerelease.length&&other.prerelease.length){return 1;}else if(!this.prerelease.length&&!other.prerelease.length){return 0;}let i=0;do{const a=this.prerelease[i];const b=other.prerelease[i];debug('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers(a,b);}}while(++i);}compareBuild(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}let i=0;do{const a=this.build[i];const b=other.build[i];debug('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers(a,b);}}while(++i);}inc(release,identifier){switch(release){case'premajor':this.prerelease.length=0;this.patch=0;this.minor=0;this.major++;this.inc('pre',identifier);break;case'preminor':this.prerelease.length=0;this.patch=0;this.minor++;this.inc('pre',identifier);break;case'prepatch':this.prerelease.length=0;this.inc('patch',identifier);this.inc('pre',identifier);break;case'prerelease':if(this.prerelease.length===0){this.inc('patch',identifier);}this.inc('pre',identifier);break;case'major':if(this.minor!==0||this.patch!==0||this.prerelease.length===0){this.major++;}this.minor=0;this.patch=0;this.prerelease=[];break;case'minor':if(this.patch!==0||this.prerelease.length===0){this.minor++;}this.patch=0;this.prerelease=[];break;case'patch':if(this.prerelease.length===0){this.patch++;}this.prerelease=[];break;case'pre':if(this.prerelease.length===0){this.prerelease=[0];}else{let i=this.prerelease.length;while(--i>=0){if(typeof this.prerelease[i]==='number'){this.prerelease[i]++;i=-2;}}if(i===-1){this.prerelease.push(0);}}if(identifier){if(this.prerelease[0]===identifier){if(isNaN(this.prerelease[1])){this.prerelease=[identifier,0];}}else{this.prerelease=[identifier,0];}}break;default:throw new Error(`invalid increment argument: ${release}`);}this.format();this.raw=this.version;return this;}}module.exports=SemVer;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

const debug=typeof process==='object'&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error('SEMVER',...args):()=>{};module.exports=debug;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

const{MAX_SAFE_COMPONENT_LENGTH}=__webpack_require__(72);const debug=__webpack_require__(114);exports=module.exports={};const re=exports.re=[];const src=exports.src=[];const t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug(index,value);t[name]=index;src[index]=value;re[index]=new RegExp(value,isGlobal?'g':undefined);};createToken('NUMERICIDENTIFIER','0|[1-9]\\d*');createToken('NUMERICIDENTIFIERLOOSE','[0-9]+');createToken('NONNUMERICIDENTIFIER','\\d*[a-zA-Z-][a-zA-Z0-9-]*');createToken('MAINVERSION',`(${src[t.NUMERICIDENTIFIER]})\\.`+`(${src[t.NUMERICIDENTIFIER]})\\.`+`(${src[t.NUMERICIDENTIFIER]})`);createToken('MAINVERSIONLOOSE',`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.`+`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.`+`(${src[t.NUMERICIDENTIFIERLOOSE]})`);createToken('PRERELEASEIDENTIFIER',`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);createToken('PRERELEASEIDENTIFIERLOOSE',`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);createToken('PRERELEASE',`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);createToken('PRERELEASELOOSE',`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);createToken('BUILDIDENTIFIER','[0-9A-Za-z-]+');createToken('BUILD',`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);createToken('FULLPLAIN',`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);createToken('FULL',`^${src[t.FULLPLAIN]}$`);createToken('LOOSEPLAIN',`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);createToken('LOOSE',`^${src[t.LOOSEPLAIN]}$`);createToken('GTLT','((?:<|>)?=?)');createToken('XRANGEIDENTIFIERLOOSE',`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);createToken('XRANGEIDENTIFIER',`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);createToken('XRANGEPLAIN',`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})`+`(?:\\.(${src[t.XRANGEIDENTIFIER]})`+`(?:\\.(${src[t.XRANGEIDENTIFIER]})`+`(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?`+`)?)?`);createToken('XRANGEPLAINLOOSE',`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?`+`)?)?`);createToken('XRANGE',`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);createToken('XRANGELOOSE',`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);createToken('COERCE',`${'(^|[^\\d])'+'(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})`+`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`+`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`+`(?:$|[^\\d])`);createToken('COERCERTL',src[t.COERCE],true);createToken('LONETILDE','(?:~>?)');createToken('TILDETRIM',`(\\s*)${src[t.LONETILDE]}\\s+`,true);exports.tildeTrimReplace='$1~';createToken('TILDE',`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);createToken('TILDELOOSE',`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);createToken('LONECARET','(?:\\^)');createToken('CARETTRIM',`(\\s*)${src[t.LONECARET]}\\s+`,true);exports.caretTrimReplace='$1^';createToken('CARET',`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);createToken('CARETLOOSE',`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);createToken('COMPARATORLOOSE',`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);createToken('COMPARATOR',`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);createToken('COMPARATORTRIM',`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,true);exports.comparatorTrimReplace='$1$2$3';createToken('HYPHENRANGE',`^\\s*(${src[t.XRANGEPLAIN]})`+`\\s+-\\s+`+`(${src[t.XRANGEPLAIN]})`+`\\s*$`);createToken('HYPHENRANGELOOSE',`^\\s*(${src[t.XRANGEPLAINLOOSE]})`+`\\s+-\\s+`+`(${src[t.XRANGEPLAINLOOSE]})`+`\\s*$`);createToken('STAR','(<|>)?=?\\s*\\*');

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('once',__webpack_require__(1),__webpack_require__(165));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject=__webpack_require__(88),createAssigner=__webpack_require__(169),keysIn=__webpack_require__(170);var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});module.exports=assignIn;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var basePick=__webpack_require__(171),flatRest=__webpack_require__(61);var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});module.exports=pick;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;(function(){'use strict';var collator;try{collator=typeof Intl!=="undefined"&&typeof Intl.Collator!=="undefined"?Intl.Collator("generic",{sensitivity:"base"}):null;}catch(err){console.log("Collator could not be initialized and wouldn't be used");}var prevRow=[],str2Char=[];var Levenshtein={get:function(str1,str2,options){var useCollator=options&&collator&&options.useCollator;var str1Len=str1.length,str2Len=str2.length;if(str1Len===0)return str2Len;if(str2Len===0)return str1Len;var curCol,nextCol,i,j,tmp;for(i=0;i<str2Len;++i){prevRow[i]=i;str2Char[i]=str2.charCodeAt(i);}prevRow[str2Len]=str2Len;var strCmp;if(useCollator){for(i=0;i<str1Len;++i){nextCol=i+1;for(j=0;j<str2Len;++j){curCol=nextCol;strCmp=0===collator.compare(str1.charAt(i),String.fromCharCode(str2Char[j]));nextCol=prevRow[j]+(strCmp?0:1);tmp=curCol+1;if(nextCol>tmp){nextCol=tmp;}tmp=prevRow[j+1]+1;if(nextCol>tmp){nextCol=tmp;}prevRow[j]=curCol;}prevRow[j]=nextCol;}}else{for(i=0;i<str1Len;++i){nextCol=i+1;for(j=0;j<str2Len;++j){curCol=nextCol;strCmp=str1.charCodeAt(i)===str2Char[j];nextCol=prevRow[j]+(strCmp?0:1);tmp=curCol+1;if(nextCol>tmp){nextCol=tmp;}tmp=prevRow[j+1]+1;if(nextCol>tmp){nextCol=tmp;}prevRow[j]=curCol;}prevRow[j]=nextCol;}}return nextCol;}};if( true&&__webpack_require__(186)!==null&&__webpack_require__(187)){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Levenshtein;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if( true&&module!==null&&typeof exports!=="undefined"&&module.exports===exports){module.exports=Levenshtein;}else if(typeof self!=="undefined"&&typeof self.postMessage==='function'&&typeof self.importScripts==='function'){self.Levenshtein=Levenshtein;}else if(typeof window!=="undefined"&&window!==null){window.Levenshtein=Levenshtein;}})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(185)(module)))

/***/ }),
/* 120 */
/***/ (function(module, exports) {

function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}module.exports=fromPairs;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom=__webpack_require__(224),isIterateeCall=__webpack_require__(46),toFinite=__webpack_require__(225);var freeParseFloat=parseFloat;var nativeMin=Math.min,nativeRandom=Math.random;function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}module.exports=random;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(7),negate=__webpack_require__(228),pickBy=__webpack_require__(22);function omitBy(object,predicate){return pickBy(object,negate(baseIteratee(predicate)));}module.exports=omitBy;

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAAAkCAYAAACQePQGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABcVJREFUeNrsmr9LZFcUx4+bZKIJrBKbUZKMEAgSAo5sYzcjbGGzaBGCndoskkZh/wC1SRfUzq1U0lgEVLaRbRybXTu1SBAbFULUBLO6wiKSZPI+1xxz5857b96M4zor78D13Xd/nnO+55x77hvrRCTrlVWJqWboXqyCGJSYYlBiUGKKQbm79H5Y59TUt5JOfxZ5sYsf9yTx+4VsHh/L6IsXJccnk0np6ekpaFtfX5ft7W2pr683fel02rSfnJzIysqKHB4eSl9fn3nyzrj+/v6ree3t7dLV1SWbm5tmfYpNc3NzMjg4WNCmazc1NRXxwzrsZbefn5+b/fb29kJloZ+x8KT8tbW1STabNX25XK58UAAkk/kyMij7Px1LqiUReTwKhUmUAvMIxvvMzIxRPO8wT0HRKH9hYcHM4x1BGU9hPkIDIu8omTproFSbdE8Uzjr6zj7UGc96Lp/aTh1FT01NmXn2GNZkjPIxOztrQEAexgMcPMFfRZ7y3cXf8mb/WJKHr6Vn5eeSSu47bZBUQ0LSzc2Se/TItGWfPSs5D0GwGhhHmNbWVsM4SgYEiPrw8LDpZzzCoRgEh6gzhyfKUyBQmlqkrWht58m+rKOWr96h4/AgCEUqcHgbvPhZO/toOTo6MvPYA/5ZizmuoUQG5ZfEeyKpZo+RY1kfL63cLEA0NEljIiGZlpbIHqNWpQq23V9JhcAiXVAQXsOdKtUOKxquWI/wZbdreAN0JTsMoUCbD5cvP1lsY4M3niojcgSFrUigVIPGHzy4jOU7O7J3duY7BuuhwLAdqzUWa8hRy9VQRT+0tLRkFKljbAXbQPhZM2AyXkOhnju24l1jIeS5nmefWcy1PUm9krZSgLwVUMb+AyV3cBAICoy6zKrSR0dHjVDqEQoS1ke/AkQ/yqKucV4VOj4+XqA0BZfQiKLsMAjZiYB9INvt6gEuqZepBwK6awy3Csqr849l649L5hL3mr2/vxUxiNC2EpVQGAekKgsFAIiGMZTPXPUK+lCErSi/uK17ah/7kEAAqF+o0sPdbqfOfraC3THwZZ9N2h8FlLrQD5K5JyJkX2s73qgfygYl3dQnn9Z3mPqv51uyebIUX0Kue0+5DSIO66GooQ2L8/Omu0x4St635J7kJf/08hk0JqS033+Y//7rXVOoh431zo685955P/IAyXvnQsF43m2y+0uRB7LZL+p6QevSxlo2IYOXtBTM89Lhorne+RSoixv9zPJP/i9p/rDNFOpBxOE7OTkpqVTKt7+xsVHGxsZ8D9ZKqKOjw+xXjfXcrwPIQHJiZ5ZcGm1aW1vzzQhr5tsXDA8MDEQaWy1QbHDszKwSgqeJiYnCjNMzIL2vsL5tbKenp0VA1hQonBsjIyMFbcvLy9LZ2Sl1dXUyNDRkrAqan58vKUwQoTQtW1tboZZe0V3MU/z+/n6RsZE9uvIxNuzyeesHvasQAOBzhB3WKPYnkEqVZq+5u7tbEG6qJcvq6v9JbCaTMZdaVz43lNWcp2BJ7tmiGZheKCm0a70alh3p0uuFIM5yu4QRvE1PTxedheWErZpMidUbOByxtCDhr+MptieaL9tO2LluGGN9P++LErZq9p5yU1YflvlVi7hLkXktLi5WFLZqAhT3QoiV6WWxu7v7qt2O1dUkkoeg7AtFul4ZBq4S5wjJBJmdn6fWPCgI0Nvbe/VOpoLl6u8rN0V6TwjzEvZ3lRkFFD9je6c+swAKbm0fiBsbGyYtBhgSgaCzpRwivb47374OvhB52Sby5ycij8u/ZB1+kJS5+5cH6dmrj7w/xRZFRuLGYLzH9iC/ZOAuUzgoZ1+JJDxL/dyrP/6m7MVfe+Wlvjx/E+gtXBJdj/EjUs5qHszvJihviVA04OA1+ju9AkT8J5TpWROUGtvv7mePKBS2Xrnr6r2qUu8O/z0lpluh+J/xYlBiikGJQYkpBuUOE9kX/5OZjlVRO/SvAAMADC1T3Wo5vNkAAAAASUVORK5CYII="

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(7),baseWhile=__webpack_require__(234);function dropWhile(array,predicate){return array&&array.length?baseWhile(array,baseIteratee(predicate,3),true):[];}module.exports=dropWhile;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('slice',__webpack_require__(235));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var convert=__webpack_require__(19),func=convert('mapValues',__webpack_require__(75));func.placeholder=__webpack_require__(17);module.exports=func;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(12),unzip=__webpack_require__(107);var zip=baseRest(unzip);module.exports=zip;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(57);var CLONE_DEEP_FLAG=1,CLONE_SYMBOLS_FLAG=4;function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}module.exports=cloneDeep;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten=__webpack_require__(43),baseRest=__webpack_require__(12),baseUniq=__webpack_require__(71),isArrayLikeObject=__webpack_require__(35);var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});module.exports=union;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

(function(){'use strict';var PI=Math.PI,sin=Math.sin,cos=Math.cos,tan=Math.tan,asin=Math.asin,atan=Math.atan2,acos=Math.acos,rad=PI/180;var dayMs=1000*60*60*24,J1970=2440588,J2000=2451545;function toJulian(date){return date.valueOf()/dayMs-0.5+J1970;}function fromJulian(j){return new Date((j+0.5-J1970)*dayMs);}function toDays(date){return toJulian(date)-J2000;}var e=rad*23.4397;function rightAscension(l,b){return atan(sin(l)*cos(e)-tan(b)*sin(e),cos(l));}function declination(l,b){return asin(sin(b)*cos(e)+cos(b)*sin(e)*sin(l));}function azimuth(H,phi,dec){return atan(sin(H),cos(H)*sin(phi)-tan(dec)*cos(phi));}function altitude(H,phi,dec){return asin(sin(phi)*sin(dec)+cos(phi)*cos(dec)*cos(H));}function siderealTime(d,lw){return rad*(280.16+360.9856235*d)-lw;}function astroRefraction(h){if(h<0)h=0;return 0.0002967/Math.tan(h+0.00312536/(h+0.08901179));}function solarMeanAnomaly(d){return rad*(357.5291+0.98560028*d);}function eclipticLongitude(M){var C=rad*(1.9148*sin(M)+0.02*sin(2*M)+0.0003*sin(3*M));return M+C+rad*102.9372+PI;}function sunCoords(d){var M=solarMeanAnomaly(d),L=eclipticLongitude(M);return{dec:declination(L,0),ra:rightAscension(L,0)};}var SunCalc={};SunCalc.getPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=sunCoords(d),H=siderealTime(d,rad*-lng)-c.ra;return{azimuth:azimuth(H,phi,c.dec),altitude:altitude(H,phi,c.dec)};};var times=SunCalc.times=[[-0.833,'sunrise','sunset'],[-0.3,'sunriseEnd','sunsetStart'],[-6,'dawn','dusk'],[-12,'nauticalDawn','nauticalDusk'],[-18,'nightEnd','night'],[6,'goldenHourEnd','goldenHour']];SunCalc.addTime=function(angle,riseName,setName){times.push([angle,riseName,setName]);};var J0=0.0009;function julianCycle(d,lw){return Math.round(d-J0-lw/(2*PI));}function approxTransit(Ht,lw,n){return J0+(Ht+lw)/(2*PI)+n;}function solarTransitJ(ds,M,L){return J2000+ds+0.0053*sin(M)-0.0069*sin(2*L);}function hourAngle(h,phi,d){return acos((sin(h)-sin(phi)*sin(d))/(cos(phi)*cos(d)));}function getSetJ(h,lw,phi,dec,n,M,L){var w=hourAngle(h,phi,dec),a=approxTransit(w,lw,n);return solarTransitJ(a,M,L);}SunCalc.getTimes=function(date,lat,lng){var lw=rad*-lng,d=toDays(date),n=julianCycle(d,lw),ds=approxTransit(0,lw,n),M=solarMeanAnomaly(ds),L=eclipticLongitude(M),dec=declination(L,0),Jnoon=solarTransitJ(ds,M,L),i,len,time,Jset,Jrise;var result={solarNoon:fromJulian(Jnoon),nadir:fromJulian(Jnoon-0.5)};for(i=0,len=times.length;i<len;i+=1){time=times[i];Jset=getSetJ(time[0]*rad,lw,rad*lat,dec,n,M,L);Jrise=Jnoon-(Jset-Jnoon);result[time[1]]=fromJulian(Jrise);result[time[2]]=fromJulian(Jset);}return result;};function moonCoords(d){var M=rad*(134.963+13.064993*d),l=rad*(218.316+13.176396*d)+rad*6.289*sin(M),b=rad*5.128*sin(rad*(93.272+13.229350*d)),dt=385001-20905*cos(M);return{ra:rightAscension(l,b),dec:declination(l,b),dist:dt};}SunCalc.getMoonPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=moonCoords(d),H=siderealTime(d,rad*-lng)-c.ra,h=altitude(H,phi,c.dec),pa=atan(sin(H),tan(phi)*cos(c.dec)-sin(c.dec)*cos(H));h=h+astroRefraction(h);return{azimuth:azimuth(H,phi,c.dec),altitude:h,distance:c.dist,parallacticAngle:pa};};SunCalc.getMoonIllumination=function(date){var d=toDays(date||new Date()),s=sunCoords(d),m=moonCoords(d),sdist=149598000,phi=acos(sin(s.dec)*sin(m.dec)+cos(s.dec)*cos(m.dec)*cos(s.ra-m.ra)),inc=atan(sdist*sin(phi),m.dist-sdist*cos(phi)),angle=atan(cos(s.dec)*sin(s.ra-m.ra),sin(s.dec)*cos(m.dec)-cos(s.dec)*sin(m.dec)*cos(s.ra-m.ra));return{fraction:(1+cos(inc))/2,phase:0.5+0.5*inc*(angle<0?-1:1)/Math.PI,angle:angle};};function hoursLater(date,h){return new Date(date.valueOf()+h*dayMs/24);}SunCalc.getMoonTimes=function(date,lat,lng,inUTC){var t=new Date(date);if(inUTC)t.setUTCHours(0,0,0,0);else t.setHours(0,0,0,0);var hc=0.133*rad,h0=SunCalc.getMoonPosition(t,lat,lng).altitude-hc,h1,h2,rise,set,a,b,xe,ye,d,roots,x1,x2,dx;for(var i=1;i<=24;i+=2){h1=SunCalc.getMoonPosition(hoursLater(t,i),lat,lng).altitude-hc;h2=SunCalc.getMoonPosition(hoursLater(t,i+1),lat,lng).altitude-hc;a=(h0+h2)/2-h1;b=(h2-h0)/2;xe=-b/(2*a);ye=(a*xe+b)*xe+h1;d=b*b-4*a*h1;roots=0;if(d>=0){dx=Math.sqrt(d)/(Math.abs(a)*2);x1=xe-dx;x2=xe+dx;if(Math.abs(x1)<=1)roots++;if(Math.abs(x2)<=1)roots++;if(x1<-1)x1=x2;}if(roots===1){if(h0<0)rise=i+x1;else set=i+x1;}else if(roots===2){rise=i+(ye<0?x2:x1);set=i+(ye<0?x1:x2);}if(rise&&set)break;h0=h2;}var result={};if(rise)result.rise=hoursLater(t,rise);if(set)result.set=hoursLater(t,set);if(!rise&&!set)result[ye>0?'alwaysUp':'alwaysDown']=true;return result;};if(true)module.exports=SunCalc;else {}})();

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license MIT
 * @fileOverview Favico animations
 * @author Miroslav Magda, http://blog.ejci.net
 * @version 0.3.10
 */(function(){var Favico=function(opt){'use strict';opt=opt?opt:{};var _def={bgColor:'#d00',textColor:'#fff',fontFamily:'sans-serif',fontStyle:'bold',type:'circle',position:'down',animation:'slide',elementId:false,dataUrl:false,win:window};var _opt,_orig,_h,_w,_canvas,_context,_img,_ready,_lastBadge,_running,_readyCb,_stop,_browser,_animTimeout,_drawTimeout,_doc;_browser={};_browser.ff=typeof InstallTrigger!='undefined';_browser.chrome=!!window.chrome;_browser.opera=!!window.opera||navigator.userAgent.indexOf('Opera')>=0;_browser.ie=false;_browser.safari=Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor')>0;_browser.supported=_browser.chrome||_browser.ff||_browser.opera;var _queue=[];_readyCb=function(){};_ready=_stop=false;var init=function(){_opt=merge(_def,opt);_opt.bgColor=hexToRgb(_opt.bgColor);_opt.textColor=hexToRgb(_opt.textColor);_opt.position=_opt.position.toLowerCase();_opt.animation=animation.types[''+_opt.animation]?_opt.animation:_def.animation;_doc=_opt.win.document;var isUp=_opt.position.indexOf('up')>-1;var isLeft=_opt.position.indexOf('left')>-1;if(isUp||isLeft){for(var i=0;i<animation.types[''+_opt.animation].length;i++){var step=animation.types[''+_opt.animation][i];if(isUp){if(step.y<0.6){step.y=step.y-0.4;}else{step.y=step.y-2*step.y+(1-step.w);}}if(isLeft){if(step.x<0.6){step.x=step.x-0.4;}else{step.x=step.x-2*step.x+(1-step.h);}}animation.types[''+_opt.animation][i]=step;}}_opt.type=type[''+_opt.type]?_opt.type:_def.type;_orig=link.getIcon();_canvas=document.createElement('canvas');_img=document.createElement('img');if(_orig.hasAttribute('href')){_img.setAttribute('crossOrigin','anonymous');_img.onload=function(){_h=_img.height>0?_img.height:32;_w=_img.width>0?_img.width:32;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src',_orig.getAttribute('href'));}else{_img.onload=function(){_h=32;_w=32;_img.height=_h;_img.width=_w;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src','');}};var icon={};icon.ready=function(){_ready=true;icon.reset();_readyCb();};icon.reset=function(){if(!_ready){return;}_queue=[];_lastBadge=false;_running=false;_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);link.setIcon(_canvas);window.clearTimeout(_animTimeout);window.clearTimeout(_drawTimeout);};icon.start=function(){if(!_ready||_running){return;}var finished=function(){_lastBadge=_queue[0];_running=false;if(_queue.length>0){_queue.shift();icon.start();}};if(_queue.length>0){_running=true;var run=function(){['type','animation','bgColor','textColor','fontFamily','fontStyle'].forEach(function(a){if(a in _queue[0].options){_opt[a]=_queue[0].options[a];}});animation.run(_queue[0].options,function(){finished();},false);};if(_lastBadge){animation.run(_lastBadge.options,function(){run();},true);}else{run();}}};var type={};var options=function(opt){opt.n=typeof opt.n==='number'?Math.abs(opt.n|0):opt.n;opt.x=_w*opt.x;opt.y=_h*opt.y;opt.w=_w*opt.w;opt.h=_h*opt.h;opt.len=(""+opt.n).length;return opt;};type.circle=function(opt){opt=options(opt);var more=false;if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;more=true;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;more=true;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.85:1))+"px "+_opt.fontFamily;_context.textAlign='center';if(more){_context.moveTo(opt.x+opt.w/2,opt.y);_context.lineTo(opt.x+opt.w-opt.h/2,opt.y);_context.quadraticCurveTo(opt.x+opt.w,opt.y,opt.x+opt.w,opt.y+opt.h/2);_context.lineTo(opt.x+opt.w,opt.y+opt.h-opt.h/2);_context.quadraticCurveTo(opt.x+opt.w,opt.y+opt.h,opt.x+opt.w-opt.h/2,opt.y+opt.h);_context.lineTo(opt.x+opt.h/2,opt.y+opt.h);_context.quadraticCurveTo(opt.x,opt.y+opt.h,opt.x,opt.y+opt.h-opt.h/2);_context.lineTo(opt.x,opt.y+opt.h/2);_context.quadraticCurveTo(opt.x,opt.y,opt.x+opt.h/2,opt.y);}else{_context.arc(opt.x+opt.w/2,opt.y+opt.h/2,opt.h/2,0,2*Math.PI);}_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fill();_context.closePath();_context.beginPath();_context.stroke();_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};type.rectangle=function(opt){opt=options(opt);if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.9:1))+"px "+_opt.fontFamily;_context.textAlign='center';_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fillRect(opt.x,opt.y,opt.w,opt.h);_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};var badge=function(number,opts){opts=(typeof opts==='string'?{animation:opts}:opts)||{};_readyCb=function(){try{if(typeof number==='number'?number>0:number!==''){var q={type:'badge',options:{n:number}};if('animation'in opts&&animation.types[''+opts.animation]){q.options.animation=''+opts.animation;}if('type'in opts&&type[''+opts.type]){q.options.type=''+opts.type;}['bgColor','textColor'].forEach(function(o){if(o in opts){q.options[o]=hexToRgb(opts[o]);}});['fontStyle','fontFamily'].forEach(function(o){if(o in opts){q.options[o]=opts[o];}});_queue.push(q);if(_queue.length>100){throw new Error('Too many badges requests in queue.');}icon.start();}else{icon.reset();}}catch(e){throw new Error('Error setting badge. Message: '+e.message);}};if(_ready){_readyCb();}};var image=function(imageElement){_readyCb=function(){try{var w=imageElement.width;var h=imageElement.height;var newImg=document.createElement('img');var ratio=w/_w<h/_h?w/_w:h/_h;newImg.setAttribute('crossOrigin','anonymous');newImg.onload=function(){_context.clearRect(0,0,_w,_h);_context.drawImage(newImg,0,0,_w,_h);link.setIcon(_canvas);};newImg.setAttribute('src',imageElement.getAttribute('src'));newImg.height=h/ratio;newImg.width=w/ratio;}catch(e){throw new Error('Error setting image. Message: '+e.message);}};if(_ready){_readyCb();}};var video=function(videoElement){_readyCb=function(){try{if(videoElement==='stop'){_stop=true;icon.reset();_stop=false;return;}videoElement.addEventListener('play',function(){drawVideo(this);},false);}catch(e){throw new Error('Error setting video. Message: '+e.message);}};if(_ready){_readyCb();}};var webcam=function(action){if(!window.URL||!window.URL.createObjectURL){window.URL=window.URL||{};window.URL.createObjectURL=function(obj){return obj;};}if(_browser.supported){var newVideo=false;navigator.getUserMedia=navigator.getUserMedia||navigator.oGetUserMedia||navigator.msGetUserMedia||navigator.mozGetUserMedia||navigator.webkitGetUserMedia;_readyCb=function(){try{if(action==='stop'){_stop=true;icon.reset();_stop=false;return;}newVideo=document.createElement('video');newVideo.width=_w;newVideo.height=_h;navigator.getUserMedia({video:true,audio:false},function(stream){newVideo.src=URL.createObjectURL(stream);newVideo.play();drawVideo(newVideo);},function(){});}catch(e){throw new Error('Error setting webcam. Message: '+e.message);}};if(_ready){_readyCb();}}};function drawVideo(video){if(video.paused||video.ended||_stop){return false;}try{_context.clearRect(0,0,_w,_h);_context.drawImage(video,0,0,_w,_h);}catch(e){}_drawTimeout=setTimeout(function(){drawVideo(video);},animation.duration);link.setIcon(_canvas);}var link={};link.getIcon=function(){var elm=false;var getLink=function(){var link=_doc.getElementsByTagName('head')[0].getElementsByTagName('link');for(var l=link.length,i=l-1;i>=0;i--){if(/(^|\s)icon(\s|$)/i.test(link[i].getAttribute('rel'))){return link[i];}}return false;};if(_opt.element){elm=_opt.element;}else if(_opt.elementId){elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',elm.getAttribute('src'));}else{elm=getLink();if(elm===false){elm=_doc.createElement('link');elm.setAttribute('rel','icon');_doc.getElementsByTagName('head')[0].appendChild(elm);}}elm.setAttribute('type','image/png');return elm;};link.setIcon=function(canvas){var url=canvas.toDataURL('image/png');if(_opt.dataUrl){_opt.dataUrl(url);}if(_opt.element){_opt.element.setAttribute('href',url);_opt.element.setAttribute('src',url);}else if(_opt.elementId){var elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',url);elm.setAttribute('src',url);}else{if(_browser.ff||_browser.opera){var old=_orig;_orig=_doc.createElement('link');if(_browser.opera){_orig.setAttribute('rel','icon');}_orig.setAttribute('rel','icon');_orig.setAttribute('type','image/png');_doc.getElementsByTagName('head')[0].appendChild(_orig);_orig.setAttribute('href',url);if(old.parentNode){old.parentNode.removeChild(old);}}else{_orig.setAttribute('href',url);}}};function hexToRgb(hex){var shorthandRegex=/^#?([a-f\d])([a-f\d])([a-f\d])$/i;hex=hex.replace(shorthandRegex,function(m,r,g,b){return r+r+g+g+b+b;});var result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);return result?{r:parseInt(result[1],16),g:parseInt(result[2],16),b:parseInt(result[3],16)}:false;}function merge(def,opt){var mergedOpt={};for(var attrname in def){mergedOpt[attrname]=def[attrname];}for(attrname in opt){mergedOpt[attrname]=opt[attrname];}return mergedOpt;}function isPageHidden(){return _doc.hidden||_doc.msHidden||_doc.webkitHidden||_doc.mozHidden;}var animation={};animation.duration=40;animation.types={};animation.types.fade=[{x:0.4,y:0.4,w:0.6,h:0.6,o:0.0},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.1},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.2},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.3},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.4},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.5},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.6},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.7},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.8},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1.0}];animation.types.none=[{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.pop=[{x:1,y:1,w:0,h:0,o:1},{x:0.9,y:0.9,w:0.1,h:0.1,o:1},{x:0.8,y:0.8,w:0.2,h:0.2,o:1},{x:0.7,y:0.7,w:0.3,h:0.3,o:1},{x:0.6,y:0.6,w:0.4,h:0.4,o:1},{x:0.5,y:0.5,w:0.5,h:0.5,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.popFade=[{x:0.75,y:0.75,w:0,h:0,o:0},{x:0.65,y:0.65,w:0.1,h:0.1,o:0.2},{x:0.6,y:0.6,w:0.2,h:0.2,o:0.4},{x:0.55,y:0.55,w:0.3,h:0.3,o:0.6},{x:0.50,y:0.50,w:0.4,h:0.4,o:0.8},{x:0.45,y:0.45,w:0.5,h:0.5,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.slide=[{x:0.4,y:1,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.8,w:0.6,h:0.6,o:1},{x:0.4,y:0.7,w:0.6,h:0.6,o:1},{x:0.4,y:0.6,w:0.6,h:0.6,o:1},{x:0.4,y:0.5,w:0.6,h:0.6,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.run=function(opt,cb,revert,step){var animationType=animation.types[isPageHidden()?'none':_opt.animation];if(revert===true){step=typeof step!=='undefined'?step:animationType.length-1;}else{step=typeof step!=='undefined'?step:0;}cb=cb?cb:function(){};if(step<animationType.length&&step>=0){type[_opt.type](merge(opt,animationType[step]));_animTimeout=setTimeout(function(){if(revert){step=step-1;}else{step=step+1;}animation.run(opt,cb,revert,step);},animation.duration);link.setIcon(_canvas);}else{cb();}};init();return{badge:badge,video:video,image:image,webcam:webcam,reset:icon.reset,browser:{supported:_browser.supported}};};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Favico;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else {}})();

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHQElEQVRYR8WXe1BU9xXHP5dld+WxLoKKSEAeGgxqFIVRjAn4BBIVUkzBOoUqDJmojYIZtT7qI2k6VVGZBGOtWlNMpz5wTBFfqIAtAg6klVGCCvHFQ1ieA8qyC3s7966A6JpabZLz1+7vnnvO957f95zf9yfwE5sg5a8RRbGp5cdHMkALMoDSZlFsbmh/cQSCFQprBV2dXSCa+sRRqtTY2gkIVgKGDpGHbfqe5w5ONmYA1xpNYktT74P/FYmVQoG+/SEOjlpUaoHOTpGOdhGlSkB3v5b0r/bSWK9j5uxIJr71Jm0t5lzaAf1eHoC9th/nT2SwOSmOQUNewW/iZPwmvcVY/0mIJpFFEcGorTpxdnbmctE3rN+6h/cWxssg/i8ApDIujoqgtvoewaEh5F3I5m5FGQaDASuFEt+RI8i7lI9CoSB521Z+s24D567UYGNnj7294uU4oFAqMXboCRnnwqpPU4n7MIbGRmiqb6b63g2S4n7B7FnB/HHPXrnkN2/c4FUfH47nlePm6Y2N7SMSvigHbO37UXAxh8VRM8kovMXgIa4YDR1IwAY5K9i9bRc7fvtrzmfn4OHhSUL8Ir6tqCT94hU6jaDpr3w5DgwY2I/NScsoupTLkZx/92G4REylUsHmjxLIOPSl/NtpsCufHczAy8eX9gcvyAEpsEJhLTNcYnzIuOHMjVpI0qa16O4bMHV19TSRVAm1WsH1q9dobW1m5Khx2GnseNCmx0p4rAv+2xzo7mUpcltbF80NOpoadXx3/VvWLI5m484/Exg0HTv7AWgd7bESRPR6gY5282xR29igUIh0dQkYDb0g+8wBKbDEym4zGkEUQaWCu7cqyT17gpyzGdwsLaGtpRHELqwEAZVKjbGzE4OxExs7DV4+owgMmsm0sAhGjhmFSZpNIggCNDe2YG1tzQAnO/lDerqgQi+KNffaOHRgFwW5WTg4DuS92PcZNNiZ1C0byTl9HEetPUFBwQQFB+PrO4phHh5oNBoEQeBBWxu6+nquXb3KxdwccnKyuXWnkjH+gSxb+ykarQPJG1dSUpyPtbWSaW+/y4oNWxnqrjWTsKSuXYwMmkhT7V3CIyKoq60lI/OUXIzAiQGsWr2G0LAwVFI5ntMK8vPZsT2Zo8eOI4omZs2YRmLSCmru32fD+nVoBrnxdV6BGUDc8g3imcO7uVp6Ha1WS3R0NFlZWaSmfk509PznTGnZLf/SJRISElBYW5ObmyvH1+l0uLo4k/zlaTOA4b5+4pK4BSxLTCIyMpIL589TVFyMt7d3b9QbpXDkEEzwh9A5lrPdqYBj6eDnB8Eze3zaHz4kJDSUiooKysrK5K2bGDCeCdMjzQD8Jk0VZ08PZPKUNwkLC6OkpITRo0f3JqmrgdfHINQ1ymviuVMwLaQviEYdjB+HcLfG7HPhTB8QRqMRNzc3wsPD2bF9O06ODvxh3wkzgJS0THHlorkyi+Pj49myZUvf4MUFCAGTe9bE32+CVev7+vzrMsKESb0+H6+HtZv6+Jw5c4Y5c+bg5TEMoZ+WjPwiM4AqURRXxC/nb/tS5DJ5eXn1DW7Qwy/nw+Hj4DsCTp0Gdws+P4+Er0+CpxuczYLhPk9tlcuQwTgM8WTP4ZO4DnMyA7hnMomZ6TmsiouguroaG1tby3ss8cBtGNjYPZuYV4rBwxO0jhZ9Aib4yXu/8uN1dLQ/Ooxud5rEk+kXSIx5m8rKKpycnF6K+d/38shXRxAcEcuyNetkN7kCNx+YxNsVOmaNdeHokUO8+7PIHwTA3Tt38PD05E/H/kHAG2+gVD6mCaWMy3+1gNtXC7l+s9wigJ07dzJlyhT8/f0tPm9paSE1NZUlS5bI/f6kLZgfRU5+MScKrmPo6KK/g6r3ONa3m2TdFjLenQ/ej+ezz1OfChAbG0taWhpRUVHMmDEDby8vlCoVdXV1FBYWcuDAATlxUVGR3OuP28GDacTExLInPZtJQUGWJZmk0fKyc0mInEp83CJ2fbFbPjwet8zMTPbv3y/PitbWVkwmkzyi3d3dmTdvHkuXLn1qZKekpJCYmEjShmTiE5PoVuAWNaG0ePmfeXwYE4Gzo4ZtyTuYGx5useR6vV4+/6WukQ6lJ624uJhVKz/iQnYuG3fsI2rRQpoaDD3SvQfAk3pA42BDQ10DKZ+s5vhf9zPC25OY2BjeeWcOr/n6olarLQKSqlFRXs658+f4Ku0v5OUXEjBlBqt/t5PXxo7q+fLul7/3XiCJEDuNFTdLb3A0bS9Zfz9MfW0Vjg79cXUdiovLUJwGDpQ1gUS+qqpKKquq0dU3YqtxYPLUUKIXfsD4wEC6OpEl2JP2XLJcUjOSen3QauJWeSllJd/wXXkZ1ffu0NLUIMe0te/PK+4euHkMx2f0WEaMfF3W/JKoefwm9EIAul+SRaZKhUoNikfCSbp4dJt09ZL+GwzQoTf20YbPGirP5MAPMoUsBO3hwE95O/4PY9MuHly+U4UAAAAASUVORK5CYII="

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee=__webpack_require__(7),baseUniq=__webpack_require__(71);function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,baseIteratee(iteratee,2)):[];}module.exports=uniqBy;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

module.exports=__webpack_require__(74);

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var mapping=__webpack_require__(136),fallbackHolder=__webpack_require__(17);var push=Array.prototype.push;function baseArity(func,n){return n==2?function(){return func.apply(undefined,arguments);}:function(){return func.apply(undefined,arguments);};}function baseAry(func,n){return n==2?function(a,b){return func(a,b);}:function(a){return func(a);};}function cloneArray(array){var length=array?array.length:0,result=Array(length);while(length--){result[length]=array[length];}return result;}function createCloner(func){return function(object){return func({},object);};}function flatSpread(func,start){return function(){var length=arguments.length,lastIndex=length-1,args=Array(length);while(length--){args[length]=arguments[length];}var array=args[start],otherArgs=args.slice(0,start);if(array){push.apply(otherArgs,array);}if(start!=lastIndex){push.apply(otherArgs,args.slice(start+1));}return func.apply(this,otherArgs);};}function wrapImmutable(func,cloner){return function(){var length=arguments.length;if(!length){return;}var args=Array(length);while(length--){args[length]=arguments[length];}var result=args[0]=cloner.apply(undefined,args);func.apply(undefined,args);return result;};}function baseConvert(util,name,func,options){var isLib=typeof name=='function',isObj=name===Object(name);if(isObj){options=func;func=name;name=undefined;}if(func==null){throw new TypeError();}options||(options={});var config={'cap':'cap'in options?options.cap:true,'curry':'curry'in options?options.curry:true,'fixed':'fixed'in options?options.fixed:true,'immutable':'immutable'in options?options.immutable:true,'rearg':'rearg'in options?options.rearg:true};var defaultHolder=isLib?func:fallbackHolder,forceCurry='curry'in options&&options.curry,forceFixed='fixed'in options&&options.fixed,forceRearg='rearg'in options&&options.rearg,pristine=isLib?func.runInContext():undefined;var helpers=isLib?func:{'ary':util.ary,'assign':util.assign,'clone':util.clone,'curry':util.curry,'forEach':util.forEach,'isArray':util.isArray,'isError':util.isError,'isFunction':util.isFunction,'isWeakMap':util.isWeakMap,'iteratee':util.iteratee,'keys':util.keys,'rearg':util.rearg,'toInteger':util.toInteger,'toPath':util.toPath};var ary=helpers.ary,assign=helpers.assign,clone=helpers.clone,curry=helpers.curry,each=helpers.forEach,isArray=helpers.isArray,isError=helpers.isError,isFunction=helpers.isFunction,isWeakMap=helpers.isWeakMap,keys=helpers.keys,rearg=helpers.rearg,toInteger=helpers.toInteger,toPath=helpers.toPath;var aryMethodKeys=keys(mapping.aryMethod);var wrappers={'castArray':function(castArray){return function(){var value=arguments[0];return isArray(value)?castArray(cloneArray(value)):castArray.apply(undefined,arguments);};},'iteratee':function(iteratee){return function(){var func=arguments[0],arity=arguments[1],result=iteratee(func,arity),length=result.length;if(config.cap&&typeof arity=='number'){arity=arity>2?arity-2:1;return length&&length<=arity?result:baseAry(result,arity);}return result;};},'mixin':function(mixin){return function(source){var func=this;if(!isFunction(func)){return mixin(func,Object(source));}var pairs=[];each(keys(source),function(key){if(isFunction(source[key])){pairs.push([key,func.prototype[key]]);}});mixin(func,Object(source));each(pairs,function(pair){var value=pair[1];if(isFunction(value)){func.prototype[pair[0]]=value;}else{delete func.prototype[pair[0]];}});return func;};},'nthArg':function(nthArg){return function(n){var arity=n<0?1:toInteger(n)+1;return curry(nthArg(n),arity);};},'rearg':function(rearg){return function(func,indexes){var arity=indexes?indexes.length:0;return curry(rearg(func,indexes),arity);};},'runInContext':function(runInContext){return function(context){return baseConvert(util,runInContext(context),options);};}};function castCap(name,func){if(config.cap){var indexes=mapping.iterateeRearg[name];if(indexes){return iterateeRearg(func,indexes);}var n=!isLib&&mapping.iterateeAry[name];if(n){return iterateeAry(func,n);}}return func;}function castCurry(name,func,n){return forceCurry||config.curry&&n>1?curry(func,n):func;}function castFixed(name,func,n){if(config.fixed&&(forceFixed||!mapping.skipFixed[name])){var data=mapping.methodSpread[name],start=data&&data.start;return start===undefined?ary(func,n):flatSpread(func,start);}return func;}function castRearg(name,func,n){return config.rearg&&n>1&&(forceRearg||!mapping.skipRearg[name])?rearg(func,mapping.methodRearg[name]||mapping.aryRearg[n]):func;}function cloneByPath(object,path){path=toPath(path);var index=-1,length=path.length,result=clone(Object(object)),nested=result;while(nested!=null&&++index<length){var key=path[index],value=nested[key];if(value!=null&&!(isFunction(value)||isError(value)||isWeakMap(value))){nested[key]=clone(index==length-1?value:Object(value));}nested=nested[key];}return result;}function convertLib(options){return _.runInContext.convert(options)(undefined);}function createConverter(name,func){var realName=mapping.aliasToReal[name]||name,methodName=mapping.remap[realName]||realName,oldOptions=options;return function(options){var newUtil=isLib?pristine:helpers,newFunc=isLib?pristine[methodName]:func,newOptions=assign(assign({},oldOptions),options);return baseConvert(newUtil,realName,newFunc,newOptions);};}function iterateeAry(func,n){return overArg(func,function(func){return typeof func=='function'?baseAry(func,n):func;});}function iterateeRearg(func,indexes){return overArg(func,function(func){var n=indexes.length;return baseArity(rearg(baseAry(func,n),indexes),n);});}function overArg(func,transform){return function(){var length=arguments.length;if(!length){return func();}var args=Array(length);while(length--){args[length]=arguments[length];}var index=config.rearg?0:length-1;args[index]=transform(args[index]);return func.apply(undefined,args);};}function wrap(name,func,placeholder){var result,realName=mapping.aliasToReal[name]||name,wrapped=func,wrapper=wrappers[realName];if(wrapper){wrapped=wrapper(func);}else if(config.immutable){if(mapping.mutate.array[realName]){wrapped=wrapImmutable(func,cloneArray);}else if(mapping.mutate.object[realName]){wrapped=wrapImmutable(func,createCloner(func));}else if(mapping.mutate.set[realName]){wrapped=wrapImmutable(func,cloneByPath);}}each(aryMethodKeys,function(aryKey){each(mapping.aryMethod[aryKey],function(otherName){if(realName==otherName){var data=mapping.methodSpread[realName],afterRearg=data&&data.afterRearg;result=afterRearg?castFixed(realName,castRearg(realName,wrapped,aryKey),aryKey):castRearg(realName,castFixed(realName,wrapped,aryKey),aryKey);result=castCap(realName,result);result=castCurry(realName,result,aryKey);return false;}});return!result;});result||(result=wrapped);if(result==func){result=forceCurry?curry(result,1):function(){return func.apply(this,arguments);};}result.convert=createConverter(realName,func);result.placeholder=func.placeholder=placeholder;return result;}if(!isObj){return wrap(name,func,defaultHolder);}var _=func;var pairs=[];each(aryMethodKeys,function(aryKey){each(mapping.aryMethod[aryKey],function(key){var func=_[mapping.remap[key]||key];if(func){pairs.push([key,wrap(key,func,_)]);}});});each(keys(_),function(key){var func=_[key];if(typeof func=='function'){var length=pairs.length;while(length--){if(pairs[length][0]==key){return;}}func.convert=createConverter(key,func);pairs.push([key,func]);}});each(pairs,function(pair){_[pair[0]]=pair[1];});_.convert=convertLib;_.placeholder=_;each(keys(_),function(key){each(mapping.realToAlias[key]||[],function(alias){_[alias]=_[key];});});return _;}module.exports=baseConvert;

/***/ }),
/* 136 */
/***/ (function(module, exports) {

exports.aliasToReal={'each':'forEach','eachRight':'forEachRight','entries':'toPairs','entriesIn':'toPairsIn','extend':'assignIn','extendAll':'assignInAll','extendAllWith':'assignInAllWith','extendWith':'assignInWith','first':'head','conforms':'conformsTo','matches':'isMatch','property':'get','__':'placeholder','F':'stubFalse','T':'stubTrue','all':'every','allPass':'overEvery','always':'constant','any':'some','anyPass':'overSome','apply':'spread','assoc':'set','assocPath':'set','complement':'negate','compose':'flowRight','contains':'includes','dissoc':'unset','dissocPath':'unset','dropLast':'dropRight','dropLastWhile':'dropRightWhile','equals':'isEqual','identical':'eq','indexBy':'keyBy','init':'initial','invertObj':'invert','juxt':'over','omitAll':'omit','nAry':'ary','path':'get','pathEq':'matchesProperty','pathOr':'getOr','paths':'at','pickAll':'pick','pipe':'flow','pluck':'map','prop':'get','propEq':'matchesProperty','propOr':'getOr','props':'at','symmetricDifference':'xor','symmetricDifferenceBy':'xorBy','symmetricDifferenceWith':'xorWith','takeLast':'takeRight','takeLastWhile':'takeRightWhile','unapply':'rest','unnest':'flatten','useWith':'overArgs','where':'conformsTo','whereEq':'isMatch','zipObj':'zipObject'};exports.aryMethod={'1':['assignAll','assignInAll','attempt','castArray','ceil','create','curry','curryRight','defaultsAll','defaultsDeepAll','floor','flow','flowRight','fromPairs','invert','iteratee','memoize','method','mergeAll','methodOf','mixin','nthArg','over','overEvery','overSome','rest','reverse','round','runInContext','spread','template','trim','trimEnd','trimStart','uniqueId','words','zipAll'],'2':['add','after','ary','assign','assignAllWith','assignIn','assignInAllWith','at','before','bind','bindAll','bindKey','chunk','cloneDeepWith','cloneWith','concat','conformsTo','countBy','curryN','curryRightN','debounce','defaults','defaultsDeep','defaultTo','delay','difference','divide','drop','dropRight','dropRightWhile','dropWhile','endsWith','eq','every','filter','find','findIndex','findKey','findLast','findLastIndex','findLastKey','flatMap','flatMapDeep','flattenDepth','forEach','forEachRight','forIn','forInRight','forOwn','forOwnRight','get','groupBy','gt','gte','has','hasIn','includes','indexOf','intersection','invertBy','invoke','invokeMap','isEqual','isMatch','join','keyBy','lastIndexOf','lt','lte','map','mapKeys','mapValues','matchesProperty','maxBy','meanBy','merge','mergeAllWith','minBy','multiply','nth','omit','omitBy','overArgs','pad','padEnd','padStart','parseInt','partial','partialRight','partition','pick','pickBy','propertyOf','pull','pullAll','pullAt','random','range','rangeRight','rearg','reject','remove','repeat','restFrom','result','sampleSize','some','sortBy','sortedIndex','sortedIndexOf','sortedLastIndex','sortedLastIndexOf','sortedUniqBy','split','spreadFrom','startsWith','subtract','sumBy','take','takeRight','takeRightWhile','takeWhile','tap','throttle','thru','times','trimChars','trimCharsEnd','trimCharsStart','truncate','union','uniqBy','uniqWith','unset','unzipWith','without','wrap','xor','zip','zipObject','zipObjectDeep'],'3':['assignInWith','assignWith','clamp','differenceBy','differenceWith','findFrom','findIndexFrom','findLastFrom','findLastIndexFrom','getOr','includesFrom','indexOfFrom','inRange','intersectionBy','intersectionWith','invokeArgs','invokeArgsMap','isEqualWith','isMatchWith','flatMapDepth','lastIndexOfFrom','mergeWith','orderBy','padChars','padCharsEnd','padCharsStart','pullAllBy','pullAllWith','rangeStep','rangeStepRight','reduce','reduceRight','replace','set','slice','sortedIndexBy','sortedLastIndexBy','transform','unionBy','unionWith','update','xorBy','xorWith','zipWith'],'4':['fill','setWith','updateWith']};exports.aryRearg={'2':[1,0],'3':[2,0,1],'4':[3,2,0,1]};exports.iterateeAry={'dropRightWhile':1,'dropWhile':1,'every':1,'filter':1,'find':1,'findFrom':1,'findIndex':1,'findIndexFrom':1,'findKey':1,'findLast':1,'findLastFrom':1,'findLastIndex':1,'findLastIndexFrom':1,'findLastKey':1,'flatMap':1,'flatMapDeep':1,'flatMapDepth':1,'forEach':1,'forEachRight':1,'forIn':1,'forInRight':1,'forOwn':1,'forOwnRight':1,'map':1,'mapKeys':1,'mapValues':1,'partition':1,'reduce':2,'reduceRight':2,'reject':1,'remove':1,'some':1,'takeRightWhile':1,'takeWhile':1,'times':1,'transform':2};exports.iterateeRearg={'mapKeys':[1],'reduceRight':[1,0]};exports.methodRearg={'assignInAllWith':[1,0],'assignInWith':[1,2,0],'assignAllWith':[1,0],'assignWith':[1,2,0],'differenceBy':[1,2,0],'differenceWith':[1,2,0],'getOr':[2,1,0],'intersectionBy':[1,2,0],'intersectionWith':[1,2,0],'isEqualWith':[1,2,0],'isMatchWith':[2,1,0],'mergeAllWith':[1,0],'mergeWith':[1,2,0],'padChars':[2,1,0],'padCharsEnd':[2,1,0],'padCharsStart':[2,1,0],'pullAllBy':[2,1,0],'pullAllWith':[2,1,0],'rangeStep':[1,2,0],'rangeStepRight':[1,2,0],'setWith':[3,1,2,0],'sortedIndexBy':[2,1,0],'sortedLastIndexBy':[2,1,0],'unionBy':[1,2,0],'unionWith':[1,2,0],'updateWith':[3,1,2,0],'xorBy':[1,2,0],'xorWith':[1,2,0],'zipWith':[1,2,0]};exports.methodSpread={'assignAll':{'start':0},'assignAllWith':{'start':0},'assignInAll':{'start':0},'assignInAllWith':{'start':0},'defaultsAll':{'start':0},'defaultsDeepAll':{'start':0},'invokeArgs':{'start':2},'invokeArgsMap':{'start':2},'mergeAll':{'start':0},'mergeAllWith':{'start':0},'partial':{'start':1},'partialRight':{'start':1},'without':{'start':1},'zipAll':{'start':0}};exports.mutate={'array':{'fill':true,'pull':true,'pullAll':true,'pullAllBy':true,'pullAllWith':true,'pullAt':true,'remove':true,'reverse':true},'object':{'assign':true,'assignAll':true,'assignAllWith':true,'assignIn':true,'assignInAll':true,'assignInAllWith':true,'assignInWith':true,'assignWith':true,'defaults':true,'defaultsAll':true,'defaultsDeep':true,'defaultsDeepAll':true,'merge':true,'mergeAll':true,'mergeAllWith':true,'mergeWith':true},'set':{'set':true,'setWith':true,'unset':true,'update':true,'updateWith':true}};exports.realToAlias=function(){var hasOwnProperty=Object.prototype.hasOwnProperty,object=exports.aliasToReal,result={};for(var key in object){var value=object[key];if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}}return result;}();exports.remap={'assignAll':'assign','assignAllWith':'assignWith','assignInAll':'assignIn','assignInAllWith':'assignInWith','curryN':'curry','curryRightN':'curryRight','defaultsAll':'defaults','defaultsDeepAll':'defaultsDeep','findFrom':'find','findIndexFrom':'findIndex','findLastFrom':'findLast','findLastIndexFrom':'findLastIndex','getOr':'get','includesFrom':'includes','indexOfFrom':'indexOf','invokeArgs':'invoke','invokeArgsMap':'invokeMap','lastIndexOfFrom':'lastIndexOf','mergeAll':'merge','mergeAllWith':'mergeWith','padChars':'pad','padCharsEnd':'padEnd','padCharsStart':'padStart','propertyOf':'get','rangeStep':'range','rangeStepRight':'rangeRight','restFrom':'rest','spreadFrom':'spread','trimChars':'trim','trimCharsEnd':'trimEnd','trimCharsStart':'trimStart','zipAll':'zip'};exports.skipFixed={'castArray':true,'flow':true,'flowRight':true,'iteratee':true,'mixin':true,'rearg':true,'runInContext':true};exports.skipRearg={'add':true,'assign':true,'assignIn':true,'bind':true,'bindKey':true,'concat':true,'difference':true,'divide':true,'eq':true,'gt':true,'gte':true,'isEqual':true,'lt':true,'lte':true,'matchesProperty':true,'merge':true,'multiply':true,'overArgs':true,'partial':true,'partialRight':true,'propertyOf':true,'random':true,'range':true,'rangeRight':true,'subtract':true,'zip':true,'zipObject':true,'zipObjectDeep':true};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={'ary':__webpack_require__(138),'assign':__webpack_require__(149),'clone':__webpack_require__(152),'curry':__webpack_require__(153),'forEach':__webpack_require__(92),'isArray':__webpack_require__(6),'isError':__webpack_require__(154),'isFunction':__webpack_require__(59),'isWeakMap':__webpack_require__(156),'iteratee':__webpack_require__(157),'keys':__webpack_require__(94),'rearg':__webpack_require__(158),'toInteger':__webpack_require__(41),'toPath':__webpack_require__(162)};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(37);var WRAP_ARY_FLAG=128;function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}module.exports=ary;

/***/ }),
/* 139 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var createCtor=__webpack_require__(38),root=__webpack_require__(24);var WRAP_BIND_FLAG=1;function createBind(func,bitmask,thisArg){var Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(bitmask&WRAP_BIND_FLAG?thisArg:this,arguments);}return wrapper;}module.exports=createBind;

/***/ }),
/* 141 */
/***/ (function(module, exports) {

var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;module.exports=freeGlobal;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),createCtor=__webpack_require__(38),createHybrid=__webpack_require__(80),createRecurry=__webpack_require__(81),getHolder=__webpack_require__(85),replaceHolders=__webpack_require__(86),root=__webpack_require__(24);function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}module.exports=createCurry;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

var nativeMax=Math.max;function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength);while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}module.exports=composeArgs;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

var nativeMax=Math.max;function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength);while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}module.exports=composeArgsRight;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}module.exports=countHolders;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray=__webpack_require__(56),isIndex=__webpack_require__(40);var nativeMin=Math.min;function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}module.exports=reorder;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),createCtor=__webpack_require__(38),root=__webpack_require__(24);var WRAP_BIND_FLAG=1;function createPartial(func,bitmask,thisArg,partials){var Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,bitmask&WRAP_BIND_FLAG?thisArg:this,args);}return wrapper;}module.exports=createPartial;

/***/ }),
/* 148 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject=__webpack_require__(88),keys=__webpack_require__(91);function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}module.exports=baseAssign;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var getNative=__webpack_require__(151);var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();module.exports=defineProperty;

/***/ }),
/* 151 */
/***/ (function(module, exports) {

function getValue(object,key){return object==null?undefined:object[key];}module.exports=getValue;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(57);var CLONE_SYMBOLS_FLAG=4;function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}module.exports=clone;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(37);var WRAP_CURRY_FLAG=8;function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}curry.placeholder={};module.exports=curry;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(58),isObjectLike=__webpack_require__(32),isPlainObject=__webpack_require__(155);var domExcTag='[object DOMException]',errorTag='[object Error]';function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}module.exports=isError;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag=__webpack_require__(58),getPrototype=__webpack_require__(93),isObjectLike=__webpack_require__(32);var objectTag='[object Object]';var funcProto=Function.prototype,objectProto=Object.prototype;var funcToString=funcProto.toString;var hasOwnProperty=objectProto.hasOwnProperty;var objectCtorString=funcToString.call(Object);function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}module.exports=isPlainObject;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var getTag=__webpack_require__(60),isObjectLike=__webpack_require__(32);var weakMapTag='[object WeakMap]';function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}module.exports=isWeakMap;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone=__webpack_require__(57),baseIteratee=__webpack_require__(7);var CLONE_DEEP_FLAG=1;function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}module.exports=iteratee;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap=__webpack_require__(37),flatRest=__webpack_require__(61);var WRAP_REARG_FLAG=256;var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});module.exports=rearg;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}module.exports=arrayPush;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol=__webpack_require__(161),isArguments=__webpack_require__(62),isArray=__webpack_require__(6);var spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined;function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}module.exports=isFlattenable;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var root=__webpack_require__(24);var Symbol=root.Symbol;module.exports=Symbol;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(11),copyArray=__webpack_require__(56),isArray=__webpack_require__(6),isSymbol=__webpack_require__(44),stringToPath=__webpack_require__(97),toKey=__webpack_require__(33),toString=__webpack_require__(63);function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}module.exports=toPath;

/***/ }),
/* 163 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger=__webpack_require__(41);var FUNC_ERROR_TEXT='Expected a function';function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}module.exports=before;

/***/ }),
/* 165 */
/***/ (function(module, exports) {

module.exports={'cap':false,'curry':false,'fixed':false,'immutable':false,'rearg':false};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear=__webpack_require__(98),listCacheDelete=__webpack_require__(99),listCacheGet=__webpack_require__(100),listCacheHas=__webpack_require__(101),listCacheSet=__webpack_require__(102);function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

/***/ }),
/* 167 */
/***/ (function(module, exports) {

function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}module.exports=arrayAggregator;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}module.exports=arrayAggregator;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest=__webpack_require__(12),isIterateeCall=__webpack_require__(46);function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}module.exports=createAssigner;

/***/ }),
/* 170 */
/***/ (function(module, exports) {

function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy=__webpack_require__(104),hasIn=__webpack_require__(174);function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}module.exports=basePick;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var isArray=__webpack_require__(6),isSymbol=__webpack_require__(44);var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}module.exports=isKey;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue=__webpack_require__(89),castPath=__webpack_require__(34),isIndex=__webpack_require__(40),isObject=__webpack_require__(20),toKey=__webpack_require__(33);function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=length-1){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}module.exports=baseSet;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn=__webpack_require__(175),hasPath=__webpack_require__(176);function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}module.exports=hasIn;

/***/ }),
/* 175 */
/***/ (function(module, exports) {

function baseHasIn(object,key){return object!=null&&key in Object(object);}module.exports=baseHasIn;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(34),isArguments=__webpack_require__(62),isArray=__webpack_require__(6),isIndex=__webpack_require__(40),isLength=__webpack_require__(106),toKey=__webpack_require__(33);function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}module.exports=hasPath;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var createFlow=__webpack_require__(178);var flow=createFlow();module.exports=flow;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var LodashWrapper=__webpack_require__(179),flatRest=__webpack_require__(61),getData=__webpack_require__(87),getFuncName=__webpack_require__(180),isArray=__webpack_require__(6),isLaziable=__webpack_require__(82);var FUNC_ERROR_TEXT='Expected a function';var WRAP_CURRY_FLAG=8,WRAP_PARTIAL_FLAG=32,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256;function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}module.exports=createFlow;

/***/ }),
/* 179 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 180 */
/***/ (function(module, exports) {

function stubString(){return'';}module.exports=stubString;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var apply=__webpack_require__(39),arrayMap=__webpack_require__(11),unzip=__webpack_require__(107);function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}module.exports=unzipWith;

/***/ }),
/* 182 */
/***/ (function(module, exports) {

function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

/***/ }),
/* 183 */
/***/ (function(module, exports) {

function baseProperty(key){return function(object){return object==null?undefined:object[key];};}module.exports=baseProperty;

/***/ }),
/* 184 */
/***/ (function(module, exports) {

function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}module.exports=baseTimes;

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports=function(module){if(!module.webpackPolyfill){module.deprecate=function(){};module.paths=[];if(!module.children)module.children=[];Object.defineProperty(module,"loaded",{enumerable:true,get:function(){return module.l;}});Object.defineProperty(module,"id",{enumerable:true,get:function(){return module.i;}});module.webpackPolyfill=1;}return module;};

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var basePullAll=__webpack_require__(189);function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}module.exports=pullAll;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(11),baseIndexOf=__webpack_require__(65),baseIndexOfWith=__webpack_require__(190),baseUnary=__webpack_require__(47),copyArray=__webpack_require__(56);var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}module.exports=basePullAll;

/***/ }),
/* 190 */
/***/ (function(module, exports) {

function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}module.exports=baseIndexOfWith;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var root=__webpack_require__(24);var now=function(){return root.Date.now();};module.exports=now;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var baseUnset=__webpack_require__(193),isIndex=__webpack_require__(40);var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}module.exports=basePullAt;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var castPath=__webpack_require__(34),last=__webpack_require__(13),parent=__webpack_require__(194),toKey=__webpack_require__(33);function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}module.exports=baseUnset;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet=__webpack_require__(105),baseSlice=__webpack_require__(66);function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}module.exports=parent;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor=__webpack_require__(196);var baseFor=createBaseFor();module.exports=baseFor;

/***/ }),
/* 196 */
/***/ (function(module, exports) {

function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}module.exports=createBaseFor;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var n={name:"de",weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),months:"Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan_Feb_Mrz_Apr_Mai_Juni_Juli_Aug_Sept_Okt_Nov_Dez".split("_"),ordinal:function(e){return e+".";},weekStart:1,formats:{LTS:"HH:mm:ss",LT:"HH:mm",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},relativeTime:{future:"in %s",past:"vor %s",s:"wenigen Sekunden",m:"einer Minute",mm:"%d Minuten",h:"einer Stunde",hh:"%d Stunden",d:"einem Tag",dd:"%d Tagen",M:"einem Monat",MM:"%d Monaten",y:"einem Jahr",yy:"%d Jahren"}};return e.locale(n,null,!0),n;});

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

!function(_,e){ true?module.exports=e(__webpack_require__(9)):undefined;}(this,function(_){"use strict";_=_&&_.hasOwnProperty("default")?_.default:_;var e={name:"el",weekdays:"______".split("_"),weekdaysShort:"______".split("_"),weekdaysMin:"______".split("_"),months:"___________".split("_"),monthsShort:"___________".split("_"),ordinal:function(_){return _;},weekStart:1,relativeTime:{future:" %s",past:" %s",s:" ",m:" ",mm:"%d ",h:" ",hh:"%d ",d:" ",dd:"%d ",M:" ",MM:"%d ",y:" ",yy:"%d "},formats:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"}};return _.locale(e,null,!0),e;});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,s){ true?module.exports=s(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var s={name:"es",monthsShort:"ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),weekdays:"domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),weekdaysShort:"dom._lun._mar._mi._jue._vie._sb.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s".split("_"),months:"Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"),weekStart:1,formats:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un da",dd:"%d das",M:"un mes",MM:"%d meses",y:"un ao",yy:"%d aos"},ordinal:function(e){return e+"";}};return e.locale(s,null,!0),s;});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

!function(Y,M){ true?module.exports=M(__webpack_require__(9)):undefined;}(this,function(Y){"use strict";Y=Y&&Y.hasOwnProperty("default")?Y.default:Y;var M={name:"he",weekdays:"______".split("_"),weekdaysShort:"______".split("_"),weekdaysMin:"______".split("_"),months:"___________".split("_"),monthsShort:"___________".split("_"),relativeTime:{future:" %s",past:" %s",s:" ",m:"",mm:"%d ",h:"",hh:"%d ",d:"",dd:"%d ",M:"",MM:"%d ",y:"",yy:"%d "},ordinal:function(Y){return Y;},format:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D []MMMM YYYY",LLL:"D []MMMM YYYY HH:mm",LLLL:"dddd, D []MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D []MMMM YYYY",LLL:"D []MMMM YYYY HH:mm",LLLL:"dddd, D []MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"}};return Y.locale(M,null,!0),M;});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var o={name:"it",weekdays:"domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),weekStart:1,monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"tra %s",past:"%s fa",s:"qualche secondo",m:"un minuto",mm:"%d minuti",h:"un' ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},ordinal:function(e){return e+"";}};return e.locale(o,null,!0),o;});

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var a={name:"nl",weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),ordinal:function(e){return e+".";},weekStart:1,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",m:"een minuut",mm:"%d minuten",h:"een uur",hh:"%d uur",d:"een dag",dd:"%d dagen",M:"een maand",MM:"%d maanden",y:"een jaar",yy:"%d jaar"}};return e.locale(a,null,!0),a;});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,i){ true?module.exports=i(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var i={name:"pl",weekdays:"Niedziela_Poniedziaek_Wtorek_roda_Czwartek_Pitek_Sobota".split("_"),weekdaysShort:"Ndz_Pon_Wt_r_Czw_Pt_Sob".split("_"),weekdaysMin:"Nd_Pn_Wt_r_Cz_Pt_So".split("_"),months:"Stycze_Luty_Marzec_Kwiecie_Maj_Czerwiec_Lipiec_Sierpie_Wrzesie_Padziernik_Listopad_Grudzie".split("_"),monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),ordinal:function(e){return e+".";},weekStart:1,relativeTime:{future:"za %s",past:"po %s",s:"kilka sekund",m:"minuta",mm:"%d minut",h:"godzina",hh:"%d godzin",d:"dzie",dd:"%d dni",M:"miesic",MM:"%d miesicy",y:"rok",yy:"%d lat"},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"}};return e.locale(i,null,!0),i;});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var o={name:"pt-br",weekdays:"Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),weekdaysMin:"Do_2_3_4_5_6_S".split("_"),weekStart:1,months:"Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),ordinal:function(e){return e+"";},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [s] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [s] HH:mm"},relativeTime:{future:"em %s",past:"h %s",s:"poucos segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um ms",MM:"%d meses",y:"um ano",yy:"%d anos"}};return e.locale(o,null,!0),o;});

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(9)):undefined;}(this,function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;var a={name:"pt",weekdays:"Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sab".split("_"),weekdaysMin:"Do_2_3_4_5_6_Sa".split("_"),months:"Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),ordinal:function(e){return e+"";},weekStart:1,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [s] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [s] HH:mm"},relativeTime:{future:"em %s",past:"h %s",s:"alguns segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um ms",MM:"%d meses",y:"um ano",yy:"%d anos"}};return e.locale(a,null,!0),a;});

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

!function(r,t){ true?module.exports=t():undefined;}(this,function(){"use strict";return function(r,t,e){var n=t.prototype;e.en.relativeTime={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};var o=function(r,t,n,o){for(var d,i,u,a=n.$locale().relativeTime,f=[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],s=f.length,l=0;l<s;l+=1){var h=f[l];h.d&&(d=o?e(r).diff(n,h.d,!0):n.diff(r,h.d,!0));var m=Math.round(Math.abs(d));if(u=d>0,m<=h.r||!h.r){1===m&&l>0&&(h=f[l-1]);var c=a[h.l];i="string"==typeof c?c.replace("%d",m):c(m,t,h.l,u);break;}}return t?i:(u?a.future:a.past).replace("%s",i);};n.to=function(r,t){return o(r,t,this,!0);},n.from=function(r,t){return o(r,t,this);};var d=function(r){return r.$u?e.utc():e();};n.toNow=function(r){return this.to(d(this),r);},n.fromNow=function(r){return this.from(d(this),r);};};});

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined;}(this,function(){"use strict";return function(e,t,o){var n=t.prototype,r=n.format,M={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};o.en.formats=M;n.format=function(e){void 0===e&&(e="YYYY-MM-DDTHH:mm:ssZ");var t=this.$locale().formats,o=void 0===t?{}:t,n=e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(e,t,n){var r=n&&n.toUpperCase();return t||o[n]||M[n]||o[r].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(e,t,o){return t||o.slice(1);});});return r.call(this,n);};};});

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap=__webpack_require__(11),baseIteratee=__webpack_require__(7),baseMap=__webpack_require__(209),baseSortBy=__webpack_require__(210),baseUnary=__webpack_require__(47),compareMultiple=__webpack_require__(211),identity=__webpack_require__(103);function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(baseIteratee));var result=baseMap(collection,function(value){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}module.exports=baseOrderBy;

/***/ }),
/* 209 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 210 */
/***/ (function(module, exports) {

function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}module.exports=baseSortBy;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending=__webpack_require__(212);function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}return object.index-other.index;}module.exports=compareMultiple;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol=__webpack_require__(44);function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}module.exports=compareAscending;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol=__webpack_require__(44);function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}module.exports=baseExtremum;

/***/ }),
/* 214 */
/***/ (function(module, exports) {

function baseGt(value,other){return value>other;}module.exports=baseGt;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep=__webpack_require__(216),isObjectLike=__webpack_require__(32);function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}module.exports=baseIsEqual;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var Stack=__webpack_require__(217),equalArrays=__webpack_require__(218),equalByTag=__webpack_require__(220),equalObjects=__webpack_require__(221),getTag=__webpack_require__(60),isArray=__webpack_require__(6),isBuffer=__webpack_require__(67),isTypedArray=__webpack_require__(68);var COMPARE_PARTIAL_FLAG=1;var argsTag='[object Arguments]',arrayTag='[object Array]',objectTag='[object Object]';var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}module.exports=baseIsEqualDeep;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear=__webpack_require__(98),listCacheDelete=__webpack_require__(99),listCacheGet=__webpack_require__(100),listCacheHas=__webpack_require__(101),listCacheSet=__webpack_require__(102);function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(48),arraySome=__webpack_require__(219),cacheHas=__webpack_require__(49);var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}module.exports=equalArrays;

/***/ }),
/* 219 */
/***/ (function(module, exports) {

function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}module.exports=arraySome;

/***/ }),
/* 220 */
/***/ (function(module, exports) {

function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys=__webpack_require__(222);var COMPARE_PARTIAL_FLAG=1;var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}module.exports=equalObjects;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var overArg=__webpack_require__(42);var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

/***/ }),
/* 223 */
/***/ (function(module, exports) {

function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

/***/ }),
/* 224 */
/***/ (function(module, exports) {

var nativeFloor=Math.floor,nativeRandom=Math.random;function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}module.exports=baseRandom;

/***/ }),
/* 225 */
/***/ (function(module, exports) {

function identity(value){return value;}module.exports=identity;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}module.exports=baseClamp;

/***/ }),
/* 227 */
/***/ (function(module, exports) {

function stubFalse(){return false;}module.exports=stubFalse;

/***/ }),
/* 228 */
/***/ (function(module, exports) {

var FUNC_ERROR_TEXT='Expected a function';function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}module.exports=negate;

/***/ }),
/* 229 */
/***/ (function(module, exports) {

function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

/***/ }),
/* 230 */
/***/ (function(module, exports) {

function noop(){}module.exports=noop;

/***/ }),
/* 231 */
/***/ (function(module, exports) {

function stubArray(){return[];}module.exports=stubArray;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache=__webpack_require__(48),arrayIncludes=__webpack_require__(69),arrayIncludesWith=__webpack_require__(70),arrayMap=__webpack_require__(11),baseUnary=__webpack_require__(47),cacheHas=__webpack_require__(49);var nativeMin=Math.min;function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}module.exports=baseIntersection;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLikeObject=__webpack_require__(35);function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}module.exports=castArrayLikeObject;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice=__webpack_require__(66);function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}module.exports=baseWhile;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice=__webpack_require__(66),isIterateeCall=__webpack_require__(46),toInteger=__webpack_require__(41);function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}module.exports=slice;

/***/ }),
/* 236 */
/***/ (function(module, exports) {

function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

const compare=__webpack_require__(112);const gt=(a,b,loose)=>compare(a,b,loose)>0;module.exports=gt;

/***/ }),
/* 238 */
/***/ (function(module, exports) {

const numeric=/^[0-9]+$/;const compareIdentifiers=(a,b)=>{const anum=numeric.test(a);const bnum=numeric.test(b);if(anum&&bnum){a=+a;b=+b;}return a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1;};const rcompareIdentifiers=(a,b)=>compareIdentifiers(b,a);module.exports={compareIdentifiers,rcompareIdentifiers};

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

const parse=__webpack_require__(240);const eq=__webpack_require__(241);const diff=(version1,version2)=>{if(eq(version1,version2)){return null;}else{const v1=parse(version1);const v2=parse(version2);let prefix='';if(v1.prerelease.length||v2.prerelease.length){prefix='pre';var defaultResult='prerelease';}for(const key in v1){if(key==='major'||key==='minor'||key==='patch'){if(v1[key]!==v2[key]){return prefix+key;}}}return defaultResult;}};module.exports=diff;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

const{MAX_LENGTH}=__webpack_require__(72);const{re,t}=__webpack_require__(115);const SemVer=__webpack_require__(113);const parse=(version,options)=>{if(!options||typeof options!=='object'){options={loose:!!options,includePrerelease:false};}if(version instanceof SemVer){return version;}if(typeof version!=='string'){return null;}if(version.length>MAX_LENGTH){return null;}const r=options.loose?re[t.LOOSE]:re[t.FULL];if(!r.test(version)){return null;}try{return new SemVer(version,options);}catch(er){return null;}};module.exports=parse;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

const compare=__webpack_require__(112);const eq=(a,b,loose)=>compare(a,b,loose)===0;module.exports=eq;

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var string_namespaceObject = {};
__webpack_require__.r(string_namespaceObject);
__webpack_require__.d(string_namespaceObject, "encode", function() { return encode; });
__webpack_require__.d(string_namespaceObject, "escape", function() { return string_escape; });
__webpack_require__.d(string_namespaceObject, "safe", function() { return safe; });
__webpack_require__.d(string_namespaceObject, "areSimilar", function() { return areSimilar; });
__webpack_require__.d(string_namespaceObject, "regexRegex", function() { return regexRegex; });
__webpack_require__.d(string_namespaceObject, "html", function() { return string_html; });
__webpack_require__.d(string_namespaceObject, "_html", function() { return _html; });
var context_namespaceObject = {};
__webpack_require__.r(context_namespaceObject);
__webpack_require__.d(context_namespaceObject, "data", function() { return context_data; });
__webpack_require__.d(context_namespaceObject, "establish", function() { return establish; });
__webpack_require__.d(context_namespaceObject, "retrieveFromParent", function() { return retrieveFromParent; });
var foreground_messaging_namespaceObject = {};
__webpack_require__.r(foreground_messaging_namespaceObject);
__webpack_require__.d(foreground_messaging_namespaceObject, "sendMessage", function() { return sendMessage; });
__webpack_require__.d(foreground_messaging_namespaceObject, "addListener", function() { return addListener; });
var privateBrowsing_namespaceObject = {};
__webpack_require__.r(privateBrowsing_namespaceObject);
__webpack_require__.d(privateBrowsing_namespaceObject, "isPrivateBrowsing", function() { return isPrivateBrowsing; });
var history_namespaceObject = {};
__webpack_require__.r(history_namespaceObject);
__webpack_require__.d(history_namespaceObject, "addURLToHistory", function() { return addURLToHistory; });
__webpack_require__.d(history_namespaceObject, "isURLVisited", function() { return isURLVisited; });
var xhrCache_namespaceObject = {};
__webpack_require__.r(xhrCache_namespaceObject);
__webpack_require__.d(xhrCache_namespaceObject, "set", function() { return set; });
__webpack_require__.d(xhrCache_namespaceObject, "check", function() { return xhrCache_check; });
__webpack_require__.d(xhrCache_namespaceObject, "delete", function() { return delete_; });
__webpack_require__.d(xhrCache_namespaceObject, "clear", function() { return clear; });
var ajax_namespaceObject = {};
__webpack_require__.r(ajax_namespaceObject);
__webpack_require__.d(ajax_namespaceObject, "ajax", function() { return ajax; });
var download_namespaceObject = {};
__webpack_require__.r(download_namespaceObject);
__webpack_require__.d(download_namespaceObject, "download", function() { return download; });
var id_namespaceObject = {};
__webpack_require__.r(id_namespaceObject);
__webpack_require__.d(id_namespaceObject, "getExtensionId", function() { return getExtensionId; });
__webpack_require__.d(id_namespaceObject, "getURL", function() { return getURL; });
__webpack_require__.d(id_namespaceObject, "getOptionsURL", function() { return getOptionsURL; });
__webpack_require__.d(id_namespaceObject, "isOptionsPage", function() { return isOptionsPage; });
var i18n_namespaceObject = {};
__webpack_require__.r(i18n_namespaceObject);
__webpack_require__.d(i18n_namespaceObject, "locale", function() { return i18n_locale; });
__webpack_require__.d(i18n_namespaceObject, "_loadI18n", function() { return _loadI18n; });
__webpack_require__.d(i18n_namespaceObject, "i18n", function() { return i18n; });
var permissions_namespaceObject = {};
__webpack_require__.r(permissions_namespaceObject);
__webpack_require__.d(permissions_namespaceObject, "has", function() { return permissions_has; });
__webpack_require__.d(permissions_namespaceObject, "request", function() { return request; });
var auth_namespaceObject = {};
__webpack_require__.r(auth_namespaceObject);
__webpack_require__.d(auth_namespaceObject, "launchAuthFlow", function() { return launchAuthFlow; });
var multicast_namespaceObject = {};
__webpack_require__.r(multicast_namespaceObject);
__webpack_require__.d(multicast_namespaceObject, "multicast", function() { return multicast; });
var tabs_namespaceObject = {};
__webpack_require__.r(tabs_namespaceObject);
__webpack_require__.d(tabs_namespaceObject, "openNewTab", function() { return openNewTab; });
__webpack_require__.d(tabs_namespaceObject, "openNewTabs", function() { return openNewTabs; });
var pageAction_namespaceObject = {};
__webpack_require__.r(pageAction_namespaceObject);
__webpack_require__.d(pageAction_namespaceObject, "onClick", function() { return pageAction_onClick; });
__webpack_require__.d(pageAction_namespaceObject, "show", function() { return show; });
__webpack_require__.d(pageAction_namespaceObject, "hide", function() { return pageAction_hide; });
var session_namespaceObject = {};
__webpack_require__.r(session_namespaceObject);
__webpack_require__.d(session_namespaceObject, "get", function() { return get; });
__webpack_require__.d(session_namespaceObject, "set", function() { return session_set; });
__webpack_require__.d(session_namespaceObject, "delete_", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "delete", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "has", function() { return session_has; });
__webpack_require__.d(session_namespaceObject, "clear", function() { return session_clear; });
var storage_namespaceObject = {};
__webpack_require__.r(storage_namespaceObject);
__webpack_require__.d(storage_namespaceObject, "get", function() { return storage_get; });
__webpack_require__.d(storage_namespaceObject, "getAll", function() { return getAll; });
__webpack_require__.d(storage_namespaceObject, "getMultiple", function() { return getMultiple; });
__webpack_require__.d(storage_namespaceObject, "set", function() { return storage_set; });
__webpack_require__.d(storage_namespaceObject, "setMultiple", function() { return setMultiple; });
__webpack_require__.d(storage_namespaceObject, "delete", function() { return storage_delete_; });
__webpack_require__.d(storage_namespaceObject, "deleteMultiple", function() { return deleteMultiple; });
__webpack_require__.d(storage_namespaceObject, "has", function() { return storage_has; });
__webpack_require__.d(storage_namespaceObject, "keys", function() { return storage_keys; });
__webpack_require__.d(storage_namespaceObject, "clear", function() { return storage_clear; });
__webpack_require__.d(storage_namespaceObject, "wrap", function() { return wrap; });
__webpack_require__.d(storage_namespaceObject, "wrapPrefix", function() { return wrapPrefix; });
__webpack_require__.d(storage_namespaceObject, "wrapBlob", function() { return wrapBlob; });
var pagePhases_namespaceObject = {};
__webpack_require__.r(pagePhases_namespaceObject);
__webpack_require__.d(pagePhases_namespaceObject, "bodyStart", function() { return bodyStart; });
__webpack_require__.d(pagePhases_namespaceObject, "sitetableStarted", function() { return sitetableStarted; });
__webpack_require__.d(pagePhases_namespaceObject, "contentLoaded", function() { return contentLoaded; });
__webpack_require__.d(pagePhases_namespaceObject, "loadComplete", function() { return loadComplete; });
var bodyClasses_namespaceObject = {};
__webpack_require__.r(bodyClasses_namespaceObject);
__webpack_require__.d(bodyClasses_namespaceObject, "addMissing", function() { return addMissing; });
__webpack_require__.d(bodyClasses_namespaceObject, "add", function() { return bodyClasses_add; });
__webpack_require__.d(bodyClasses_namespaceObject, "remove", function() { return bodyClasses_remove; });
__webpack_require__.d(bodyClasses_namespaceObject, "toggle", function() { return bodyClasses_toggle; });
var browserDetect_namespaceObject = {};
__webpack_require__.r(browserDetect_namespaceObject);
__webpack_require__.d(browserDetect_namespaceObject, "browser", function() { return browser; });
__webpack_require__.d(browserDetect_namespaceObject, "version", function() { return version; });
__webpack_require__.d(browserDetect_namespaceObject, "OS", function() { return OS; });
var createElement_namespaceObject = {};
__webpack_require__.r(createElement_namespaceObject);
__webpack_require__.d(createElement_namespaceObject, "toggleButton", function() { return toggleButton; });
__webpack_require__.d(createElement_namespaceObject, "icon", function() { return icon; });
__webpack_require__.d(createElement_namespaceObject, "table", function() { return createElement_table; });
__webpack_require__.d(createElement_namespaceObject, "tabMenuItem", function() { return createElement_tabMenuItem; });
__webpack_require__.d(createElement_namespaceObject, "fancyToggleButton", function() { return fancyToggleButton; });
var alert_namespaceObject = {};
__webpack_require__.r(alert_namespaceObject);
__webpack_require__.d(alert_namespaceObject, "open", function() { return alert_open; });
__webpack_require__.d(alert_namespaceObject, "makeButton", function() { return makeButton; });
var selectedThing_namespaceObject = {};
__webpack_require__.r(selectedThing_namespaceObject);
__webpack_require__.d(selectedThing_namespaceObject, "current", function() { return selectedThing_current; });
__webpack_require__.d(selectedThing_namespaceObject, "addListener", function() { return selectedThing_addListener; });
__webpack_require__.d(selectedThing_namespaceObject, "set", function() { return selectedThing_set; });
__webpack_require__.d(selectedThing_namespaceObject, "selectClosestInView", function() { return selectClosestInView; });
__webpack_require__.d(selectedThing_namespaceObject, "refresh", function() { return refresh; });
__webpack_require__.d(selectedThing_namespaceObject, "move", function() { return move; });
__webpack_require__.d(selectedThing_namespaceObject, "setScrollToSelectedThingOnLoad", function() { return setScrollToSelectedThingOnLoad; });
var table_namespaceObject = {};
__webpack_require__.r(table_namespaceObject);
__webpack_require__.d(table_namespaceObject, "RESTable", function() { return table_RESTable; });
__webpack_require__.d(table_namespaceObject, "sortByColumn", function() { return sortByColumn; });
var caseBuilder_namespaceObject = {};
__webpack_require__.r(caseBuilder_namespaceObject);
__webpack_require__.d(caseBuilder_namespaceObject, "drawOptionBuilder", function() { return drawOptionBuilder; });
__webpack_require__.d(caseBuilder_namespaceObject, "drawBuilderBlock", function() { return drawBuilderBlock; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderItem", function() { return readBuilderItem; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderBlock", function() { return readBuilderBlock; });
var stage_namespaceObject = {};
__webpack_require__.r(stage_namespaceObject);
__webpack_require__.d(stage_namespaceObject, "add", function() { return stageOption; });
__webpack_require__.d(stage_namespaceObject, "commit", function() { return commitStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "reset", function() { return clearStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "isDirty", function() { return hasStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "get", function() { return getStagedOptions; });
var options_table_namespaceObject = {};
__webpack_require__.r(options_table_namespaceObject);
__webpack_require__.d(options_table_namespaceObject, "getMatchingValueOrAdd", function() { return getMatchingValueOrAdd; });
var commandLine_namespaceObject = {};
__webpack_require__.r(commandLine_namespaceObject);
__webpack_require__.d(commandLine_namespaceObject, "module", function() { return commandLine_module; });
__webpack_require__.d(commandLine_namespaceObject, "open", function() { return commandLine_open; });
__webpack_require__.d(commandLine_namespaceObject, "toggle", function() { return commandLine_toggle; });
__webpack_require__.d(commandLine_namespaceObject, "registerCommand", function() { return registerCommand; });
var newCommentCount_namespaceObject = {};
__webpack_require__.r(newCommentCount_namespaceObject);
__webpack_require__.d(newCommentCount_namespaceObject, "module", function() { return newCommentCount_module; });
__webpack_require__.d(newCommentCount_namespaceObject, "hasEntry", function() { return hasEntry; });
__webpack_require__.d(newCommentCount_namespaceObject, "getNewCount", function() { return getNewCount; });
var showImages_namespaceObject = {};
__webpack_require__.r(showImages_namespaceObject);
__webpack_require__.d(showImages_namespaceObject, "genericHosts", function() { return genericHosts; });
__webpack_require__.d(showImages_namespaceObject, "module", function() { return showImages_module; });
__webpack_require__.d(showImages_namespaceObject, "viewImagesButton", function() { return viewImagesButton; });
__webpack_require__.d(showImages_namespaceObject, "toggleThingExpandos", function() { return toggleThingExpandos; });
__webpack_require__.d(showImages_namespaceObject, "types", function() { return showImages_types; });
__webpack_require__.d(showImages_namespaceObject, "matchesTypes", function() { return matchesTypes; });
__webpack_require__.d(showImages_namespaceObject, "getLinkExpando", function() { return getLinkExpando; });
__webpack_require__.d(showImages_namespaceObject, "Media", function() { return showImages_Media; });
__webpack_require__.d(showImages_namespaceObject, "move", function() { return showImages_move; });
__webpack_require__.d(showImages_namespaceObject, "resize", function() { return resize; });
var filteReddit_namespaceObject = {};
__webpack_require__.r(filteReddit_namespaceObject);
__webpack_require__.d(filteReddit_namespaceObject, "module", function() { return filteReddit_module; });
__webpack_require__.d(filteReddit_namespaceObject, "defaultFilters", function() { return defaultFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "filterlinePromise", function() { return filterlinePromise; });
__webpack_require__.d(filteReddit_namespaceObject, "ensureFilterlineVisible", function() { return ensureFilterlineVisible; });
__webpack_require__.d(filteReddit_namespaceObject, "listFilters", function() { return listFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "addExternalFilter", function() { return addExternalFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "addOndemandCase", function() { return addOndemandCase; });
__webpack_require__.d(filteReddit_namespaceObject, "addCustomFilter", function() { return addCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "updateCustomFilter", function() { return updateCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "saveFilterlineStateAsDefault", function() { return saveFilterlineStateAsDefault; });
var userTagger_namespaceObject = {};
__webpack_require__.r(userTagger_namespaceObject);
__webpack_require__.d(userTagger_namespaceObject, "module", function() { return userTagger_module; });
__webpack_require__.d(userTagger_namespaceObject, "applyToUser", function() { return applyToUser; });
__webpack_require__.d(userTagger_namespaceObject, "tags", function() { return tags; });
__webpack_require__.d(userTagger_namespaceObject, "Tag", function() { return userTagger_Tag; });
var postCases_namespaceObject = {};
__webpack_require__.r(postCases_namespaceObject);
__webpack_require__.d(postCases_namespaceObject, "commentCount", function() { return CommentCount_CommentCount; });
__webpack_require__.d(postCases_namespaceObject, "newCommentCount", function() { return NewCommentCount_NewCommentCount; });
__webpack_require__.d(postCases_namespaceObject, "commentsOpened", function() { return CommentsOpened_CommentsOpened; });
__webpack_require__.d(postCases_namespaceObject, "domain", function() { return Domain_Domain; });
__webpack_require__.d(postCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(postCases_namespaceObject, "isLocked", function() { return IsLocked_IsLocked; });
__webpack_require__.d(postCases_namespaceObject, "isNSFW", function() { return IsNSFW_IsNSFW; });
__webpack_require__.d(postCases_namespaceObject, "isSpoiler", function() { return IsSpoiler_IsSpoiler; });
__webpack_require__.d(postCases_namespaceObject, "isVisited", function() { return IsVisited_IsVisited; });
__webpack_require__.d(postCases_namespaceObject, "linkFlair", function() { return LinkFlair_LinkFlair; });
__webpack_require__.d(postCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(postCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(postCases_namespaceObject, "postTitle", function() { return PostTitle_PostTitle; });
__webpack_require__.d(postCases_namespaceObject, "postType", function() { return PostType_PostType; });
__webpack_require__.d(postCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(postCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(postCases_namespaceObject, "subreddit", function() { return Subreddit_Subreddit; });
__webpack_require__.d(postCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(postCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(postCases_namespaceObject, "userTag", function() { return UserTag_UserTag; });
__webpack_require__.d(postCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(postCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(postCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });
var readComments_namespaceObject = {};
__webpack_require__.r(readComments_namespaceObject);
__webpack_require__.d(readComments_namespaceObject, "module", function() { return readComments_module; });
__webpack_require__.d(readComments_namespaceObject, "add", function() { return readComments_add; });
__webpack_require__.d(readComments_namespaceObject, "isRead", function() { return isRead; });
var commentCases_namespaceObject = {};
__webpack_require__.r(commentCases_namespaceObject);
__webpack_require__.d(commentCases_namespaceObject, "commentContent", function() { return CommentContent_CommentContent; });
__webpack_require__.d(commentCases_namespaceObject, "commentLength", function() { return CommentLength_CommentLength; });
__webpack_require__.d(commentCases_namespaceObject, "depth", function() { return Depth_Depth; });
__webpack_require__.d(commentCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(commentCases_namespaceObject, "isDeleted", function() { return IsDeleted_IsDeleted; });
__webpack_require__.d(commentCases_namespaceObject, "isRead", function() { return IsRead_IsRead; });
__webpack_require__.d(commentCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(commentCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(commentCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(commentCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(commentCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(commentCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(commentCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(commentCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(commentCases_namespaceObject, "userTag", function() { return UserTag_UserTag; });
__webpack_require__.d(commentCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });
var browseCases_namespaceObject = {};
__webpack_require__.r(browseCases_namespaceObject);
__webpack_require__.d(browseCases_namespaceObject, "browsingFrontPage", function() { return BrowsingFrontPage_BrowsingFrontPage; });
__webpack_require__.d(browseCases_namespaceObject, "currentLocation", function() { return CurrentLocation_CurrentLocation; });
__webpack_require__.d(browseCases_namespaceObject, "currentMulti", function() { return CurrentMulti_CurrentMulti; });
__webpack_require__.d(browseCases_namespaceObject, "currentUserProfile", function() { return CurrentUserProfile_CurrentUserProfile; });
__webpack_require__.d(browseCases_namespaceObject, "currentSub", function() { return CurrentSub_CurrentSub; });
__webpack_require__.d(browseCases_namespaceObject, "date", function() { return Date_Date; });
__webpack_require__.d(browseCases_namespaceObject, "dow", function() { return Dow_Dow; });
__webpack_require__.d(browseCases_namespaceObject, "loggedInAs", function() { return LoggedInAs_LoggedInAs; });
__webpack_require__.d(browseCases_namespaceObject, "toggle", function() { return Toggle_Toggle; });
var usernameHider_namespaceObject = {};
__webpack_require__.r(usernameHider_namespaceObject);
__webpack_require__.d(usernameHider_namespaceObject, "module", function() { return usernameHider_module; });
__webpack_require__.d(usernameHider_namespaceObject, "getDisplayText", function() { return getDisplayText; });
var quickMessage_namespaceObject = {};
__webpack_require__.r(quickMessage_namespaceObject);
__webpack_require__.d(quickMessage_namespaceObject, "module", function() { return quickMessage_module; });
__webpack_require__.d(quickMessage_namespaceObject, "messageLinkEventHandler", function() { return messageLinkEventHandler; });
__webpack_require__.d(quickMessage_namespaceObject, "openQuickMessageDialog", function() { return openQuickMessageDialog; });
var commentNavigator_namespaceObject = {};
__webpack_require__.r(commentNavigator_namespaceObject);
__webpack_require__.d(commentNavigator_namespaceObject, "module", function() { return commentNavigator_module; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateCustomConditions", function() { return updateCustomConditions; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateFromSelected", function() { return updateFromSelected; });
__webpack_require__.d(commentNavigator_namespaceObject, "setCategory", function() { return setCategory; });
__webpack_require__.d(commentNavigator_namespaceObject, "toggle", function() { return commentNavigator_toggle; });
__webpack_require__.d(commentNavigator_namespaceObject, "move", function() { return commentNavigator_move; });
var hideChildComments_namespaceObject = {};
__webpack_require__.r(hideChildComments_namespaceObject);
__webpack_require__.d(hideChildComments_namespaceObject, "module", function() { return hideChildComments_module; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggleAll", function() { return toggleAll; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggle", function() { return hideChildComments_toggle; });
var neverEndingReddit_namespaceObject = {};
__webpack_require__.r(neverEndingReddit_namespaceObject);
__webpack_require__.d(neverEndingReddit_namespaceObject, "module", function() { return neverEndingReddit_module; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "loadNextPage", function() { return loadNextPage; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "getNextPrevLinks", function() { return getNextPrevLinks; });
var noParticipation_namespaceObject = {};
__webpack_require__.r(noParticipation_namespaceObject);
__webpack_require__.d(noParticipation_namespaceObject, "module", function() { return noParticipation_module; });
__webpack_require__.d(noParticipation_namespaceObject, "isVotingBlocked", function() { return isVotingBlocked; });
__webpack_require__.d(noParticipation_namespaceObject, "nonNpLocation", function() { return nonNpLocation; });
__webpack_require__.d(noParticipation_namespaceObject, "notifyNoVote", function() { return notifyNoVote; });
var saveComments_namespaceObject = {};
__webpack_require__.r(saveComments_namespaceObject);
__webpack_require__.d(saveComments_namespaceObject, "module", function() { return saveComments_module; });
__webpack_require__.d(saveComments_namespaceObject, "showEducationalNotification", function() { return showEducationalNotification; });
var showParent_namespaceObject = {};
__webpack_require__.r(showParent_namespaceObject);
__webpack_require__.d(showParent_namespaceObject, "module", function() { return showParent_module; });
__webpack_require__.d(showParent_namespaceObject, "startHover", function() { return startHover; });
var singleClick_namespaceObject = {};
__webpack_require__.r(singleClick_namespaceObject);
__webpack_require__.d(singleClick_namespaceObject, "module", function() { return singleClick_module; });
__webpack_require__.d(singleClick_namespaceObject, "invokeOnPostMap", function() { return invokeOnPostMap; });
var keyboardNav_namespaceObject = {};
__webpack_require__.r(keyboardNav_namespaceObject);
__webpack_require__.d(keyboardNav_namespaceObject, "module", function() { return keyboardNav_module; });
var providers_namespaceObject = {};
__webpack_require__.r(providers_namespaceObject);
__webpack_require__.d(providers_namespaceObject, "File", function() { return File_File; });
__webpack_require__.d(providers_namespaceObject, "GoogleDrive", function() { return GoogleDrive_GoogleDrive; });
__webpack_require__.d(providers_namespaceObject, "OneDrive", function() { return OneDrive_OneDrive; });
__webpack_require__.d(providers_namespaceObject, "Dropbox", function() { return Dropbox_Dropbox; });
var subredditManager_namespaceObject = {};
__webpack_require__.r(subredditManager_namespaceObject);
__webpack_require__.d(subredditManager_namespaceObject, "module", function() { return subredditManager_module; });
__webpack_require__.d(subredditManager_namespaceObject, "createShortcutToggleButton", function() { return createShortcutToggleButton; });
__webpack_require__.d(subredditManager_namespaceObject, "getMultiCounts", function() { return getMultiCounts; });
__webpack_require__.d(subredditManager_namespaceObject, "subscribeToSubreddit", function() { return subscribeToSubreddit; });
var modules_dashboard_namespaceObject = {};
__webpack_require__.r(modules_dashboard_namespaceObject);
__webpack_require__.d(modules_dashboard_namespaceObject, "module", function() { return dashboard_module; });
__webpack_require__.d(modules_dashboard_namespaceObject, "widgets", function() { return widgets; });
__webpack_require__.d(modules_dashboard_namespaceObject, "createSubredditToggleButton", function() { return createSubredditToggleButton; });

// CONCATENATED MODULE: ./node_modules/file-loader/dist/cjs.js?name=LICENSE!./LICENSE
/* harmony default export */ var cjsname_LICENSE_LICENSE = (__webpack_require__.p + "LICENSE");
// CONCATENATED MODULE: ./lib/constants/urlHashes.js
const RES_DISABLED_HASH = '#res:disabled';
const RES_SETTINGS_HASH = '#res:settings';
const RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH = '#res:settings-redirect-standalone-options-page';
const RES_NER_PAGE_HASH = '#res:ner-page';
// EXTERNAL MODULE: ./node_modules/lodash/fp/once.js
var once = __webpack_require__(116);
var once_default = /*#__PURE__*/__webpack_require__.n(once);

// EXTERNAL MODULE: ./node_modules/lodash/once.js
var lodash_once = __webpack_require__(1);
var lodash_once_default = /*#__PURE__*/__webpack_require__.n(lodash_once);

// CONCATENATED MODULE: ./lib/utils/time.js
const MINUTE = 1000 * 60;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
function fromSecondsToTime(timeInSeconds) {
  const minutes = Math.floor(timeInSeconds / 60) % 60;
  const hours = Math.floor(timeInSeconds / 3600);
  const time = [minutes, timeInSeconds % 60];

  if (hours > 0) {
    time.unshift(hours);
  }

  return time.map(part => String(part).padStart(2, '0')).join(':');
}
// EXTERNAL MODULE: ./node_modules/lodash/memoize.js
var memoize = __webpack_require__(2);
var memoize_default = /*#__PURE__*/__webpack_require__.n(memoize);

// EXTERNAL MODULE: ./node_modules/lodash/partition.js
var partition = __webpack_require__(76);
var partition_default = /*#__PURE__*/__webpack_require__.n(partition);

// EXTERNAL MODULE: ./node_modules/lodash/assignIn.js
var assignIn = __webpack_require__(117);
var assignIn_default = /*#__PURE__*/__webpack_require__.n(assignIn);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(118);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./lib/utils/flow.js
function downcast(val, ty) {
  return val;
}
// CONCATENATED MODULE: ./lib/utils/dom.js





function waitForEvent(ele, ...events) {
  return Promise.race(events.map(event => new Promise(resolve => ele.addEventListener(event, function fire(e) {
    ele.removeEventListener(event, fire);
    resolve(e);
  }))));
}
function waitForChild(ele, selector) {
  return new Promise(resolve => {
    const child = Array.from(ele.children).find(child => child.matches(selector));

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
            observer.disconnect();
            resolve(downcast(node, HTMLElement));
            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true
    });
  });
}
function watchForChildren(ele, selector, callback) {
  for (const child of Array.from(ele.children).filter(child => child.matches(selector))) {
    callback(child);
  }

  watchForFutureChildren(ele, selector, callback);
}
function watchForFutureChildren(ele, selector, callback) {
  new MutationObserver(mutations => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
          callback(downcast(node, HTMLElement));
        }
      }
    }
  }).observe(ele, {
    childList: true
  });
}
function waitForDescendant(ele, selector) {
  return new Promise(resolve => {
    const child = ele.querySelector(selector);

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const child = ele.querySelector(selector);

            if (child) {
              observer.disconnect();
              resolve(child);
            }

            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForFutureDescendant(ele, selector, {
  added = false,
  removed = false
} = {
  added: true,
  removed: false
}) {
  return new Promise(resolve => {
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of [...(added ? mutation.addedNodes : []), ...(removed ? mutation.removedNodes : [])]) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const child = ele.querySelector(selector);

            if (child) {
              observer.disconnect();
              resolve(child);
            }

            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForAttach(parent, el, cancel) {
  if (parent.contains(el)) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(() => {
      if (parent.contains(el)) resolve();
    });
    observer.observe(parent, {
      subtree: true,
      childList: true
    });
    if (cancel) cancel.then(() => {
      observer.disconnect();
      reject(new Error('Canceled'));
    });
  });
}
function waitForDetach(el, cancel) {
  const parent = document.documentElement;
  if (!parent.contains(el)) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(() => {
      if (!parent.contains(el)) resolve();
    });
    observer.observe(parent, {
      subtree: true,
      childList: true
    });
    if (cancel) cancel.then(() => {
      observer.disconnect();
      reject(new Error('Canceled'));
    });
  });
}
function watchForDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  for (const child of ele.querySelectorAll(selector)) {
    callback(child);
  }

  watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches);
}
function watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  new MutationObserver(mutations => {
    const children = new Set();

    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.matches(selector)) {
            children.add(node);
            if (ignoreChildrenIfAddedNodeMatches) continue;
          }

          for (const child of node.querySelectorAll(selector)) {
            children.add(child);
          }
        }
      }
    }

    for (const child of children) {
      callback(downcast(child, HTMLElement));
    }
  }).observe(ele, {
    childList: true,
    subtree: true
  });
}
function empty(parent) {
  while (parent.lastChild) parent.removeChild(parent.lastChild);

  return parent;
}
function click(obj, button = 0) {
  obj.dispatchEvent(new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    detail: 0,
    screenX: 1,
    screenY: 1,
    clientX: 1,
    clientY: 1,
    button
  }));
}

click.isProgrammaticEvent = e => e.clientX === 1 && e.clientY === 1;

const getViewportSize = memoize_default()(() => {
  waitForEvent(window, 'resize').then(() => {
    getViewportSize.cache.clear();
  });
  let visualViewport;

  if (window.visualViewport) {
    visualViewport = window.visualViewport;
  } else {
    const viewportSizedElement = document.createElement('div');
    viewportSizedElement.style.width = viewportSizedElement.style.height = '100%';
    viewportSizedElement.style.position = 'fixed';
    document.body.appendChild(viewportSizedElement);
    visualViewport = viewportSizedElement.getBoundingClientRect();

    if (!visualViewport.height || !visualViewport.width) {
      visualViewport = document.documentElement.getBoundingClientRect();
    }

    viewportSizedElement.remove();
  }

  return pick_default()(visualViewport, ['height', 'width']);
});
function elementInViewport(ele) {
  if (!ele || !ele.offsetParent) return false;
  const {
    top,
    left,
    bottom,
    right
  } = ele.getBoundingClientRect();
  return top >= 0 && left >= 0 && bottom <= getViewportSize().height && right <= getViewportSize().width;
}

function getViewportDimensions() {
  const headerOffset = getHeaderOffset();
  const left = window.pageXOffset;
  const top = window.pageYOffset + headerOffset;
  const width = getViewportSize().width;
  const height = getViewportSize().height - headerOffset;
  return {
    yOffset: headerOffset,
    left,
    top,
    bottom: top + height,
    right: left + width,
    width,
    height
  };
}

function getPercentageVisibleYAxis(obj) {
  const rect = obj.getBoundingClientRect();
  const top = Math.max(0, rect.bottom - rect.height);
  const bottom = Math.min(getViewportSize().height, rect.bottom);

  if (rect.height === 0) {
    return 0;
  }

  return Math.max(0, (bottom - top) / rect.height);
}

const padBottom = lodash_once_default()(() => {
  const element = document.createElement('div');
  element.style.clear = 'both';
  return (scrollTop, viewportHeight) => {
    const currentPadding = element.clientHeight;
    const paddingRequired = 50 + -(document.documentElement.scrollHeight - scrollTop - viewportHeight - currentPadding);
    if (paddingRequired > 0) document.body.append(element);else element.remove();
    element.style.height = `${paddingRequired}px`;
  };
});

let recentScroll = false;
let scrollInvokationToken;
function scrollToElement(to, from, {
  scrollStyle,
  restrictDirectionTo,
  direction: selectedDirection,
  anchor,
  waitTillVisible
}) {
  const _scrollInvokationToken = scrollInvokationToken = {};

  if (waitTillVisible && !to.offsetParent) {
    return new Promise(res => {
      requestAnimationFrame(() => {
        if (scrollInvokationToken !== _scrollInvokationToken) return;
        (scrollToElement(...arguments) || Promise.resolve()).then(res);
      });
    });
  }

  if (scrollStyle === 'none' && !anchor) {
    return;
  }

  if (!to.offsetParent) {
    console.error('Element is not visible.');
    return;
  }

  if (scrollStyle === 'none' && anchor) {
    const diff = to.getBoundingClientRect().top - anchor.to;
    if (diff) window.scrollBy(0, diff);
  }

  const viewport = getViewportDimensions();

  const target = assignIn_default()({}, to.getBoundingClientRect());

  target.top -= viewport.yOffset;
  target.bottom -= viewport.yOffset;
  const top = viewport.top + target.top - 5;

  if (scrollStyle === 'middle' && target.height >= viewport.height) {
    scrollStyle = 'top';
  }

  let compensateHeader = true;
  let scrollY;

  if (scrollStyle === 'top') {
    padBottom()(top, viewport.height);
    scrollY = top;
  } else if (from && scrollStyle === 'adopt') {
    const fromTop = anchor && typeof anchor.from === 'number' ? anchor.from : from.getBoundingClientRect().top;
    let diff = to.getBoundingClientRect().top - fromTop;

    if (fromTop < 0) {
      diff += fromTop;
    } else if (fromTop > viewport.height - 60) {
      diff += fromTop - viewport.height + 60;
    }

    scrollY = window.scrollY + diff;
    compensateHeader = false;
  } else if (scrollStyle === 'middle') {
    const buffer = (viewport.height - target.height) / 2;
    const newScrollY = top - buffer;

    if (elementInViewport(to)) {
      const viewportDirection = newScrollY >= window.scrollY ? 'down' : 'up';
      if (viewportDirection !== selectedDirection) return;
    }

    scrollY = newScrollY;
  } else if (target.top >= 0 && target.bottom <= viewport.height) {} else if (scrollStyle === 'legacy') {
    scrollY = top;
  } else if (target.top < viewport.yOffset) {
    scrollY = top;
  } else if (viewport.height < target.bottom && target.height < viewport.height) {
    if (scrollStyle === 'page') {
      scrollY = top;
    } else {
      scrollY = viewport.top + target.bottom - viewport.height;
    }
  } else {
    scrollY = top;
  }

  if (scrollY !== undefined) {
    if (compensateHeader) scrollY -= getHeaderOffset();
    const scollDirection = scrollY > viewport.top ? 'down' : 'up';
    if (viewport.top === scrollY || restrictDirectionTo && restrictDirectionTo !== scollDirection) return;
    window.scrollTo(0, scrollY);
    recentScroll = true;
    waitForEvent(window, 'scroll').then(() => {
      recentScroll = false;
    });
  }
}

scrollToElement.isProgrammaticEvent = () => recentScroll;

const dom_headerIds = {
  fullWidth: [],
  partialWidth: []
};
function _addHeaderId(elementId, partialWidth = false) {
  dom_headerIds[partialWidth ? 'partialWidth' : 'fullWidth'].push(elementId);
}
const getHeaderOffset = memoize_default()((includePartialWidthHeaders = false) => {
  const headers = [...dom_headerIds.fullWidth, ...(includePartialWidthHeaders ? dom_headerIds.partialWidth : [])];
  return headers.map(id => document.getElementById(id)).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
});
const getD2xBodyOffset = memoize_default()(() => {
  try {
    return document.getElementById('2x-container').offsetTop;
  } catch (e) {
    return 65;
  }
});
function addCSS(css) {
  let style = addStyle(css);
  return {
    remove() {
      if (!style) return;
      style.remove();
      style.textContent = '';
      style = undefined;
    }

  };
}

function addStyle(css) {
  const style = document.createElement('style');
  style.textContent = css;
  (document.head || document.documentElement).appendChild(style);
  return style;
}

const preventCloning = (() => {
  if (typeof window === 'undefined') return e => e;
  const attribute = `res-prevent-cloning-${Date.now()}`;
  const elements = new WeakSet();
  waitForEvent(window, 'DOMContentLoaded', 'load').then(() => {
    watchForFutureDescendants(document.body, `[${attribute}]`, e => {
      if (!elements.has(e)) e.remove();
    });
  });
  return element => {
    element.setAttribute(attribute, '');
    elements.add(element);
    return element;
  };
})();
// CONCATENATED MODULE: ./lib/utils/location.js




function matchesPageLocation(includes, excludes = []) {
  const [includeStrings, includeRegExps] = partition_default()(includes, x => typeof x === 'string');

  const [excludeStrings, excludeRegExps] = partition_default()(excludes, x => typeof x === 'string');

  return (!excludes.length || !(isPageType(...excludeStrings) || isAppType(...excludeStrings) || matchesPageRegex(...excludeRegExps))) && (!includes.length || isPageType(...includeStrings) || isAppType(...includeStrings) || matchesPageRegex(...includeRegExps));
}
const regexes = {
  frontpage: /^\/(?:hot|new|rising|controversial|top)?(?:\/|$)/i,
  comments: /^\/(?:r\/([\w\.]+)\/|(u(?:ser)?\/[\w-]+)\/)?comments\/([a-z0-9]+)(?:\/|$)/i,
  commentsLinklist: /^\/(r\/[\w\.\+]+\/|u(?:ser)?\/[\w-]+\/)?comments\/?$/i,
  inbox: /^\/(?:r\/([\w\.]+)\/)?message(?:\/|$)/i,
  profile: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profile2x: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profileCommentsPage: /^\/user\/([\w\-]+)\/comments\/([a-z0-9]+)(?:\/|$)/i,
  submit: /^\/(?:r\/([\w\.\+]+)\/)?submit(?:\/|$)/i,
  prefs: /^\/prefs(?:\/|$)/i,
  account: /^\/account-activity(?:\/|$)/i,
  wiki: /^\/(?:r\/([\w\.]+)\/)?wiki(?:\/|$)/i,
  stylesheet: /^\/(?:r\/([\w\.]+)\/)about\/stylesheet(?:\/|$)/i,
  search: /^\/(?:r\/[\w\.\+]+\/|(?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+\/|domain\/[^\/]+\/)?search(?:\/|$)/i,
  commentPermalink: /^\/(?:r\/([\w\.]+)\/)?comments\/([a-z0-9]+)\/[^\/]*\/([a-z0-9]+)(?:\/|$)/i,
  duplicates: /^\/r\/[\w\.\+]+\/duplicates\/([a-z0-9]+)/i,
  subreddit: /^\/r\/([\w\.\+]+)(?:\/|$)/i,
  subredditAbout: /^\/r\/([\w\.]+)\/about(?:\/(?!modqueue|reports|spam|unmoderated|edited)|$)/i,
  modqueue: /^\/(?:r|me\/f)\/([\w\.\+]+)\/about\/(?:modqueue|reports|spam|unmoderated|edited)(?:\/|$)/i,
  multireddit: /^\/((?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+)(?:\/|$)/i,
  domain: /^\/domain\/([\w\.]+)(?:\/|$)/i,
  composeMessage: /^\/(?:r\/([\w\.\+]+)\/)?message\/compose(?:\/|$)/i,
  liveThread: /^\/live\/(?!create(?:\/|$))([a-z0-9]+)(?:\/|$)/i
};
const execRegexes = {
  comments: path => {
    const match = regexes.comments.exec(path);
    if (!match) return match;
    match.splice(1, 2, match[1] || match[2] && match[2].replace(/^u.*\//, 'u_'));
    return match;
  }
};
const appType = lodash_once_default()(() => {
  if (document.documentElement.hasAttribute('res-options')) {
    return 'options';
  }

  if (document.documentElement.getAttribute('xmlns')) {
    return 'r2';
  }

  return 'd2x';
});
function isAppType(...types) {
  const thisApp = appType();
  return types.some(type => type === thisApp);
}
const appPageTypes = {
  r2: {
    default: 'linklist',
    pageTypes: ['wiki', 'search', 'stylesheet', 'modqueue', 'subredditAbout', 'comments', 'commentsLinklist', 'profile', 'liveThread', 'inbox', 'submit', 'account', 'prefs']
  },
  d2x: {
    pageTypes: ['profile2x', 'profileCommentsPage', 'submit']
  },
  options: {
    pageTypes: []
  }
};
const pageType = memoize_default()(() => {
  waitForEvent(document, 'reddit.urlChanged').then(() => {
    pageType.cache.clear();
  });
  const spec = appPageTypes[appType()];
  return spec.pageTypes.find(pageType => regexes[pageType].test(location.pathname)) || spec.default;
});
function isPageType(...types) {
  const thisPage = pageType();
  return types.some(type => type === thisPage);
}
function matchesPageRegex(...regexps) {
  return regexps.some(regex => regex.test(location.pathname));
}
const currentSubreddit = lodash_once_default()(() => {
  const match = location.pathname.match(regexes.subreddit);
  if (match) return match[1];
});
function isCurrentSubreddit(...subreddits) {
  const sub = (currentSubreddit() || '').toLowerCase();
  if (!sub) return false;
  return subreddits.some(v => v.toLowerCase() === sub);
}
const currentMultireddit = lodash_once_default()(() => {
  const match = location.pathname.match(regexes.multireddit);
  if (match) return match[1];
});
function isCurrentMultireddit(...multireddits) {
  const multi = (currentMultireddit() || '').toLowerCase();
  if (!multi) return false;
  return multireddits.some(v => v.toLowerCase() === multi);
}
const currentDomain = lodash_once_default()(() => {
  const match = location.pathname.match(regexes.domain);
  if (match) return match[1];
});
const currentUserProfile = lodash_once_default()(() => {
  const match = location.pathname.match(regexes.profile);
  if (match) return match[1];
});
const fullLocation = (pathname = location.pathname) => {
  const regex = Object.keys(regexes).find(key => pathname.match(regexes[key]));
  if (!regex) return pathname.toLowerCase();
  return [regex, ...(pathname.match(regexes[regex]) || []).slice(1)].filter(v => v).join('-').toLowerCase();
};
const COMMENT_CODE_REGEX = /^[\/#].+$/;
function isCommentCode(link) {
  const href = link.getAttribute('href');
  const emptyText = link.textContent.length === 0;
  const isCommentCode = COMMENT_CODE_REGEX.test(href);
  return emptyText && isCommentCode;
}
function isEmptyLink(link) {
  const href = link.getAttribute('href');
  return typeof href !== 'string' || href.startsWith('javascript:') || href === '#';
}
const inQuarantinedSubreddit = lodash_once_default()(() => document.body.classList.contains('quarantine'));
// EXTERNAL MODULE: ./node_modules/lodash/fp/flow.js
var flow = __webpack_require__(5);
var flow_default = /*#__PURE__*/__webpack_require__.n(flow);

// EXTERNAL MODULE: ./node_modules/lodash/zipWith.js
var zipWith = __webpack_require__(25);
var zipWith_default = /*#__PURE__*/__webpack_require__.n(zipWith);

// EXTERNAL MODULE: ./node_modules/fast-levenshtein/levenshtein.js
var levenshtein = __webpack_require__(119);
var levenshtein_default = /*#__PURE__*/__webpack_require__.n(levenshtein);

// CONCATENATED MODULE: ./lib/utils/html.js
const escapeLookups = {
  '&': '&amp;',
  '"': '&quot;',
  "'": '&apos;',
  '<': '&lt;',
  '>': '&gt;',
  '/': '&#47;'
};
function escapeHTML(str) {
  return str ? str.toString().replace(/[&"'<>\/]/g, m => escapeLookups[m]) : '';
}
// CONCATENATED MODULE: ./lib/utils/string.js






function stringTagFunction(valueTransform) {
  return (strings, ...values) => zipWith_default()(strings, values.map(valueTransform), (s, v) => `${s}${v === undefined ? '' : v}`).join('');
}

const encode = stringTagFunction(encodeURIComponent);
const string_escape = stringTagFunction(escapeHTML);
function safe(str) {
  return {
    __safe__: str
  };
}
const MAX_DISTANCE_RATIO = 0.05;
function areSimilar(a, b) {
  return levenshtein_default.a.get(a, b) <= MAX_DISTANCE_RATIO * Math.max(a.length, b.length);
}
const regexRegex = /^\/(.*)\/([gimu]+)?$/;
const htmlTagFunction = stringTagFunction(x => {
  if (typeof x === 'number') return String(x);
  if (!x) return '';
  if (typeof x === 'string') return escapeHTML(x);
  if (Array.isArray(x)) return x.filter(s => s && typeof s.__safe__ === 'string').map(s => s.__safe__).join('');
  if (x.hasOwnProperty('__safe__')) return x.__safe__;
  throw new TypeError(`Invalid html template interpolation: ${String(x)}`);
});
const string_html = flow_default()(htmlTagFunction, markup => {
  const template = document.createElement('div');
  template.innerHTML = markup;

  if (template.childElementCount !== 1) {
    throw new Error(`Html template should have exactly one root node, but had ${template.childElementCount}`);
  }

  const child = downcast(template.firstElementChild, HTMLElement);
  child.remove();
  return child;
});
const _html = flow_default()(htmlTagFunction, safe);
// CONCATENATED MODULE: ./lib/utils/user.js





const isLoggedIn = lodash_once_default()(() => {
  if (loggedInUser()) {
    return true;
  } else if (document.querySelector('header a[href^="/message/inbox"]')) {
    return true;
  }
});
const loggedInUser = lodash_once_default()(() => documentLoggedInUser(document));
const documentLoggedInUser = document => {
  if (isAppType('d2x')) {
    const findFirstTextNode = e => [...e.childNodes].filter(v => v.nodeType === 3).concat(...[...e.children].map(findFirstTextNode));

    const button = document.querySelector('#USER_DROPDOWN_ID > *');
    const username = button && findFirstTextNode(button)[0];
    return username && username.textContent;
  }

  const link = document.querySelector('#header-bottom-right > span.user > a');
  if (!link || link.classList.contains('login-required')) return;
  const profile = regexes.profile.exec(link.pathname);

  if (profile) {
    return profile[1];
  }
};
const isModeratorAnywhere = lodash_once_default()(() => !!document.getElementById('modmail'));
const loggedInUserHash = lodash_once_default()(async () => {
  const hashEle = document.querySelector('[name=uh]');

  if (hashEle instanceof HTMLInputElement) {
    return hashEle.value;
  }

  const userInfo = await loggedInUserInfo();
  return userInfo && userInfo.data && userInfo.data.modhash;
});
const loggedInUserInfo = lodash_once_default()(() => !isLoggedIn() ? Promise.resolve() : ajax({
  url: '/api/me.json',
  type: 'json'
}).then(data => data.data && data.data.modhash ? data : undefined));
const usernameRE = /(?:u|user)\/([\w\-]{3,20}(?![\w\-]))/;
const usernameSelector = ['.contents .author', 'p.tagline a.author', '#friend-table span.user a', '.sidecontentbox .author', 'div.md a[href^="/u/"]:not([href*="/m/"])', 'div.md a[href*="reddit.com/u/"]:not([href*="/m/"])', '.usertable a.author', '.parent > a.author', '.usertable span.user a', 'div.wiki-page-content .author', '.Post__authorLink'].join(', ');
function getUsernameFromLink(element) {
  if (!(element instanceof HTMLAnchorElement)) return;
  const {
    href,
    origin
  } = element;
  if (!location.origin.endsWith(origin.split('.').slice(-2).join('.'))) return;
  const [, username] = href.match(usernameRE) || [];
  if (username) return username;
}
function getUserInfo(username = loggedInUser()) {
  if (!username) {
    return Promise.reject(new Error('getUserInfo: null/undefined username'));
  }

  return ajax({
    url: encode`/user/${username}/about.json`,
    type: 'json',
    cacheFor: 10 * MINUTE
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/context.js


const context_data = {
  userHash: null,
  username: null,
  origin: 'https://www.reddit.com',
  pathname: location.pathname
};
function establish(contentStart) {
  if (!location.protocol.startsWith('http')) return;
  context_data.origin = location.origin;
  contentStart.then(() => {
    context_data.username = loggedInUser();
    loggedInUserHash().then(hash => {
      context_data.userHash = hash;
    });
  });
}
function retrieveFromParent() {
  if (window === window.parent) return Promise.resolve();
  return waitForEvent(window, 'message').then(({
    data: {
      context
    }
  }) => {
    Object.assign(context_data, context);
  });
}
// CONCATENATED MODULE: ./lib/environment/utils/messaging.js
class MessageHandlerError extends Error {
  constructor(message, stack) {
    super();
    this.message = message;
    this.stack = stack;
  }

}

function createMessageHandler(_sendMessage, errorOnUnrecognizedTypes = false) {
  const listeners = new Map();
  return {
    _handleMessage: function ({
      type,
      data
    }, sendResponse, context) {
      const listener = listeners.get(type);

      if (!listener) {
        if (errorOnUnrecognizedTypes) {
          sendResponse({
            error: {
              message: `Unrecognised message type: ${type}`,
              stack: ''
            }
          });
        }

        return false;
      }

      let response;

      try {
        response = listener(data, context);
      } catch (e) {
        console.error(e);
        sendResponse({
          error: {
            message: e.message,
            stack: e.stack
          }
        });
        return false;
      }

      if (response instanceof Promise) {
        response.then(data => sendResponse({
          data
        }), e => {
          console.error(e);
          sendResponse({
            error: {
              message: e.message,
              stack: e.stack
            }
          });
        });
        return true;
      } else {
        sendResponse({
          data: response
        });
        return false;
      }
    },
    sendMessage: async function (type, data, context) {
      const {
        data: newData,
        error
      } = await _sendMessage({
        type,
        data
      }, context);

      if (error) {
        throw new MessageHandlerError(error.message, `${error.stack}\n    at target's "${type}" handler`);
      } else {
        return newData;
      }
    },
    addListener: function (type, callback) {
      if (listeners.has(type)) {
        throw new Error(`Listener for "${type}" already exists.`);
      }

      listeners.set(type, callback);
    }
  };
}
// CONCATENATED MODULE: ./lib/environment/utils/api.js
function apiToPromise(func) {
  return (...args) => new Promise((resolve, reject) => func(...args, (...results) => {
    if (chrome.runtime.lastError) {
      reject(new Error(chrome.runtime.lastError.message));
    } else {
      resolve(results.length > 1 ? results : results[0]);
    }
  }));
}
// CONCATENATED MODULE: ./lib/environment/foreground/messaging.js



const _sendMessage = apiToPromise(chrome.runtime.sendMessage);

const {
  _handleMessage,
  sendMessage,
  addListener
} = createMessageHandler(obj => _sendMessage(obj));
chrome.runtime.onMessage.addListener((obj, sender, sendResponse) => _handleMessage(obj, sendResponse));

// CONCATENATED MODULE: ./lib/environment/foreground/privateBrowsing.js
function isPrivateBrowsing() {
  return chrome.extension.inIncognitoContext;
}
// CONCATENATED MODULE: ./lib/environment/foreground/history.js


async function addURLToHistory(url) {
  if (isPrivateBrowsing()) return;
  await sendMessage('addURLToHistory', url);
}
function isURLVisited(url) {
  return sendMessage('isURLVisited', url);
}
// EXTERNAL MODULE: ./node_modules/lodash/fromPairs.js
var fromPairs = __webpack_require__(120);
var fromPairs_default = /*#__PURE__*/__webpack_require__.n(fromPairs);

// CONCATENATED MODULE: ./lib/environment/foreground/xhrCache.js

function set(key, value) {
  return sendMessage('XHRCache', ['set', key, value]);
}
function xhrCache_check(key, maxAge) {
  return sendMessage('XHRCache', ['check', key, maxAge]);
}

function delete_(key) {
  return sendMessage('XHRCache', ['delete', key]);
}


function clear() {
  return sendMessage('XHRCache', ['clear']);
}
// CONCATENATED MODULE: ./lib/environment/foreground/ajax.js





class FetchError extends Error {
  constructor(url, status) {
    super(`${url} failed with status ${status}`);
    this.status = void 0;
    this.status = status;
  }

}

async function ajax(options) {
  const {
    method,
    url,
    headers,
    data,
    type,
    cacheFor,
    sameOrigin,
    credentials
  } = buildRequestParams(options);

  if (cacheFor) {
    const cached = await xhrCache_check(url, cacheFor);

    if (cached) {
      return processResponse(cached, type);
    }
  }

  const response = await (sameOrigin ? fetch(url, {
    method,
    headers,
    credentials,
    body: data
  }).then(async r => ({
    ok: r.ok,
    status: r.status,
    headers: fromPairs_default()(Array.from(r.headers.entries())),
    text: await r.text()
  })) : sendMessage('ajax', {
    method,
    url,
    headers,
    data,
    credentials
  }));

  if (!response.ok) {
    throw new FetchError(url, response.status);
  }

  if (cacheFor) {
    set(url, response);
  }

  return processResponse(response, type);
}

ajax.invalidate = options => delete_(buildRequestParams(options).url);

function buildRequestParams({
  method = 'GET',
  url,
  query = {},
  headers = {},
  data,
  type = 'text',
  credentials,
  cacheFor = 0
}) {
  const siteOrigin = new URL(context_data.origin);
  const requestURL = new URL(url, siteOrigin);

  for (const [key, val] of Object.entries(query)) {
    requestURL.searchParams.set(key, String(val));
  }

  const sameSite = requestURL.hostname.split('.').slice(-2).join('.') === siteOrigin.hostname.split('.').slice(-2).join('.');

  if (sameSite) {
    requestURL.searchParams.set('app', 'res');
    if (!credentials) credentials = 'include';

    if (method !== 'GET' && method !== 'HEAD') {
      if (context_data.userHash) headers['X-Modhash'] = context_data.userHash;
    }

    requestURL.hostname = requestURL.hostname.replace(/new\./, 'www.');
  }

  const sameOrigin = siteOrigin.origin === requestURL.origin;

  if (typeof data === 'object') {
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    data = new URLSearchParams(data).toString();
  }

  return {
    method,
    url: requestURL.href,
    headers,
    data,
    type,
    cacheFor,
    credentials: credentials || 'omit',
    sameOrigin
  };
}

function processResponse(response, type) {
  switch (type) {
    case 'text':
      return response.text;

    case 'json':
      return JSON.parse(response.text);

    case 'raw':
      return response;

    default:
      throw new Error(`Invalid type: ${type}`);
  }
}
// CONCATENATED MODULE: ./lib/environment/foreground/download.js

function download(url, filename) {
  sendMessage('download', {
    url: new URL(url, location.href).href,
    filename
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/id.js
function getExtensionId() {
  return chrome.runtime.id;
}
const getURL = chrome.runtime.getURL;
const getOptionsURL = (hash = '') => new URL(hash, getURL('options.html'));
const isOptionsPage = () => location.origin === getOptionsURL().origin;
// CONCATENATED MODULE: ./lib/constants/localStorage.js
const CACHED_LANG_KEY = 'RES.i18nCachedLang';
const CACHED_MESSAGES_KEY = 'RES.i18nCachedMessages';
const CACHED_MESSAGES_TOKEN_KEY = 'RES.i18nCachedMessagesToken';
// CONCATENATED MODULE: ./node_modules/exec-loader!./build/buildToken.js
/* harmony default export */ var buildToken = ("5.18.10");
// CONCATENATED MODULE: ./lib/environment/foreground/i18n.js



const REDDIT_LANGUAGES = new Set(['en', 'af', 'ar', 'be', 'bg', 'bn-IN', 'bn-bd', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en-us', 'eo', 'es', 'es-ar', 'es-mx', 'et', 'eu', 'fa', 'fi', 'fil', 'fr', 'fr-ca', 'fy-NL', 'ga-ie', 'gd', 'gl', 'he', 'hi', 'hr', 'hu', 'hy', 'id', 'is', 'it', 'ja', 'kn_IN', 'ko', 'la', 'leet', 'lol', 'lt', 'lv', 'ms', 'mt-MT', 'nl', 'nn', 'no', 'pir', 'pl', 'pt', 'pt-pt', 'pt_BR', 'ro', 'ru', 'sk', 'sl', 'sr', 'sr-la', 'sv', 'ta', 'th', 'tr', 'uk', 'vi', 'zh', 'zh-cn']);
const SPECIAL_LANGUAGES = new Set(['leet', 'lol', 'pir']);
let i18n_locale = navigator.language || 'en';

function isValidLocale(localeString) {
  try {
    return typeof 0 .toLocaleString(localeString) === 'string';
  } catch (e) {
    return false;
  }
}

function getRedditLocale() {
  const redditLocale = typeof document !== 'undefined' && document.documentElement.getAttribute('lang');

  if (redditLocale && REDDIT_LANGUAGES.has(redditLocale)) {
    const locale = redditLocale.toLowerCase().replace('_', '-');

    if (isValidLocale(locale)) {
      requestIdleCallback(() => {
        sendMessage('setLastRedditLocale', locale);
      });
      return locale;
    }
  }

  return sendMessage('getLastRedditLocale');
}

let messages;
async function _loadI18n() {
  const redditLocale = await getRedditLocale();
  if (redditLocale && !SPECIAL_LANGUAGES.has(redditLocale)) i18n_locale = redditLocale;

  if (localStorage.getItem(CACHED_LANG_KEY) === redditLocale && localStorage.getItem(CACHED_MESSAGES_TOKEN_KEY) === buildToken) {
    try {
      messages = JSON.parse(localStorage.getItem(CACHED_MESSAGES_KEY) || '');
      return;
    } catch (e) {
      console.error('Failed to parse cached i18n', e);
    }
  }

  messages = await sendMessage('i18n', redditLocale);

  try {
    localStorage.setItem(CACHED_MESSAGES_KEY, JSON.stringify(messages));
    localStorage.setItem(CACHED_LANG_KEY, redditLocale);
    localStorage.setItem(CACHED_MESSAGES_TOKEN_KEY, buildToken);
  } catch (e) {
    console.error('Could not cache i18n - RES will load VERY slowly', e);
    localStorage.removeItem('ads.adserverDownvotePixel');
    localStorage.removeItem('ads.adserverUpvotePixel');
  }
}
function i18n(messageName, ...substitutions) {
  if (!messageName) return '';

  if (!messages) {
    console.error('i18n called too early! key:', messageName);
    return messageName;
  }

  const message = messages[messageName];
  if (!message) return messageName;
  if (substitutions.length === 0) return message;
  return message.replace(/\$(\d)\b(?!\$)/g, (match, number) => substitutions[number - 1]);
}
// EXTERNAL MODULE: ./node_modules/lodash/pull.js
var pull = __webpack_require__(4);
var pull_default = /*#__PURE__*/__webpack_require__.n(pull);

// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(3);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./node_modules/lodash/curryRight.js
var curryRight = __webpack_require__(50);
var curryRight_default = /*#__PURE__*/__webpack_require__.n(curryRight);

// EXTERNAL MODULE: ./node_modules/lodash/remove.js
var lodash_remove = __webpack_require__(51);
var remove_default = /*#__PURE__*/__webpack_require__.n(lodash_remove);

// CONCATENATED MODULE: ./lib/utils/generator.js
function* range(start, end) {
  for (let i = start; i < end; ++i) {
    yield i;
  }
}
function* zip(...iterables) {
  const generators = iterables.map(it => it[Symbol.iterator]());
  let results;

  while ((results = generators.map(gen => gen.next())).some(r => !r.done)) {
    yield results.map(r => r.value);
  }
}
// CONCATENATED MODULE: ./lib/utils/async.js






function waitFor(callback, interval = 1) {
  return new Promise(resolve => {
    (function repeat() {
      const val = callback();

      if (!val) {
        setTimeout(repeat, interval);
        return;
      }

      resolve(val);
    })();
  });
}
const forEachChunked = (() => {
  const queues = [];
  const run = frameThrottle(() => {
    const start = performance.now();

    do {
      remove_default()(queues, ({
        generator,
        callback,
        resolve,
        reject
      }) => {
        const {
          value,
          done
        } = generator.next();

        if (done) {
          resolve();
          return true;
        }

        try {
          callback(value);
        } catch (e) {
          if (generator.return) generator.return();
          reject(e);
          return true;
        }
      });

      if (!queues.length) {
        return;
      }
    } while (performance.now() - start < 1000 / 30);

    run();
  });
  return curryRight_default()((collection, callback) => new Promise((resolve, reject) => {
    const iterable = Symbol.iterator in collection ? collection : Array.from(collection);
    queues.push({
      generator: iterable[Symbol.iterator](),
      callback,
      resolve,
      reject
    });
    run();
  }));
})();
function batch(callback, {
  size = 100,
  delay = 50,
  flushBeforeUnload = false
} = {}) {
  let invoke;

  function* batchAccumulator() {
    const entries = [];
    const promises = [];

    function addPromise() {
      if (entries.length) {
        return new Promise((resolve, reject) => {
          promises.push({
            resolve,
            reject
          });
        });
      } else {
        return undefined;
      }
    }

    invoke = lodash_once_default()(async () => {
      startNewBatch();
      if (!entries.length) return;

      try {
        const results = (await callback(entries)) || [];

        for (const [{
          resolve,
          reject
        }, result] of zip(promises, results)) {
          if (result instanceof Error) reject(result);else resolve(result);
        }
      } catch (e) {
        for (const {
          reject
        } of promises) {
          reject(e);
        }
      }
    });
    const timeout = delay ? debounce_default()(invoke, delay) : async_throttle(invoke);

    while (entries.length < size) {
      const entry = yield addPromise();
      if (entry === undefined) throw new Error('undefined passed into batch generator');
      entries.push(entry);
      timeout();
    }

    const lastPromise = addPromise();
    invoke();
    yield lastPromise;
  }

  let currentBatch;

  function startNewBatch() {
    currentBatch = batchAccumulator();
    currentBatch.next();
  }

  startNewBatch();
  if (flushBeforeUnload) window.addEventListener('beforeunload', () => {
    invoke();
  }, true);
  return entry => {
    const {
      value
    } = currentBatch.next(entry);
    if (value === undefined) throw new Error('Batch generator was not replaced after completion');
    return value;
  };
}

function always(promise, callback) {
  return promise.then(callback, callback);
}

function fastAsync(callback) {
  return function (...args) {
    return function next(generator, arg, throwing) {
      const {
        value,
        done
      } = !throwing ? generator.next(arg) : generator.throw(arg);

      if (done) {
        return value;
      } else if (!(value instanceof Promise)) {
        return next(generator, value, false);
      } else {
        return value.then(val => next(generator, val, false), err => next(generator, err, true));
      }
    }(Reflect.apply(callback, this, args), undefined, false);
  };
}
function asyncFlow(firstFn, ...fns) {
  return fastAsync(function* (...args) {
    let accum = firstFn(...args);

    for (const fn of fns) {
      accum = fn((yield accum));
    }

    return accum;
  });
}
function reifyPromise(promise) {
  let val = promise;
  promise.then(x => {
    val = x;
  });
  return {
    get: () => val
  };
}
function keyedMutex(callback, keyResolver = x => x) {
  const queues = new Map();
  return function (...args) {
    const key = keyResolver(...args);
    const tail = queues.has(key) ? always(queues.get(key), () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queues.set(key, tail);
      always(tail, () => {
        if (queues.get(key) === tail) queues.delete(key);
      });
    }

    return tail;
  };
}
function mutex(callback) {
  let queue;
  return function (...args) {
    const tail = queue ? always(queue, () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queue = tail;
      always(tail, () => {
        if (queue === tail) queue = undefined;
      });
    }

    return tail;
  };
}
function async_throttle(callback) {
  let promise;
  return () => {
    promise = promise || Promise.resolve().then(() => {
      promise = null;
      callback();
    });
    return promise;
  };
}
function frameDebounce(callback, debounce = 1) {
  let remaining;
  const update = frameThrottle(() => {
    if (remaining) requestAnimationFrame(() => {
      update();
    });else callback();
    remaining -= 1;
  });
  return () => {
    remaining = debounce;
    requestAnimationFrame(() => {
      update();
    });
  };
}
function frameThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestAnimationFrame(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}
const throttleQueuePositionReset = (() => {
  let queues = [];
  const run = async_throttle(() => {
    for (const fn of queues) {
      try {
        fn();
      } catch (e) {}
    }

    queues = [];
  });
  return function (callback) {
    let queued = false;
    return (...a) => {
      if (queued) {
        pull_default()(queues, callback);
      } else {
        queued = true;
      }

      queues.push(callback);
      run();
    };
  };
})();
function idleThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestIdleCallback(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}
// CONCATENATED MODULE: ./lib/environment/foreground/permissions.js




function filterPerms(perms) {
  const permissions = perms.filter(p => !p.includes('://') && p !== '<all_urls>');
  const origins = perms.filter(p => p.includes('://') || p === '<all_urls>');
  return {
    permissions,
    origins
  };
}

const permissions_has = memoize_default()(perms => sendMessage('permissions', {
  operation: 'contains',
  ...filterPerms(perms)
}), perms => perms.join(','));
const request = mutex(async perms => {
  if (await permissions_has(perms)) return;
  const {
    permissions,
    origins
  } = filterPerms(perms);
  const granted = await sendMessage('permissions', {
    operation: 'request',
    permissions,
    origins
  });

  if (granted) {
    permissions_has.cache.set(perms.join(','), true);
  } else {
    throw new Error(`Permission not granted for: ${perms.join(', ')}`);
  }
});
// CONCATENATED MODULE: ./lib/environment/foreground/auth.js


async function launchAuthFlow({
  domain,
  clientId,
  scope = '',
  permissions
}, warnUserInteraction) {
  if (permissions.length && !(await permissions_has(permissions))) {
    const resAuth = 'https://redditenhancementsuite.com/oauth';

    if ( true && !(await permissions_has([resAuth]))) {
      permissions.push(resAuth);
    }

    await warnUserInteraction(permissions.includes(resAuth) ? 'You may be redirected to redditenhancementsuite.com to complete the login process.' : '');
    await request(permissions);
  }

  let responseUrl;

  try {
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: false
    });
  } catch (e) {
    console.error('Noninteractive auth failed:', e);
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: true
    });
  }

  const hash = new URL(responseUrl).hash.slice(1);
  const token = new URLSearchParams(hash).get('access_token');
  if (!token) throw new Error('No token found in response.');
  return token;
}
// CONCATENATED MODULE: ./lib/environment/foreground/multicast.js

const callbacks = new Map();
addListener('multicast', ({
  name,
  args
}) => {
  const callback = callbacks.get(name);
  if (callback) return callback(...args);
});
function multicast(callback, {
  name,
  local = true,
  crossContext = true
}) {
  if (callbacks.has(name)) {
    throw new Error(`Multicast handler with name "${name}" exists.`);
  }

  callbacks.set(name, callback);

  function localOnly(...args) {
    callback(...args);
  }

  const invoke = (...args) => {
    sendMessage('multicast', {
      name,
      args,
      crossContext
    });

    if (local) {
      localOnly(...args);
    }
  };

  invoke.local = localOnly;
  return invoke;
}
// CONCATENATED MODULE: ./lib/environment/foreground/tabs.js

function openNewTab(url, focus = true) {
  return openNewTabs(focus, url);
}
function openNewTabs(focus, ...urls) {
  let focusIndex;
  if (typeof focus !== 'string') focus = !!focus;

  switch (focus) {
    case 'first':
      focusIndex = 0;
      break;

    case true:
    case 'last':
      focusIndex = urls.length - 1;
      break;

    case false:
    case 'none':
      focusIndex = -1;
      break;

    default:
      throw new Error(`Invalid focus specified: ${focus}`);
  }

  urls = urls.map(url => new URL(url, location.href).href);
  return sendMessage('openNewTabs', {
    urls,
    focusIndex
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/pageAction.js


const clickListeners = [];
function pageAction_onClick(callback) {
  clickListeners.push(callback);
}
addListener('pageActionClick', () => {
  for (const fn of clickListeners) fn();
});
const pageAction_update = frameThrottle(value => sendMessage('pageAction', value));
function show(state = false) {
  return pageAction_update({
    operation: 'show',
    state
  });
}
function pageAction_hide() {
  return pageAction_update({
    operation: 'hide'
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/session.js

function get(key) {
  return sendMessage('session', ['get', key]);
}
function session_set(key, value) {
  return sendMessage('session', ['set', key, value]);
}
function session_delete_(key) {
  return sendMessage('session', ['delete', key]);
}

function session_has(key) {
  return sendMessage('session', ['has', key]);
}
function session_clear() {
  return sendMessage('session', ['clear']);
}
// EXTERNAL MODULE: ./node_modules/lodash/transform.js
var transform = __webpack_require__(30);
var transform_default = /*#__PURE__*/__webpack_require__.n(transform);

// CONCATENATED MODULE: ./lib/utils/object.js
function extendDeep(target, source) {
  for (const key of Object.keys(source)) {
    if (target[key] && source[key] && typeof target[key] === 'object' && typeof source[key] === 'object' && !Array.isArray(source[key]) && !Array.isArray(target[key])) {
      extendDeep(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }

  return target;
}
// CONCATENATED MODULE: ./lib/environment/foreground/storage.js







const __set = apiToPromise((items, callback) => chrome.storage.local.set(items, callback));

const _set = (key, value) => __set({
  [key]: value
});

const __get = apiToPromise((keys, callback) => chrome.storage.local.get(keys, callback));

const _get = async (key, defaultValue = null) => (await __get({
  [key]: defaultValue
}))[key];

const _delete = apiToPromise((keys, callback) => chrome.storage.local.remove(keys, callback));

const _clear = apiToPromise(callback => chrome.storage.local.clear(callback));

const withLockOn = keyedMutex((key, fn) => fn());
function storage_get(key) {
  return withLockOn(key, () => _get(key, null));
}
function getAll() {
  return __get(null);
}
function getMultiple(keys) {
  const defaults = {};

  for (const k of keys) {
    defaults[k] = null;
  }

  return __get(defaults);
}
function storage_set(key, value) {
  return withLockOn(key, () => _set(key, value));
}
function setMultiple(valueMap) {
  return __set(valueMap);
}

function compareAndSet(key, defaultValue, oldValue, newValue) {
  return sendMessage('storage-cas', [key, defaultValue, oldValue, newValue]);
}

function patch(key, value) {
  return withLockOn(key, async () => {
    const extended = extendDeep((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function patchShallow(key, value) {
  return withLockOn(key, async () => {
    const extended = Object.assign((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function deletePaths(key, paths) {
  return withLockOn(key, async () => {
    const stored = await _get(key);
    if (!stored) return;

    for (const path of paths) {
      path.reduce((obj, key, i, {
        length
      }) => {
        if (!obj) return;
        if (i < length - 1) return obj[key];
        delete obj[key];
      }, stored);
    }

    return _set(key, stored);
  });
}

function storage_delete_(key) {
  return withLockOn(key, () => _delete(key));
}


function deleteMultiple(keys) {
  return _delete(keys);
}
function storage_has(key) {
  return withLockOn(key, async () => {
    const sentinel = Math.random();
    return (await _get(key, sentinel)) !== sentinel;
  });
}
async function storage_keys() {
  return Object.keys((await __get(null)));
}
function storage_clear() {
  return _clear();
}

class Wrapper {
  constructor(key, def) {
    this._key = void 0;
    this._default = void 0;
    this._key = key;
    this._default = def;
  }

  get() {
    return storage_get(this._key()).then(val => val === null ? this._default : val);
  }

  set(value) {
    return storage_set(this._key(), value);
  }

  patch(value) {
    return patch(this._key(), value);
  }

  compareAndSet(oldValue, newValue) {
    return compareAndSet(this._key(), this._default, oldValue, newValue);
  }

  deletePath(...path) {
    return deletePaths(this._key(), [path]);
  }

  delete() {
    return storage_delete_(this._key());
  }

  has() {
    return storage_has(this._key());
  }

}

function wrap(key, defaultValue) {
  const keyGenerator = typeof key === 'string' ? () => key : lodash_once_default()(key);
  return new Wrapper(keyGenerator, defaultValue);
}

class storage_PrefixWrapper {
  constructor(prefix, def, keyMapper, batching) {
    this._prefix = void 0;
    this._keyMapper = void 0;
    this._default = void 0;
    this._get = void 0;
    this._prefix = prefix;
    this._default = def;
    this._keyMapper = keyMapper;

    if (batching) {
      this._get = batch(async keys => {
        const v = await this.getMultipleNullable(keys);
        return keys.map(key => v[this._keyMapper(key)]);
      }, {
        size: Infinity,
        delay: 0
      });
    } else {
      this._get = key => storage_get(this._keyGen(key));
    }
  }

  _keyGen(key) {
    return this._prefix + this._keyMapper(key);
  }

  get(key) {
    return this._get(key).then(val => val === null ? this._default() : val);
  }

  getNullable(key) {
    return this._get(key);
  }

  async getAll() {
    const everything = await getAll();
    return transform_default()(everything, (acc, v, k) => {
      if (k.startsWith(this._prefix)) {
        acc[k.slice(this._prefix.length)] = v;
      }
    }, {});
  }

  async getMultiple(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return transform_default()(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v === null ? this._default() : v;
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return transform_default()(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v;
    }, {});
  }

  set(key, value) {
    return storage_set(this._keyGen(key), value);
  }

  patch(key, value) {
    return patch(this._keyGen(key), value);
  }

  deletePath(key, ...path) {
    return deletePaths(this._keyGen(key), [path]);
  }

  delete(key) {
    return storage_delete_(this._keyGen(key));
  }

  deleteMultiple(keys) {
    return deleteMultiple(keys.map(k => this._keyGen(k)));
  }

  has(key) {
    return storage_has(this._keyGen(key));
  }

}

function wrapPrefix(prefix, defaultValue, destructiveKeyMapper = x => x, batching = false) {
  return new storage_PrefixWrapper(prefix, defaultValue, destructiveKeyMapper, batching);
}

class storage_BlobWrapper {
  constructor(rootKey, def) {
    this._rootKey = void 0;
    this._default = void 0;
    this._rootKey = rootKey;
    this._default = def;
  }

  get(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? this._default() : val[key]);
  }

  getNullable(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? null : val[key]);
  }

  getAll() {
    return storage_get(this._rootKey).then(val => val === null ? {} : val);
  }

  async getMultiple(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return transform_default()(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? this._default() : rawValues[key];
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return transform_default()(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? null : rawValues[key];
    }, {});
  }

  set(key, value) {
    return patchShallow(this._rootKey, {
      [key]: value
    });
  }

  patch(key, value) {
    return patch(this._rootKey, {
      [key]: value
    });
  }

  deletePath(key, ...path) {
    return deletePaths(this._rootKey, [[key, ...path]]);
  }

  delete(key) {
    return deletePaths(this._rootKey, [[key]]);
  }

  deleteMultiple(keys) {
    return deletePaths(this._rootKey, keys.map(k => [k]));
  }

  has(key) {
    return storage_get(this._rootKey).then(val => val !== null && val[key] !== undefined);
  }

  clear() {
    return storage_delete_(this._rootKey);
  }

}

function wrapBlob(rootKey, defaultValue) {
  return new storage_BlobWrapper(rootKey, defaultValue);
}
// CONCATENATED MODULE: ./lib/environment/index.js




















// CONCATENATED MODULE: ./lib/utils/Cache.js
class LRUCache {
  constructor(capacity) {
    this.map = void 0;
    this.capacity = void 0;
    this.map = new Map();
    this.capacity = capacity;
  }

  get(key, maxAge = Infinity) {
    const now = Date.now();
    const entry = this.map.get(key);

    if (entry && now - entry.createTime < maxAge) {
      entry.hitTime = now;
      return entry.value;
    }
  }

  set(key, value) {
    const now = Date.now();
    this.map.set(key, {
      value,
      createTime: now,
      hitTime: now
    });

    if (this.map.size > this.capacity) {
      Array.from(this.map.entries()).sort(([, a], [, b]) => b.hitTime - a.hitTime).slice(this.capacity / 2 | 0).forEach(([key]) => this.map.delete(key));
    }

    return this;
  }

  delete(key) {
    return this.map.delete(key);
  }

  clear() {
    this.map.clear();
  }

}
// CONCATENATED MODULE: ./lib/utils/array.js


async function forEachSeq(iterable, callback) {
  for (const val of iterable) {
    await callback(val);
  }
}
async function asyncFilter(array, predicate) {
  const shouldKeep = await Promise.all(array.map(predicate));
  return array.filter((e, i) => shouldKeep[i]);
}
async function asyncReduce(iterable, callback, initialValue) {
  let accumulator = initialValue;

  for (const val of iterable) {
    accumulator = await callback(accumulator, val);
  }

  return accumulator;
}
const asyncFind = fastAsync(function* (iterable, predicate) {
  for (const val of iterable) {
    if (yield predicate(val)) return val;
  }
});

function concurrentFold(array, reduce, initialValue, baseCase) {
  if (!array.length) return Promise.resolve(initialValue);
  return new Promise((resolve, reject) => {
    let remaining = array.length;
    let accum = initialValue;

    function onResolve(x) {
      if (remaining === 0) return;
      accum = reduce(accum, x);

      if (accum === baseCase || --remaining === 0) {
        remaining = 0;
        resolve(accum);
      }
    }

    function onReject(err) {
      if (remaining === 0) return;
      remaining = 0;
      reject(err);
    }

    array.forEach(promise => promise.then(onResolve, onReject));
  });
}

function asyncSome(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a || !!b, false, true);
}
function asyncEvery(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a && !!b, true, false);
}
const filterMap = curryRight_default()((iterable, callback) => {
  const mapped = [];

  for (const x of iterable) {
    const result = callback(x);
    if (result) mapped.push(result[0]);
  }

  return mapped;
});
// CONCATENATED MODULE: ./lib/utils/Thing.js






const elementMap = new WeakMap();
const Thing_things = new Set();
const SECRET_TOKEN = new class {}();

const thingElementsCached = memoize_default()(doc => {
  waitForFutureDescendant(doc, Thing_Thing.thingSelector, {
    added: true,
    removed: true
  }).then(() => thingElementsCached.cache.delete(doc));
  return Array.from(doc.querySelectorAll(Thing_Thing.thingSelector));
});

class Thing_Thing {
  static thingElements(doc = document.body) {
    const eles = thingElementsCached(doc);
    let last = eles.slice(-1)[0];

    if (last) {
      do {
        if (last.nextElementSibling) break;
      } while (last = last.parentElement);

      if (!last) eles.pop();
    }

    return eles;
  }

  static things(doc) {
    return Thing_Thing.thingElements(doc).map(e => Thing_Thing.checkedFrom(e));
  }

  static visibleThingElements(doc) {
    return Thing_Thing.thingElements(doc).filter(v => v.offsetParent);
  }

  static visibleThings(doc) {
    return filterMap(Thing_Thing.visibleThingElements(doc), ele => {
      const thing = Thing_Thing.from(ele);
      if (thing) return [thing];
    });
  }

  static runTasksRange(a, b, marginTop, marginBottom, stopAfterCls) {
    let top, bottom;

    if (a && b) {
      [top, bottom] = a.getDirectionOf(b) === 'down' ? [a, b] : [b, a];
    } else if (a || b) {
      top = bottom = downcast(a || b, Thing_Thing);
    } else {
      return;
    }

    const thingElements = Thing_Thing.thingElements();
    let tidx = thingElements.indexOf(top.element);
    let bidx = thingElements.indexOf(bottom.element);
    let thing;

    for (const e of thingElements.slice(tidx, bidx + 1)) {
      thing = Thing_Thing.checkedFrom(e);
      if (thing.tasks.completed) continue;
      if (thing.isVisible()) thing.runTasks();
    }

    while ((thing = Thing_Thing.from(thingElements[--tidx])) && (marginTop > 0 || thing.parent)) {
      if (thing.tasks.completed || thing.isVisible()) {
        marginTop--;
        thing.runTasks();
      }
    }

    while ((thing = Thing_Thing.from(thingElements[++bidx])) && !(stopAfterCls && thing.element.classList.contains(stopAfterCls)) && (marginBottom > 0 || thing.parent)) {
      if (thing.tasks.completed || thing.isVisible()) {
        marginBottom--;
        thing.runTasks();
      }
    }
  }

  static checkedFrom(element) {
    const thing = Thing_Thing.from(element);

    if (!thing) {
      throw new Error(`Could not construct Thing from ${String(element)}`);
    }

    return thing;
  }

  static from(element) {
    if (!element) return null;
    if (element instanceof Thing_Thing) return element;
    const thingElement = element.closest(Thing_Thing.thingSelector);
    if (!thingElement) return null;
    if (elementMap.has(thingElement)) return elementMap.get(thingElement);
    const entry = thingElement.querySelector(Thing_Thing.entrySelector) || thingElement;
    const thing = new Thing_Thing(SECRET_TOKEN, downcast(thingElement, HTMLElement), entry);
    elementMap.set(thingElement, thing);
    Thing_things.add(thing);
    return thing;
  }

  constructor(token, thing, entry) {
    this.element = void 0;
    this.entry = void 0;
    this.parent = void 0;
    this.children = new Set();
    this.tasks = {
      completed: false,
      visible: [],
      immediate: [],
      byId: new Map()
    };
    this.refreshPartialVisibility = throttleQueuePositionReset(() => {
      this.element.classList.toggle('res-thing-partial', this.isHiddenByFilter(true) && (this.element.matches('.morerecursion, .morechildren') || Array.from(this.children).some(v => !v.isHiddenByFilter())));
    });

    if (token !== SECRET_TOKEN) {
      throw new Error('Use Thing.from() or Thing.checkedFrom() instead of new Thing()');
    }

    this.element = thing;
    this.entry = entry;
    const _p = this.element.parentElement;
    this.parent = _p && Thing_Thing.from(_p.closest('.thing'));
    if (this.parent) this.parent.children.add(this);
  }

  runTasks() {
    if (this.tasks.completed) return;
    this.tasks.immediate.map(fn => fn());
    this.tasks.visible.map(fn => fn());
  }

  anchor() {
    const anchor = getPercentageVisibleYAxis(this.entry) && {
      to: this.entry.getBoundingClientRect().top
    };
    if (!anchor) return;
    requestAnimationFrame(() => {
      if (!this.entry.offsetParent) return;
      scrollToElement(this.entry, undefined, {
        scrollStyle: 'none',
        anchor
      });
    });
  }

  setHideFilter(match) {
    this.element.classList.toggle('res-thing-filter-hide', !!match);

    if (this.isComment()) {
      this.refreshPartialVisibility();

      for (const p of this.getParents()) p.refreshPartialVisibility();
    }
  }

  setFilterReasons(elements) {
    for (const old of this.element.querySelectorAll('.res-thing-filter-remove-matching-entry')) old.remove();

    this.element.prepend(...elements);
  }

  getDirectionOf(other) {
    if (!this.isVisible() || !other.isVisible()) return;
    return other.entry.compareDocumentPosition(this.entry) & Node.DOCUMENT_POSITION_FOLLOWING ? 'up' : 'down';
  }

  getThreadTop() {
    let thing = this;
    let current = this.element;

    while (current = current.parentElement) {
      if (current.matches(Thing_Thing.thingSelector)) thing = downcast(current, HTMLElement);
    }

    return Thing_Thing.checkedFrom(thing);
  }

  getParents() {
    const parents = [];
    let level = this;

    while (level = level.parent) parents.push(level);

    return parents;
  }

  getNext({
    direction = 'down',
    excludeMoreChildren = false
  } = {}, things = Thing_Thing.thingElements()) {
    let index = things.indexOf(this.element);
    let target;

    do {
      index += direction === 'down' ? 1 : -1;
      const _target = things[index];
      target = _target;
      if (!target) return null;
      if (excludeMoreChildren && target.matches('.morechildren')) continue;
    } while (!target.offsetParent);

    return Thing_Thing.from(target);
  }

  getNextSibling(options) {
    if (!this.element.parentElement) return null;
    const things = Array.from(this.element.parentElement.children).filter(e => e.matches(Thing_Thing.thingSelector));
    return this.getNext(options, things);
  }

  getClosest(func, ...args) {
    const target = Reflect.apply(func, this, args);

    if (target) {
      return target;
    } else {
      if (this.parent) return this.parent.getClosest(func, ...args);
    }
  }

  getClosestVisible(options = {
    excludeMoreChildren: true
  }) {
    if (this.element.offsetParent) return this;
    return this.getNext({
      direction: 'down',
      ...options
    }) || this.getNext({
      direction: 'up',
      ...options
    });
  }

  isMessage() {
    return this.element.classList.contains('message');
  }

  isSubreddit() {
    return this.element.classList.contains('subreddit');
  }

  isPost() {
    return this.element.classList.contains('link') || this.element.classList.contains('search-result-link');
  }

  isLinkPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return !this.element.querySelector('a').classList.contains('self');
    } else {
      return !this.element.classList.contains('self');
    }
  }

  isSelfPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return this.element.querySelector('a').classList.contains('self');
    } else {
      return this.element.classList.contains('self');
    }
  }

  isComment() {
    return this.element.classList.contains('comment') || this.element.classList.contains('was-comment');
  }

  isTopLevelComment() {
    return this.isComment() && !!this.element.parentElement && this.element.parentElement.classList.contains('nestedlisting');
  }

  getTitle() {
    const element = this.getTitleElement();
    return element && element.textContent || '';
  }

  getTitleElement() {
    return this.entry.querySelector('a.title, a.search-title') || this.entry.querySelector('.title');
  }

  getTitleUrl() {
    const element = this.getTitleElement();

    if (element) {
      return element.href;
    }

    return '';
  }

  getPostLink() {
    return downcast(this.entry.querySelector('a.title, a.search-link'), HTMLAnchorElement);
  }

  getPostUrl() {
    return this.element.dataset.url || this.getPostLink().href;
  }

  getTextBody() {
    return this.entry.querySelector('.md');
  }

  getCommentsLink() {
    return downcast(this.entry.querySelector('a.comments, a.search-comments'), HTMLAnchorElement);
  }

  getCommentPermalink() {
    return this.entry.querySelector('a.bylink');
  }

  getHideElement() {
    return this.entry.querySelector('.hide-button a, .unhide-button a');
  }

  getButtons() {
    return this.entry.querySelector('.flat-list.buttons');
  }

  getNumberOfChildren() {
    const numChildrenElem = this.element.querySelector('.numchildren');
    const match = numChildrenElem && /(\d+)/.exec(numChildrenElem.textContent);
    return match && parseInt(match[1], 10) || 0;
  }

  static _parseScore(scoreEle) {
    return parseInt(scoreEle.title || scoreEle.textContent, 10) || 0;
  }

  getScore() {
    const element = this._getActiveScoreElement();

    return element && Thing_Thing._parseScore(element);
  }

  _getActiveScoreElement() {
    if (this.isPost()) {
      return this.element.querySelector(['.midcol.unvoted > .score.unvoted', '.midcol.likes > .score.likes', '.midcol.dislikes > .score.dislikes', '.search-score'].join(', '));
    } else {
      return this.entry.querySelector('.tagline > .score');
    }
  }

  getAllScoreElements() {
    const toScoreTuple = ele => [ele, Thing_Thing._parseScore(ele)];

    if (this.isPost()) {
      return Array.from(this.element.querySelectorAll('.midcol > .score, .search-score')).map(toScoreTuple);
    } else {
      return Array.from(this.entry.querySelectorAll('.tagline > .score')).map(toScoreTuple);
    }
  }

  getAuthor() {
    const data = this.element.getAttribute('data-author');

    if (data) {
      return data;
    }

    const element = this.getAuthorElement();

    if (element) {
      const match = regexes.profile.exec(element.pathname);

      if (match) {
        return match[1];
      }
    }
  }

  getAuthorUrl() {
    const author = this.getAuthor();

    if (author) {
      return `/user/${author}/`;
    }

    return '';
  }

  getAuthorElement() {
    return this.entry.querySelector('.tagline a.author, .search-author .author');
  }

  getSubreddit() {
    const data = this.element.getAttribute('data-subreddit');

    if (data) {
      return data;
    }

    const element = this.getSubredditLink();

    if (element) {
      const match = regexes.subreddit.exec(element.pathname);

      if (match) {
        return match[1];
      }
    } else {
      return currentSubreddit();
    }
  }

  getSubredditLink() {
    if (this.isPost()) {
      return this.entry.querySelector('.tagline a.subreddit, a.search-subreddit-link');
    } else if (this.isComment()) {
      return this.entry.querySelector('.parent a.subreddit, .tagline .subreddit a');
    }
  }

  getPostDomain() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.getPostDomainLink();

    if (element) {
      return element.textContent;
    }

    const text = this.getPostDomainText();

    if (text) {
      return text;
    }

    const subreddit = this.getSubreddit();

    if (subreddit) {
      return `self.${subreddit}`;
    }

    return 'reddit.com';
  }

  getPostDomainUrl() {
    const link = this.getPostDomainLink();

    if (link) {
      return link.href;
    }

    return `/domain/${this.getPostDomain()}/`;
  }

  getPostDomainLink() {
    return this.element.querySelector('.domain a');
  }

  getPostDomainText() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.element.querySelector('.domain');
    if (!element) return '';
    const text = element.textContent || '';
    return text.replace(/[\(\)\s]/g, '');
  }

  getCommentCount() {
    const element = this.getCommentCountElement();
    if (!element) return;
    return parseInt(/\d+/.exec(element.textContent || element.getAttribute('data-text')), 10) || 0;
  }

  getCommentCountElement() {
    if (this.isPost()) {
      return this.element.querySelector('.buttons .comments');
    } else if (this.isComment()) {
      return this.element.querySelector('.buttons a.full-comments');
    }
  }

  getPostThumbnailUrl() {
    const thumbnail = this.getPostThumbnailElement();
    if (!thumbnail) return '';
    return thumbnail.src || '';
  }

  getPostThumbnailElement() {
    return this.element.querySelector('.thumbnail img');
  }

  getPostFlairText() {
    const element = this.getPostFlairElement();
    return element && element.textContent || '';
  }

  getPostFlairElement() {
    return this.entry.querySelector('.title > .linkflairlabel');
  }

  getUserFlairText() {
    const element = this.getUserFlairElement();
    return element && element.textContent || '';
  }

  getUserFlairElement() {
    return this.entry.querySelector('.tagline > .flair');
  }

  getCrosspostBadgeElement() {
    return this.entry.querySelector('.crosspost-badge');
  }

  getUpvoteButton() {
    return this._getVoteButton('div.up, div.upmod');
  }

  getDownvoteButton() {
    return this._getVoteButton('div.down, div.downmod');
  }

  _getVoteButton(selector) {
    const previousSibling = this.entry.previousSibling;

    if (previousSibling.tagName === 'A') {
      return previousSibling.previousSibling.querySelector(selector);
    } else {
      return previousSibling.querySelector(selector);
    }
  }

  getTimestamp() {
    const element = this.getTimestampElement();
    return element && new Date(element.getAttribute('datetime'));
  }

  getTimestampElement() {
    return this.entry.querySelector('time');
  }

  getPostEditTimestamp() {
    const element = this.getPostEditTimestampElement();
    return element && Date.parse(element.getAttribute('datetime')) / 1000 || 0;
  }

  getPostEditTimestampElement() {
    return this.entry.querySelector('time.edited-timestamp');
  }

  getFullname() {
    return this.element.getAttribute('data-fullname') || '';
  }

  getUserattrsElement() {
    return this.entry.querySelector('.userattrs');
  }

  getRank() {
    const rank = parseInt(this.element.getAttribute('data-rank'), 10);
    if (!isNaN(rank)) return rank;
  }

  getRankElement() {
    if (!this.isPost()) return;
    return this.element.querySelector('.rank');
  }

  getTaglineElement() {
    return this.entry.querySelector('.tagline');
  }

  getCommentCollapseToggleElement() {
    return this.entry.querySelector('.expand');
  }

  setCommentCollapse(state, reason, openOnlyWhenSameReason = false) {
    const toggle = this.getCommentCollapseToggleElement();
    if (!toggle) return;
    if (state) toggle.setAttribute('collapse-reason', reason);
    if (this.isCollapsed() === state) return;
    if (!state && openOnlyWhenSameReason && toggle.getAttribute('collapse-reason') !== reason) return;
    if (!state) toggle.removeAttribute('collapse-reason');
    click(toggle);
  }

  getPostTime() {
    const element = this.getPostTimeElement();

    if (element) {
      return element.textContent;
    }

    return '';
  }

  getPostTimeElement() {
    return this.entry.querySelector('.tagline time');
  }

  isNSFW() {
    return this.element.classList.contains('over18') || !!this.entry.querySelector('.nsfw-stamp');
  }

  isSpoiler() {
    if (this.element.classList.contains('search-result')) {
      return !!this.entry.querySelector('.spoiler-stamp');
    }

    return this.element.classList.contains('spoiler');
  }

  isCrosspost() {
    return !!this.getCrosspostBadgeElement();
  }

  isLocked() {
    if (this.element.classList.contains('search-result')) {
      return this.element.classList.contains('linkflair-locked');
    }

    return this.element.classList.contains('locked');
  }

  isDeleted() {
    return this.element.classList.contains('deleted');
  }

  isHiddenByFilter(partialAsFiltered = false) {
    if (this.element.matches('body.hideOver18 .over18:not(.allowOver18)')) return true;
    if (!this.element.classList.contains('res-thing-filter-hide')) return false;
    if (this.element.classList.contains('res-filterline-highlight-match')) return false;

    if (partialAsFiltered) {
      if (this.element.classList.contains('res-thing-partial') && this.element.classList.contains('res-selected')) return false;
      return true;
    } else {
      if (this.element.classList.contains('res-thing-hide-children')) return true;
      return !this.element.classList.contains('res-thing-partial');
    }
  }

  isCollapsed() {
    return this.element.classList.contains('collapsed');
  }

  isVisible() {
    if (this.element.classList.contains('promoted')) return false;
    if (!document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter()) return false;
    const {
      parent
    } = this;

    if (parent) {
      if (parent.isCollapsed()) return false;
      if (parent.element.classList.contains('res-children-hidden')) return false;
      if (!parent.isVisible()) return false;
    }

    return true;
  }

  isContentVisible() {
    return !(this.element.classList.contains('res-thing-has-placeholder') || !document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter(true) || this.isCollapsed() || !this.isVisible());
  }

  isSelected() {
    return this.element.classList.contains('res-selected');
  }

  isUpvoted() {
    return this.entry.classList.contains('likes');
  }

  isDownvoted() {
    return this.entry.classList.contains('dislikes');
  }

  isUnvoted() {
    return this.entry.classList.contains('unvoted');
  }

}
Thing_Thing.thingSelector = '.listing .thing, .linklisting .thing, .nestedlisting .thing, .search-result-link';
Thing_Thing.entrySelector = '.entry';

Thing_Thing.registeredThings = (doc = document.body) => Array.from(Thing_things).filter(thing => doc.contains(thing.element));
// CONCATENATED MODULE: ./lib/utils/thingMetadata.js


const getPostMetadata = batch(async requests => {
  const byId = requests.map(r => r.id).map(id => `t3_${id}`).join(',');
  const {
    data: {
      children
    }
  } = await ajax({
    url: `/by_id/${byId}.json`,
    query: {
      limit: 100,
      raw_json: 1
    },
    type: 'json'
  });
  return children.map(c => c.data);
}, {
  size: 100
});
// EXTERNAL MODULE: ./node_modules/tinycolor2/tinycolor.js
var tinycolor = __webpack_require__(77);
var tinycolor_default = /*#__PURE__*/__webpack_require__.n(tinycolor);

// CONCATENATED MODULE: ./lib/utils/color.js

function colorToArray(colorString) {
  const {
    r,
    g,
    b
  } = tinycolor_default()(colorString).toRgb();
  return [r, g, b];
}
function colorFromArray([r, g, b]) {
  return tinycolor_default()({
    r,
    g,
    b
  }).toHexString();
}
// CONCATENATED MODULE: ./lib/utils/dashboard.js

const initialTabID = location.hash.replace('#', '') || 'dashboardContents';
let selectedTabMenuItem;
function addDashboardTab(tabID, tabName, moduleId, callback) {
  if (!isCurrentSubreddit('dashboard')) return;
  bodyClasses_namespaceObject.add('res-dashboard');
  let tabPage;
  const tabMenuItem = createElement_namespaceObject.tabMenuItem({
    text: tabName,
    className: 'res-dashboard-tab',
    order: -1,
    onChange: active => {
      const container = document.querySelector('#siteTable.linklisting');
      if (!container) return;

      if (active) {
        if (selectedTabMenuItem) selectedTabMenuItem.click();
        selectedTabMenuItem = tabMenuItem;
        tabPage = string_namespaceObject.html`<div class="dashboardPane"></div>`;
        container.append(tabPage);
        callback(tabPage);
        location.hash = tabID;
      } else {
        tabPage.remove();
      }
    }
  });

  if (moduleId) {
    tabMenuItem.after(string_namespaceObject.html`<a class="gearIcon" href="#res:settings/${moduleId}"></a>`);
  }

  if (tabID === initialTabID) tabMenuItem.click();
}
// CONCATENATED MODULE: ./lib/utils/pagePhases.js



const bodyStart = waitForChild(document.documentElement, 'body').then(() => waitFor(() => document.body, 10));
const sitetableStarted = bodyStart.then(() => Promise.race([waitForDescendant(document.body, isPageType('comments') ? '.sitetable.nestedlisting' : '#siteTable'), contentLoaded]));
const contentLoaded = bodyStart.then(() => Promise.race([waitForEvent(window, 'DOMContentLoaded', 'load'), waitFor(() => document.readyState === 'interactive' || document.readyState === 'complete', 500)]));
const loadComplete = bodyStart.then(() => Promise.race([waitForEvent(window, 'load'), waitFor(() => document.readyState === 'complete', 500)]));
// CONCATENATED MODULE: ./lib/utils/floater.js


var _class, _temp, _class2, _temp2, _class3, _temp3, _class4, _temp4;







class floater_Container {
  static isAvailable() {
    return true;
  }

  constructor() {
    this.element = document.createElement('div');
    this.list = string_html`<ul class="res-floater-list"></ul>`;
    if (this.constructor.useList) this.element.append(this.list);
    this.constructor.phase.then(() => this.go());
  }

  go() {}

  add(element, {
    separate,
    order
  }) {
    if (separate || !this.constructor.useList) {
      element.style.order = String(order);
      this.element.append(element);
    } else {
      if (element instanceof HTMLLIElement) {
        this.list.append(element);
      } else {
        const li = string_html`<li style="order: ${order}"></li>`;
        li.append(element);
        this.list.append(li);
      }
    }
  }

}

floater_Container.fallback = void 0;
floater_Container.phase = loadComplete;
floater_Container.useList = true;
const containers = {
  inNavbar: (_temp = _class = class inNavbar extends floater_Container {
    constructor(...args) {
      super(...args);
      this.updateHeaderWidth = frameThrottle(() => {
        const {
          width
        } = this.element.getBoundingClientRect();
        const headerButton = document.querySelector('.header-user-dropdown');
        headerButton.style.marginRight = `${width}px`;
      });
    }

    static isAvailable() {
      return isAppType('d2x') && !!document.querySelector('.header-user-dropdown');
    }

    go() {
      this.element.classList.add('res-floater-inNavbar');
      document.body.append(this.element);
      this.updateHeaderWidth();
    }

    add(element, opts) {
      super.add(element, opts);
      this.updateHeaderWidth();
    }

  }, _class.fallback = 'userMenu', _class.phase = sitetableStarted, _temp),
  userMenu: (_temp2 = _class2 = class userMenu extends floater_Container {
    static isAvailable() {
      return isAppType('r2');
    }

    go() {
      const element = document.body.querySelector('#header-bottom-right ul');
      element.append(...this.element.children);
      this.element = element;
    }

    add(element) {
      this.element.append(string_html`<span class="separator">|</span>`, element);
    }

  }, _class2.phase = sitetableStarted, _class2.useList = false, _temp2),
  belowFixedNavbar: class extends floater_Container {
    static isAvailable() {
      return isAppType('d2x');
    }

    go() {
      this.element.classList.add('res-floater-belowNavbar');
      this.element.style.top = `${5 + getD2xBodyOffset()}px`;
      document.body.append(this.element);
    }

  },
  visibleAfterScroll: (_temp3 = _class3 = class visibleAfterScroll extends floater_Container {
    static isAvailable() {
      return !isAppType('d2x');
    }

    go() {
      this.element.classList.add('res-floater-visibleAfterScroll');
      document.body.append(this.element);
      this.element.style.top = `${8 + getHeaderOffset(true)}px`;

      if (!document.querySelector('#RESPinnedHeaderSpacer')) {
        this.element.hidden = true;
        new IntersectionObserver(entries => {
          this.element.hidden = entries[0].isIntersecting;
        }).observe(document.querySelector('#header'));
      }
    }

  }, _class3.fallback = 'belowFixedNavbar', _temp3),
  tabMenu: (_temp4 = _class4 = class tabMenu extends floater_Container {
    static isAvailable() {
      return isAppType('r2');
    }

    go() {
      let menu = document.querySelector('#header-bottom-left ul.tabmenu');

      if (menu) {} else if (document.querySelector('#header-bottom-left')) {
        menu = string_html`<ul class="tabmenu" />`;
        document.querySelector('#header-bottom-left').append(menu);
      } else {
        return;
      }

      menu.append(...this.element.children);
      this.element = menu;
    }

  }, _class4.fallback = 'belowFixedNavbar', _class4.phase = sitetableStarted, _class4.useList = false, _temp4),
  inert: floater_Container
};

const getContainer = memoize_default()(name => {
  let container;

  if (containers[name].isAvailable()) {
    container = new containers[name]();
  } else if (containers[name].fallback) {
    container = getContainer(containers[name].fallback);
  }

  if (container) {
    return container;
  } else {
    const InertContainer = containers.inert;
    return new InertContainer();
  }
});

function addFloater(element, {
  container: containerName = ['inNavbar', 'belowFixedNavbar', 'visibleAfterScroll'].find(name => containers[name].isAvailable()) || 'inert',
  separate = false,
  order = 0
} = {}) {
  getContainer(containerName).add(element, {
    separate,
    order
  });
}
// CONCATENATED MODULE: ./lib/utils/hash.js

const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
function randomHash(len = 5) {
  const arr = new Array(len);

  for (const i of range(0, len)) {
    arr[i] = chars.charAt(Math.random() * chars.length | 0);
  }

  return arr.join('');
}
function hashCode(str) {
  let hash = 0;

  for (const char of str) {
    hash = (hash << 5) - hash + char.charCodeAt(0) | 0;
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/thingHide.js




const hideEndpoint = '/api/hide';
const unhideEndpoint = '/api/unhide';
const [HIDE, UNHIDE] = ['hide', 'unhide'];
const send = async (state, things) => {
  if (!isLoggedIn()) throw new Error('Not logged in');
  const values = filterMap(things, thing => {
    const id = thing.getFullname();
    const element = thing.getHideElement();
    return id && element && element.dataset.eventAction === state ? [{
      id,
      element
    }] : undefined;
  });
  if (!values.length) return;

  const updateElements = (action, text) => {
    for (const {
      element
    } of values) {
      if (action) element.dataset.eventAction = action;
      if (element.classList.contains('noCtrlF')) element.dataset.text = text;else element.textContent = text;
    }
  };

  updateElements(state === HIDE ? UNHIDE : HIDE, state === HIDE ? 'hiding...' : 'unhiding...');

  try {
    await ajax({
      method: 'POST',
      url: state === HIDE ? hideEndpoint : unhideEndpoint,
      data: {
        id: values.map(({
          id
        }) => id).join(',')
      },
      type: 'json'
    });
    updateElements(undefined, state === HIDE ? UNHIDE : HIDE);
  } catch (e) {
    updateElements(state, state);
    throw e;
  }
};
const thingHide_hide = batch(things => send(HIDE, things), {
  size: 50
});
const unhide = batch(things => send(UNHIDE, things), {
  size: 50
});
// CONCATENATED MODULE: ./lib/utils/keycode.js


const NAMED_KEYS = {
  Backspace: 'Backspace',
  Tab: 'Tab',
  Enter: 'Enter',
  Escape: 'Escape',
  Space: ' ',
  PageUp: 'PageUp',
  PageDown: 'PageDown',
  End: 'End',
  Home: 'Home',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Shift: 'Shift',
  Control: 'Control',
  Alt: 'Alt'
};
const keyCodes = {
  '-1': 'none',
  '8': 'backspace',
  '9': 'tab',
  '13': 'enter',
  '16': 'shift',
  '17': 'ctrl',
  '18': 'alt',
  '19': 'pause/break',
  '20': 'caps lock',
  '27': 'escape',
  '33': 'page up',
  '34': 'page down',
  '35': 'end',
  '36': 'home',
  '37': 'left arrow',
  '38': 'up arrow',
  '39': 'right arrow',
  '40': 'down arrow',
  '45': 'insert',
  '46': 'delete',
  '91': 'left window',
  '92': 'right window',
  '93': 'select key',
  '96': 'numpad 0',
  '97': 'numpad 1',
  '98': 'numpad 2',
  '99': 'numpad 3',
  '100': 'numpad 4',
  '101': 'numpad 5',
  '102': 'numpad 6',
  '103': 'numpad 7',
  '104': 'numpad 8',
  '105': 'numpad 9',
  '106': 'multiply',
  '107': 'add',
  '109': 'subtract',
  '110': 'decimal point',
  '111': 'divide',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'num lock',
  '145': 'scroll lock',
  '186': ';',
  '187': '=',
  '188': ',',
  '189': '-',
  '190': '.',
  '191': '/',
  '192': '`',
  '219': '[',
  '220': '\\',
  '221': ']',
  '222': '\''
};
function keycode_niceKeyCode(keyArray) {
  if (!keyArray && isNaN(keyArray)) {
    return '';
  }

  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (typeof keyArray === 'string') {
    const split = keyArray.split(',');
    const code = parseInt(split[0], 10);
    const modifiers = [...split.slice(1).map(s => s === 'true'), false, false, false, false];
    const [alt, ctrl, shift, meta] = modifiers;
    keyArray = [code, alt, ctrl, shift, meta];
  }

  const [keyCode, ...modifiers] = keyArray;

  const keyCombo = zipWith_default()(modifiers, ['alt-', 'ctrl-', 'shift-', 'command-'], (predicate, name) => predicate && name).filter(x => x).join('');

  const keyName = keyCodes[keyCode] || String.fromCharCode(keyCode);
  return `${keyCombo}${keyName}`;
}
function checkKeysForEvent(event, keyArray) {
  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (keyArray.length === 4) {
    keyArray.push(false);
  }

  const eventHash = hashKeyEvent(event);
  const arrayHash = hashKeyArray(keyArray);
  return eventHash === arrayHash;
}
function hashKeyEvent(event) {
  const keyArray = [event.keyCode, event.altKey, event.ctrlKey, event.shiftKey, event.metaKey];
  return hashKeyArray(keyArray);
}
function hashKeyArray(keyArray) {
  const length = 5;
  let hash = keyArray[0] * 2 ** length;

  for (const i of range(1, length)) {
    if (keyArray[i]) {
      hash += 2 ** i;
    }
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/localization.js



const Dayjs = lodash_once_default()(() => {
  const dayjs = __webpack_require__(9);

  const localeCode = i18n_locale.toLowerCase();
  if (localeCode.startsWith('de')) dayjs.locale(__webpack_require__(197));
  if (localeCode.startsWith('el')) dayjs.locale(__webpack_require__(198));
  if (localeCode.startsWith('es')) dayjs.locale(__webpack_require__(199));
  if (localeCode.startsWith('he')) dayjs.locale(__webpack_require__(200));
  if (localeCode.startsWith('it')) dayjs.locale(__webpack_require__(201));
  if (localeCode.startsWith('nl')) dayjs.locale(__webpack_require__(202));
  if (localeCode.startsWith('pl')) dayjs.locale(__webpack_require__(203));
  if (localeCode.startsWith('pt-br')) dayjs.locale(__webpack_require__(204));
  if (localeCode.startsWith('pt')) dayjs.locale(__webpack_require__(205));
  dayjs.extend(__webpack_require__(206));
  dayjs.extend(__webpack_require__(207));
  return dayjs;
});

const localization_dayjs = (...args) => new Dayjs()(...args);
function formatNumber(number) {
  return number.toLocaleString(i18n_locale);
}
function formatDate(date) {
  return localization_dayjs(date).format('L');
}
function formatDateTime(date) {
  return localization_dayjs(date).format('L LTS');
}
function formatDateDiff(from, to) {
  return localization_dayjs(to).from(from, true);
}
function formatRelativeTime(from) {
  return localization_dayjs(from).fromNow();
}
// CONCATENATED MODULE: ./lib/utils/math.js
function numericalCompare(op, a, b) {
  switch (op) {
    case '==':
      return a == b;

    case '!=':
      return a != b;

    case '>':
      return a > b;

    case '<':
      return a < b;

    case '>=':
      return a >= b;

    case '<=':
      return a <= b;

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function inverseOperator(op) {
  switch (op) {
    case '==':
      return '!=';

    case '!=':
      return '==';

    case '>':
      return '<=';

    case '<':
      return '>=';

    case '>=':
      return '<';

    case '<=':
      return '>';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function prettyOperator(op) {
  switch (op) {
    case '==':
      return '=';

    case '!=':
      return '';

    case '>':
      return '>';

    case '<':
      return '<';

    case '>=':
      return '';

    case '<=':
      return '';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function interpolate(low, high, frac) {
  return (1 - frac) * low + frac * high;
}
function deinterpolate(low, high, value) {
  if (low === -Infinity && high === Infinity) {
    return 0.5;
  } else if (low === -Infinity) {
    return 1;
  } else if (high === Infinity) {
    return 0;
  }

  return (value - low) / (high - low);
}
function projectInto(fromLow, fromHigh, toLow, toHigh, value) {
  return interpolate(toLow, toHigh, deinterpolate(fromLow, fromHigh, value));
}
function positiveModulo(a, n) {
  return (a % n + n) % n;
}
// EXTERNAL MODULE: ./node_modules/lodash/groupBy.js
var groupBy = __webpack_require__(26);
var groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);

// CONCATENATED MODULE: ./lib/utils/options.js

function indexOptionTable(option, keyIndex, keyTransformer = v => v) {
  const source = option.fields[keyIndex].type === 'list' ? Array.from(function* (nestedArray) {
    for (const arr of nestedArray) {
      for (const subKey of arr[keyIndex].split(',')) {
        yield [...arr.slice(0, keyIndex), subKey, ...arr.slice(keyIndex + 1)];
      }
    }
  }(option.value)) : option.value;
  return groupBy_default()(source, arr => keyTransformer(arr[keyIndex]));
}
// CONCATENATED MODULE: ./lib/utils/profiling.js
let profiling_counter = 0;
function markStart() {
  const tag = (++profiling_counter).toString();
  performance.mark(tag);
  return tag;
}
function markEnd(tag, name) {
  performance.measure(name, tag);
}
// CONCATENATED MODULE: ./lib/utils/storage.js


async function maybePruneOldEntries(id, entryStorage, keepTrackDays = 30) {
  if (!(await shouldPrune(id))) return;
  const now = Date.now();

  for (const [id, data] of Object.entries((await entryStorage.getAll()))) {
    const {
      updateTime
    } = data || {};

    if (!updateTime || now - updateTime > DAY * keepTrackDays) {
      entryStorage.delete(id);
    }
  }
}
async function shouldPrune(id, interval = WEEK) {
  await new Promise(res => setTimeout(() => requestIdleCallback(res), 10000));
  const lastStorage = storage_namespaceObject.wrap(`last_prune.${id}`, 0);
  const now = Date.now();
  if (now - (await lastStorage.get()) < interval) return false;
  lastStorage.set(now);
  return true;
}
// CONCATENATED MODULE: ./lib/utils/subreddits.js
const fakeSubreddits = ['mod', 'friends', 'random', 'myrandom', 'all', 'contrib', 'popular'];
function isFakeSubreddit(subreddit) {
  return fakeSubreddits.some(fakeSubreddit => fakeSubreddit === subreddit.toLowerCase());
}
// CONCATENATED MODULE: ./lib/utils/value.js
function firstValid(...vals) {
  return vals.find(val => val !== undefined && val !== null && (typeof val !== 'number' || !isNaN(val)));
}
// EXTERNAL MODULE: ./node_modules/lodash/sortBy.js
var lodash_sortBy = __webpack_require__(8);
var sortBy_default = /*#__PURE__*/__webpack_require__.n(lodash_sortBy);

// CONCATENATED MODULE: ./lib/utils/watchers.js







const elementWatchers = {
  page: [],
  selfText: []
};
const thingWatchers = {
  comment: [],
  message: [],
  post: [],
  subreddit: []
};

const runCallback = fn => {
  try {
    return fn();
  } catch (e) {
    console.error(e);
  }
};

const addCallback = (callback, actingOnElement, {
  immediate,
  id
} = {}) => {
  const thing = Thing_Thing.from(actingOnElement);

  if (thing) {
    const task = lodash_once_default()(() => runCallback(callback));

    if (id) thing.tasks.byId.set(id, task);
    (immediate ? thing.tasks.immediate : thing.tasks.visible).push(task);
    if (immediate || thing.tasks.completed) task();
  } else {
    runCallback(callback);
  }
};

function registerElement(type, element) {
  for (const {
    selector,
    callback,
    options,
    registered
  } of elementWatchers[type]) {
    const elements = selector && !element.matches(selector) ? Array.from(element.querySelectorAll(selector)) : [element];

    for (const e of elements) {
      if (registered.has(e)) continue;
      registered.add(e);
      addCallback(() => callback(e), e, options);
    }
  }
}

function registerThing(element) {
  const thing = Thing_Thing.checkedFrom(element);
  const thingWatcherCallbacks = thing.isPost() && thingWatchers.post || thing.isComment() && thingWatchers.comment || thing.isMessage() && thingWatchers.message || thing.isSubreddit() && thingWatchers.subreddit || [];

  for (const {
    callback,
    options,
    registered
  } of thingWatcherCallbacks) {
    if (registered.has(thing)) continue;
    registered.add(thing);
    addCallback(() => callback(thing), thing.element, options);
  }

  return thing;
}

function watchForThings(types, callback, options) {
  if (!types) types = Object.keys(thingWatchers);
  const entry = {
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) thingWatchers[type].push(entry);
}
function watchForElements(types, selector, callback, options) {
  const entry = {
    selector,
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) elementWatchers[type].push(entry);
}

const _runLikelyVisibleTasks = () => {
  let max = Math.ceil(screen.availHeight / 55);
  const queue = [];
  let i = 0;
  return async thing => {
    const n = i++;
    const filterTask = thing.tasks.byId.get('filter');
    await (filterTask && filterTask());

    const check = queue[n] = () => {
      delete queue[n];

      if (thing.tasks.completed || thing.isVisible()) {
        thing.runTasks();
      } else if (n < max) {
        max++;
        const nextCheck = queue.find(Boolean);
        if (nextCheck) nextCheck();
      }
    };

    if (n < max) check();
  };
};

function registerPage(page, runLikelyVisibleTasks = _runLikelyVisibleTasks()) {
  const things = filterMap([page.matches(Thing_Thing.thingSelector) && page, ...page.querySelectorAll(Thing_Thing.thingSelector)], e => e instanceof HTMLElement ? [registerThing(e)] : undefined);
  registerElement('page', page);
  things.forEach(runLikelyVisibleTasks);
}
const HIDE_FOLLOWING_CLASS = 'res-hide-following';
function r2WatcherSitetableStart() {
  watchForThings(['post'], thing => {
    const container = thing.entry.querySelector('div.expando');
    if (!container) return;
    watchForChildren(container, 'form', () => {
      const body = thing.getTextBody();
      if (body) registerElement('selfText', body);
    });
  });
  const thingElements = Thing_Thing.thingElements(document.body);

  const runLikelyVisibleVisibleTasks = _runLikelyVisibleTasks();

  for (const e of thingElements) registerPage(e, runLikelyVisibleVisibleTasks);

  let last = thingElements.slice(-1)[0];

  if (last) {
    do {
      last.classList.add(HIDE_FOLLOWING_CLASS);
    } while ((last = last.parentElement) && last !== document.body);
  }
}
function r2WatcherContentLoaded() {
  for (const ele of document.querySelectorAll(`.${HIDE_FOLLOWING_CLASS}`)) ele.classList.remove(HIDE_FOLLOWING_CLASS);

  const io = new IntersectionObserver(entries => {
    const intersecting = filterMap(entries, ({
      target,
      isIntersecting
    }) => isIntersecting && [Thing_Thing.from(target)]);
    if (!intersecting.length) return;
    const thingElements = Thing_Thing.thingElements();

    const things = sortBy_default()(intersecting, thing => thingElements.indexOf(thing.element));

    for (const thing of things) thing.runTasks();

    Thing_Thing.runTasksRange(things.slice(-1)[0], things[0], 10, 10, HIDE_FOLLOWING_CLASS);
  }, {
    rootMargin: '50%'
  });
  watchForThings(null, async thing => {
    await waitForAttach(document.body, thing.element);
    io.observe(thing.element);
    addCallback(() => {
      io.unobserve(thing.element);
      thing.tasks.completed = true;
    }, thing.element);
  }, {
    immediate: true
  });

  if (isPageType('comments')) {
    const commentarea = document.body.querySelector('.commentarea');
    if (commentarea) watchForFutureDescendants(commentarea, '.thing', registerPage, true);
  } else {
    const watchList = memoize_default()(ele => {
      if (ele) watchForFutureChildren(ele, '.thing', registerPage);
    });

    watchForThings(null, thing => {
      watchList(thing.element.parentElement);
    });
  }

  registerPage(document.body);
}
// CONCATENATED MODULE: ./lib/constants/jsapi.js
const JSAPI_CONSUMER_NAME = 'reddit-enhancement-suite';
// CONCATENATED MODULE: ./lib/utils/watchers_d2x.js

const watchers_d2x_callbacks = {
  subreddit: [],
  postAuthor: [],
  post: []
};
function watchForRedditEvents(type, callback) {
  if (!watchers_d2x_callbacks[type]) {
    watchers_d2x_callbacks[type] = [];
  }

  watchers_d2x_callbacks[type].push(callback);
}

function handleRedditEvent(event) {
  const {
    target,
    detail: {
      type,
      data
    }
  } = event;
  const fns = watchers_d2x_callbacks[type];

  if (!fns) {
    return;
  }

  let expandoId = `${type}|`;

  switch (type) {
    case 'postAuthor':
      expandoId += data.post.id;
      break;

    case 'commentAuthor':
      expandoId += data.comment.id;
      break;

    case 'userHovercard':
      expandoId += `${data.contextId}|${data.user.id}`;
      break;

    case 'subreddit':
    case 'post':
    case 'postModTools':
    default:
      expandoId += data.id;
      break;
  }

  const update = target.expando && target.expando._.id === expandoId ? (target.expando._.update || 0) + 1 : 0;
  const expando = { ...data,
    _: {
      id: expandoId,
      type,
      update
    }
  };
  target.expando = expando;
  const ownedTarget = target.querySelector(`[data-name="${JSAPI_CONSUMER_NAME}"]`);

  for (const fn of fns) {
    try {
      fn(ownedTarget, expando);
    } catch (e) {
      console.log(e);
    }
  }
}

function initD2xWatcher() {
  document.addEventListener('reddit', handleRedditEvent, true);
  const meta = document.createElement('meta');
  meta.name = 'jsapi.consumer';
  meta.content = JSAPI_CONSUMER_NAME;
  document.head.appendChild(meta);
  meta.dispatchEvent(new CustomEvent('reddit.ready'));
}
// EXTERNAL MODULE: ./node_modules/lodash/difference.js
var difference = __webpack_require__(10);
var difference_default = /*#__PURE__*/__webpack_require__.n(difference);

// CONCATENATED MODULE: ./lib/utils/bodyClasses.js

const classes = new Set();
const addMissing = () => {
  document.body.classList.add(...difference_default()(Array.from(classes), Array.from(document.body.classList)));
};
function bodyClasses_add(...change) {
  for (const cls of change) classes.add(cls);

  if (document.documentElement) document.documentElement.classList.add(...change);
  if (document.body) document.body.classList.add(...change);
}
function bodyClasses_remove(...change) {
  for (const cls of change) classes.delete(cls);

  if (document.documentElement) document.documentElement.classList.remove(...change);
  if (document.body) document.body.classList.remove(...change);
}
function bodyClasses_toggle(state, ...change) {
  if (state) bodyClasses_add(...change);else bodyClasses_remove(...change);
}
// CONCATENATED MODULE: ./lib/utils/browserDetect.js
let versionSearchString;

const searchString = datas => {
  const data = datas.find(data => {
    versionSearchString = data.versionSearch || data.identity;
    return data.string ? data.string.includes(data.subString) : data.prop;
  });
  return data ? data.identity : undefined;
};

const searchVersion = dataString => {
  const index = dataString.indexOf(versionSearchString);

  if (index === -1) {
    return;
  }

  return parseFloat(dataString.substring(index + versionSearchString.length + 1));
};

const hasNavigator = typeof navigator !== 'undefined';
const browser = hasNavigator ? searchString(dataBrowser()) || 'An unknown browser' : 'An unknown browser without `navigator`';
const version = hasNavigator ? searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || 'an unknown version' : 'an unknown version without `navigator`';
const OS = hasNavigator ? searchString(dataOS()) || 'an unknown OS' : 'an unknown OS without `navigator`';

function dataBrowser() {
  return [{
    string: navigator.userAgent,
    subString: 'OPR/',
    identity: 'Opera'
  }, {
    string: navigator.userAgent,
    subString: 'Edge',
    identity: 'Edge Spartan'
  }, {
    string: navigator.userAgent,
    subString: 'Edg',
    identity: 'Edge'
  }, {
    string: navigator.userAgent,
    subString: 'Chrome',
    identity: 'Chrome'
  }, {
    string: navigator.userAgent,
    subString: 'OmniWeb',
    versionSearch: 'OmniWeb/',
    identity: 'OmniWeb'
  }, {
    string: navigator.vendor,
    subString: 'Apple',
    identity: 'Safari',
    versionSearch: 'Version'
  }, {
    prop: window.opera,
    identity: 'Opera',
    versionSearch: 'Version'
  }, {
    string: navigator.vendor,
    subString: 'iCab',
    identity: 'iCab'
  }, {
    string: navigator.vendor,
    subString: 'KDE',
    identity: 'Konqueror'
  }, {
    string: navigator.userAgent,
    subString: 'Firefox',
    identity: 'Firefox'
  }, {
    string: navigator.vendor,
    subString: 'Camino',
    identity: 'Camino'
  }, {
    string: navigator.userAgent,
    subString: 'Netscape',
    identity: 'Netscape'
  }, {
    string: navigator.userAgent,
    subString: 'MSIE',
    identity: 'Explorer',
    versionSearch: 'MSIE'
  }, {
    string: navigator.userAgent,
    subString: 'Gecko',
    identity: 'Mozilla',
    versionSearch: 'rv'
  }, {
    string: navigator.userAgent,
    subString: 'Mozilla',
    identity: 'Netscape',
    versionSearch: 'Mozilla'
  }];
}

function dataOS() {
  return [{
    string: navigator.platform,
    subString: 'Win',
    identity: 'Windows'
  }, {
    string: navigator.platform,
    subString: 'Mac',
    identity: 'Mac'
  }, {
    string: navigator.userAgent,
    subString: 'iPhone',
    identity: 'iPhone/iPod'
  }, {
    string: navigator.platform,
    subString: 'Linux',
    identity: 'Linux'
  }];
}
// CONCATENATED MODULE: ./lib/utils/createElement.js




function toggleButton(onClick = () => {}, fieldID, enabled = false, onText = i18n('toggleOn'), offText = i18n('toggleOff'), isTable = false, usesBatch = false) {
  const toggle = string_html`
		<div ${fieldID && _html`id="${fieldID}Container"`} class="toggleButton ${enabled && 'enabled'}">
			<span class="toggleThumb"></span>
			<div class="toggleLabel ${usesBatch && 'res-icon'}"
				${onText && _html`data-enabled-text="${onText}"`}
				${offText && _html`data-disabled-text="${offText}"`}
			></div>
			<input id="${fieldID}" name="${fieldID}" type="checkbox" ${enabled && 'checked'}
				${isTable && _html`tableOption="true"`}
			/>
		</div>
	`;
  toggle.addEventListener('click', () => {
    const checkbox = downcast(toggle.querySelector('input[type=checkbox]'), HTMLInputElement);
    const enabling = !checkbox.checked;
    checkbox.checked = enabling;
    toggle.classList.toggle('enabled', enabling);
    onClick(enabling);
  });
  return toggle;
}
function icon(charCode, tagName = 'span', className = '', title = '') {
  const icon = document.createElement(tagName);
  icon.className = className;
  icon.classList.add('res-icon');
  icon.textContent = String.fromCharCode(charCode);
  icon.setAttribute('title', title);
  return icon;
}
function createElement_table(items, callback) {
  items = [].concat(items);
  const description = [];
  description.push('<table>');

  for (const item of items.map(callback)) {
    if (typeof item === 'string') {
      description.push(item);
    } else if (item) {
      description.push(...item);
    }
  }

  description.push('</table>');
  return description.join('\n');
}
function createElement_tabMenuItem({
  text,
  aftercontent,
  className,
  title,
  checked,
  onChange,
  order
}) {
  const element = string_html`
		<li class="res-tabmenu-button ${checked && 'selected'} ${className}">
			<a
				${title && _html`title="${title}"`}
				${aftercontent && _html`aftercontent="${aftercontent}"`}
			>${text}</a>
		</li>
	`;
  addFloater(element, {
    container: 'tabMenu',
    order
  });
  const a = element.querySelector('a');
  a.addEventListener('click', () => {
    checked = !checked;
    element.classList.toggle('selected', checked);
    onChange(checked);
  });
  return a;
}
function fancyToggleButton(text, title, getState, callback) {
  const element = document.createElement('span');
  element.className = 'res-fancy-toggle-button';
  element.title = title;
  let state;

  const refresh = _state => {
    if (state === _state) return;
    state = _state;

    if (state) {
      element.textContent = `-${text}`;
      element.classList.add('remove');
    } else {
      element.textContent = `+${text}`;
      element.classList.remove('remove');
    }
  };

  element.addEventListener('click', () => {
    callback(!state);
    refresh(!state);
  });
  element.addEventListener('refresh', () => {
    refresh(getState());
  });
  refresh(getState());
  return element;
}
// CONCATENATED MODULE: ./lib/utils/alert.js



const alert_open = mutex((content, {
  cancelable = false
} = {}) => new Promise((resolve, reject) => {
  const overlay = string_html`<div id="alert_message_background"></div>`;
  const container = string_html`<div id="alert_message"></div>`;
  container.append(content instanceof HTMLElement ? content : string_html`<div>${safe(content)}</div>`);
  document.body.append(overlay, container);

  function confirm() {
    resolve();
    close();
  }

  function cancel() {
    reject(new Error('User cancelled alert.'));
    close();
  }

  function close() {
    document.body.removeEventListener('keyup', listenForEscape);
    container.remove();
    overlay.remove();
  }

  function listenForEscape(e) {
    if (e.key === NAMED_KEYS.Escape) {
      if (cancelable) cancel();else confirm();
    }
  }

  document.body.addEventListener('keyup', listenForEscape);

  if (cancelable) {
    container.append(makeButton('confirm', 'button-right', confirm), makeButton('cancel', 'button-right', cancel, true));
  } else {
    container.append(makeButton('ok', undefined, confirm, true));
  }
}));
function makeButton(text, cls, onClick, focus) {
  const btn = document.createElement('input');
  btn.setAttribute('type', 'button');
  btn.setAttribute('value', text);
  if (onClick) btn.addEventListener('click', onClick);
  if (cls) btn.classList.add(cls);
  if (focus) requestAnimationFrame(() => {
    btn.focus();
  });
  return btn;
}
// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var lodash_throttle = __webpack_require__(27);
var throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// EXTERNAL MODULE: ./node_modules/lodash/maxBy.js
var maxBy = __webpack_require__(52);
var maxBy_default = /*#__PURE__*/__webpack_require__.n(maxBy);

// CONCATENATED MODULE: ./lib/constants/sessionStorage.js
const LAST_SELECTED_ENTRY_KEY = 'RES.lastSelectedEntry';
// CONCATENATED MODULE: ./lib/utils/selectedThing.js





let selectedThing_current;
let currentContainer;
let selectedThing_previous;
const listeners = {
  instantly: [],
  beforePaint: [],
  idle: []
};
function selectedThing_addListener(callback, when = 'idle', priority = 0) {
  callback.priority = priority;
  listeners[when].push(callback);
  listeners[when].sort((a, b) => a.priority - b.priority);
}

const runCallbacks = (() => {
  function runListeners(listeners, new_, old, opt) {
    for (const listener of listeners) try {
      listener(new_, old, opt);
    } catch (e) {
      console.error(e);
    }
  }

  function throttle(throttler, listeners) {
    let oldest;
    const throttled = throttler((new_, old, opt) => {
      runListeners(listeners, new_, oldest, opt);
      oldest = null;
    });
    return (new_, old, opt) => {
      if (!oldest) oldest = old;
      throttled(new_, old, opt);
    };
  }

  const runBeforePaint = throttle(frameThrottle, listeners.beforePaint);
  const runIdle = throttle(idleThrottle, listeners.idle);
  return (new_, old, opt) => {
    if (listeners.instantly.length) runListeners(listeners.instantly, new_, old, opt);
    if (listeners.beforePaint.length) runBeforePaint(new_, old, opt);
    if (listeners.idle.length) runIdle(new_, old, opt);
  };
})();

function selectedThing_set(_new, options = {
  scrollStyle: 'none'
}, force = false) {
  if (!force && _new === selectedThing_current) return;
  selectedThing_previous = selectedThing_current;
  selectedThing_current = _new;
  currentContainer = selectedThing_current.element.closest('.sitetable');
  const direction = selectedThing_previous && selectedThing_previous.getDirectionOf(selectedThing_current);
  runCallbacks(selectedThing_current, selectedThing_previous, { ...options,
    ...(direction ? {
      direction
    } : undefined)
  });
}
const selectClosestInView = frameDebounce(() => {
  if (selectedThing_current && getPercentageVisibleYAxis(selectedThing_current.entry)) return;
  const closestToCurrent = selectedThing_current && selectedThing_current.getClosestVisible();

  if (closestToCurrent && getPercentageVisibleYAxis(closestToCurrent.entry)) {
    selectedThing_set(closestToCurrent);
    return;
  }

  const things = Thing_Thing.visibleThings();
  const currentIndex = things.indexOf(selectedThing_current);

  const closestThings = sortBy_default()(things.filter(thing => thing.isVisible()), thing => Math.abs(things.indexOf(thing) - currentIndex));

  const closestVisible = maxBy_default()(closestThings, ({
    entry
  }) => getPercentageVisibleYAxis(entry));

  if (closestVisible) selectedThing_set(closestVisible);
});
function refresh() {
  if (!selectedThing_current || selectedThing_current.isVisible()) return;
  selectClosestInView();
}
const movers = {
  closestVisible: thing => thing.getClosestVisible(),
  up: thing => thing.getNext({
    direction: 'up'
  }),
  down: thing => thing.getNext({
    direction: 'down'
  }),
  top: () => Thing_Thing.visibleThings()[0],
  bottom: () => Thing_Thing.visibleThings().slice(-1)[0],
  upSibling: thing => thing.getNextSibling({
    direction: 'up'
  }) || thing.parent,
  downSibling: thing => thing.getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  downParentSibling: thing => (thing.parent || thing).getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  upThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'up'
  }) || thing.getThreadTop(),
  downThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'down'
  }),
  toTopComment: thing => thing.getThreadTop(),
  toParent: thing => thing.parent,
  previous: () => selectedThing_previous
};
function move(direction, options, fallback) {
  if (!selectedThing_current || !selectedThing_current.element.offsetParent) {
    selectClosestInView();
    return;
  }

  const targetFn = movers[direction];

  if (!selectedThing_current && targetFn.length) {
    if (!fallback || !fallback()) throw new Error('Function only works when an entry is current');
  }

  const target = targetFn(selectedThing_current);

  if (!target) {
    if (fallback && fallback()) return;
    if (selectedThing_current) return selectedThing_set(selectedThing_current, {
      scrollStyle: 'middle'
    });
    throw new Error('Could not find a target');
  } else if (selectedThing_current === target) {
    if (selectedThing_current) return selectedThing_set(selectedThing_current, {
      scrollStyle: 'middle'
    });
    throw new Error('Target already current');
  }

  selectedThing_set(target, options);
}
let selectedThing_anchor;
selectedThing_addListener((current, previous, {
  scrollStyle
}) => {
  if (previous && current !== previous && ['none', 'adopt'].includes(scrollStyle) && (current.element.classList.contains('res-thing-partial') || previous.element.classList.contains('res-thing-partial'))) {
    selectedThing_anchor = {
      to: current.entry.getBoundingClientRect().top,
      from: previous.entry.getBoundingClientRect().top
    };
  } else {
    selectedThing_anchor = undefined;
  }
}, 'instantly', -Infinity);
selectedThing_addListener((current, previous, {
  direction,
  scrollStyle
}) => {
  scrollToElement(current.entry, previous && previous.entry, {
    scrollStyle,
    direction,
    anchor: selectedThing_anchor,
    waitTillVisible: true
  });
}, 'beforePaint', 9);
selectedThing_addListener((current, previous, {
  scrollStyle,
  direction
}) => {
  if (scrollStyle === 'none') return;
  Thing_Thing.runTasksRange(current, direction === 'down' ? previous : undefined, 10, 10);
}, 'instantly');
watchForThings(['comment'], throttle_default()(thing => {
  if (!selectedThing_current) return;
  if (selectedThing_current && document.contains(selectedThing_current.element)) return;
  if (currentContainer && currentContainer !== thing.element.closest('.sitetable')) return;
  selectedThing_set(thing);
}, 100, {
  leading: true,
  trailing: false
}), {
  immediate: true
});
const lastSelectedKey = `${LAST_SELECTED_ENTRY_KEY}-${location.pathname}`;

const getLastSelectedId = () => sessionStorage[lastSelectedKey];

let scrollToSelectedThingOnLoad = false;
const setScrollToSelectedThingOnLoad = v => {
  scrollToSelectedThingOnLoad = v;
};
const lastSelectedId = getLastSelectedId();
watchForThings(null, thing => {
  if (selectedThing_current) return;
  if (!lastSelectedId) return selectedThing_set(thing);
  if (thing.getFullname() !== lastSelectedId) return;
  if (scrollToSelectedThingOnLoad) history.scrollRestoration = 'manual';
  selectedThing_set(thing, {
    scrollStyle: history.scrollRestoration === 'manual' ? 'legacy' : 'none'
  });
}, {
  immediate: true
});
selectedThing_addListener(current => {
  const id = current.getFullname();
  if (!id) return;
  sessionStorage[lastSelectedKey] = id;
}, 'beforePaint');
selectedThing_addListener((current, previous) => {
  if (previous) {
    previous.entry.classList.remove('res-selected');
    previous.element.classList.remove('res-selected');
  }

  if (current) {
    current.entry.classList.add('res-selected');
    current.element.classList.add('res-selected');
  }
}, 'instantly');
// EXTERNAL MODULE: ./node_modules/lodash/escapeRegExp.js
var escapeRegExp = __webpack_require__(36);
var escapeRegExp_default = /*#__PURE__*/__webpack_require__.n(escapeRegExp);

// CONCATENATED MODULE: ./lib/utils/table.js




const RESTables = new Map();
class table_RESTable {
  constructor(headers, _data, getRow, opts) {
    this._data = void 0;
    this.getRow = void 0;
    this.page = 0;
    this.pageSize = 100;
    this.tbody = void 0;
    this.element = void 0;
    this.columns = [];
    this.filters = [];
    this.onRowsChanges = [];
    this.sortBy = void 0;
    this.sortDirection = 'asc';
    this.data = memoize_default()(() => {
      const data = this._data.filter(v => this.filters.every(filter => filter(v)));

      if (this.sortBy) {
        const getValue = r => {
          const v = this.getRow(r)[this.sortBy];
          return v instanceof HTMLElement ? v.textContent : String(v);
        };

        const values = new Map(data.map(r => [r, getValue(r)]));
        data.sort((a, b) => values.get(a).localeCompare(values.get(b), undefined, {
          numeric: true
        }));
      }

      if (this.sortDirection === 'desc') {
        data.reverse();
      }

      return data;
    });
    this.updatePage = frameThrottle(() => {
      this.page = positiveModulo(this.page, Math.ceil(this.data().length / this.pageSize)) || 0;
      const start = this.page * this.pageSize || 0;
      empty(this.tbody);

      for (const rawRow of this.data().slice(start, start + this.pageSize)) {
        const tr = document.createElement('tr');
        this.tbody.append(tr);
        const row = this.getRow(rawRow);

        for (const id of this.columns) {
          const td = document.createElement('td');
          const content = row[id];
          if (content instanceof HTMLElement) td.append(content);else td.textContent = content;
          tr.append(td);
        }
      }

      for (const observer of this.onRowsChanges) observer();
    });
    this._data = _data;
    this.getRow = getRow;
    Object.assign(this, opts);
    const table = this.element = document.createElement('table');
    table.style.width = '100%';
    const thead = document.createElement('thead');
    const tbody = this.tbody = downcast(document.createElement('tbody'), HTMLTableSectionElement);
    table.append(thead, tbody);

    const _tr = document.createElement('tr');

    thead.append(_tr);

    for (const [id, label] of Object.entries(headers)) {
      const th = document.createElement('th');
      th.addEventListener('click', sortByColumn);
      th.textContent = label;
      this.columns.push(id);

      _tr.append(th);

      if (this.sortBy === id) th.classList.add(`sort-${this.sortDirection}`);
    }

    RESTables.set(table, this);
    this.start();
  }

  start() {
    this.page = 0;
    this.data.cache.clear();
    this.updatePage();
  }

  createSearchElement(valueGetter, placeholder, focus) {
    const search = document.createElement('input');
    search.setAttribute('placeholder', placeholder);
    if (focus) requestAnimationFrame(() => {
      search.focus();
    });
    let lastFilter;
    search.addEventListener('input', () => {
      let regex;

      if (string_namespaceObject.regexRegex.test(search.value)) {
        const [, str, flags = ''] = string_namespaceObject.regexRegex.exec(search.value);
        regex = new RegExp(str, flags);
      } else {
        regex = new RegExp(escapeRegExp_default()(search.value), 'i');
      }

      if (lastFilter) pull_default()(this.filters, lastFilter);
      if (search.value) this.filters.push(lastFilter = data => regex.test(valueGetter(data)));
      this.start();
    });
    return search;
  }

  createSelectFilters(filters) {
    const ele = string_namespaceObject.html`<div>
			Show only:
			<select>${filters.map(({
      name,
      initialSelected
    }) => string_namespaceObject._html`<option ${initialSelected ? 'selected' : ''}>${name}</option>`)}</select>
		</div>`;
    const filterSelect = downcast(ele.querySelector('select'), HTMLSelectElement);
    let lastFilter;
    this.filters.push(lastFilter = filters[filterSelect.selectedIndex].filter);
    filterSelect.addEventListener('change', () => {
      pull_default()(this.filters, lastFilter);

      const filter = filters[filterSelect.selectedIndex].filter;
      this.filters.push(lastFilter = filter);
      this.start();
    });
    return ele;
  }

  createPaginationElement() {
    const ele = string_namespaceObject.html`<div class="res-step-container">
			<div class="res-step res-step-previous"></div>
			<div class="res-step-progress">
				<span class="res-step-position"></span> of <span class="res-step-total"></span>
			</div>
			<div class="res-step res-step-next"></div>
		</div>`;
    ele.querySelector('.res-step-previous').addEventListener('click', () => {
      this.page--;
      this.updatePage();
    });
    ele.querySelector('.res-step-next').addEventListener('click', () => {
      this.page++;
      this.updatePage();
    });
    const position = ele.querySelector('.res-step-position');
    const total = ele.querySelector('.res-step-total');
    this.onRowsChanges.push(() => {
      const pages = Math.ceil(this.data().length / this.pageSize);
      ele.setAttribute('first-piece', String(this.page === 0));
      ele.setAttribute('last-piece', String(this.page === pages - 1));
      position.textContent = String(this.page + 1);
      total.textContent = String(pages || 1);
    });
    return ele;
  }

  sort(by, reverseCurrent) {
    this.sortBy = typeof by === 'number' ? this.columns[by] : by;
    this.sortDirection = reverseCurrent ? this.sortDirection === 'asc' ? 'desc' : 'asc' : 'asc';
    this.start();
  }

}
function sortByColumn({
  target: sortColumn
}) {
  const table = downcast(sortColumn.closest('table'), HTMLTableElement);
  const reverseCurrent = sortColumn.classList.contains('sort-asc') || sortColumn.classList.contains('sort-asc');
  const tableRES = RESTables.get(table);

  if (tableRES) {
    const index = [...downcast(sortColumn.parentElement, HTMLElement).children].indexOf(sortColumn);
    tableRES.sort(index, reverseCurrent);
  } else {
    const tbody = table.querySelector('tbody');
    const columns = Array.from(table.querySelectorAll('thead th'));
    const rows = Array.from(tbody.querySelectorAll('tr'));

    if (reverseCurrent) {
      rows.reverse();
    } else {
      const index = columns.indexOf(sortColumn);

      const getCellValue = memoize_default()(row => {
        const cell = row.querySelectorAll('td')[index];
        return cell.textContent;
      });

      rows.sort((rowA, rowB) => getCellValue(rowA).localeCompare(getCellValue(rowB), undefined, {
        numeric: true
      }));
    }

    tbody.append(...rows);
  }

  if (reverseCurrent) {
    sortColumn.classList.toggle('sort-asc');
    sortColumn.classList.toggle('sort-desc');
  } else {
    const previous = table.querySelector('.sort-asc, .sort-desc');
    if (previous) previous.classList.remove('sort-asc');
    if (previous) previous.classList.remove('sort-desc');
    sortColumn.classList.add('sort-asc');
  }
}
// EXTERNAL MODULE: ./node_modules/lodash/flatten.js
var flatten = __webpack_require__(21);
var flatten_default = /*#__PURE__*/__webpack_require__.n(flatten);

// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var dist_jquery = __webpack_require__(0);
var jquery_default = /*#__PURE__*/__webpack_require__.n(dist_jquery);

// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.core.esm.js
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function(obj){return typeof obj;};}else{_typeof=function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty(target,key,source[key]);});}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2;}}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance");}var sortable_core_esm_version="1.10.2";function userAgent(pattern){if(typeof window!=='undefined'&&window.navigator){return!!navigator.userAgent.match(pattern);}}var IE11OrLess=userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);var Edge=userAgent(/Edge/i);var FireFox=userAgent(/firefox/i);var Safari=userAgent(/safari/i)&&!userAgent(/chrome/i)&&!userAgent(/android/i);var IOS=userAgent(/iP(ad|od|hone)/i);var ChromeForAndroid=userAgent(/chrome/i)&&userAgent(/android/i);var captureMode={capture:false,passive:false};function sortable_core_esm_on(el,event,fn){el.addEventListener(event,fn,!IE11OrLess&&captureMode);}function sortable_core_esm_off(el,event,fn){el.removeEventListener(event,fn,!IE11OrLess&&captureMode);}function sortable_core_esm_matches(el,selector){if(!selector)return;selector[0]==='>'&&(selector=selector.substring(1));if(el){try{if(el.matches){return el.matches(selector);}else if(el.msMatchesSelector){return el.msMatchesSelector(selector);}else if(el.webkitMatchesSelector){return el.webkitMatchesSelector(selector);}}catch(_){return false;}}return false;}function getParentOrHost(el){return el.host&&el!==document&&el.host.nodeType?el.host:el.parentNode;}function closest(el,selector,ctx,includeCTX){if(el){ctx=ctx||document;do{if(selector!=null&&(selector[0]==='>'?el.parentNode===ctx&&sortable_core_esm_matches(el,selector):sortable_core_esm_matches(el,selector))||includeCTX&&el===ctx){return el;}if(el===ctx)break;}while(el=getParentOrHost(el));}return null;}var R_SPACE=/\s+/g;function toggleClass(el,name,state){if(el&&name){if(el.classList){el.classList[state?'add':'remove'](name);}else{var className=(' '+el.className+' ').replace(R_SPACE,' ').replace(' '+name+' ',' ');el.className=(className+(state?' '+name:'')).replace(R_SPACE,' ');}}}function css(el,prop,val){var style=el&&el.style;if(style){if(val===void 0){if(document.defaultView&&document.defaultView.getComputedStyle){val=document.defaultView.getComputedStyle(el,'');}else if(el.currentStyle){val=el.currentStyle;}return prop===void 0?val:val[prop];}else{if(!(prop in style)&&prop.indexOf('webkit')===-1){prop='-webkit-'+prop;}style[prop]=val+(typeof val==='string'?'':'px');}}}function matrix(el,selfOnly){var appliedTransforms='';if(typeof el==='string'){appliedTransforms=el;}else{do{var transform=css(el,'transform');if(transform&&transform!=='none'){appliedTransforms=transform+' '+appliedTransforms;}}while(!selfOnly&&(el=el.parentNode));}var matrixFn=window.DOMMatrix||window.WebKitCSSMatrix||window.CSSMatrix||window.MSCSSMatrix;return matrixFn&&new matrixFn(appliedTransforms);}function find(ctx,tagName,iterator){if(ctx){var list=ctx.getElementsByTagName(tagName),i=0,n=list.length;if(iterator){for(;i<n;i++){iterator(list[i],i);}}return list;}return[];}function getWindowScrollingElement(){var scrollingElement=document.scrollingElement;if(scrollingElement){return scrollingElement;}else{return document.documentElement;}}function getRect(el,relativeToContainingBlock,relativeToNonStaticParent,undoScale,container){if(!el.getBoundingClientRect&&el!==window)return;var elRect,top,left,bottom,right,height,width;if(el!==window&&el!==getWindowScrollingElement()){elRect=el.getBoundingClientRect();top=elRect.top;left=elRect.left;bottom=elRect.bottom;right=elRect.right;height=elRect.height;width=elRect.width;}else{top=0;left=0;bottom=window.innerHeight;right=window.innerWidth;height=window.innerHeight;width=window.innerWidth;}if((relativeToContainingBlock||relativeToNonStaticParent)&&el!==window){container=container||el.parentNode;if(!IE11OrLess){do{if(container&&container.getBoundingClientRect&&(css(container,'transform')!=='none'||relativeToNonStaticParent&&css(container,'position')!=='static')){var containerRect=container.getBoundingClientRect();top-=containerRect.top+parseInt(css(container,'border-top-width'));left-=containerRect.left+parseInt(css(container,'border-left-width'));bottom=top+elRect.height;right=left+elRect.width;break;}}while(container=container.parentNode);}}if(undoScale&&el!==window){var elMatrix=matrix(container||el),scaleX=elMatrix&&elMatrix.a,scaleY=elMatrix&&elMatrix.d;if(elMatrix){top/=scaleY;left/=scaleX;width/=scaleX;height/=scaleY;bottom=top+height;right=left+width;}}return{top:top,left:left,bottom:bottom,right:right,width:width,height:height};}function isScrolledPast(el,elSide,parentSide){var parent=getParentAutoScrollElement(el,true),elSideVal=getRect(el)[elSide];while(parent){var parentSideVal=getRect(parent)[parentSide],visible=void 0;if(parentSide==='top'||parentSide==='left'){visible=elSideVal>=parentSideVal;}else{visible=elSideVal<=parentSideVal;}if(!visible)return parent;if(parent===getWindowScrollingElement())break;parent=getParentAutoScrollElement(parent,false);}return false;}function getChild(el,childNum,options){var currentChild=0,i=0,children=el.children;while(i<children.length){if(children[i].style.display!=='none'&&children[i]!==Sortable.ghost&&children[i]!==Sortable.dragged&&closest(children[i],options.draggable,el,false)){if(currentChild===childNum){return children[i];}currentChild++;}i++;}return null;}function lastChild(el,selector){var last=el.lastElementChild;while(last&&(last===Sortable.ghost||css(last,'display')==='none'||selector&&!sortable_core_esm_matches(last,selector))){last=last.previousElementSibling;}return last||null;}function sortable_core_esm_index(el,selector){var index=0;if(!el||!el.parentNode){return-1;}while(el=el.previousElementSibling){if(el.nodeName.toUpperCase()!=='TEMPLATE'&&el!==Sortable.clone&&(!selector||sortable_core_esm_matches(el,selector))){index++;}}return index;}function getRelativeScrollOffset(el){var offsetLeft=0,offsetTop=0,winScroller=getWindowScrollingElement();if(el){do{var elMatrix=matrix(el),scaleX=elMatrix.a,scaleY=elMatrix.d;offsetLeft+=el.scrollLeft*scaleX;offsetTop+=el.scrollTop*scaleY;}while(el!==winScroller&&(el=el.parentNode));}return[offsetLeft,offsetTop];}function indexOfObject(arr,obj){for(var i in arr){if(!arr.hasOwnProperty(i))continue;for(var key in obj){if(obj.hasOwnProperty(key)&&obj[key]===arr[i][key])return Number(i);}}return-1;}function getParentAutoScrollElement(el,includeSelf){if(!el||!el.getBoundingClientRect)return getWindowScrollingElement();var elem=el;var gotSelf=false;do{if(elem.clientWidth<elem.scrollWidth||elem.clientHeight<elem.scrollHeight){var elemCSS=css(elem);if(elem.clientWidth<elem.scrollWidth&&(elemCSS.overflowX=='auto'||elemCSS.overflowX=='scroll')||elem.clientHeight<elem.scrollHeight&&(elemCSS.overflowY=='auto'||elemCSS.overflowY=='scroll')){if(!elem.getBoundingClientRect||elem===document.body)return getWindowScrollingElement();if(gotSelf||includeSelf)return elem;gotSelf=true;}}}while(elem=elem.parentNode);return getWindowScrollingElement();}function extend(dst,src){if(dst&&src){for(var key in src){if(src.hasOwnProperty(key)){dst[key]=src[key];}}}return dst;}function isRectEqual(rect1,rect2){return Math.round(rect1.top)===Math.round(rect2.top)&&Math.round(rect1.left)===Math.round(rect2.left)&&Math.round(rect1.height)===Math.round(rect2.height)&&Math.round(rect1.width)===Math.round(rect2.width);}var _throttleTimeout;function sortable_core_esm_throttle(callback,ms){return function(){if(!_throttleTimeout){var args=arguments,_this=this;if(args.length===1){callback.call(_this,args[0]);}else{callback.apply(_this,args);}_throttleTimeout=setTimeout(function(){_throttleTimeout=void 0;},ms);}};}function cancelThrottle(){clearTimeout(_throttleTimeout);_throttleTimeout=void 0;}function scrollBy(el,x,y){el.scrollLeft+=x;el.scrollTop+=y;}function clone(el){var Polymer=window.Polymer;var $=window.jQuery||window.Zepto;if(Polymer&&Polymer.dom){return Polymer.dom(el).cloneNode(true);}else if($){return $(el).clone(true)[0];}else{return el.cloneNode(true);}}function setRect(el,rect){css(el,'position','absolute');css(el,'top',rect.top);css(el,'left',rect.left);css(el,'width',rect.width);css(el,'height',rect.height);}function unsetRect(el){css(el,'position','');css(el,'top','');css(el,'left','');css(el,'width','');css(el,'height','');}var sortable_core_esm_expando='Sortable'+new Date().getTime();function AnimationStateManager(){var animationStates=[],animationCallbackId;return{captureAnimationState:function(){animationStates=[];if(!this.options.animation)return;var children=[].slice.call(this.el.children);children.forEach(function(child){if(css(child,'display')==='none'||child===Sortable.ghost)return;animationStates.push({target:child,rect:getRect(child)});var fromRect=_objectSpread({},animationStates[animationStates.length-1].rect);if(child.thisAnimationDuration){var childMatrix=matrix(child,true);if(childMatrix){fromRect.top-=childMatrix.f;fromRect.left-=childMatrix.e;}}child.fromRect=fromRect;});},addAnimationState:function(state){animationStates.push(state);},removeAnimationState:function(target){animationStates.splice(indexOfObject(animationStates,{target:target}),1);},animateAll:function(callback){var _this=this;if(!this.options.animation){clearTimeout(animationCallbackId);if(typeof callback==='function')callback();return;}var animating=false,animationTime=0;animationStates.forEach(function(state){var time=0,target=state.target,fromRect=target.fromRect,toRect=getRect(target),prevFromRect=target.prevFromRect,prevToRect=target.prevToRect,animatingRect=state.rect,targetMatrix=matrix(target,true);if(targetMatrix){toRect.top-=targetMatrix.f;toRect.left-=targetMatrix.e;}target.toRect=toRect;if(target.thisAnimationDuration){if(isRectEqual(prevFromRect,toRect)&&!isRectEqual(fromRect,toRect)&&(animatingRect.top-toRect.top)/(animatingRect.left-toRect.left)===(fromRect.top-toRect.top)/(fromRect.left-toRect.left)){time=calculateRealTime(animatingRect,prevFromRect,prevToRect,_this.options);}}if(!isRectEqual(toRect,fromRect)){target.prevFromRect=fromRect;target.prevToRect=toRect;if(!time){time=_this.options.animation;}_this.animate(target,animatingRect,toRect,time);}if(time){animating=true;animationTime=Math.max(animationTime,time);clearTimeout(target.animationResetTimer);target.animationResetTimer=setTimeout(function(){target.animationTime=0;target.prevFromRect=null;target.fromRect=null;target.prevToRect=null;target.thisAnimationDuration=null;},time);target.thisAnimationDuration=time;}});clearTimeout(animationCallbackId);if(!animating){if(typeof callback==='function')callback();}else{animationCallbackId=setTimeout(function(){if(typeof callback==='function')callback();},animationTime);}animationStates=[];},animate:function(target,currentRect,toRect,duration){if(duration){css(target,'transition','');css(target,'transform','');var elMatrix=matrix(this.el),scaleX=elMatrix&&elMatrix.a,scaleY=elMatrix&&elMatrix.d,translateX=(currentRect.left-toRect.left)/(scaleX||1),translateY=(currentRect.top-toRect.top)/(scaleY||1);target.animatingX=!!translateX;target.animatingY=!!translateY;css(target,'transform','translate3d('+translateX+'px,'+translateY+'px,0)');repaint(target);css(target,'transition','transform '+duration+'ms'+(this.options.easing?' '+this.options.easing:''));css(target,'transform','translate3d(0,0,0)');typeof target.animated==='number'&&clearTimeout(target.animated);target.animated=setTimeout(function(){css(target,'transition','');css(target,'transform','');target.animated=false;target.animatingX=false;target.animatingY=false;},duration);}}};}function repaint(target){return target.offsetWidth;}function calculateRealTime(animatingRect,fromRect,toRect,options){return Math.sqrt(Math.pow(fromRect.top-animatingRect.top,2)+Math.pow(fromRect.left-animatingRect.left,2))/Math.sqrt(Math.pow(fromRect.top-toRect.top,2)+Math.pow(fromRect.left-toRect.left,2))*options.animation;}var plugins=[];var sortable_core_esm_defaults={initializeByDefault:true};var PluginManager={mount:function(plugin){for(var option in sortable_core_esm_defaults){if(sortable_core_esm_defaults.hasOwnProperty(option)&&!(option in plugin)){plugin[option]=sortable_core_esm_defaults[option];}}plugins.push(plugin);},pluginEvent:function(eventName,sortable,evt){var _this=this;this.eventCanceled=false;evt.cancel=function(){_this.eventCanceled=true;};var eventNameGlobal=eventName+'Global';plugins.forEach(function(plugin){if(!sortable[plugin.pluginName])return;if(sortable[plugin.pluginName][eventNameGlobal]){sortable[plugin.pluginName][eventNameGlobal](_objectSpread({sortable:sortable},evt));}if(sortable.options[plugin.pluginName]&&sortable[plugin.pluginName][eventName]){sortable[plugin.pluginName][eventName](_objectSpread({sortable:sortable},evt));}});},initializePlugins:function(sortable,el,defaults){plugins.forEach(function(plugin){var pluginName=plugin.pluginName;if(!sortable.options[pluginName]&&!plugin.initializeByDefault)return;var initialized=new plugin(sortable,el,sortable.options);initialized.sortable=sortable;initialized.options=sortable.options;sortable[pluginName]=initialized;_extends(defaults,initialized.defaults);});for(var option in sortable.options){if(!sortable.options.hasOwnProperty(option))continue;var modified=this.modifyOption(sortable,option,sortable.options[option]);if(typeof modified!=='undefined'){sortable.options[option]=modified;}}},getEventProperties:function(name,sortable){var eventProperties={};plugins.forEach(function(plugin){if(typeof plugin.eventProperties!=='function')return;_extends(eventProperties,plugin.eventProperties.call(sortable[plugin.pluginName],name));});return eventProperties;},modifyOption:function(sortable,name,value){var modifiedValue;plugins.forEach(function(plugin){if(!sortable[plugin.pluginName])return;if(plugin.optionListeners&&typeof plugin.optionListeners[name]==='function'){modifiedValue=plugin.optionListeners[name].call(sortable[plugin.pluginName],value);}});return modifiedValue;}};function dispatchEvent(_ref){var sortable=_ref.sortable,rootEl=_ref.rootEl,name=_ref.name,targetEl=_ref.targetEl,cloneEl=_ref.cloneEl,toEl=_ref.toEl,fromEl=_ref.fromEl,oldIndex=_ref.oldIndex,newIndex=_ref.newIndex,oldDraggableIndex=_ref.oldDraggableIndex,newDraggableIndex=_ref.newDraggableIndex,originalEvent=_ref.originalEvent,putSortable=_ref.putSortable,extraEventProperties=_ref.extraEventProperties;sortable=sortable||rootEl&&rootEl[sortable_core_esm_expando];if(!sortable)return;var evt,options=sortable.options,onName='on'+name.charAt(0).toUpperCase()+name.substr(1);if(window.CustomEvent&&!IE11OrLess&&!Edge){evt=new CustomEvent(name,{bubbles:true,cancelable:true});}else{evt=document.createEvent('Event');evt.initEvent(name,true,true);}evt.to=toEl||rootEl;evt.from=fromEl||rootEl;evt.item=targetEl||rootEl;evt.clone=cloneEl;evt.oldIndex=oldIndex;evt.newIndex=newIndex;evt.oldDraggableIndex=oldDraggableIndex;evt.newDraggableIndex=newDraggableIndex;evt.originalEvent=originalEvent;evt.pullMode=putSortable?putSortable.lastPutMode:undefined;var allEventProperties=_objectSpread({},extraEventProperties,PluginManager.getEventProperties(name,sortable));for(var option in allEventProperties){evt[option]=allEventProperties[option];}if(rootEl){rootEl.dispatchEvent(evt);}if(options[onName]){options[onName].call(sortable,evt);}}var pluginEvent=function(eventName,sortable){var _ref=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},originalEvent=_ref.evt,data=_objectWithoutProperties(_ref,["evt"]);PluginManager.pluginEvent.bind(Sortable)(eventName,sortable,_objectSpread({dragEl:dragEl,parentEl:parentEl,ghostEl:ghostEl,rootEl:rootEl,nextEl:nextEl,lastDownEl:lastDownEl,cloneEl:cloneEl,cloneHidden:cloneHidden,dragStarted:moved,putSortable:putSortable,activeSortable:Sortable.active,originalEvent:originalEvent,oldIndex:oldIndex,oldDraggableIndex:oldDraggableIndex,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex,hideGhostForTarget:_hideGhostForTarget,unhideGhostForTarget:_unhideGhostForTarget,cloneNowHidden:function(){cloneHidden=true;},cloneNowShown:function(){cloneHidden=false;},dispatchSortableEvent:function(name){_dispatchEvent({sortable:sortable,name:name,originalEvent:originalEvent});}},data));};function _dispatchEvent(info){dispatchEvent(_objectSpread({putSortable:putSortable,cloneEl:cloneEl,targetEl:dragEl,rootEl:rootEl,oldIndex:oldIndex,oldDraggableIndex:oldDraggableIndex,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex},info));}var dragEl,parentEl,ghostEl,rootEl,nextEl,lastDownEl,cloneEl,cloneHidden,oldIndex,sortable_core_esm_newIndex,oldDraggableIndex,newDraggableIndex,activeGroup,putSortable,awaitingDragStarted=false,ignoreNextClick=false,sortables=[],tapEvt,touchEvt,lastDx,lastDy,tapDistanceLeft,tapDistanceTop,moved,lastTarget,lastDirection,pastFirstInvertThresh=false,isCircumstantialInvert=false,targetMoveDistance,ghostRelativeParent,ghostRelativeParentInitialScroll=[],_silent=false,savedInputChecked=[];var documentExists=typeof document!=='undefined',PositionGhostAbsolutely=IOS,CSSFloatProperty=Edge||IE11OrLess?'cssFloat':'float',supportDraggable=documentExists&&!ChromeForAndroid&&!IOS&&'draggable'in document.createElement('div'),supportCssPointerEvents=function(){if(!documentExists)return;if(IE11OrLess){return false;}var el=document.createElement('x');el.style.cssText='pointer-events:auto';return el.style.pointerEvents==='auto';}(),_detectDirection=function(el,options){var elCSS=css(el),elWidth=parseInt(elCSS.width)-parseInt(elCSS.paddingLeft)-parseInt(elCSS.paddingRight)-parseInt(elCSS.borderLeftWidth)-parseInt(elCSS.borderRightWidth),child1=getChild(el,0,options),child2=getChild(el,1,options),firstChildCSS=child1&&css(child1),secondChildCSS=child2&&css(child2),firstChildWidth=firstChildCSS&&parseInt(firstChildCSS.marginLeft)+parseInt(firstChildCSS.marginRight)+getRect(child1).width,secondChildWidth=secondChildCSS&&parseInt(secondChildCSS.marginLeft)+parseInt(secondChildCSS.marginRight)+getRect(child2).width;if(elCSS.display==='flex'){return elCSS.flexDirection==='column'||elCSS.flexDirection==='column-reverse'?'vertical':'horizontal';}if(elCSS.display==='grid'){return elCSS.gridTemplateColumns.split(' ').length<=1?'vertical':'horizontal';}if(child1&&firstChildCSS["float"]&&firstChildCSS["float"]!=='none'){var touchingSideChild2=firstChildCSS["float"]==='left'?'left':'right';return child2&&(secondChildCSS.clear==='both'||secondChildCSS.clear===touchingSideChild2)?'vertical':'horizontal';}return child1&&(firstChildCSS.display==='block'||firstChildCSS.display==='flex'||firstChildCSS.display==='table'||firstChildCSS.display==='grid'||firstChildWidth>=elWidth&&elCSS[CSSFloatProperty]==='none'||child2&&elCSS[CSSFloatProperty]==='none'&&firstChildWidth+secondChildWidth>elWidth)?'vertical':'horizontal';},_dragElInRowColumn=function(dragRect,targetRect,vertical){var dragElS1Opp=vertical?dragRect.left:dragRect.top,dragElS2Opp=vertical?dragRect.right:dragRect.bottom,dragElOppLength=vertical?dragRect.width:dragRect.height,targetS1Opp=vertical?targetRect.left:targetRect.top,targetS2Opp=vertical?targetRect.right:targetRect.bottom,targetOppLength=vertical?targetRect.width:targetRect.height;return dragElS1Opp===targetS1Opp||dragElS2Opp===targetS2Opp||dragElS1Opp+dragElOppLength/2===targetS1Opp+targetOppLength/2;},_detectNearestEmptySortable=function(x,y){var ret;sortables.some(function(sortable){if(lastChild(sortable))return;var rect=getRect(sortable),threshold=sortable[sortable_core_esm_expando].options.emptyInsertThreshold,insideHorizontally=x>=rect.left-threshold&&x<=rect.right+threshold,insideVertically=y>=rect.top-threshold&&y<=rect.bottom+threshold;if(threshold&&insideHorizontally&&insideVertically){return ret=sortable;}});return ret;},_prepareGroup=function(options){function toFn(value,pull){return function(to,from,dragEl,evt){var sameGroup=to.options.group.name&&from.options.group.name&&to.options.group.name===from.options.group.name;if(value==null&&(pull||sameGroup)){return true;}else if(value==null||value===false){return false;}else if(pull&&value==='clone'){return value;}else if(typeof value==='function'){return toFn(value(to,from,dragEl,evt),pull)(to,from,dragEl,evt);}else{var otherGroup=(pull?to:from).options.group.name;return value===true||typeof value==='string'&&value===otherGroup||value.join&&value.indexOf(otherGroup)>-1;}};}var group={};var originalGroup=options.group;if(!originalGroup||_typeof(originalGroup)!='object'){originalGroup={name:originalGroup};}group.name=originalGroup.name;group.checkPull=toFn(originalGroup.pull,true);group.checkPut=toFn(originalGroup.put);group.revertClone=originalGroup.revertClone;options.group=group;},_hideGhostForTarget=function(){if(!supportCssPointerEvents&&ghostEl){css(ghostEl,'display','none');}},_unhideGhostForTarget=function(){if(!supportCssPointerEvents&&ghostEl){css(ghostEl,'display','');}};if(documentExists){document.addEventListener('click',function(evt){if(ignoreNextClick){evt.preventDefault();evt.stopPropagation&&evt.stopPropagation();evt.stopImmediatePropagation&&evt.stopImmediatePropagation();ignoreNextClick=false;return false;}},true);}var nearestEmptyInsertDetectEvent=function(evt){if(dragEl){evt=evt.touches?evt.touches[0]:evt;var nearest=_detectNearestEmptySortable(evt.clientX,evt.clientY);if(nearest){var event={};for(var i in evt){if(evt.hasOwnProperty(i)){event[i]=evt[i];}}event.target=event.rootEl=nearest;event.preventDefault=void 0;event.stopPropagation=void 0;nearest[sortable_core_esm_expando]._onDragOver(event);}}};var _checkOutsideTargetEl=function(evt){if(dragEl){dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(evt.target);}};function Sortable(el,options){if(!(el&&el.nodeType&&el.nodeType===1)){throw"Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));}this.el=el;this.options=options=_extends({},options);el[sortable_core_esm_expando]=this;var defaults={group:null,sort:true,disabled:false,store:null,handle:null,draggable:/^[uo]l$/i.test(el.nodeName)?'>li':'>*',swapThreshold:1,invertSwap:false,invertedSwapThreshold:null,removeCloneOnHide:true,direction:function(){return _detectDirection(el,this.options);},ghostClass:'sortable-ghost',chosenClass:'sortable-chosen',dragClass:'sortable-drag',ignore:'a, img',filter:null,preventOnFilter:true,animation:0,easing:null,setData:function(dataTransfer,dragEl){dataTransfer.setData('Text',dragEl.textContent);},dropBubble:false,dragoverBubble:false,dataIdAttr:'data-id',delay:0,delayOnTouchOnly:false,touchStartThreshold:(Number.parseInt?Number:window).parseInt(window.devicePixelRatio,10)||1,forceFallback:false,fallbackClass:'sortable-fallback',fallbackOnBody:false,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:Sortable.supportPointer!==false&&'PointerEvent'in window,emptyInsertThreshold:5};PluginManager.initializePlugins(this,el,defaults);for(var name in defaults){!(name in options)&&(options[name]=defaults[name]);}_prepareGroup(options);for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}this.nativeDraggable=options.forceFallback?false:supportDraggable;if(this.nativeDraggable){this.options.touchStartThreshold=1;}if(options.supportPointer){sortable_core_esm_on(el,'pointerdown',this._onTapStart);}else{sortable_core_esm_on(el,'mousedown',this._onTapStart);sortable_core_esm_on(el,'touchstart',this._onTapStart);}if(this.nativeDraggable){sortable_core_esm_on(el,'dragover',this);sortable_core_esm_on(el,'dragenter',this);}sortables.push(this.el);options.store&&options.store.get&&this.sort(options.store.get(this)||[]);_extends(this,AnimationStateManager());}Sortable.prototype={constructor:Sortable,_isOutsideThisEl:function(target){if(!this.el.contains(target)&&target!==this.el){lastTarget=null;}},_getDirection:function(evt,target){return typeof this.options.direction==='function'?this.options.direction.call(this,evt,target,dragEl):this.options.direction;},_onTapStart:function(evt){if(!evt.cancelable)return;var _this=this,el=this.el,options=this.options,preventOnFilter=options.preventOnFilter,type=evt.type,touch=evt.touches&&evt.touches[0]||evt.pointerType&&evt.pointerType==='touch'&&evt,target=(touch||evt).target,originalTarget=evt.target.shadowRoot&&(evt.path&&evt.path[0]||evt.composedPath&&evt.composedPath()[0])||target,filter=options.filter;_saveInputCheckedState(el);if(dragEl){return;}if(/mousedown|pointerdown/.test(type)&&evt.button!==0||options.disabled){return;}if(originalTarget.isContentEditable){return;}target=closest(target,options.draggable,el,false);if(target&&target.animated){return;}if(lastDownEl===target){return;}oldIndex=sortable_core_esm_index(target);oldDraggableIndex=sortable_core_esm_index(target,options.draggable);if(typeof filter==='function'){if(filter.call(this,evt,target,this)){_dispatchEvent({sortable:_this,rootEl:originalTarget,name:'filter',targetEl:target,toEl:el,fromEl:el});pluginEvent('filter',_this,{evt:evt});preventOnFilter&&evt.cancelable&&evt.preventDefault();return;}}else if(filter){filter=filter.split(',').some(function(criteria){criteria=closest(originalTarget,criteria.trim(),el,false);if(criteria){_dispatchEvent({sortable:_this,rootEl:criteria,name:'filter',targetEl:target,fromEl:el,toEl:el});pluginEvent('filter',_this,{evt:evt});return true;}});if(filter){preventOnFilter&&evt.cancelable&&evt.preventDefault();return;}}if(options.handle&&!closest(originalTarget,options.handle,el,false)){return;}this._prepareDragStart(evt,touch,target);},_prepareDragStart:function(evt,touch,target){var _this=this,el=_this.el,options=_this.options,ownerDocument=el.ownerDocument,dragStartFn;if(target&&!dragEl&&target.parentNode===el){var dragRect=getRect(target);rootEl=el;dragEl=target;parentEl=dragEl.parentNode;nextEl=dragEl.nextSibling;lastDownEl=target;activeGroup=options.group;Sortable.dragged=dragEl;tapEvt={target:dragEl,clientX:(touch||evt).clientX,clientY:(touch||evt).clientY};tapDistanceLeft=tapEvt.clientX-dragRect.left;tapDistanceTop=tapEvt.clientY-dragRect.top;this._lastX=(touch||evt).clientX;this._lastY=(touch||evt).clientY;dragEl.style['will-change']='all';dragStartFn=function(){pluginEvent('delayEnded',_this,{evt:evt});if(Sortable.eventCanceled){_this._onDrop();return;}_this._disableDelayedDragEvents();if(!FireFox&&_this.nativeDraggable){dragEl.draggable=true;}_this._triggerDragStart(evt,touch);_dispatchEvent({sortable:_this,name:'choose',originalEvent:evt});toggleClass(dragEl,options.chosenClass,true);};options.ignore.split(',').forEach(function(criteria){find(dragEl,criteria.trim(),_disableDraggable);});sortable_core_esm_on(ownerDocument,'dragover',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'mousemove',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'touchmove',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'mouseup',_this._onDrop);sortable_core_esm_on(ownerDocument,'touchend',_this._onDrop);sortable_core_esm_on(ownerDocument,'touchcancel',_this._onDrop);if(FireFox&&this.nativeDraggable){this.options.touchStartThreshold=4;dragEl.draggable=true;}pluginEvent('delayStart',this,{evt:evt});if(options.delay&&(!options.delayOnTouchOnly||touch)&&(!this.nativeDraggable||!(Edge||IE11OrLess))){if(Sortable.eventCanceled){this._onDrop();return;}sortable_core_esm_on(ownerDocument,'mouseup',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'touchend',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'touchcancel',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'mousemove',_this._delayedDragTouchMoveHandler);sortable_core_esm_on(ownerDocument,'touchmove',_this._delayedDragTouchMoveHandler);options.supportPointer&&sortable_core_esm_on(ownerDocument,'pointermove',_this._delayedDragTouchMoveHandler);_this._dragStartTimer=setTimeout(dragStartFn,options.delay);}else{dragStartFn();}}},_delayedDragTouchMoveHandler:function(e){var touch=e.touches?e.touches[0]:e;if(Math.max(Math.abs(touch.clientX-this._lastX),Math.abs(touch.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))){this._disableDelayedDrag();}},_disableDelayedDrag:function(){dragEl&&_disableDraggable(dragEl);clearTimeout(this._dragStartTimer);this._disableDelayedDragEvents();},_disableDelayedDragEvents:function(){var ownerDocument=this.el.ownerDocument;sortable_core_esm_off(ownerDocument,'mouseup',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'touchend',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'touchcancel',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'mousemove',this._delayedDragTouchMoveHandler);sortable_core_esm_off(ownerDocument,'touchmove',this._delayedDragTouchMoveHandler);sortable_core_esm_off(ownerDocument,'pointermove',this._delayedDragTouchMoveHandler);},_triggerDragStart:function(evt,touch){touch=touch||evt.pointerType=='touch'&&evt;if(!this.nativeDraggable||touch){if(this.options.supportPointer){sortable_core_esm_on(document,'pointermove',this._onTouchMove);}else if(touch){sortable_core_esm_on(document,'touchmove',this._onTouchMove);}else{sortable_core_esm_on(document,'mousemove',this._onTouchMove);}}else{sortable_core_esm_on(dragEl,'dragend',this);sortable_core_esm_on(rootEl,'dragstart',this._onDragStart);}try{if(document.selection){_nextTick(function(){document.selection.empty();});}else{window.getSelection().removeAllRanges();}}catch(err){}},_dragStarted:function(fallback,evt){awaitingDragStarted=false;if(rootEl&&dragEl){pluginEvent('dragStarted',this,{evt:evt});if(this.nativeDraggable){sortable_core_esm_on(document,'dragover',_checkOutsideTargetEl);}var options=this.options;!fallback&&toggleClass(dragEl,options.dragClass,false);toggleClass(dragEl,options.ghostClass,true);Sortable.active=this;fallback&&this._appendGhost();_dispatchEvent({sortable:this,name:'start',originalEvent:evt});}else{this._nulling();}},_emulateDragOver:function(){if(touchEvt){this._lastX=touchEvt.clientX;this._lastY=touchEvt.clientY;_hideGhostForTarget();var target=document.elementFromPoint(touchEvt.clientX,touchEvt.clientY);var parent=target;while(target&&target.shadowRoot){target=target.shadowRoot.elementFromPoint(touchEvt.clientX,touchEvt.clientY);if(target===parent)break;parent=target;}dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(target);if(parent){do{if(parent[sortable_core_esm_expando]){var inserted=void 0;inserted=parent[sortable_core_esm_expando]._onDragOver({clientX:touchEvt.clientX,clientY:touchEvt.clientY,target:target,rootEl:parent});if(inserted&&!this.options.dragoverBubble){break;}}target=parent;}while(parent=parent.parentNode);}_unhideGhostForTarget();}},_onTouchMove:function(evt){if(tapEvt){var options=this.options,fallbackTolerance=options.fallbackTolerance,fallbackOffset=options.fallbackOffset,touch=evt.touches?evt.touches[0]:evt,ghostMatrix=ghostEl&&matrix(ghostEl,true),scaleX=ghostEl&&ghostMatrix&&ghostMatrix.a,scaleY=ghostEl&&ghostMatrix&&ghostMatrix.d,relativeScrollOffset=PositionGhostAbsolutely&&ghostRelativeParent&&getRelativeScrollOffset(ghostRelativeParent),dx=(touch.clientX-tapEvt.clientX+fallbackOffset.x)/(scaleX||1)+(relativeScrollOffset?relativeScrollOffset[0]-ghostRelativeParentInitialScroll[0]:0)/(scaleX||1),dy=(touch.clientY-tapEvt.clientY+fallbackOffset.y)/(scaleY||1)+(relativeScrollOffset?relativeScrollOffset[1]-ghostRelativeParentInitialScroll[1]:0)/(scaleY||1);if(!Sortable.active&&!awaitingDragStarted){if(fallbackTolerance&&Math.max(Math.abs(touch.clientX-this._lastX),Math.abs(touch.clientY-this._lastY))<fallbackTolerance){return;}this._onDragStart(evt,true);}if(ghostEl){if(ghostMatrix){ghostMatrix.e+=dx-(lastDx||0);ghostMatrix.f+=dy-(lastDy||0);}else{ghostMatrix={a:1,b:0,c:0,d:1,e:dx,f:dy};}var cssMatrix="matrix(".concat(ghostMatrix.a,",").concat(ghostMatrix.b,",").concat(ghostMatrix.c,",").concat(ghostMatrix.d,",").concat(ghostMatrix.e,",").concat(ghostMatrix.f,")");css(ghostEl,'webkitTransform',cssMatrix);css(ghostEl,'mozTransform',cssMatrix);css(ghostEl,'msTransform',cssMatrix);css(ghostEl,'transform',cssMatrix);lastDx=dx;lastDy=dy;touchEvt=touch;}evt.cancelable&&evt.preventDefault();}},_appendGhost:function(){if(!ghostEl){var container=this.options.fallbackOnBody?document.body:rootEl,rect=getRect(dragEl,true,PositionGhostAbsolutely,true,container),options=this.options;if(PositionGhostAbsolutely){ghostRelativeParent=container;while(css(ghostRelativeParent,'position')==='static'&&css(ghostRelativeParent,'transform')==='none'&&ghostRelativeParent!==document){ghostRelativeParent=ghostRelativeParent.parentNode;}if(ghostRelativeParent!==document.body&&ghostRelativeParent!==document.documentElement){if(ghostRelativeParent===document)ghostRelativeParent=getWindowScrollingElement();rect.top+=ghostRelativeParent.scrollTop;rect.left+=ghostRelativeParent.scrollLeft;}else{ghostRelativeParent=getWindowScrollingElement();}ghostRelativeParentInitialScroll=getRelativeScrollOffset(ghostRelativeParent);}ghostEl=dragEl.cloneNode(true);toggleClass(ghostEl,options.ghostClass,false);toggleClass(ghostEl,options.fallbackClass,true);toggleClass(ghostEl,options.dragClass,true);css(ghostEl,'transition','');css(ghostEl,'transform','');css(ghostEl,'box-sizing','border-box');css(ghostEl,'margin',0);css(ghostEl,'top',rect.top);css(ghostEl,'left',rect.left);css(ghostEl,'width',rect.width);css(ghostEl,'height',rect.height);css(ghostEl,'opacity','0.8');css(ghostEl,'position',PositionGhostAbsolutely?'absolute':'fixed');css(ghostEl,'zIndex','100000');css(ghostEl,'pointerEvents','none');Sortable.ghost=ghostEl;container.appendChild(ghostEl);css(ghostEl,'transform-origin',tapDistanceLeft/parseInt(ghostEl.style.width)*100+'% '+tapDistanceTop/parseInt(ghostEl.style.height)*100+'%');}},_onDragStart:function(evt,fallback){var _this=this;var dataTransfer=evt.dataTransfer;var options=_this.options;pluginEvent('dragStart',this,{evt:evt});if(Sortable.eventCanceled){this._onDrop();return;}pluginEvent('setupClone',this);if(!Sortable.eventCanceled){cloneEl=clone(dragEl);cloneEl.draggable=false;cloneEl.style['will-change']='';this._hideClone();toggleClass(cloneEl,this.options.chosenClass,false);Sortable.clone=cloneEl;}_this.cloneId=_nextTick(function(){pluginEvent('clone',_this);if(Sortable.eventCanceled)return;if(!_this.options.removeCloneOnHide){rootEl.insertBefore(cloneEl,dragEl);}_this._hideClone();_dispatchEvent({sortable:_this,name:'clone'});});!fallback&&toggleClass(dragEl,options.dragClass,true);if(fallback){ignoreNextClick=true;_this._loopId=setInterval(_this._emulateDragOver,50);}else{sortable_core_esm_off(document,'mouseup',_this._onDrop);sortable_core_esm_off(document,'touchend',_this._onDrop);sortable_core_esm_off(document,'touchcancel',_this._onDrop);if(dataTransfer){dataTransfer.effectAllowed='move';options.setData&&options.setData.call(_this,dataTransfer,dragEl);}sortable_core_esm_on(document,'drop',_this);css(dragEl,'transform','translateZ(0)');}awaitingDragStarted=true;_this._dragStartId=_nextTick(_this._dragStarted.bind(_this,fallback,evt));sortable_core_esm_on(document,'selectstart',_this);moved=true;if(Safari){css(document.body,'user-select','none');}},_onDragOver:function(evt){var el=this.el,target=evt.target,dragRect,targetRect,revert,options=this.options,group=options.group,activeSortable=Sortable.active,isOwner=activeGroup===group,canSort=options.sort,fromSortable=putSortable||activeSortable,vertical,_this=this,completedFired=false;if(_silent)return;function dragOverEvent(name,extra){pluginEvent(name,_this,_objectSpread({evt:evt,isOwner:isOwner,axis:vertical?'vertical':'horizontal',revert:revert,dragRect:dragRect,targetRect:targetRect,canSort:canSort,fromSortable:fromSortable,target:target,completed:completed,onMove:function(target,after){return _onMove(rootEl,el,dragEl,dragRect,target,getRect(target),evt,after);},changed:changed},extra));}function capture(){dragOverEvent('dragOverAnimationCapture');_this.captureAnimationState();if(_this!==fromSortable){fromSortable.captureAnimationState();}}function completed(insertion){dragOverEvent('dragOverCompleted',{insertion:insertion});if(insertion){if(isOwner){activeSortable._hideClone();}else{activeSortable._showClone(_this);}if(_this!==fromSortable){toggleClass(dragEl,putSortable?putSortable.options.ghostClass:activeSortable.options.ghostClass,false);toggleClass(dragEl,options.ghostClass,true);}if(putSortable!==_this&&_this!==Sortable.active){putSortable=_this;}else if(_this===Sortable.active&&putSortable){putSortable=null;}if(fromSortable===_this){_this._ignoreWhileAnimating=target;}_this.animateAll(function(){dragOverEvent('dragOverAnimationComplete');_this._ignoreWhileAnimating=null;});if(_this!==fromSortable){fromSortable.animateAll();fromSortable._ignoreWhileAnimating=null;}}if(target===dragEl&&!dragEl.animated||target===el&&!target.animated){lastTarget=null;}if(!options.dragoverBubble&&!evt.rootEl&&target!==document){dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(evt.target);!insertion&&nearestEmptyInsertDetectEvent(evt);}!options.dragoverBubble&&evt.stopPropagation&&evt.stopPropagation();return completedFired=true;}function changed(){sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);_dispatchEvent({sortable:_this,name:'change',toEl:el,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex,originalEvent:evt});}if(evt.preventDefault!==void 0){evt.cancelable&&evt.preventDefault();}target=closest(target,options.draggable,el,true);dragOverEvent('dragOver');if(Sortable.eventCanceled)return completedFired;if(dragEl.contains(evt.target)||target.animated&&target.animatingX&&target.animatingY||_this._ignoreWhileAnimating===target){return completed(false);}ignoreNextClick=false;if(activeSortable&&!options.disabled&&(isOwner?canSort||(revert=!rootEl.contains(dragEl)):putSortable===this||(this.lastPutMode=activeGroup.checkPull(this,activeSortable,dragEl,evt))&&group.checkPut(this,activeSortable,dragEl,evt))){vertical=this._getDirection(evt,target)==='vertical';dragRect=getRect(dragEl);dragOverEvent('dragOverValid');if(Sortable.eventCanceled)return completedFired;if(revert){parentEl=rootEl;capture();this._hideClone();dragOverEvent('revert');if(!Sortable.eventCanceled){if(nextEl){rootEl.insertBefore(dragEl,nextEl);}else{rootEl.appendChild(dragEl);}}return completed(true);}var elLastChild=lastChild(el,options.draggable);if(!elLastChild||_ghostIsLast(evt,vertical,this)&&!elLastChild.animated){if(elLastChild===dragEl){return completed(false);}if(elLastChild&&el===evt.target){target=elLastChild;}if(target){targetRect=getRect(target);}if(_onMove(rootEl,el,dragEl,dragRect,target,targetRect,evt,!!target)!==false){capture();el.appendChild(dragEl);parentEl=el;changed();return completed(true);}}else if(target.parentNode===el){targetRect=getRect(target);var direction=0,targetBeforeFirstSwap,differentLevel=dragEl.parentNode!==el,differentRowCol=!_dragElInRowColumn(dragEl.animated&&dragEl.toRect||dragRect,target.animated&&target.toRect||targetRect,vertical),side1=vertical?'top':'left',scrolledPastTop=isScrolledPast(target,'top','top')||isScrolledPast(dragEl,'top','top'),scrollBefore=scrolledPastTop?scrolledPastTop.scrollTop:void 0;if(lastTarget!==target){targetBeforeFirstSwap=targetRect[side1];pastFirstInvertThresh=false;isCircumstantialInvert=!differentRowCol&&options.invertSwap||differentLevel;}direction=_getSwapDirection(evt,target,targetRect,vertical,differentRowCol?1:options.swapThreshold,options.invertedSwapThreshold==null?options.swapThreshold:options.invertedSwapThreshold,isCircumstantialInvert,lastTarget===target);var sibling;if(direction!==0){var dragIndex=sortable_core_esm_index(dragEl);do{dragIndex-=direction;sibling=parentEl.children[dragIndex];}while(sibling&&(css(sibling,'display')==='none'||sibling===ghostEl));}if(direction===0||sibling===target){return completed(false);}lastTarget=target;lastDirection=direction;var nextSibling=target.nextElementSibling,after=false;after=direction===1;var moveVector=_onMove(rootEl,el,dragEl,dragRect,target,targetRect,evt,after);if(moveVector!==false){if(moveVector===1||moveVector===-1){after=moveVector===1;}_silent=true;setTimeout(_unsilent,30);capture();if(after&&!nextSibling){el.appendChild(dragEl);}else{target.parentNode.insertBefore(dragEl,after?nextSibling:target);}if(scrolledPastTop){scrollBy(scrolledPastTop,0,scrollBefore-scrolledPastTop.scrollTop);}parentEl=dragEl.parentNode;if(targetBeforeFirstSwap!==undefined&&!isCircumstantialInvert){targetMoveDistance=Math.abs(targetBeforeFirstSwap-getRect(target)[side1]);}changed();return completed(true);}}if(el.contains(dragEl)){return completed(false);}}return false;},_ignoreWhileAnimating:null,_offMoveEvents:function(){sortable_core_esm_off(document,'mousemove',this._onTouchMove);sortable_core_esm_off(document,'touchmove',this._onTouchMove);sortable_core_esm_off(document,'pointermove',this._onTouchMove);sortable_core_esm_off(document,'dragover',nearestEmptyInsertDetectEvent);sortable_core_esm_off(document,'mousemove',nearestEmptyInsertDetectEvent);sortable_core_esm_off(document,'touchmove',nearestEmptyInsertDetectEvent);},_offUpEvents:function(){var ownerDocument=this.el.ownerDocument;sortable_core_esm_off(ownerDocument,'mouseup',this._onDrop);sortable_core_esm_off(ownerDocument,'touchend',this._onDrop);sortable_core_esm_off(ownerDocument,'pointerup',this._onDrop);sortable_core_esm_off(ownerDocument,'touchcancel',this._onDrop);sortable_core_esm_off(document,'selectstart',this);},_onDrop:function(evt){var el=this.el,options=this.options;sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);pluginEvent('drop',this,{evt:evt});parentEl=dragEl&&dragEl.parentNode;sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);if(Sortable.eventCanceled){this._nulling();return;}awaitingDragStarted=false;isCircumstantialInvert=false;pastFirstInvertThresh=false;clearInterval(this._loopId);clearTimeout(this._dragStartTimer);_cancelNextTick(this.cloneId);_cancelNextTick(this._dragStartId);if(this.nativeDraggable){sortable_core_esm_off(document,'drop',this);sortable_core_esm_off(el,'dragstart',this._onDragStart);}this._offMoveEvents();this._offUpEvents();if(Safari){css(document.body,'user-select','');}css(dragEl,'transform','');if(evt){if(moved){evt.cancelable&&evt.preventDefault();!options.dropBubble&&evt.stopPropagation();}ghostEl&&ghostEl.parentNode&&ghostEl.parentNode.removeChild(ghostEl);if(rootEl===parentEl||putSortable&&putSortable.lastPutMode!=='clone'){cloneEl&&cloneEl.parentNode&&cloneEl.parentNode.removeChild(cloneEl);}if(dragEl){if(this.nativeDraggable){sortable_core_esm_off(dragEl,'dragend',this);}_disableDraggable(dragEl);dragEl.style['will-change']='';if(moved&&!awaitingDragStarted){toggleClass(dragEl,putSortable?putSortable.options.ghostClass:this.options.ghostClass,false);}toggleClass(dragEl,this.options.chosenClass,false);_dispatchEvent({sortable:this,name:'unchoose',toEl:parentEl,newIndex:null,newDraggableIndex:null,originalEvent:evt});if(rootEl!==parentEl){if(sortable_core_esm_newIndex>=0){_dispatchEvent({rootEl:parentEl,name:'add',toEl:parentEl,fromEl:rootEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'remove',toEl:parentEl,originalEvent:evt});_dispatchEvent({rootEl:parentEl,name:'sort',toEl:parentEl,fromEl:rootEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'sort',toEl:parentEl,originalEvent:evt});}putSortable&&putSortable.save();}else{if(sortable_core_esm_newIndex!==oldIndex){if(sortable_core_esm_newIndex>=0){_dispatchEvent({sortable:this,name:'update',toEl:parentEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'sort',toEl:parentEl,originalEvent:evt});}}}if(Sortable.active){if(sortable_core_esm_newIndex==null||sortable_core_esm_newIndex===-1){sortable_core_esm_newIndex=oldIndex;newDraggableIndex=oldDraggableIndex;}_dispatchEvent({sortable:this,name:'end',toEl:parentEl,originalEvent:evt});this.save();}}}this._nulling();},_nulling:function(){pluginEvent('nulling',this);rootEl=dragEl=parentEl=ghostEl=nextEl=cloneEl=lastDownEl=cloneHidden=tapEvt=touchEvt=moved=sortable_core_esm_newIndex=newDraggableIndex=oldIndex=oldDraggableIndex=lastTarget=lastDirection=putSortable=activeGroup=Sortable.dragged=Sortable.ghost=Sortable.clone=Sortable.active=null;savedInputChecked.forEach(function(el){el.checked=true;});savedInputChecked.length=lastDx=lastDy=0;},handleEvent:function(evt){switch(evt.type){case'drop':case'dragend':this._onDrop(evt);break;case'dragenter':case'dragover':if(dragEl){this._onDragOver(evt);_globalDragOver(evt);}break;case'selectstart':evt.preventDefault();break;}},toArray:function(){var order=[],el,children=this.el.children,i=0,n=children.length,options=this.options;for(;i<n;i++){el=children[i];if(closest(el,options.draggable,this.el,false)){order.push(el.getAttribute(options.dataIdAttr)||_generateId(el));}}return order;},sort:function(order){var items={},rootEl=this.el;this.toArray().forEach(function(id,i){var el=rootEl.children[i];if(closest(el,this.options.draggable,rootEl,false)){items[id]=el;}},this);order.forEach(function(id){if(items[id]){rootEl.removeChild(items[id]);rootEl.appendChild(items[id]);}});},save:function(){var store=this.options.store;store&&store.set&&store.set(this);},closest:function(el,selector){return closest(el,selector||this.options.draggable,this.el,false);},option:function(name,value){var options=this.options;if(value===void 0){return options[name];}else{var modifiedValue=PluginManager.modifyOption(this,name,value);if(typeof modifiedValue!=='undefined'){options[name]=modifiedValue;}else{options[name]=value;}if(name==='group'){_prepareGroup(options);}}},destroy:function(){pluginEvent('destroy',this);var el=this.el;el[sortable_core_esm_expando]=null;sortable_core_esm_off(el,'mousedown',this._onTapStart);sortable_core_esm_off(el,'touchstart',this._onTapStart);sortable_core_esm_off(el,'pointerdown',this._onTapStart);if(this.nativeDraggable){sortable_core_esm_off(el,'dragover',this);sortable_core_esm_off(el,'dragenter',this);}Array.prototype.forEach.call(el.querySelectorAll('[draggable]'),function(el){el.removeAttribute('draggable');});this._onDrop();this._disableDelayedDragEvents();sortables.splice(sortables.indexOf(this.el),1);this.el=el=null;},_hideClone:function(){if(!cloneHidden){pluginEvent('hideClone',this);if(Sortable.eventCanceled)return;css(cloneEl,'display','none');if(this.options.removeCloneOnHide&&cloneEl.parentNode){cloneEl.parentNode.removeChild(cloneEl);}cloneHidden=true;}},_showClone:function(putSortable){if(putSortable.lastPutMode!=='clone'){this._hideClone();return;}if(cloneHidden){pluginEvent('showClone',this);if(Sortable.eventCanceled)return;if(rootEl.contains(dragEl)&&!this.options.group.revertClone){rootEl.insertBefore(cloneEl,dragEl);}else if(nextEl){rootEl.insertBefore(cloneEl,nextEl);}else{rootEl.appendChild(cloneEl);}if(this.options.group.revertClone){this.animate(dragEl,cloneEl);}css(cloneEl,'display','');cloneHidden=false;}}};function _globalDragOver(evt){if(evt.dataTransfer){evt.dataTransfer.dropEffect='move';}evt.cancelable&&evt.preventDefault();}function _onMove(fromEl,toEl,dragEl,dragRect,targetEl,targetRect,originalEvent,willInsertAfter){var evt,sortable=fromEl[sortable_core_esm_expando],onMoveFn=sortable.options.onMove,retVal;if(window.CustomEvent&&!IE11OrLess&&!Edge){evt=new CustomEvent('move',{bubbles:true,cancelable:true});}else{evt=document.createEvent('Event');evt.initEvent('move',true,true);}evt.to=toEl;evt.from=fromEl;evt.dragged=dragEl;evt.draggedRect=dragRect;evt.related=targetEl||toEl;evt.relatedRect=targetRect||getRect(toEl);evt.willInsertAfter=willInsertAfter;evt.originalEvent=originalEvent;fromEl.dispatchEvent(evt);if(onMoveFn){retVal=onMoveFn.call(sortable,evt,originalEvent);}return retVal;}function _disableDraggable(el){el.draggable=false;}function _unsilent(){_silent=false;}function _ghostIsLast(evt,vertical,sortable){var rect=getRect(lastChild(sortable.el,sortable.options.draggable));var spacer=10;return vertical?evt.clientX>rect.right+spacer||evt.clientX<=rect.right&&evt.clientY>rect.bottom&&evt.clientX>=rect.left:evt.clientX>rect.right&&evt.clientY>rect.top||evt.clientX<=rect.right&&evt.clientY>rect.bottom+spacer;}function _getSwapDirection(evt,target,targetRect,vertical,swapThreshold,invertedSwapThreshold,invertSwap,isLastTarget){var mouseOnAxis=vertical?evt.clientY:evt.clientX,targetLength=vertical?targetRect.height:targetRect.width,targetS1=vertical?targetRect.top:targetRect.left,targetS2=vertical?targetRect.bottom:targetRect.right,invert=false;if(!invertSwap){if(isLastTarget&&targetMoveDistance<targetLength*swapThreshold){if(!pastFirstInvertThresh&&(lastDirection===1?mouseOnAxis>targetS1+targetLength*invertedSwapThreshold/2:mouseOnAxis<targetS2-targetLength*invertedSwapThreshold/2)){pastFirstInvertThresh=true;}if(!pastFirstInvertThresh){if(lastDirection===1?mouseOnAxis<targetS1+targetMoveDistance:mouseOnAxis>targetS2-targetMoveDistance){return-lastDirection;}}else{invert=true;}}else{if(mouseOnAxis>targetS1+targetLength*(1-swapThreshold)/2&&mouseOnAxis<targetS2-targetLength*(1-swapThreshold)/2){return _getInsertDirection(target);}}}invert=invert||invertSwap;if(invert){if(mouseOnAxis<targetS1+targetLength*invertedSwapThreshold/2||mouseOnAxis>targetS2-targetLength*invertedSwapThreshold/2){return mouseOnAxis>targetS1+targetLength/2?1:-1;}}return 0;}function _getInsertDirection(target){if(sortable_core_esm_index(dragEl)<sortable_core_esm_index(target)){return 1;}else{return-1;}}function _generateId(el){var str=el.tagName+el.className+el.src+el.href+el.textContent,i=str.length,sum=0;while(i--){sum+=str.charCodeAt(i);}return sum.toString(36);}function _saveInputCheckedState(root){savedInputChecked.length=0;var inputs=root.getElementsByTagName('input');var idx=inputs.length;while(idx--){var el=inputs[idx];el.checked&&savedInputChecked.push(el);}}function _nextTick(fn){return setTimeout(fn,0);}function _cancelNextTick(id){return clearTimeout(id);}if(documentExists){sortable_core_esm_on(document,'touchmove',function(evt){if((Sortable.active||awaitingDragStarted)&&evt.cancelable){evt.preventDefault();}});}Sortable.utils={on:sortable_core_esm_on,off:sortable_core_esm_off,css:css,find:find,is:function(el,selector){return!!closest(el,selector,el,false);},extend:extend,throttle:sortable_core_esm_throttle,closest:closest,toggleClass:toggleClass,clone:clone,index:sortable_core_esm_index,nextTick:_nextTick,cancelNextTick:_cancelNextTick,detectDirection:_detectDirection,getChild:getChild};Sortable.get=function(element){return element[sortable_core_esm_expando];};Sortable.mount=function(){for(var _len=arguments.length,plugins=new Array(_len),_key=0;_key<_len;_key++){plugins[_key]=arguments[_key];}if(plugins[0].constructor===Array)plugins=plugins[0];plugins.forEach(function(plugin){if(!plugin.prototype||!plugin.prototype.constructor){throw"Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));}if(plugin.utils)Sortable.utils=_objectSpread({},Sortable.utils,plugin.utils);PluginManager.mount(plugin);});};Sortable.create=function(el,options){return new Sortable(el,options);};Sortable.version=sortable_core_esm_version;var autoScrolls=[],scrollEl,scrollRootEl,scrolling=false,lastAutoScrollX,lastAutoScrollY,touchEvt$1,pointerElemChangedInterval;function AutoScrollPlugin(){function AutoScroll(){this.defaults={scroll:true,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:true};for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}}AutoScroll.prototype={dragStarted:function(_ref){var originalEvent=_ref.originalEvent;if(this.sortable.nativeDraggable){sortable_core_esm_on(document,'dragover',this._handleAutoScroll);}else{if(this.options.supportPointer){sortable_core_esm_on(document,'pointermove',this._handleFallbackAutoScroll);}else if(originalEvent.touches){sortable_core_esm_on(document,'touchmove',this._handleFallbackAutoScroll);}else{sortable_core_esm_on(document,'mousemove',this._handleFallbackAutoScroll);}}},dragOverCompleted:function(_ref2){var originalEvent=_ref2.originalEvent;if(!this.options.dragOverBubble&&!originalEvent.rootEl){this._handleAutoScroll(originalEvent);}},drop:function(){if(this.sortable.nativeDraggable){sortable_core_esm_off(document,'dragover',this._handleAutoScroll);}else{sortable_core_esm_off(document,'pointermove',this._handleFallbackAutoScroll);sortable_core_esm_off(document,'touchmove',this._handleFallbackAutoScroll);sortable_core_esm_off(document,'mousemove',this._handleFallbackAutoScroll);}clearPointerElemChangedInterval();clearAutoScrolls();cancelThrottle();},nulling:function(){touchEvt$1=scrollRootEl=scrollEl=scrolling=pointerElemChangedInterval=lastAutoScrollX=lastAutoScrollY=null;autoScrolls.length=0;},_handleFallbackAutoScroll:function(evt){this._handleAutoScroll(evt,true);},_handleAutoScroll:function(evt,fallback){var _this=this;var x=(evt.touches?evt.touches[0]:evt).clientX,y=(evt.touches?evt.touches[0]:evt).clientY,elem=document.elementFromPoint(x,y);touchEvt$1=evt;if(fallback||Edge||IE11OrLess||Safari){autoScroll(evt,this.options,elem,fallback);var ogElemScroller=getParentAutoScrollElement(elem,true);if(scrolling&&(!pointerElemChangedInterval||x!==lastAutoScrollX||y!==lastAutoScrollY)){pointerElemChangedInterval&&clearPointerElemChangedInterval();pointerElemChangedInterval=setInterval(function(){var newElem=getParentAutoScrollElement(document.elementFromPoint(x,y),true);if(newElem!==ogElemScroller){ogElemScroller=newElem;clearAutoScrolls();}autoScroll(evt,_this.options,newElem,fallback);},10);lastAutoScrollX=x;lastAutoScrollY=y;}}else{if(!this.options.bubbleScroll||getParentAutoScrollElement(elem,true)===getWindowScrollingElement()){clearAutoScrolls();return;}autoScroll(evt,this.options,getParentAutoScrollElement(elem,false),false);}}};return _extends(AutoScroll,{pluginName:'scroll',initializeByDefault:true});}function clearAutoScrolls(){autoScrolls.forEach(function(autoScroll){clearInterval(autoScroll.pid);});autoScrolls=[];}function clearPointerElemChangedInterval(){clearInterval(pointerElemChangedInterval);}var autoScroll=sortable_core_esm_throttle(function(evt,options,rootEl,isFallback){if(!options.scroll)return;var x=(evt.touches?evt.touches[0]:evt).clientX,y=(evt.touches?evt.touches[0]:evt).clientY,sens=options.scrollSensitivity,speed=options.scrollSpeed,winScroller=getWindowScrollingElement();var scrollThisInstance=false,scrollCustomFn;if(scrollRootEl!==rootEl){scrollRootEl=rootEl;clearAutoScrolls();scrollEl=options.scroll;scrollCustomFn=options.scrollFn;if(scrollEl===true){scrollEl=getParentAutoScrollElement(rootEl,true);}}var layersOut=0;var currentParent=scrollEl;do{var el=currentParent,rect=getRect(el),top=rect.top,bottom=rect.bottom,left=rect.left,right=rect.right,width=rect.width,height=rect.height,canScrollX=void 0,canScrollY=void 0,scrollWidth=el.scrollWidth,scrollHeight=el.scrollHeight,elCSS=css(el),scrollPosX=el.scrollLeft,scrollPosY=el.scrollTop;if(el===winScroller){canScrollX=width<scrollWidth&&(elCSS.overflowX==='auto'||elCSS.overflowX==='scroll'||elCSS.overflowX==='visible');canScrollY=height<scrollHeight&&(elCSS.overflowY==='auto'||elCSS.overflowY==='scroll'||elCSS.overflowY==='visible');}else{canScrollX=width<scrollWidth&&(elCSS.overflowX==='auto'||elCSS.overflowX==='scroll');canScrollY=height<scrollHeight&&(elCSS.overflowY==='auto'||elCSS.overflowY==='scroll');}var vx=canScrollX&&(Math.abs(right-x)<=sens&&scrollPosX+width<scrollWidth)-(Math.abs(left-x)<=sens&&!!scrollPosX);var vy=canScrollY&&(Math.abs(bottom-y)<=sens&&scrollPosY+height<scrollHeight)-(Math.abs(top-y)<=sens&&!!scrollPosY);if(!autoScrolls[layersOut]){for(var i=0;i<=layersOut;i++){if(!autoScrolls[i]){autoScrolls[i]={};}}}if(autoScrolls[layersOut].vx!=vx||autoScrolls[layersOut].vy!=vy||autoScrolls[layersOut].el!==el){autoScrolls[layersOut].el=el;autoScrolls[layersOut].vx=vx;autoScrolls[layersOut].vy=vy;clearInterval(autoScrolls[layersOut].pid);if(vx!=0||vy!=0){scrollThisInstance=true;autoScrolls[layersOut].pid=setInterval(function(){if(isFallback&&this.layer===0){Sortable.active._onTouchMove(touchEvt$1);}var scrollOffsetY=autoScrolls[this.layer].vy?autoScrolls[this.layer].vy*speed:0;var scrollOffsetX=autoScrolls[this.layer].vx?autoScrolls[this.layer].vx*speed:0;if(typeof scrollCustomFn==='function'){if(scrollCustomFn.call(Sortable.dragged.parentNode[sortable_core_esm_expando],scrollOffsetX,scrollOffsetY,evt,touchEvt$1,autoScrolls[this.layer].el)!=='continue'){return;}}scrollBy(autoScrolls[this.layer].el,scrollOffsetX,scrollOffsetY);}.bind({layer:layersOut}),24);}}layersOut++;}while(options.bubbleScroll&&currentParent!==winScroller&&(currentParent=getParentAutoScrollElement(currentParent,false)));scrolling=scrollThisInstance;},30);var drop=function(_ref){var originalEvent=_ref.originalEvent,putSortable=_ref.putSortable,dragEl=_ref.dragEl,activeSortable=_ref.activeSortable,dispatchSortableEvent=_ref.dispatchSortableEvent,hideGhostForTarget=_ref.hideGhostForTarget,unhideGhostForTarget=_ref.unhideGhostForTarget;if(!originalEvent)return;var toSortable=putSortable||activeSortable;hideGhostForTarget();var touch=originalEvent.changedTouches&&originalEvent.changedTouches.length?originalEvent.changedTouches[0]:originalEvent;var target=document.elementFromPoint(touch.clientX,touch.clientY);unhideGhostForTarget();if(toSortable&&!toSortable.el.contains(target)){dispatchSortableEvent('spill');this.onSpill({dragEl:dragEl,putSortable:putSortable});}};function Revert(){}Revert.prototype={startIndex:null,dragStart:function(_ref2){var oldDraggableIndex=_ref2.oldDraggableIndex;this.startIndex=oldDraggableIndex;},onSpill:function(_ref3){var dragEl=_ref3.dragEl,putSortable=_ref3.putSortable;this.sortable.captureAnimationState();if(putSortable){putSortable.captureAnimationState();}var nextSibling=getChild(this.sortable.el,this.startIndex,this.options);if(nextSibling){this.sortable.el.insertBefore(dragEl,nextSibling);}else{this.sortable.el.appendChild(dragEl);}this.sortable.animateAll();if(putSortable){putSortable.animateAll();}},drop:drop};_extends(Revert,{pluginName:'revertOnSpill'});function Remove(){}Remove.prototype={onSpill:function(_ref4){var dragEl=_ref4.dragEl,putSortable=_ref4.putSortable;var parentSortable=putSortable||this.sortable;parentSortable.captureAnimationState();dragEl.parentNode&&dragEl.parentNode.removeChild(dragEl);parentSortable.animateAll();},drop:drop};_extends(Remove,{pluginName:'removeOnSpill'});var OnSpill=[Remove,Revert];var lastSwapEl;function SwapPlugin(){function Swap(){this.defaults={swapClass:'sortable-swap-highlight'};}Swap.prototype={dragStart:function(_ref){var dragEl=_ref.dragEl;lastSwapEl=dragEl;},dragOverValid:function(_ref2){var completed=_ref2.completed,target=_ref2.target,onMove=_ref2.onMove,activeSortable=_ref2.activeSortable,changed=_ref2.changed,cancel=_ref2.cancel;if(!activeSortable.options.swap)return;var el=this.sortable.el,options=this.options;if(target&&target!==el){var prevSwapEl=lastSwapEl;if(onMove(target)!==false){toggleClass(target,options.swapClass,true);lastSwapEl=target;}else{lastSwapEl=null;}if(prevSwapEl&&prevSwapEl!==lastSwapEl){toggleClass(prevSwapEl,options.swapClass,false);}}changed();completed(true);cancel();},drop:function(_ref3){var activeSortable=_ref3.activeSortable,putSortable=_ref3.putSortable,dragEl=_ref3.dragEl;var toSortable=putSortable||this.sortable;var options=this.options;lastSwapEl&&toggleClass(lastSwapEl,options.swapClass,false);if(lastSwapEl&&(options.swap||putSortable&&putSortable.options.swap)){if(dragEl!==lastSwapEl){toSortable.captureAnimationState();if(toSortable!==activeSortable)activeSortable.captureAnimationState();swapNodes(dragEl,lastSwapEl);toSortable.animateAll();if(toSortable!==activeSortable)activeSortable.animateAll();}}},nulling:function(){lastSwapEl=null;}};return _extends(Swap,{pluginName:'swap',eventProperties:function(){return{swapItem:lastSwapEl};}});}function swapNodes(n1,n2){var p1=n1.parentNode,p2=n2.parentNode,i1,i2;if(!p1||!p2||p1.isEqualNode(n2)||p2.isEqualNode(n1))return;i1=sortable_core_esm_index(n1);i2=sortable_core_esm_index(n2);if(p1.isEqualNode(p2)&&i1<i2){i2++;}p1.insertBefore(n2,p1.children[i1]);p2.insertBefore(n1,p2.children[i2]);}var multiDragElements=[],multiDragClones=[],lastMultiDragSelect,multiDragSortable,initialFolding=false,folding=false,dragStarted=false,dragEl$1,clonesFromRect,clonesHidden;function MultiDragPlugin(){function MultiDrag(sortable){for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}if(sortable.options.supportPointer){sortable_core_esm_on(document,'pointerup',this._deselectMultiDrag);}else{sortable_core_esm_on(document,'mouseup',this._deselectMultiDrag);sortable_core_esm_on(document,'touchend',this._deselectMultiDrag);}sortable_core_esm_on(document,'keydown',this._checkKeyDown);sortable_core_esm_on(document,'keyup',this._checkKeyUp);this.defaults={selectedClass:'sortable-selected',multiDragKey:null,setData:function(dataTransfer,dragEl){var data='';if(multiDragElements.length&&multiDragSortable===sortable){multiDragElements.forEach(function(multiDragElement,i){data+=(!i?'':', ')+multiDragElement.textContent;});}else{data=dragEl.textContent;}dataTransfer.setData('Text',data);}};}MultiDrag.prototype={multiDragKeyDown:false,isMultiDrag:false,delayStartGlobal:function(_ref){var dragged=_ref.dragEl;dragEl$1=dragged;},delayEnded:function(){this.isMultiDrag=~multiDragElements.indexOf(dragEl$1);},setupClone:function(_ref2){var sortable=_ref2.sortable,cancel=_ref2.cancel;if(!this.isMultiDrag)return;for(var i=0;i<multiDragElements.length;i++){multiDragClones.push(clone(multiDragElements[i]));multiDragClones[i].sortableIndex=multiDragElements[i].sortableIndex;multiDragClones[i].draggable=false;multiDragClones[i].style['will-change']='';toggleClass(multiDragClones[i],this.options.selectedClass,false);multiDragElements[i]===dragEl$1&&toggleClass(multiDragClones[i],this.options.chosenClass,false);}sortable._hideClone();cancel();},clone:function(_ref3){var sortable=_ref3.sortable,rootEl=_ref3.rootEl,dispatchSortableEvent=_ref3.dispatchSortableEvent,cancel=_ref3.cancel;if(!this.isMultiDrag)return;if(!this.options.removeCloneOnHide){if(multiDragElements.length&&multiDragSortable===sortable){insertMultiDragClones(true,rootEl);dispatchSortableEvent('clone');cancel();}}},showClone:function(_ref4){var cloneNowShown=_ref4.cloneNowShown,rootEl=_ref4.rootEl,cancel=_ref4.cancel;if(!this.isMultiDrag)return;insertMultiDragClones(false,rootEl);multiDragClones.forEach(function(clone){css(clone,'display','');});cloneNowShown();clonesHidden=false;cancel();},hideClone:function(_ref5){var _this=this;var sortable=_ref5.sortable,cloneNowHidden=_ref5.cloneNowHidden,cancel=_ref5.cancel;if(!this.isMultiDrag)return;multiDragClones.forEach(function(clone){css(clone,'display','none');if(_this.options.removeCloneOnHide&&clone.parentNode){clone.parentNode.removeChild(clone);}});cloneNowHidden();clonesHidden=true;cancel();},dragStartGlobal:function(_ref6){_ref6.sortable;if(!this.isMultiDrag&&multiDragSortable){multiDragSortable.multiDrag._deselectMultiDrag();}multiDragElements.forEach(function(multiDragElement){multiDragElement.sortableIndex=sortable_core_esm_index(multiDragElement);});multiDragElements=multiDragElements.sort(function(a,b){return a.sortableIndex-b.sortableIndex;});dragStarted=true;},dragStarted:function(_ref7){var _this2=this;var sortable=_ref7.sortable;if(!this.isMultiDrag)return;if(this.options.sort){sortable.captureAnimationState();if(this.options.animation){multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;css(multiDragElement,'position','absolute');});var dragRect=getRect(dragEl$1,false,true,true);multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;setRect(multiDragElement,dragRect);});folding=true;initialFolding=true;}}sortable.animateAll(function(){folding=false;initialFolding=false;if(_this2.options.animation){multiDragElements.forEach(function(multiDragElement){unsetRect(multiDragElement);});}if(_this2.options.sort){removeMultiDragElements();}});},dragOver:function(_ref8){var target=_ref8.target,completed=_ref8.completed,cancel=_ref8.cancel;if(folding&&~multiDragElements.indexOf(target)){completed(false);cancel();}},revert:function(_ref9){var fromSortable=_ref9.fromSortable,rootEl=_ref9.rootEl,sortable=_ref9.sortable,dragRect=_ref9.dragRect;if(multiDragElements.length>1){multiDragElements.forEach(function(multiDragElement){sortable.addAnimationState({target:multiDragElement,rect:folding?getRect(multiDragElement):dragRect});unsetRect(multiDragElement);multiDragElement.fromRect=dragRect;fromSortable.removeAnimationState(multiDragElement);});folding=false;insertMultiDragElements(!this.options.removeCloneOnHide,rootEl);}},dragOverCompleted:function(_ref10){var sortable=_ref10.sortable,isOwner=_ref10.isOwner,insertion=_ref10.insertion,activeSortable=_ref10.activeSortable,parentEl=_ref10.parentEl,putSortable=_ref10.putSortable;var options=this.options;if(insertion){if(isOwner){activeSortable._hideClone();}initialFolding=false;if(options.animation&&multiDragElements.length>1&&(folding||!isOwner&&!activeSortable.options.sort&&!putSortable)){var dragRectAbsolute=getRect(dragEl$1,false,true,true);multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;setRect(multiDragElement,dragRectAbsolute);parentEl.appendChild(multiDragElement);});folding=true;}if(!isOwner){if(!folding){removeMultiDragElements();}if(multiDragElements.length>1){var clonesHiddenBefore=clonesHidden;activeSortable._showClone(sortable);if(activeSortable.options.animation&&!clonesHidden&&clonesHiddenBefore){multiDragClones.forEach(function(clone){activeSortable.addAnimationState({target:clone,rect:clonesFromRect});clone.fromRect=clonesFromRect;clone.thisAnimationDuration=null;});}}else{activeSortable._showClone(sortable);}}}},dragOverAnimationCapture:function(_ref11){var dragRect=_ref11.dragRect,isOwner=_ref11.isOwner,activeSortable=_ref11.activeSortable;multiDragElements.forEach(function(multiDragElement){multiDragElement.thisAnimationDuration=null;});if(activeSortable.options.animation&&!isOwner&&activeSortable.multiDrag.isMultiDrag){clonesFromRect=_extends({},dragRect);var dragMatrix=matrix(dragEl$1,true);clonesFromRect.top-=dragMatrix.f;clonesFromRect.left-=dragMatrix.e;}},dragOverAnimationComplete:function(){if(folding){folding=false;removeMultiDragElements();}},drop:function(_ref12){var evt=_ref12.originalEvent,rootEl=_ref12.rootEl,parentEl=_ref12.parentEl,sortable=_ref12.sortable,dispatchSortableEvent=_ref12.dispatchSortableEvent,oldIndex=_ref12.oldIndex,putSortable=_ref12.putSortable;var toSortable=putSortable||this.sortable;if(!evt)return;var options=this.options,children=parentEl.children;if(!dragStarted){if(options.multiDragKey&&!this.multiDragKeyDown){this._deselectMultiDrag();}toggleClass(dragEl$1,options.selectedClass,!~multiDragElements.indexOf(dragEl$1));if(!~multiDragElements.indexOf(dragEl$1)){multiDragElements.push(dragEl$1);dispatchEvent({sortable:sortable,rootEl:rootEl,name:'select',targetEl:dragEl$1,originalEvt:evt});if(evt.shiftKey&&lastMultiDragSelect&&sortable.el.contains(lastMultiDragSelect)){var lastIndex=sortable_core_esm_index(lastMultiDragSelect),currentIndex=sortable_core_esm_index(dragEl$1);if(~lastIndex&&~currentIndex&&lastIndex!==currentIndex){var n,i;if(currentIndex>lastIndex){i=lastIndex;n=currentIndex;}else{i=currentIndex;n=lastIndex+1;}for(;i<n;i++){if(~multiDragElements.indexOf(children[i]))continue;toggleClass(children[i],options.selectedClass,true);multiDragElements.push(children[i]);dispatchEvent({sortable:sortable,rootEl:rootEl,name:'select',targetEl:children[i],originalEvt:evt});}}}else{lastMultiDragSelect=dragEl$1;}multiDragSortable=toSortable;}else{multiDragElements.splice(multiDragElements.indexOf(dragEl$1),1);lastMultiDragSelect=null;dispatchEvent({sortable:sortable,rootEl:rootEl,name:'deselect',targetEl:dragEl$1,originalEvt:evt});}}if(dragStarted&&this.isMultiDrag){if((parentEl[sortable_core_esm_expando].options.sort||parentEl!==rootEl)&&multiDragElements.length>1){var dragRect=getRect(dragEl$1),multiDragIndex=sortable_core_esm_index(dragEl$1,':not(.'+this.options.selectedClass+')');if(!initialFolding&&options.animation)dragEl$1.thisAnimationDuration=null;toSortable.captureAnimationState();if(!initialFolding){if(options.animation){dragEl$1.fromRect=dragRect;multiDragElements.forEach(function(multiDragElement){multiDragElement.thisAnimationDuration=null;if(multiDragElement!==dragEl$1){var rect=folding?getRect(multiDragElement):dragRect;multiDragElement.fromRect=rect;toSortable.addAnimationState({target:multiDragElement,rect:rect});}});}removeMultiDragElements();multiDragElements.forEach(function(multiDragElement){if(children[multiDragIndex]){parentEl.insertBefore(multiDragElement,children[multiDragIndex]);}else{parentEl.appendChild(multiDragElement);}multiDragIndex++;});if(oldIndex===sortable_core_esm_index(dragEl$1)){var update=false;multiDragElements.forEach(function(multiDragElement){if(multiDragElement.sortableIndex!==sortable_core_esm_index(multiDragElement)){update=true;}});if(update){dispatchSortableEvent('update');}}}multiDragElements.forEach(function(multiDragElement){unsetRect(multiDragElement);});toSortable.animateAll();}multiDragSortable=toSortable;}if(rootEl===parentEl||putSortable&&putSortable.lastPutMode!=='clone'){multiDragClones.forEach(function(clone){clone.parentNode&&clone.parentNode.removeChild(clone);});}},nullingGlobal:function(){this.isMultiDrag=dragStarted=false;multiDragClones.length=0;},destroyGlobal:function(){this._deselectMultiDrag();sortable_core_esm_off(document,'pointerup',this._deselectMultiDrag);sortable_core_esm_off(document,'mouseup',this._deselectMultiDrag);sortable_core_esm_off(document,'touchend',this._deselectMultiDrag);sortable_core_esm_off(document,'keydown',this._checkKeyDown);sortable_core_esm_off(document,'keyup',this._checkKeyUp);},_deselectMultiDrag:function(evt){if(typeof dragStarted!=="undefined"&&dragStarted)return;if(multiDragSortable!==this.sortable)return;if(evt&&closest(evt.target,this.options.draggable,this.sortable.el,false))return;if(evt&&evt.button!==0)return;while(multiDragElements.length){var el=multiDragElements[0];toggleClass(el,this.options.selectedClass,false);multiDragElements.shift();dispatchEvent({sortable:this.sortable,rootEl:this.sortable.el,name:'deselect',targetEl:el,originalEvt:evt});}},_checkKeyDown:function(evt){if(evt.key===this.options.multiDragKey){this.multiDragKeyDown=true;}},_checkKeyUp:function(evt){if(evt.key===this.options.multiDragKey){this.multiDragKeyDown=false;}}};return _extends(MultiDrag,{pluginName:'multiDrag',utils:{select:function(el){var sortable=el.parentNode[sortable_core_esm_expando];if(!sortable||!sortable.options.multiDrag||~multiDragElements.indexOf(el))return;if(multiDragSortable&&multiDragSortable!==sortable){multiDragSortable.multiDrag._deselectMultiDrag();multiDragSortable=sortable;}toggleClass(el,sortable.options.selectedClass,true);multiDragElements.push(el);},deselect:function(el){var sortable=el.parentNode[sortable_core_esm_expando],index=multiDragElements.indexOf(el);if(!sortable||!sortable.options.multiDrag||!~index)return;toggleClass(el,sortable.options.selectedClass,false);multiDragElements.splice(index,1);}},eventProperties:function(){var _this3=this;var oldIndicies=[],newIndicies=[];multiDragElements.forEach(function(multiDragElement){oldIndicies.push({multiDragElement:multiDragElement,index:multiDragElement.sortableIndex});var newIndex;if(folding&&multiDragElement!==dragEl$1){newIndex=-1;}else if(folding){newIndex=sortable_core_esm_index(multiDragElement,':not(.'+_this3.options.selectedClass+')');}else{newIndex=sortable_core_esm_index(multiDragElement);}newIndicies.push({multiDragElement:multiDragElement,index:newIndex});});return{items:_toConsumableArray(multiDragElements),clones:[].concat(multiDragClones),oldIndicies:oldIndicies,newIndicies:newIndicies};},optionListeners:{multiDragKey:function(key){key=key.toLowerCase();if(key==='ctrl'){key='Control';}else if(key.length>1){key=key.charAt(0).toUpperCase()+key.substr(1);}return key;}}});}function insertMultiDragElements(clonesInserted,rootEl){multiDragElements.forEach(function(multiDragElement,i){var target=rootEl.children[multiDragElement.sortableIndex+(clonesInserted?Number(i):0)];if(target){rootEl.insertBefore(multiDragElement,target);}else{rootEl.appendChild(multiDragElement);}});}function insertMultiDragClones(elementsInserted,rootEl){multiDragClones.forEach(function(clone,i){var target=rootEl.children[clone.sortableIndex+(elementsInserted?Number(i):0)];if(target){rootEl.insertBefore(clone,target);}else{rootEl.appendChild(clone);}});}function removeMultiDragElements(){multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;multiDragElement.parentNode&&multiDragElement.parentNode.removeChild(multiDragElement);});}/* harmony default export */ var sortable_core_esm = (Sortable);
// CONCATENATED MODULE: ./lib/vendor/index.js

sortable_core_esm.mount(new AutoScrollPlugin());

// CONCATENATED MODULE: ./lib/utils/caseBuilder.js





function drawOptionBuilder(options, mod, optionName) {
  const option = options[optionName];
  const $addRowButton = jquery_default()('<button class="addRowButton">');
  const $itemContainer = jquery_default()('<div class="optionBuilder">');
  $itemContainer.attr({
    'data-module-id': mod.moduleID,
    'data-option-name': optionName
  });
  $addRowButton.text(i18n(option.addItemText) || '+add item').on('click', function () {
    const $newBody = drawBuilderItem(option.defaultTemplate(), option.customOptionsFields, option.cases);
    jquery_default()(this).siblings('.optionBuilder:first').trigger('change').append($newBody);
    const firstText = $newBody.find('input[type=text], textarea')[0];

    if (firstText) {
      setTimeout(() => firstText.focus(), 200);
    }
  });
  option.value.forEach(item => drawBuilderItem(item, option.customOptionsFields, option.cases).appendTo($itemContainer));
  sortable_core_esm.create($itemContainer.get(0), {
    handle: '.handle'
  });
  return jquery_default()('<div>').append($itemContainer, $addRowButton)[0];
}

function drawBuilderItem(data, customOptionsFields = [], cases) {
  const $editButton = jquery_default()('<div>').addClass('res-icon-button res-icon builderControls builderTrailingControls').html('&#xF061;').attr('title', 'copy and share, or update your settings with a new version').on('click', function () {
    const $item = jquery_default()(this).closest('.builderItem');
    const data = readBuilderItem($item, customOptionsFields, cases);
    const json = prompt('Copy this and share it, or paste a new version and update your settings', JSON.stringify(data));

    if (json !== null) {
      const newData = JSON.parse(json);
      $item.trigger('change').replaceWith(drawBuilderItem(newData, customOptionsFields, cases));
    }
  });
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want remove this filter?')) {
      jquery_default()(this).trigger('change');
      jquery_default()(this).closest('.builderItem').trigger('change').remove();
    }
  });
  const customOptions = string_namespaceObject.html`<ul class="builderCustomOptions"></ul>`;

  for (const fields of customOptionsFields) {
    const li = document.createElement('li');
    jquery_default()(li).append(drawFields(fields, data.opts || {}));
    customOptions.append(li);
  }

  const $header = jquery_default()('<div class="builderItemControls">').append(drawHandle(), jquery_default()('<textarea name="builderNote" rows="2" cols="40" placeholder="Write a description/note for this">').val(data.note), jquery_default()('<input type="hidden" name="version">').val(data.ver), jquery_default()('<input type="hidden" name="id">').val(data.id), customOptions, $editButton, $deleteButton);
  const $body = drawBuilderBlock(data.body, cases, false);
  return jquery_default()('<div class="builderItem">').append($header, $body);
}

function drawHandle() {
  return jquery_default()('<div>').addClass('res-icon-button res-icon handle builderControls').html('&#xF0AA;').attr('title', 'drag and drop to move this condition');
}

function drawDeleteButton() {
  return jquery_default()('<div>').addClass('res-icon-button res-icon builderControls').html('&#xF056;').attr('title', 'remove this condition');
}

function drawBuilderBlock(data, cases, addBaseControls = true) {
  if (!cases.hasOwnProperty(data.type)) {
    console.error(`Case type ${data.type} is not available. Ignoring block.`, data);
    return jquery_default()();
  }

  const $block = jquery_default()('<div class="builderBlock">').attr('data-type', data.type).append(drawFields(cases[data.type].fields, data, cases));
  if (!addBaseControls) return $block;
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want to delete this condition?')) {
      jquery_default()(this).trigger('change');
      jquery_default()(this).closest('.builderWrap').parent('li').remove();
    }
  });
  return jquery_default()('<div class="builderWrap">').append(drawHandle(), $block, $deleteButton);
}
function readBuilderItem(item, customOptionsFields = [], cases) {
  const $firstBlock = jquery_default()(item).find('> .builderBlock');
  const $header = jquery_default()(item).find('.builderItemControls');
  return {
    note: $header.find('textarea[name=builderNote]').val(),
    ver: parseInt($header.find('input[name=version]').val(), 10),
    id: $header.find('input[name=id]').val(),
    body: readBuilderBlock($firstBlock, cases),
    opts: readFields($header.find('.builderCustomOptions li'), flatten_default()(customOptionsFields), cases)
  };
}
function readBuilderBlock($element, cases) {
  const type = $element.attr('data-type');
  const BlockClass = cases[type];
  const data = {
    type,
    ...readFields($element, BlockClass.fields, cases)
  };
  const multiType = BlockClass.fields.find(({
    type
  }) => type === 'multi');

  if (!multiType) {
    try {
      BlockClass.validate(data);
      $element.removeClass('builderBlock-error');
    } catch (e) {
      $element.attr('error', e.message).addClass('builderBlock-error');
      throw e;
    }
  }

  return data;
}

function readFields($element, fields, cases) {
  return fields.reduce((acc, field) => {
    if (typeof field === 'string') return acc;
    const $fieldElem = $element.find(`> [name=${field.id}]`);
    const fieldModule = builderFields[field.type];

    if (fieldModule && typeof fieldModule.read === 'function') {
      acc[field.id] = fieldModule.read($fieldElem, field, cases);
    } else {
      acc[field.id] = $fieldElem.val();
    }

    return acc;
  }, {});
}

function drawFields(fields, data, cases) {
  return fields.map(field => {
    if (typeof field === 'string') return field;
    const fieldModule = builderFields[field.type];

    if (fieldModule) {
      return fieldModule.draw(data, field, cases);
    } else {
      return jquery_default()(`<input type="${field.type}">`).attr('name', field.id).val(data[field.id]);
    }
  });
}

const builderFields = {
  multi: {
    draw(data, field, cases = {}) {
      const $rowWrapper = jquery_default()('<ul class="builderMulti">').attr('name', field.id);

      const addItem = itemData => drawBuilderBlock(itemData, cases).appendTo($rowWrapper).wrap('<li>');

      const items = data[field.id];
      items.forEach(addItem);
      const addCaseSelect = downcast(string_namespaceObject.html`
				<select class="addBuilderBlock">
					<option>+ add a condition</option>
					${Object.entries(cases).map(([key, {
        text
      }]) => string_namespaceObject._html`
						<option value="${key}">${text}</option>
					`)}
				</select>
			`, HTMLSelectElement);
      addCaseSelect.addEventListener('change', () => {
        const type = addCaseSelect.value;

        if (type !== '' && cases.hasOwnProperty(type)) {
          addItem({
            type,
            ...cases[type].defaultConditions
          }).find('input[type=text], input[type=number], textarea').focus();
        }

        addCaseSelect.selectedIndex = 0;
      });
      sortable_core_esm.create($rowWrapper.get(0), {
        group: 'block',
        handle: '.handle'
      });
      return $rowWrapper.add(addCaseSelect);
    },

    read($elem, fields, cases) {
      return $elem.find('> li > .builderWrap > .builderBlock').map(function () {
        return readBuilderBlock(jquery_default()(this), cases);
      }).get();
    }

  },
  hidden: {
    draw(data, field) {
      const id = field.id;
      return jquery_default()('<input type="hidden">').attr('name', id).val(data[id]);
    }

  },
  number: {
    draw(data, field) {
      const id = field.id;
      return jquery_default()('<input type="number">').attr('name', id).val(data[id]);
    },

    read($elem) {
      return parseInt($elem.val(), 10);
    }

  },
  check: {
    draw(data, field) {
      const id = field.id;
      const $input = jquery_default()('<input type="checkbox">').prop('checked', data[id]);
      return jquery_default()('<label>').attr('name', id).text(field.label).prepend($input);
    },

    read($elem) {
      return $elem.find('input').get(0).checked;
    }

  },
  checkset: {
    uid: 0,

    draw(data, field) {
      const id = field.id;
      const prefixId = this.uid++;
      const $wrap = jquery_default()('<span class="checkset">').attr('name', field.id);
      field.items.forEach((e, idx) => {
        const itemId = `checkset-${prefixId}-${idx}X`;
        const $box = jquery_default()('<input type="checkbox" />').attr('id', itemId).attr('name', e);

        if (data.hasOwnProperty(id) && data[id].includes(e)) {
          $box.prop('checked', true);
        }

        const $label = jquery_default()('<label>').attr('for', itemId).text(e);
        $wrap.append($box, $label);
      });
      return $wrap;
    },

    read($elem, fields) {
      return fields.items.filter(e => $elem.children(`[name="${e}"]`).prop('checked'));
    }

  },
  duration: {
    draw(data, field) {
      let durr = data[field.id];
      durr /= 60 * 1000;
      const minutes = durr % 60;
      durr = (durr - minutes) / 60;
      const hours = durr % 24;
      durr = (durr - hours) / 24;
      const days = durr;
      return jquery_default()('<span class="durationField">').attr('name', field.id).append([jquery_default()('<input type="number" name="days" />').val(days), ' days ', jquery_default()('<input type="number" name="hours" />').val(hours), ' hours ', jquery_default()('<input type="number" name="minutes" />').val(minutes), ' minutes ']);
    },

    read($elem) {
      const days = parseFloat($elem.children('[name=days]').val()) || 0;
      const hours = parseFloat($elem.children('[name=hours]').val()) || 0;
      const minutes = parseFloat($elem.children('[name=minutes]').val()) || 0;
      let duration = 0;
      duration += days * 24 * 60 * 60;
      duration += hours * 60 * 60;
      duration += minutes * 60;
      duration *= 1000;
      return duration;
    }

  },
  select: {
    draw(data, field) {
      const value = data[field.id];
      let entries = field.options;

      if (typeof entries === 'string') {
        entries = this.getPredefinedChoices(entries);
      }

      const $dropdown = jquery_default()('<select>').attr('name', field.id);
      entries.forEach(row => {
        let label, value;

        if (typeof row === 'string') {
          label = value = row;
        } else {
          label = row[0];
          value = row[1];
        }

        jquery_default()('<option>').text(label).val(value).appendTo($dropdown);
      });
      $dropdown.val(value);
      return $dropdown;
    },

    getPredefinedChoices(name) {
      if (name === 'COMPARISON') {
        return [['exactly', '=='], ['not', '!='], ['more than', '>'], ['less than', '<'], ['at least', '>='], ['at most', '<=']];
      } else {
        throw new Error(`Option set "${name}" is not defined`);
      }
    }

  }
};
// CONCATENATED MODULE: ./lib/utils/index.js














































// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js
var isEqual = __webpack_require__(14);
var isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);

// EXTERNAL MODULE: ./node_modules/lodash/fp/map.js
var map = __webpack_require__(15);
var map_default = /*#__PURE__*/__webpack_require__.n(map);

// EXTERNAL MODULE: ./node_modules/lodash/fp/keyBy.js
var keyBy = __webpack_require__(28);
var keyBy_default = /*#__PURE__*/__webpack_require__.n(keyBy);

// CONCATENATED MODULE: ./lib/core/module.js
class Module {
  constructor(moduleID) {
    this.moduleID = void 0;
    this.moduleName = void 0;
    this.category = '';
    this.description = '';
    this.descriptionRaw = false;
    this.keywords = [];
    this.bodyClass = false;
    this.options = {};
    this.include = [];
    this.exclude = [];

    this.shouldRun = () => true;

    this.onToggle = () => {};

    this.onSaveSettings = () => {};

    this.hidden = false;
    this.disabledByDefault = false;
    this.alwaysEnabled = false;
    this.sort = 0;
    this.onInit = undefined;
    this.beforeLoad = undefined;
    this.contentStart = undefined;
    this.go = undefined;
    this.afterLoad = undefined;
    this.always = undefined;
    this.permissions = {
      requiredPermissions: []
    };
    this.moduleID = moduleID;
    this.moduleName = moduleID;
  }

}
function getModuleId(opaqueId) {
  if (!opaqueId) {
    throw new TypeError(`Expected module, moduleID, or namespace; found: ${opaqueId}`);
  }

  if (typeof opaqueId === 'string') {
    return opaqueId;
  } else if (opaqueId.module) {
    return opaqueId.module.moduleID;
  } else {
    return opaqueId.moduleID;
  }
}
// CONCATENATED MODULE: ./lib/core/modules/storage.js

const storage_storage = storage_namespaceObject.wrapBlob('RES.modulePrefs', () => {
  throw new Error('Default module enabled state should never be accessed');
});
function setEnabled(moduleId, enable) {
  return storage_storage.set(moduleId, enable);
}
// EXTERNAL MODULE: ./node_modules/lodash/random.js
var random = __webpack_require__(121);
var random_default = /*#__PURE__*/__webpack_require__.n(random);

// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__(29);
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);

// CONCATENATED MODULE: ./lib/vendor/guiders.js

const guiders = {};

(() => {
  guiders.version = "2.0.0";
  guiders._defaultSettings = {
    attachTo: null,
    autoFocus: false,
    buttons: [{
      name: "Close"
    }],
    buttonCustomHTML: "",
    classString: null,
    closeOnEscape: false,
    description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    highlight: null,
    isHashable: true,
    maxWidth: null,
    offset: {
      top: null,
      left: null
    },
    onClose: null,
    onHide: null,
    onShow: null,
    overlay: false,
    position: 0,
    shouldSkip: function () {},
    title: "Sample title goes here",
    width: 400,
    xButton: false
  };
  guiders._htmlSkeleton = ["<div class='guider'>", "  <div class='guiders_content'>", "    <h1 class='guiders_title'></h1>", "    <div class='guiders_close'></div>", "    <p class='guiders_description'></p>", "    <div class='guiders_buttons_container'>", "    </div>", "  </div>", "  <div class='guiders_arrow'>", "  </div>", "</div>"].join("");
  guiders._arrowSize = 42;
  guiders._backButtonTitle = "Back";
  guiders._buttonAttributes = {
    "href": "javascript:void(0);"
  };
  guiders._buttonClassName = "guiders_button";
  guiders._buttonClickEvent = "click touch";
  guiders._buttonElement = "<a></a>";
  guiders._closeButtonTitle = "Close";
  guiders._currentGuiderID = null;
  guiders._fixedOrAbsolute = "fixed";
  guiders._guiders = {};
  guiders._lastCreatedGuiderID = null;
  guiders._nextButtonTitle = "Next";
  guiders._offsetNameMapping = {
    "topLeft": 11,
    "top": 12,
    "topRight": 1,
    "rightTop": 2,
    "right": 3,
    "rightBottom": 4,
    "bottomRight": 5,
    "bottom": 6,
    "bottomLeft": 7,
    "leftBottom": 8,
    "left": 9,
    "leftTop": 10
  };
  guiders._windowHeight = 0;
  var ieBrowserMatch = navigator.userAgent.match(/MSIE\s([\d.]+)/);
  guiders._isIE = ieBrowserMatch && ieBrowserMatch.length > 1;
  guiders._ieVersion = ieBrowserMatch && ieBrowserMatch.length > 1 ? Number(ieBrowserMatch[1]) : -1;

  guiders._addButtons = function (myGuider) {
    var guiderButtonsContainer = myGuider.elem.find(".guiders_buttons_container");

    if (myGuider.buttons === null || myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
      return;
    }

    for (var i = myGuider.buttons.length - 1; i >= 0; i--) {
      var thisButton = myGuider.buttons[i];
      var thisButtonElem = jquery_default()(guiders._buttonElement, jquery_default.a.extend({
        "class": guiders._buttonClassName,
        "html": thisButton.name
      }, guiders._buttonAttributes, thisButton.html || {}));

      if (typeof thisButton.classString !== "undefined" && thisButton.classString !== null) {
        thisButtonElem.addClass(thisButton.classString);
      }

      guiderButtonsContainer.append(thisButtonElem);
      var thisButtonName = thisButton.name.toLowerCase();

      if (thisButton.onclick) {
        thisButtonElem.bind(guiders._buttonClickEvent, thisButton.onclick);
      } else {
        switch (thisButtonName) {
          case guiders._closeButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              guiders.hideAll();

              if (myGuider.onClose) {
                myGuider.onClose(myGuider, false);
              }

              jquery_default()("body").trigger("guidersClose");
            });
            break;

          case guiders._nextButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.next();
            });
            break;

          case guiders._backButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.prev();
            });
            break;
        }
      }
    }

    if (myGuider.buttonCustomHTML !== "") {
      var myCustomHTML = jquery_default()(myGuider.buttonCustomHTML);
      myGuider.elem.find(".guiders_buttons_container").append(myCustomHTML);
    }

    if (myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
    }
  };

  guiders._addXButton = function (myGuider) {
    var xButtonContainer = myGuider.elem.find(".guiders_close");
    var xButton = jquery_default()("<div></div>", {
      "class": "guiders_x_button",
      "role": "button"
    });
    xButtonContainer.append(xButton);
    xButton.click(function () {
      guiders.hideAll();

      if (myGuider.onClose) {
        myGuider.onClose(myGuider, true);
      }

      jquery_default()("body").trigger("guidersClose");
    });
  };

  guiders._attach = function (myGuider) {
    if (typeof myGuider !== 'object') {
      return;
    }

    var attachTo = jquery_default()(myGuider.attachTo);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();

    if (myGuider.position === 0 || attachTo.length === 0) {
      var fixedOrAbsolute = "fixed";

      if (guiders._isIE && guiders._ieVersion < 9) {
        fixedOrAbsolute = "absolute";
      }

      myGuider.elem.css("position", fixedOrAbsolute);
      myGuider.elem.css("top", (jquery_default()(window).height() - myHeight) / 3 + "px");
      myGuider.elem.css("left", (jquery_default()(window).width() - myWidth) / 2 + "px");
      return;
    }

    var base = attachTo.offset();
    var top = base.top;
    var left = base.left;
    var topMarginOfBody = jquery_default()("body").outerHeight(true) - jquery_default()("body").outerHeight(false);
    top -= topMarginOfBody;

    if (guiders._offsetNameMapping[myGuider.position]) {
      myGuider.position = guiders._offsetNameMapping[myGuider.position];
    }

    var attachToHeight = attachTo.innerHeight();
    var attachToWidth = attachTo.innerWidth();
    var bufferOffset = 0.9 * guiders._arrowSize;
    var offset = {
      1: [-bufferOffset - myHeight, attachToWidth - myWidth],
      2: [0, bufferOffset + attachToWidth],
      3: [attachToHeight / 2 - myHeight / 2, bufferOffset + attachToWidth],
      4: [attachToHeight - myHeight, bufferOffset + attachToWidth],
      5: [bufferOffset + attachToHeight, attachToWidth - myWidth],
      6: [bufferOffset + attachToHeight, attachToWidth / 2 - myWidth / 2],
      7: [bufferOffset + attachToHeight, 0],
      8: [attachToHeight - myHeight, -myWidth - bufferOffset],
      9: [attachToHeight / 2 - myHeight / 2, -myWidth - bufferOffset],
      10: [0, -myWidth - bufferOffset],
      11: [-bufferOffset - myHeight, 0],
      12: [-bufferOffset - myHeight, attachToWidth / 2 - myWidth / 2]
    }[myGuider.position];
    top += offset[0];
    left += offset[1];
    var positionType = "absolute";

    if (attachTo.css("position") === "fixed" && guiders._fixedOrAbsolute === "fixed") {
      positionType = "fixed";
      top -= jquery_default()(window).scrollTop();
      left -= jquery_default()(window).scrollLeft();
    }

    if (myGuider.offset.top !== null) {
      top += myGuider.offset.top;
    }

    if (myGuider.offset.left !== null) {
      left += myGuider.offset.left;
    }

    guiders._styleArrow(myGuider);

    myGuider.elem.css({
      "position": positionType,
      "top": top,
      "left": left
    });
    return myGuider;
  };

  guiders._dehighlightElement = function (selector) {
    jquery_default()(selector).removeClass('guiders_highlight');
  };

  guiders._hideOverlay = function () {
    jquery_default()("#guiders_overlay").fadeOut("fast");
  };

  guiders._highlightElement = function (selector) {
    jquery_default()(selector).addClass('guiders_highlight');
  };

  guiders._initializeOverlay = function () {
    if (jquery_default()("#guiders_overlay").length === 0) {
      jquery_default()("<div id='guiders_overlay'></div>").hide().appendTo("body");
    }
  };

  guiders._showOverlay = function () {
    jquery_default()("#guiders_overlay").fadeIn("fast", function () {
      if (this.style.removeAttribute) {
        this.style.removeAttribute("filter");
      }
    });

    if (guiders._isIE) {
      jquery_default()("#guiders_overlay").css("position", "absolute");
    }
  };

  guiders._styleArrow = function (myGuider) {
    var position = myGuider.position || 0;

    if (!position) {
      return;
    }

    var myGuiderArrow = jquery_default()(myGuider.elem.find(".guiders_arrow"));
    myGuiderArrow.addClass({
      1: "guiders_arrow_down",
      2: "guiders_arrow_left",
      3: "guiders_arrow_left",
      4: "guiders_arrow_left",
      5: "guiders_arrow_up",
      6: "guiders_arrow_up",
      7: "guiders_arrow_up",
      8: "guiders_arrow_right",
      9: "guiders_arrow_right",
      10: "guiders_arrow_right",
      11: "guiders_arrow_down",
      12: "guiders_arrow_down"
    }[position]);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();
    var arrowOffset = guiders._arrowSize / 2;
    var position = {
      1: ["right", arrowOffset],
      2: ["top", arrowOffset],
      3: ["top", myHeight / 2 - arrowOffset],
      4: ["bottom", arrowOffset],
      5: ["right", arrowOffset],
      6: ["left", myWidth / 2 - arrowOffset],
      7: ["left", arrowOffset],
      8: ["bottom", arrowOffset],
      9: ["top", myHeight / 2 - arrowOffset],
      10: ["top", arrowOffset],
      11: ["left", arrowOffset],
      12: ["left", myWidth / 2 - arrowOffset]
    }[myGuider.position];
    myGuiderArrow.css(position[0], position[1] + "px");
  };

  guiders._showIfHashed = function (myGuider) {
    var GUIDER_HASH_TAG = "guider=";
    var hashIndex = window.location.hash.indexOf(GUIDER_HASH_TAG);

    if (hashIndex !== -1) {
      var hashGuiderId = window.location.hash.substr(hashIndex + GUIDER_HASH_TAG.length);

      if (myGuider.id.toLowerCase() === hashGuiderId.toLowerCase()) {
        guiders.show(myGuider.id);
      }
    }
  };

  guiders._updatePositionOnResize = function () {
    var _resizing = undefined;
    jquery_default()(window).resize(function () {
      if (typeof _resizing !== "undefined") {
        clearTimeout(_resizing);
      }

      _resizing = setTimeout(function () {
        _resizing = undefined;
        guiders.reposition();
      }, 20);
    });
  };

  guiders._updatePositionOnResize();

  guiders._unwireEscape = function () {
    jquery_default()(document).unbind("keydown");
  };

  guiders._wireEscape = function (myGuider) {
    jquery_default()(document).keydown(function (event) {
      if (event.keyCode == 27 || event.which == 27) {
        guiders.hideAll();

        if (myGuider.onClose) {
          myGuider.onClose(myGuider, true);
        }

        jquery_default()("body").trigger("guidersClose");
        return false;
      }
    });
  };

  guiders.createGuider = function (passedSettings) {
    if (passedSettings === null || passedSettings === undefined) {
      passedSettings = {};
    }

    var myGuider = jquery_default.a.extend({}, guiders._defaultSettings, passedSettings);
    myGuider.id = myGuider.id || "guider_random_" + String(Math.floor(Math.random() * 1000));
    var guiderElement = jquery_default()("#" + myGuider.id);

    if (!guiderElement.length) {
      guiderElement = jquery_default()(guiders._htmlSkeleton);
    }

    myGuider.elem = guiderElement;

    if (typeof myGuider.classString !== "undefined" && myGuider.classString !== null) {
      myGuider.elem.addClass(myGuider.classString);
    }

    if (Number(myGuider.width) === myGuider.width) {
      myGuider.width = String(myGuider.width) + "px";
    }

    if (Number(myGuider.maxWidth) === myGuider.maxWidth) {
      myGuider.maxWidth = String(myGuider.maxWidth) + "px";
    }

    myGuider.elem.css("width", myGuider.width);
    myGuider.elem.css("maxWidth", myGuider.maxWidth);
    var guiderTitleContainer = guiderElement.find(".guiders_title");
    guiderTitleContainer.html(myGuider.title);
    guiderElement.find(".guiders_description").html(myGuider.description);

    guiders._addButtons(myGuider);

    if (myGuider.xButton) {
      guiders._addXButton(myGuider);
    }

    guiderElement.hide();
    guiderElement.appendTo("body");
    guiderElement.attr("id", myGuider.id);

    if (typeof myGuider.attachTo !== "undefined" && myGuider !== null) {
      guiders._attach(myGuider);
    }

    guiders._initializeOverlay();

    guiders._guiders[myGuider.id] = myGuider;

    if (guiders._lastCreatedGuiderID != null) {
      myGuider.prev = guiders._lastCreatedGuiderID;
    }

    guiders._lastCreatedGuiderID = myGuider.id;

    if (myGuider.isHashable) {
      guiders._showIfHashed(myGuider);
    }

    return guiders;
  };

  guiders.get = function (id) {
    if (typeof guiders._guiders[id] === "undefined") {
      return null;
    }

    return guiders._guiders[id] || null;
  };

  guiders.getCurrentGuider = function () {
    return guiders._guiders[guiders._currentGuiderID] || null;
  };

  guiders.hideAll = function (omitHidingOverlay, next) {
    next = next || false;
    jquery_default()(".guider:visible").each(function (index, elem) {
      var myGuider = guiders.get(jquery_default()(elem).attr('id'));

      if (myGuider.onHide) {
        myGuider.onHide(myGuider, next);
      }
    });
    jquery_default()(".guider").fadeOut("fast");
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (currentGuider && currentGuider.highlight) {
      guiders._dehighlightElement(currentGuider.highlight);
    }

    if (!(typeof omitHidingOverlay !== "undefined" && omitHidingOverlay === true)) {
      guiders._hideOverlay();
    }

    return guiders;
  };

  guiders.next = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    currentGuider.elem.data("locked", true);
    var nextGuiderId = currentGuider.next || null;

    if (nextGuiderId !== null && nextGuiderId !== "") {
      var nextGuider = guiders.get(nextGuiderId);
      var omitHidingOverlay = nextGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (currentGuider && currentGuider.highlight) {
        guiders._dehighlightElement(currentGuider.highlight);
      }

      if (nextGuider.shouldSkip && nextGuider.shouldSkip()) {
        guiders._currentGuiderID = nextGuider.id;
        guiders.next();
        return guiders.getCurrentGuider();
      } else {
        guiders.show(nextGuiderId);
        return guiders.getCurrentGuider();
      }
    }
  };

  guiders.prev = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    if (currentGuider.prev === null) {
      return null;
    }

    var prevGuider = guiders._guiders[currentGuider.prev];
    prevGuider.elem.data("locked", true);
    var prevGuiderId = prevGuider.id || null;

    if (prevGuiderId !== null && prevGuiderId !== "") {
      var myGuider = guiders.get(prevGuiderId);
      var omitHidingOverlay = myGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (prevGuider && prevGuider.highlight) {
        guiders._dehighlightElement(prevGuider.highlight);
      }

      guiders.show(prevGuiderId);
      return myGuider;
    }
  };

  guiders.reposition = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    guiders._attach(currentGuider);
  };

  guiders.scrollToCurrent = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return;
    }

    var windowHeight = guiders._windowHeight;
    jquery_default()(window).scrollTop();
    var guiderOffset = currentGuider.elem.offset();
    var guiderElemHeight = currentGuider.elem.height();
    var scrollToHeight = Math.round(Math.max(guiderOffset.top + guiderElemHeight / 2 - windowHeight / 2, 0));
    window.scrollTo(0, scrollToHeight);
  };

  guiders.show = function (id) {
    if (!id && guiders._lastCreatedGuiderID) {
      id = guiders._lastCreatedGuiderID;
    }

    var myGuider = guiders.get(id);

    if (myGuider.overlay) {
      guiders._showOverlay(myGuider);

      if (myGuider.highlight && myGuider.attachTo) {
        guiders._highlightElement(myGuider.attachTo);
      }
    }

    if (myGuider.closeOnEscape) {
      guiders._wireEscape(myGuider);
    } else {
      guiders._unwireEscape(myGuider);
    }

    if (myGuider.onShow) {
      myGuider.onShow(myGuider);
    }

    guiders._attach(myGuider);

    myGuider.elem.fadeIn("fast").data("locked", false);
    guiders._currentGuiderID = id;
    var windowHeight = guiders._windowHeight = jquery_default()(window).height();
    var scrollHeight = jquery_default()(window).scrollTop();
    var guiderOffset = myGuider.elem.offset();
    var guiderElemHeight = myGuider.elem.height();
    var isGuiderBelow = scrollHeight + windowHeight < guiderOffset.top + guiderElemHeight;
    var isGuiderAbove = guiderOffset.top < scrollHeight;

    if (myGuider.autoFocus && (isGuiderBelow || isGuiderAbove)) {
      setTimeout(guiders.scrollToCurrent, 10);
    }

    jquery_default()(myGuider.elem).trigger("guiders.show");
    return guiders;
  };
})();
// CONCATENATED MODULE: ./lib/core/options/storage.js


const options_storage_storage = storage_namespaceObject.wrapPrefix('RESoptions.', () => ({}), undefined, true);
const loadRaw = moduleId => options_storage_storage.get(moduleId);
async function options_storage_get(opaqueId, optionKey) {
  const options = await options_storage_storage.get(getModuleId(opaqueId));
  return options && options[optionKey];
}
async function getValue(opaqueId, optionKey) {
  const option = await options_storage_get(getModuleId(opaqueId), optionKey);
  return option && option.value;
}
function options_storage_set(opaqueId, optionKey, value) {
  if (/_[\d]+$/.test(optionKey)) {
    optionKey = optionKey.replace(/_[\d]+$/, '');
  }

  return options_storage_storage.patch(getModuleId(opaqueId), {
    [optionKey]: {
      value
    }
  });
}
// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js
var isEmpty = __webpack_require__(16);
var isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);

// EXTERNAL MODULE: ./node_modules/lodash/omitBy.js
var omitBy = __webpack_require__(122);
var omitBy_default = /*#__PURE__*/__webpack_require__.n(omitBy);

// CONCATENATED MODULE: ./lib/core/options/modified.js







function getModified() {
  return filterMap(modules_all(), module => {
    const {
      moduleID,
      options
    } = module;
    const enabledByDefault = !module.disabledByDefault;
    const isEnabled = modules_isEnabled(module);
    const moduleStatusChanged = enabledByDefault !== isEnabled;
    const modifiedOptions = isEnabled ? omitBy_default()(options, v => isEqual_default()(v.value, v.default)) : {};

    if (!isEmpty_default()(modifiedOptions) || moduleStatusChanged) {
      return [{
        moduleID,
        modifiedOptions,
        moduleStatus: moduleStatusChanged ? `${enabledByDefault ? 'on' : 'off'}  ${isEnabled ? 'on' : 'off'}` : ''
      }];
    }
  });
}

function getModifiedText(types = ['text', 'boolean', 'enum']) {
  const lines = [];
  let optionMaxLength = 0;
  let moduleMaxLength = 0;

  for (const {
    moduleID,
    modifiedOptions,
    moduleStatus
  } of getModified()) {
    moduleMaxLength = Math.max(moduleMaxLength, moduleID.length);
    optionMaxLength = Math.max(optionMaxLength, ...Object.keys(modifiedOptions).map(v => v.length));
    lines.push(() => [`    ${moduleID.padEnd(moduleMaxLength)} ${moduleStatus}`, ...Object.entries(modifiedOptions).filter(([, {
      type
    }]) => types.includes(type)).map(([key, value]) => `      ${key.padEnd(optionMaxLength)}\t${JSON.stringify(value.default)}  ${JSON.stringify(value.value)}`)]);
  }

  return flatten_default()(lines.map(v => v())).join('\n');
}
// CONCATENATED MODULE: ./lib/core/options/stage.js




let stagedOptions;
clearStagedOptions();


function stageOption(moduleID, optionName, optionValue) {
  const mod = modules_get(moduleID);
  stagedOptions[moduleID] = stagedOptions[moduleID] || {};

  if (!isEqual_default()(mod.options[optionName].value, optionValue)) {
    stagedOptions[moduleID][optionName] = {
      value: optionValue
    };
  } else {
    delete stagedOptions[moduleID][optionName];
  }

  if (isEmpty_default()(stagedOptions[moduleID])) {
    delete stagedOptions[moduleID];
  }
}



function commitStagedOptions() {
  for (const [modId, options] of Object.entries(stagedOptions)) {
    const module = modules_get(modId);

    for (const [optionName, option] of Object.entries(options)) {
      const _option = module.options[optionName];
      _option.value = option.value;
      options_save(_option);
    }

    module.onSaveSettings(options);
  }

  clearStagedOptions();
}



function clearStagedOptions() {
  stagedOptions = {};
}



function hasStagedOptions() {
  return !isEmpty_default()(stagedOptions);
}



function getStagedOptions(moduleID) {
  return stagedOptions[moduleID];
}
// CONCATENATED MODULE: ./lib/core/options/table.js



function getMatchingValueOrAdd(opaqueId, optionKey, valueIdentifier, _default) {
  const module = modules_get(opaqueId);
  const option = module.options[optionKey];

  if (option.type !== 'table') {
    throw new Error(`Tried to save table value to non-table option: modules.${module.moduleID}.options.${optionKey}`);
  }

  let row = option.value.find(value => option.fields.every((field, i) => !valueIdentifier.hasOwnProperty(field.key) || value[i] === valueIdentifier[field.key]));

  if (!row) {
    const value = { ...valueIdentifier,
      ..._default
    };
    row = option.fields.map(field => firstValid(value[field.key], field.value));
    option.value.push(row);
    options_storage_set(module, optionKey, option.value);
  }

  return option.fields.reduce((acc, field, i) => {
    Object.defineProperty(acc, field.key, {
      enumerable: true,
      get: () => row[i],
      set: v => {
        row[i] = v;
        options_storage_set(module, optionKey, option.value);
      }
    });
    return acc;
  }, {});
}
// CONCATENATED MODULE: ./lib/core/options/index.js







// CONCATENATED MODULE: ./lib/modules/hover.js




const hover_module = new Module('hover');
hover_module.moduleName = 'hoverName';
hover_module.category = 'coreCategory';
hover_module.description = 'hoverDesc';
hover_module.alwaysEnabled = true;
hover_module.options = {
  instances: {
    description: 'hoverInstancesDesc',
    title: 'hoverInstancesTitle',
    type: 'table',
    value: [],
    fields: [{
      key: 'id',
      name: 'hoverInstancesName',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'hoverInstancesEnabled',
      type: 'boolean',
      value: true
    }]
  },
  openDelay: {
    type: 'text',
    value: '500',
    description: 'hoverOpenDelayDesc',
    title: 'hoverOpenDelayTitle'
  },
  fadeDelay: {
    type: 'text',
    value: '500',
    description: 'hoverFadeDelayDesc',
    title: 'hoverFadeDelayTitle'
  },
  fadeSpeed: {
    noconfig: true,
    type: 'text',
    value: '0.7',
    description: 'hoverFadeSpeedDesc',
    title: 'hoverFadeSpeedTitle'
  },
  width: {
    type: 'text',
    value: '512',
    description: 'hoverWidthDesc',
    title: 'hoverWidthTitle'
  },
  closeOnMouseOut: {
    type: 'boolean',
    value: true,
    description: 'hoverCloseOnMouseOutDesc',
    title: 'hoverCloseOnMouseOutTitle'
  }
};

hover_module.beforeLoad = () => {
  hover_Hover._defaultOptions = {
    openDelay: parseFloat(hover_module.options.openDelay.value),
    fadeDelay: parseFloat(hover_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(hover_module.options.fadeSpeed.value),
    width: parseFloat(hover_module.options.width.value),
    closeOnMouseOut: hover_module.options.closeOnMouseOut.value,
    enabled: true
  };
};

const instances = {};

const getInstance = (TypeClass, id) => instances[id] || (instances[id] = new TypeClass(id));

const infocard = name => getInstance(hover_HoverInfoCard, name);
const dropdownList = name => getInstance(hover_HoverDropdownList, name);

function getFixedParent(e) {
  const p = e.parentElement;
  return p && (window.getComputedStyle(p).position === 'fixed' && e || getFixedParent(p));
}

const pin = {
  bottom: 'bottom',
  right: 'right'
};

class hover_Hover {
  constructor(id) {
    this.template = `
		<div class="RESHover">
			<div data-hover-element="0" />
			<div data-hover-element="1" />
			<div data-hover-element="2" />
			<div data-hover-element="3" />
		</div>
	`;
    this._options = hover_Hover._defaultOptions;
    this.instanceID = void 0;
    this.visible = false;
    this._hideTimer = null;
    this._showTimer = null;
    this._closeFadeTimer = null;
    this._target = void 0;
    this._callback = void 0;
    this._container = void 0;
    this._fixedPosition = false;
    this._closePromise = void 0;
    this._closePromiseResolve = void 0;
    this._checkMouseLeave = frameThrottle(({
      target
    }) => {
      if (this.visible && this._options.closeOnMouseOut && !this.getCheckedTarget().contains(target) && !Object.values(instances).some(instance => instance._container && instance._container.contains(target))) this._startHideTimer();
    });

    this._startShowTimer = () => {
      if (this._showTimer) return;

      this._cancelHideTimer();

      waitForEvent(this.getCheckedTarget(), 'mouseleave').then(this._cancelShowTimer);
      this._showTimer = setTimeout(() => this.open(), this._options.openDelay);
    };

    this._cancelShowTimer = () => {
      if (!this._showTimer) return;
      clearTimeout(this._showTimer);
      this._showTimer = null;
    };

    this._startHideTimer = () => {
      if (this._hideTimer || this._closeFadeTimer) return;

      this._cancelShowTimer();

      this._hideTimer = setTimeout(() => this.close(true), this._options.fadeDelay);
    };

    this._cancelHideTimer = () => {
      if (!this._hideTimer) return;
      clearTimeout(this._hideTimer);
      this._hideTimer = null;
    };

    this.instanceID = id;
  }

  options(options, persistent = true) {
    const persistentOptions = persistent ? options_table_namespaceObject.getMatchingValueOrAdd(hover_module, 'instances', {
      id: this.instanceID
    }, {
      enabled: true
    }) : undefined;
    this._options = { ...this._options,
      ...options,
      ...persistentOptions
    };
    return this;
  }

  target(element) {
    if (this._target && this._target !== element) {
      this.close();
    }

    this._target = element;
    return this;
  }

  getCheckedTarget() {
    if (!this._target || !this._target.offsetParent) {
      this.close();
      throw new Error('Cannot show hover without target; closing hover.');
    }

    return this._target;
  }

  populateWith(callback) {
    this._callback = callback;
    return this;
  }

  getContainer() {
    const container = this._container = this._container || this._render();

    if (!document.body.contains(container)) {
      document.body.append(container);
    }

    return container;
  }

  _render() {
    const ele = jquery_default()(this.template).get(0);

    this._addContainerHandlers(ele);

    if (this._options.className) ele.classList.add(this._options.className);
    return ele;
  }

  _addContainerHandlers(ele) {
    jquery_default()(ele).on('mouseenter', () => {
      this._cancelHideTimer();

      this._clearCloseFade();
    }).on('mouseleave', this._checkMouseLeave).on('click', '.RESCloseButton', () => this.close()).on('keyup', e => {
      if (e.key === NAMED_KEYS.Escape) this.close();
      e.stopImmediatePropagation();
    });
  }

  begin() {
    if (!this._options.enabled) return false;

    if (this._options.openDelay) {
      this._startShowTimer();
    } else {
      this.open();
    }
  }

  watch(selector) {
    jquery_default()(document.body).on('mouseenter', selector, ({
      currentTarget
    }) => {
      this.target(currentTarget).begin();
    });
  }

  open() {
    if (!this._options.enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    this._clearCloseFade();

    const callback = this._callback;
    if (!callback) throw new Error();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this._closePromise = new Promise(res => {
      this._closePromiseResolve = res;
    });

    this._displayLoadIndicator();

    (async () => {
      try {
        this.populate((await callback(this)));
      } catch (e) {
        this.close();
        throw e;
      }
    })();

    waitForDetach(this.getCheckedTarget(), this._closePromise).then(() => {
      this.close();
    }).catch(() => {});

    if (this._options.closeOnMouseOut) {
      document.body.addEventListener('mousemove', this._checkMouseLeave);
      document.body.addEventListener('mouseover', this._checkMouseLeave);
    }

    this.visible = true;
  }

  _displayLoadIndicator() {}

  async refresh() {
    const callback = this._callback;
    if (callback) this.populate((await callback(this)));
  }

  populate(items) {
    if (!this._options.enabled) return false;
    const container = this.getContainer();
    items.forEach((item, i) => {
      if (!item) return;
      const $element = jquery_default()(container).find(`[data-hover-element="${i}"]`);
      $element.children().detach();
      $element.empty().append(item);
    });
    const fixedParent = getFixedParent(this.getCheckedTarget());

    if (fixedParent) {
      this._fixedPosition = true;

      const onScroll = () => {
        this.close(false);
        fixedParent.removeEventListener('scroll', onScroll, true);
      };

      fixedParent.addEventListener('scroll', onScroll, true);
    }

    this._updatePosition();
  }

  _positionContainer({
    top = 'auto',
    right = 'auto',
    bottom = 'auto',
    left = 'auto'
  }) {
    jquery_default()(this.getContainer()).css({
      position: this._fixedPosition ? 'fixed' : 'absolute',
      top: top !== 'auto' ? top + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      right: right !== 'auto' ? right + (this._fixedPosition ? 0 : window.scrollX) : 'auto',
      bottom: bottom !== 'auto' ? bottom + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      left: left !== 'auto' ? left + (this._fixedPosition ? 0 : window.scrollX) : 'auto'
    });
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left
    } = target.getBoundingClientRect();

    this._positionContainer({
      top,
      left
    });
  }

  resetShowTimer() {
    if (this._showTimer) {
      this._cancelShowTimer();

      this._startShowTimer();
    }
  }

  _startCloseFade() {
    if (this._closeFadeTimer) return;
    this._closeFadeTimer = setTimeout(() => {
      this.remove();
    }, this._options.fadeSpeed * 1000);
    this.getContainer().style.transitionDuration = `${this._options.fadeSpeed}s`;
    this.getContainer().classList.add('transitionToTransparent');
  }

  _clearCloseFade() {
    if (!this._closeFadeTimer) return;
    clearTimeout(this._closeFadeTimer);
    this.getContainer().style.transitionDuration = '';
    this.getContainer().classList.remove('transitionToTransparent');
    this._closeFadeTimer = null;
  }

  close(fade = false) {
    if (!this._options.enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    if (fade) this._startCloseFade();else this.remove();
  }

  remove() {
    this._clearCloseFade();

    this.getContainer().remove();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this.visible = false;

    if (this._options.closeOnMouseOut) {
      document.body.removeEventListener('mousemove', this._checkMouseLeave);
      document.body.removeEventListener('mouseover', this._checkMouseLeave);
    }
  }

}

hover_Hover._defaultOptions = {};

class hover_HoverInfoCard extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverInfoCard RESDialogSmall">
			<h3 class="RESHoverTitle" data-hover-element="0"></h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESHoverBody RESDialogContents" data-hover-element="1"></div>
		</div>
	`;
    this._loadIndicator = '<div class="RESCenteredLoadIndicator"><span class="RESLoadingSpinner"></span></div>';
  }

  _displayLoadIndicator() {
    this.populate(['', this._loadIndicator]);
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      bottom,
      right
    } = target.getBoundingClientRect();
    const $container = jquery_default()(this.getContainer()).removeClass('right below');
    const tooltipWidth = this._options.width;
    let tooltipLeft, tooltipTop;

    if (!this._options.pin && right + tooltipWidth + 25 < getViewportSize().width) {
      tooltipTop = top - 14;
      tooltipLeft = right + 25;
    } else if (this._options.pin === pin.bottom || left - tooltipWidth - 30 < 0) {
      $container.addClass('below');
      tooltipTop = bottom + 10;
      tooltipLeft = Math.min(Math.max(getViewportSize().width - tooltipWidth, 0), left);
    } else {
      $container.addClass('right');
      tooltipTop = top - 14;
      tooltipLeft = left - tooltipWidth - 30;
    }

    $container.get(0).style.width = `${tooltipWidth}px`;

    this._positionContainer({
      left: tooltipLeft,
      top: tooltipTop
    });
  }

}

class hover_HoverDropdownList extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverDropdownList RESDropdownList">
			<ul class="RESDropdownOptions" data-hover-element="0"></ul>
		</div>
	`;
    this._options = { ...hover_Hover._defaultOptions,
      pin: pin.bottom,
      offsetWidth: 0,
      offsetHeight: 2,
      bottomPadding: 10
    };
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      height,
      width
    } = target.getBoundingClientRect();
    const $container = jquery_default()(this.getContainer());

    switch (this._options.pin) {
      case pin.right:
        const bottomAlign = top + $container.height() + this._options.bottomPadding > getViewportSize().height;

        if (bottomAlign) {
          this._positionContainer({
            left: left + width,
            bottom: this._options.bottomPadding
          });
        } else {
          this._positionContainer({
            left: left + width,
            top: top + this._options.offsetHeight
          });
        }

        break;

      case pin.bottom:
      default:
        const leftAlign = left + $container.outerWidth() < getViewportSize().width;

        if (leftAlign) {
          this._positionContainer({
            left,
            top: top + height + this._options.offsetHeight
          });
        } else {
          this._positionContainer({
            right: getViewportSize().width - left - width + this._options.offsetWidth,
            top: top + height + this._options.offsetHeight
          });
        }

        break;
    }
  }

}
// EXTERNAL MODULE: ./node_modules/dompurify/dist/purify.js
var purify = __webpack_require__(23);

// CONCATENATED MODULE: ./lib/modules/commandLine.js






const commandLine_module = new Module('commandLine');
commandLine_module.moduleName = 'commandLineName';
commandLine_module.description = 'commandLineDesc';
commandLine_module.category = 'coreCategory';
commandLine_module.options = {
  launch: {
    title: 'commandLineLaunchTitle',
    type: 'button',
    text: 'Launch',
    description: 'commandLineLaunchDesc',

    callback() {
      commandLine_open();
    }

  },
  menuItem: {
    title: 'commandLineMenuItemTitle',
    type: 'boolean',
    description: 'commandLineMenuItemDesc',
    value: false
  }
};

commandLine_module.contentStart = () => {
  if (commandLine_module.options.menuItem.value) {
    addMenuItem();
  }
};

function addMenuItem() {
  menu_addMenuItem(() => string_namespaceObject.html`<div>command line <span class="RESMenuItemButton res-icon">\uF060</span></div>`, () => commandLine_open());
}

const commandLine = lodash_once_default()(() => {
  const widget = string_namespaceObject.html`
		<div id="keyCommandLineWidget" hidden>
			<div id="keyCommandForm">
				<input id="keyCommandInput" type="text" autocomplete="off">
				type a command, ? for help, esc to close
				<div id="keyCommandInputTip"></div>
				<div id="keyCommandInputError"></div>
			</div>
		</div>
	`;
  document.body.append(widget);
  const input = downcast(widget.querySelector('#keyCommandInput'), HTMLInputElement);
  const tip = widget.querySelector('#keyCommandInputTip');
  const error = widget.querySelector('#keyCommandInputError');

  const setTip = str => {
    tip.innerHTML = Object(purify["sanitize"])(str);
  };

  const clearTip = () => empty(tip);

  const setError = str => {
    error.innerHTML = Object(purify["sanitize"])(str);
  };

  const clearError = () => empty(error);

  input.addEventListener('blur', () => {
    if (!input.value.length) {
      commandLine_close();
    } else {
      setError('click into the text input and press escape to close the command line');
    }
  });
  document.addEventListener('keyup', e => {
    if (!widget.hidden && e.key === NAMED_KEYS.Escape) {
      commandLine_close();
      e.stopImmediatePropagation();
    }
  });
  input.addEventListener('input', async () => {
    clearTip();
    clearError();
    const tip = await commandLine_getTip(commandLine_parse(input.value));
    if (tip) setTip(tip);
  });
  const commandLineForm = widget.querySelector('#keyCommandForm');
  commandLineForm.addEventListener('keydown', async e => {
    if (e.key === NAMED_KEYS.Enter) {
      const error = await commandLine_executeCommand(commandLine_parse(input.value), e);

      if (error) {
        setError(error);
      } else if (error !== false) {
        commandLine_close();
      }
    }
  });
  return {
    widget,
    input
  };
});

function commandLine_open(initialCmd = '') {
  commandLine().widget.hidden = false;
  commandLine().input.focus();
  commandLine().input.value = initialCmd;
  commandLine().input.dispatchEvent(new Event('input'));
}

function commandLine_close() {
  commandLine().input.blur();
  commandLine().widget.hidden = true;
}

function commandLine_toggle() {
  if (commandLine().widget.hidden) commandLine_open();else commandLine_close();
}

function navigateTo(url, e) {
  if (e.shiftKey) {
    openNewTab(url, !e.altKey);
  } else {
    location.href = url;
  }
}

const commands = [];
function registerCommand(commandPredicate, description, getTip, executeCommand) {
  commands.push({
    commandPredicate,
    description,
    getTip,
    executeCommand
  });
}

function getCommandSpec(command, val) {
  let result;
  commands.some(commandSpec => {
    let predicateResult;

    if (typeof commandSpec.commandPredicate.exec === 'function') {
      predicateResult = commandSpec.commandPredicate.exec(command);
    } else if (typeof commandSpec.commandPredicate === 'string') {
      predicateResult = commandSpec.commandPredicate === command;
    } else if (typeof commandSpec.commandPredicate === 'function') {
      predicateResult = commandSpec.commandPredicate(command, val);
    }

    if (predicateResult) {
      result = { ...commandSpec,
        predicateResult
      };
      return true;
    }
  });
  return result;
}

function commandLine_parse(input) {
  const splitWords = input.split(' ');
  const command = splitWords[0];
  const value = splitWords.slice(1).join(' ');
  return {
    command,
    value
  };
}

function commandLine_getTip({
  command,
  value
}) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.getTip(command, value, matchingCommandSpec.predicateResult) || matchingCommandSpec.description;
  }
}

function commandLine_executeCommand({
  command,
  value
}, event) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.executeCommand(command, value, matchingCommandSpec.predicateResult, event);
  } else {
    return 'unknown command - type ? for help';
  }
}

registerCommand(/^\/?r\/(.*)/, 'r/[subreddit] - navigates to subreddit', (command, val, match) => `navigate to subreddit: ${match[1]}`, (command, val, match, e) => {
  navigateTo(`/r/${match[1]}`, e);
});
registerCommand(/^\/?m\/(.*)/, 'm/[multi] - view your multi-reddit [multi]', (command, val, match) => `navigate to multi-reddit: /me/m/${match[1]}`, (command, val, match, e) => {
  navigateTo(`/me/m/${match[1]}`, e);
});
registerCommand('m', 'm - go to inbox', () => 'View messages', (command, value, match, e) => {
  navigateTo('/message/inbox/', e);
});
registerCommand('mm', 'mm - go to moderator mail', () => 'View moderator mail', (command, value, match, e) => {
  navigateTo('/message/moderator/', e);
});
registerCommand('front', 'front - go to frontpage', () => 'Go to frontpage', (command, value, match, e) => {
  navigateTo('/', e);
});
registerCommand(/^XHR/, 'XHRCache clear - manipulate the XHR cache', () => 'clear - clear the cache (use if inline images aren\'t loading properly)', (command, value) => {
  if (/^\s*$/.test(value)) {
    return 'Operation required [clear]';
  }

  switch (value) {
    case 'clear':
      xhrCache_namespaceObject.clear();
      break;

    default:
      return 'The only accepted operation is <tt>clear</tt>';
  }
});
registerCommand(/^user$|^u$|^\/?u(?:ser)?\/(\w*((?!\/m\/).)*)$/, 'user [username] or u/[username] - view profile for [username]', (command, val, match) => {
  val = val || match[1];

  if (!val && loggedInUser()) {
    return 'go to profile';
  } else if (!val) {
    return false;
  } else {
    return `go to profile for: ${val}`;
  }
}, (command, val, match, e) => {
  val = val || match[1] || loggedInUser();

  if (!val) {
    return 'not logged in';
  }

  navigateTo(`/u/${val}`, e);
});
registerCommand(/^\/?u(?:ser)?\/(\w+)\/m(?:\/(.+))?/, 'u/[username]/m/[multi] - view the multireddit [multi] curated by [username]', (command, val, match) => `navigate to multi-reddit: /u/${match[1]}/m/${match[2] || ''}`, (command, val, match, e) => {
  if (!match[1]) {
    return 'no multi-reddit specified';
  }

  navigateTo(`/u/${match[1]}/m/${match[2]}`, e);
});
registerCommand(/^\/?me(?:\/?(.*))$/, ['me - view profile for current user', 'me/saved or me/s - view current user\'s saved links', 'me/saved#comments or me/sc - view current user\'s saved comments', 'me/submitted or me/sub - view current user\'s submitted content', 'me/comments or me/c - view current user\'s comments', 'me/gilded or me/g - view current user\'s gilded content', 'me/liked or me/l - view current user\'s liked content ', 'me/disliked or me/d - view current user\'s disliked content', 'me/hidden or me/h - view current user\'s hidden content'], (command, val, match) => {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    return 'not logged in';
  }

  let str;

  switch (match[1]) {
    case '':
      str = `navigate to user profile: ${loggedIn}`;
      break;

    case 'saved':
    case 's':
      str = 'navigate to current user\'s saved content';
      break;

    case 'saved#comments':
    case 'sc':
      str = 'navigate to current RES\'s saved comments';
      break;

    case 'submitted':
    case 'sub':
      str = 'navigate to current user\'s submitted content';
      break;

    case 'comments':
    case 'c':
      str = 'navigate to current user\'s comments';
      break;

    case 'gilded':
    case 'g':
      str = 'navigate to current user\'s gilded content';
      break;

    case 'liked':
    case 'l':
      str = 'navigate to current user\'s liked content';
      break;

    case 'disliked':
    case 'd':
      str = 'navigate to current user\'s disliked content';
      break;

    case 'hidden':
    case 'h':
      str = 'navigate to current user\'s hidden content';
      break;

    default:
      str = 'navigate to [s]aved, [s]aved[c]omments, [sub]mitted, [c]omments, [g]ilded, [l]iked, [d]isliked, [h]idden';
      break;
  }

  return str;
}, (command, val, match, e) => {
  const currentUser = loggedInUser();

  if (!currentUser) {
    return 'not logged in';
  }

  switch (match[1]) {
    case '':
      navigateTo(`/user/${currentUser}`, e);
      break;

    case 'saved':
    case 's':
      navigateTo(`/user/${currentUser}/saved`, e);
      break;

    case 'saved#comments':
    case 'sc':
      navigateTo(`/user/${currentUser}/saved#comments`, e);
      break;

    case 'submitted':
    case 'sub':
      navigateTo(`/user/${currentUser}/submitted`, e);
      break;

    case 'comments':
    case 'c':
      navigateTo(`/user/${currentUser}/comments`, e);
      break;

    case 'gilded':
    case 'g':
      navigateTo(`/user/${currentUser}/gilded`, e);
      break;

    case 'liked':
    case 'l':
      navigateTo(`/user/${currentUser}/liked`, e);
      break;

    case 'disliked':
    case 'd':
      navigateTo(`/user/${currentUser}/disliked`, e);
      break;

    case 'hidden':
    case 'h':
      navigateTo(`/user/${currentUser}/hidden`, e);
      break;

    default:
      return 'unknown command - type ? for help';
  }
});
registerCommand('userinfo', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`
    }).then(alert_namespaceObject.open);
  }
});
registerCommand('userbadge', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`,
      type: 'json'
    }).then(({
      data
    }) => alert_namespaceObject.open(`, .id-t2_${data.id}::before`));
  }
});
{
  const optionsRegex = /(?:RES)?opt(?:ion)?s?[\.\s]+(.*)/i;
  const moduleDataRegex = /(?:RES)?mod(?:ule)?s?[\.\s]+(.*)/i;

  function sanitizeStorageKey(key) {
    let match;

    if (match = optionsRegex.exec(key)) {
      key = `RESoptions.${match[1]}`;
    } else if (match = moduleDataRegex.exec(key)) {
      key = `RESmodules.${match[1]}`;
    }

    return key;
  }

  function executeCommand(command, key, value) {
    if (command === 'get') {
      storage_namespaceObject.get(key).then(value => alert_namespaceObject.open(string_namespaceObject.escape`Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value)}</textarea>`));
    } else if (command === 'update') {
      storage_namespaceObject.get(key).then(value => {
        const element = string_namespaceObject.html`<div>Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value)}</textarea></div>`;
        alert_namespaceObject.open(element, {
          cancelable: true
        }).then(() => storage_namespaceObject.set(key, JSON.parse(downcast(element.querySelector('textarea'), HTMLTextAreaElement).value)));
      });
    } else if (command === 'remove') {
      storage_namespaceObject.delete(key);
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] deleted`);
    } else if (command === 'set') {
      storage_namespaceObject.set(key, JSON.parse(value));
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] set to:<br><br><textarea rows="5" cols="50">${value}</textarea>`);
    } else {
      return 'You must specify either "get [key]" or "set [key] [value]"';
    }
  }

  registerCommand(/(?:RES)?stor(?:e|age)?/i, 'RESStorage [get|set|update|remove] [key] [value] - For debug use only, you shouldn\'t mess with this unless you know what you\'re doing.', () => {}, (command, val) => {
    const splitWords = val.split(' ');

    if (splitWords.length < 2) {
      return 'You must specify "get [key]", "update [key]" or "set [key] [value]"';
    } else {
      const key = sanitizeStorageKey(splitWords[1]);
      const value = splitWords.slice(2).join(' ');
      return executeCommand(splitWords[0], key, value);
    }
  });
}
const sortTypes = {
  n: 'new',
  t: 'top',
  h: 'hot',
  r: 'rising',
  c: 'controversial',
  g: 'gilded',
  p: 'ads'
};

const sortTypeRecognizesPeriod = sortType => sortTypes.t === sortType || sortTypes.c === sortType;

const periods = ['hour', 'day', 'week', 'month', 'year', 'all'];

const getPeriod = val => val && periods.find(period => period.startsWith(val));

registerCommand(/^\/([nthrcgp])?/, '/n, /t, /h, /r, /c, /g, or /p - goes to new, top, hot, rising, controversial, gilded, or promoted sort of current subreddit, multireddit or user page', (command, val, match) => {
  const sortType = sortTypes[match[1]];

  if (sortType) {
    return sortTypeRecognizesPeriod(sortType) ? `sort by ${sortType} [(${periods.map(period => getPeriod(val) === period ? `<b>${period}</b>` : period).join('|')})]` : `sort by ${sortType}`;
  } else {
    return 'sort by ([n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted)';
  }
}, (command, val, match, e) => {
  const sortType = sortTypes[match[1]];

  if (!sortType) {
    return 'invalid sort command - must be one of [n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted';
  }

  function _navigateTo(v) {
    const url = new URL(v, location.href);
    const period = getPeriod(val);

    if (sortTypeRecognizesPeriod(sortType) && period) {
      url.searchParams.append('t', period);
    }

    navigateTo(url.href, e);
  }

  const currentUser = currentUserProfile();

  if (currentUser) {
    if (sortType === 'gilded') {
      _navigateTo(`/user/${currentUser}/${sortType}`);
    } else if (sortType === 'ads' || sortType === 'rising') {
      return `invalid sort command - "${sortType}" is not supported on profile pages`;
    } else {
      _navigateTo(`/user/${currentUser}?sort=${sortType}`);
    }

    return;
  }

  const subreddit = currentSubreddit();

  if (subreddit) {
    _navigateTo(`/r/${subreddit}/${sortType}`);

    return;
  }

  const multi = currentMultireddit();

  if (multi) {
    _navigateTo(`/${multi}/${sortType}`);
  } else {
    _navigateTo(`/${sortType}`);
  }
});
registerCommand(cmd => ['s', 'search'].includes(cmd), 's[earch] [query] - searches the current subreddit (if any) or all of Reddit', (command, val) => {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    return `Search all of Reddit: ${val}`;
  }

  return `Search /r/${subreddit}: ${val}`;
}, (command, val, match, e) => {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
    return;
  }

  navigateTo(string_namespaceObject.encode`/r/${subreddit}/search?q=${val}&restrict_sr=on`, e);
});
registerCommand('sr', 'sr [query] - searches all of Reddit', (command, val) => `Search all of Reddit: ${val}`, (command, val, match, e) => {
  navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
});
registerCommand('?', false, () => {
  const descriptions = commands.map(command => command.description).reduce((a, b) => b ? a.concat(b) : a, []);

  if (descriptions.length) {
    return `<ul><li>${descriptions.join('</li><li>')}</li></ul>`;
  }
}, () => false);
// CONCATENATED MODULE: ./lib/modules/menu.js







const menu_module = new Module('RESMenu');
menu_module.moduleName = 'menuName';
menu_module.category = 'coreCategory';
menu_module.description = 'The <span class="gearIcon"></span> dropdown menu to manage RES settings and quick options';
menu_module.descriptionRaw = true;
menu_module.alwaysEnabled = true;
menu_module.options = {
  gearIconClickAction: {
    title: 'menuGearIconClickActionTitle',
    type: 'enum',
    values: [{
      name: 'menuGearIconClickActionOpenSettings',
      value: 'openSettings'
    }, {
      name: 'menuGearIconClickActionOpenCommandLine',
      value: 'openCommandLine'
    }, {
      name: 'menuGearIconClickActionToggleMenu',
      value: 'toggleMenu'
    }, {
      name: 'menuGearIconClickActionToggleMenuNoHover',
      value: 'toggleMenuNoHover'
    }],
    value: 'toggleMenuNoHover',
    description: 'menuGearIconClickActionDesc',
    bodyClass: true,
    advanced: true
  }
};
const menu_items = [];
let gear;

menu_module.contentStart = () => {
  gear = string_namespaceObject.html`<span id="RESSettingsButton" style="cursor: pointer" title="${i18n('RESSettings')}" class="gearIcon"></span>`;

  if (menu_module.options.gearIconClickAction.value !== 'toggleMenuNoHover') {
    gear.addEventListener('mouseenter', () => {
      showDropdown(200);
    });
  }

  gear.addEventListener('click', () => {
    if (menu_module.options.gearIconClickAction.value === 'openCommandLine' && isRunning(commandLine_namespaceObject)) {
      commandLine_toggle();
      hideDropdown();
    } else if (menu_module.options.gearIconClickAction.value === 'openSettings') {
      settingsNavigation_open();
      hideDropdown();
    } else {
      showDropdown(0);
    }
  });
  addFloater(gear, {
    order: 5,
    container: 'inNavbar'
  });
};

menu_module.afterLoad = () => {
  requestAnimationFrame(addLegacyStyling);
};

function showDropdown(openDelay) {
  dropdownList(menu_module.moduleID).options({
    openDelay,
    fadeDelay: 200,
    fadeSpeed: 0.2
  }, false).populateWith(() => {
    const f = document.createDocumentFragment();
    f.append(...menu_items.sort(({
      order: a
    }, {
      order: b
    }) => a - b).map(buildItem));
    return [f];
  }).target(gear).begin();
}

function hideDropdown() {
  dropdownList(menu_module.moduleID).close(true);
}

function menu_addMenuItem(getElement, onClick = () => {}, order = 0) {
  menu_items.push({
    getElement,
    onClick,
    order
  });
}

function buildItem({
  getElement,
  onClick
}) {
  const li = document.createElement('li');
  li.addEventListener('click', onClick, true);
  li.addEventListener('click', hideDropdown);
  li.append(getElement());
  return li;
}

function addLegacyStyling() {
  const {
    backgroundImage
  } = window.getComputedStyle(gear);

  if (backgroundImage && backgroundImage !== 'none') {
    gear.classList.add('res-gearIcon-legacy');
  }
}
// CONCATENATED MODULE: ./lib/modules/settingsNavigation.js







const settingsNavigation_module = new Module('settingsNavigation');
settingsNavigation_module.moduleName = 'settingsNavName';
settingsNavigation_module.category = 'coreCategory';
settingsNavigation_module.description = 'settingsNavDesc';
settingsNavigation_module.hidden = true;
settingsNavigation_module.alwaysEnabled = true;
settingsNavigation_module.options = {
  showAllOptions: {
    title: 'settingsNavigationShowAllOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'settingsNavigationShowAllOptionsDesc',
    noconfig: true
  },
  showAllOptionsAlert: {
    title: 'settingsNavigationShowAllOptionsAlertTitle',
    type: 'boolean',
    value: true,
    description: 'settingsNavigationShowAllOptionsAlertDesc',
    noconfig: true
  }
};

settingsNavigation_module.beforeLoad = () => {
  menu_addMenuItem(() => string_namespaceObject.html`<div id="SettingsConsole">
			${i18n('RESSettingsConsole')}
			<span module="search" class="RESMenuItemButton res-icon" title="search settings">\uF094</span>
		</div>`, e => settingsNavigation_open(e.target.getAttribute('module')), -10);
  registerCommand(/^set(?:t?ings?)?$/, 'settings [words to search for]- search RES settings console', (command, val) => `Search RES settings ${val && val.length ? ` for: ${val}` : ''}`, (command, val) => settingsNavigation_open('search', val));
};

settingsNavigation_module.contentStart = () => {
  function findModules(val) {
    return modules_all().filter(v => !v.hidden).map(v => v.moduleID).filter(id => id.toLowerCase().match(val.toLowerCase())).sort();
  }

  registerCommand(/^mod(?:ule?)?$/, 'module [name of module] - open module settings', (command, val) => {
    const matches = findModules(val);
    return matches.length ? `Open module ${matches[0]}` : 'Could not find any matching module.';
  }, (command, val) => settingsNavigation_open(findModules(val)[0]));
  window.addEventListener('popstate', () => {
    settingsNavigation_update();
  });
  settingsNavigation_update();
  document.body.addEventListener('click', e => {
    if (e.ctrlKey) return;
    const url = e.target instanceof HTMLAnchorElement && new URL(e.target.href, location.origin);

    if (url && isSettingsUrl(url.href)) {
      settingsNavigation_update(url);
      e.stopImmediatePropagation();
      e.preventDefault();
    }
  }, true);
};

function makeUrlHashLink(moduleID, optionKey, displayText, cssClass) {
  const mod = getUnchecked(moduleID);

  if (!displayText) {
    if (mod && optionKey) {
      displayText = i18n(mod.options[optionKey].title);
    } else if (mod) {
      displayText = i18n(mod.moduleName);
    } else {
      displayText = 'Settings';
    }
  }

  let title = ['RES Settings'];

  if (mod) {
    title.push(i18n(mod.moduleName));
  }

  if (optionKey) {
    title.push(optionKey);
  }

  title = title.join(' &gt; ');
  const hash = makeUrlHash(moduleID, optionKey);
  return `<a class="${cssClass || ''}" href="${hash}" title="${title}">${displayText}</a>`;
}
function parseHash(hash) {
  const params = hash.match(/\/(?:\w|\s|%20)+/g);
  return {
    moduleID: params && params[0] && params[0].substring(1).replace('%20', ' ') || undefined,
    optionKey: params && params[1] && params[1].substring(1).replace('%20', ' ') || undefined
  };
}
function makeUrlHash(moduleID, optionKey) {
  const hashComponents = [RES_SETTINGS_HASH];

  if (moduleID) {
    hashComponents.push(moduleID);
  }

  if (moduleID && optionKey) {
    hashComponents.push(optionKey);
  }

  return hashComponents.join('/');
}
function isSettingsUrl(href) {
  const {
    origin,
    hash
  } = new URL(href, location.origin);
  const sameSite = origin === getOptionsURL().origin || origin.split('.').slice(-2).join('.') === context_data.origin.split('.').slice(-2).join('.');
  if (!sameSite) return false;
  return hash.startsWith(RES_SETTINGS_HASH) || hash.startsWith('#!settings');
}
function setHash(hash) {
  if (window.top === window) {
    if (parseHash(location.hash).moduleID === parseHash(hash).moduleID) {
      history.replaceState(null, '', hash);
    } else {
      history.pushState(null, '', hash);
    }
  } else {
    window.parent.postMessage({
      hash
    }, '*');
  }
}
let iframe;
function settingsNavigation_update(url = location) {
  if (isSettingsUrl(url.href)) {
    const {
      moduleID,
      optionKey
    } = parseHash(url.hash);
    settingsNavigation_open(moduleID, optionKey);
  } else if (iframe) {
    iframe.contentWindow.postMessage({
      close: true
    }, '*');
  }
}

function listener({
  origin,
  data
}) {
  if (origin !== getOptionsURL().origin) return;
  const {
    failedToLoad,
    hash,
    closing
  } = data;
  if (failedToLoad) handleEmbedFailure();
  if (hash) setHash(hash);
  if (closing) settingsNavigation_close();
}

function handleEmbedFailure() {
  console.warn('Embed failed. Opening RES settings console in new tab');
  if (iframe) openNewTab(iframe.src, true);
  settingsNavigation_close();
}

function settingsNavigation_open(moduleID, optionKey) {
  if (iframe || isOptionsPage()) {
    (iframe && iframe.contentWindow || window).postMessage({
      load: {
        moduleID,
        optionKey
      }
    }, '*');
  } else {
    iframe = document.createElement('iframe');
    iframe.id = 'console-container';
    iframe.src = getOptionsURL(makeUrlHash(moduleID, optionKey)).href;
    window.addEventListener('message', listener);
    iframe.addEventListener('load', () => {
      if (iframe) iframe.contentWindow.postMessage({
        context: context_data
      }, '*');
      let success;
      window.addEventListener('message', ({
        origin,
        data
      }) => {
        if (origin === getOptionsURL().origin && data.loadSuccess) success = true;
      });
      setTimeout(() => {
        if (!success) handleEmbedFailure();
      }, 3000);
    });
    document.body.append(iframe);
    document.body.classList.add('res-console-open');
  }
}
function settingsNavigation_close() {
  if (isOptionsPage()) {
    window.parent.postMessage({
      closing: true
    }, '*');
    window.close();
  } else {
    window.removeEventListener('message', listener);
    if (!iframe) return;
    iframe.remove();
    iframe = null;
    document.body.classList.remove('res-console-open');
    if (isSettingsUrl(location.href)) history.pushState(null, '', location.pathname + location.search);
  }
}
// CONCATENATED MODULE: ./lib/modules/notifications.js








const notifications_module = new Module('notifications');
notifications_module.moduleName = 'notificationsName';
notifications_module.category = 'coreCategory';
notifications_module.description = 'notificationsDesc';
notifications_module.options = {
  sticky: {
    description: 'notificationStickyDesc',
    title: 'notificationStickyTitle',
    type: 'enum',
    value: 'notificationType',
    values: [{
      name: 'notificationsPerNotificationType',
      value: 'notificationType'
    }, {
      name: 'notificationsAlwaysSticky',
      value: 'all'
    }, {
      name: 'notificationsNeverSticky',
      value: 'none'
    }]
  },
  closeDelay: {
    type: 'text',
    value: '3000',
    description: 'notificationCloseDelayDesc',
    title: 'notificationCloseDelayTitle'
  },
  fadeOutLength: {
    type: 'text',
    value: '3000',
    description: 'notificationFadeOutLengthDesc',
    title: 'notificationFadeOutLengthTitle',
    advanced: true
  },
  notificationTypes: {
    description: 'notificationNotificationTypesDesc',
    title: 'notificationNotificationTypesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'notificationsAddNotificationType',
    fields: [{
      key: 'id',
      name: 'notificationsNotificationID',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'notificationsEnabled',
      type: 'boolean',
      value: true
    }, {
      key: 'sticky',
      name: 'notificationsSticky',
      type: 'boolean',
      value: false
    }],
    value: []
  }
};
const notificationsContainer = string_namespaceObject.html`<div id="RESNotifications"></div>`;
const lastShownStorage = storage_namespaceObject.wrapBlob('notifications.lastShown', () => 0);

notifications_module.go = () => {
  document.body.append(notificationsContainer);
};

const activeNotifications = new Set();
function notifications_showNotification(opts, _delay) {
  const data = typeof opts === 'string' ? {
    message: opts
  } : opts;
  const id = `${String(firstValid(data.moduleID, '--'))}-${String(firstValid(data.notificationID, data.optionKey, data.header, hashCode(data.message instanceof HTMLElement ? data.message.outerHTML : data.message)))}`;
  const mod = data.moduleID && getUnchecked(data.moduleID);
  const element = string_namespaceObject.html`
		<div class="RESNotification" data-id="${id}">
			<div class="RESNotificationHeader">
				<h3>${data.header || (mod ? i18n(mod.moduleName) : '') || ''}</h3>
				${mod && !mod.hidden ? string_namespaceObject.safe(makeUrlHashLink(mod.moduleID, data.optionKey, ' ', 'gearIcon')) : ''}
				<div class="RESCloseButton"></div>
			</div>
			<div class="RESNotificationContent"></div>
			<div class="RESNotificationFooter" ${data.noDisable ? 'hidden' : ''}>
				<label class="RESNotificationToggle" title="Show notifications from ${id}">
					<input type="checkbox" checked> Always show this type of notification
				</label>
			</div>
		</div>
	`;
  jquery_default()(element.querySelector('.RESNotificationContent')).append(data.message);
  const inner = element.innerHTML;
  const existing = [...activeNotifications.values()].find(({
    element
  }) => element.innerHTML === inner);

  if (existing) {
    existing.element.dispatchEvent(new CustomEvent('notification-reset'));
    return existing;
  }

  const close = lodash_once_default()(() => {
    activeNotifications.delete(notification);
    element.remove();
  });

  const notification = {
    element,
    close
  };
  activeNotifications.add(notification);
  const storage = options_table_namespaceObject.getMatchingValueOrAdd(notifications_module, 'notificationTypes', {
    id
  }, data);
  element.querySelector('.RESNotificationToggle input').addEventListener('change', e => {
    storage.enabled = e.currentTarget.checked;
  });
  element.querySelector('.RESCloseButton').addEventListener('click', () => {
    close();
  });
  const isSticky = notifications_module.options.sticky.value === 'all' || notifications_module.options.sticky.value === 'notificationType' && storage.sticky;
  const delay = +firstValid(_delay, data.closeDelay, parseInt(notifications_module.options.closeDelay.value, 10), notifications_module.options.closeDelay.default);
  const fadeDuration = +firstValid(parseInt(notifications_module.options.fadeOutLength.value, 10), notifications_module.options.fadeOutLength.default);

  async function resetCloseTimer() {
    await new Promise(requestAnimationFrame);
    if (element.matches(':hover')) await waitForEvent(element, 'mouseleave');
    let fadeTimer;
    const hideTimer = setTimeout(() => {
      element.classList.add('transitionToTransparent');
      element.style.transitionDuration = `${fadeDuration / 1000}s`;
      fadeTimer = setTimeout(() => close(), fadeDuration);
    }, delay);
    await waitForEvent(element, 'mouseenter', 'notification-reset');
    element.classList.remove('transitionToTransparent');
    if (fadeTimer) clearTimeout(fadeTimer);
    if (hideTimer) clearTimeout(hideTimer);
    resetCloseTimer();
  }

  (async () => {
    if (!storage.enabled || !isRunning(notifications_module)) return;

    if (data.cooldown) {
      if (data.cooldown > Date.now() - (await lastShownStorage.get(id))) return;
      lastShownStorage.set(id, Date.now());
    }

    requestAnimationFrame(() => {
      if (window.getComputedStyle(element).maxHeight === 'initial') return;
      element.style.maxHeight = '100vh';
    });
    notificationsContainer.prepend(element);
    if (!isSticky && delay !== Infinity) resetCloseTimer();
  })();

  return notification;
}
// CONCATENATED MODULE: ./lib/modules/penaltyBox.js








const penaltyBox_module = new Module('penaltyBox');
const MIN_PENALTY = 1;
const MAX_PENALTY = 100;
penaltyBox_module.moduleName = 'penaltyBoxName';
penaltyBox_module.category = 'coreCategory';
penaltyBox_module.description = 'penaltyBoxDesc';
penaltyBox_module.options = {
  delayFeatures: {
    type: 'boolean',
    value: true,
    description: 'penaltyBoxDelayFeaturesDesc',
    title: 'penaltyBoxDelayFeaturesTitle'
  },
  suspendFeatures: {
    type: 'boolean',
    value: false,
    description: 'penaltyBoxSuspendFeaturesDesc',
    title: 'penaltyBoxSuspendFeaturesTitle'
  },
  features: {
    description: 'penaltyBoxFeaturesDesc',
    title: 'penaltyBoxFeaturesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'penaltyBoxFeaturesAddRowText',
    fields: [{
      key: 'moduleID',
      name: 'moduleID',
      type: 'text'
    }, {
      key: 'optionKey',
      name: 'optionKey',
      type: 'text'
    }, {
      key: 'monitoring',
      name: 'penaltyBoxFeaturesMonitoring',
      type: 'boolean',
      value: true
    }, {
      key: 'penalty',
      name: 'penaltyBoxFeaturesPenalty',
      type: 'text',
      value: '0'
    }],
    value: []
  }
};
function alterFeaturePenalty(moduleID, optionKey, valueDelta) {
  if (isNaN(parseInt(valueDelta, 10))) {
    console.warn('Could not alter penalty for', moduleID, optionKey, ' - bad value:', valueDelta);
    return MIN_PENALTY;
  }

  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);
  if (!value.monitoring) return MIN_PENALTY;
  value.penalty = clamp_default()(value.penalty + valueDelta, MIN_PENALTY, MAX_PENALTY);
  options_save(penaltyBox_module.options.features);

  if (value.penalty >= MAX_PENALTY) {
    suspendFeature(moduleID, optionKey);
  }

  return value.penalty;
}

function stopMonitoringFeature(moduleID, optionKey) {
  const value = getOrAddFeatures(moduleID, optionKey);
  value.monitoring = false;
  value.penalty = MIN_PENALTY;
  options_save(penaltyBox_module.options.features);
}

function getFeaturePenalty(moduleID, optionKey) {
  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  if (!penaltyBox_module.options.delayFeatures.value) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);

  if (!value.monitoring) {
    return MIN_PENALTY;
  }

  if (!value.penalty || MIN_PENALTY >= value.penalty) {
    return MIN_PENALTY;
  }

  return value.penalty;
}
function penalizedDelay(moduleID, optionKey, delayOption) {
  const penalty = getFeaturePenalty(moduleID, optionKey);

  if (!penalty || penalty === MIN_PENALTY) {
    return parseInt(delayOption.value, 10);
  }

  const max = parseInt(delayOption.penalizedValue || delayOption.value, 10) * 6;
  const initial = parseInt(delayOption.default, 10);
  return Math.min(max, (max - initial) * (penalty / 100) + initial);
}

const getOrAddFeatures = (moduleID, optionKey) => options_table_namespaceObject.getMatchingValueOrAdd(penaltyBox_module, 'features', {
  moduleID,
  optionKey
}, {
  penalty: 0
});

function suspendFeature(moduleID, optionKey) {
  const featureModule = modules_get(moduleID);
  const option = featureModule.options[optionKey];

  if (!option) {
    console.warn('Could not find option', moduleID, optionKey);
    return;
  }

  if (option.type !== 'boolean') {
    console.warn(`${penaltyBox_module.moduleID} could not disable option`, moduleID, optionKey);
    return;
  }

  const oldValue = option.value;
  const newValue = !option.value;
  options_storage_set(moduleID, optionKey, newValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  const notification = notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesNotificationHeader'),
    message: `
			${i18n('penaltyBoxSuspendFeaturesNotificationMessage', featureOptionLink)}
			<p><a class="RESNotificationButtonBlue" id="penaltyBoxEnableFeature" href="#">
				${i18n('penaltyBoxSuspendFeaturesUndoButton')}
			</a></p>
		`.trim()
  });
  jquery_default()(notification.element).on('click', '#penaltyBoxEnableFeature', e => {
    e.preventDefault();
    notification.close();
    pardonSuspendedFeature(moduleID, optionKey, oldValue);
  });
}

function pardonSuspendedFeature(moduleID, optionKey, oldValue) {
  options_storage_set(moduleID, optionKey, oldValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesRevertNotificationHeader'),
    message: i18n('penaltyBoxSuspendFeaturesRevertNotificationMessage', featureOptionLink)
  });
}
// EXTERNAL MODULE: ./node_modules/lodash/last.js
var lodash_last = __webpack_require__(13);
var last_default = /*#__PURE__*/__webpack_require__.n(lodash_last);

// EXTERNAL MODULE: ./node_modules/lodash/without.js
var without = __webpack_require__(18);
var without_default = /*#__PURE__*/__webpack_require__.n(without);

// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__(78);
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);

// EXTERNAL MODULE: ./node_modules/lodash/pickBy.js
var pickBy = __webpack_require__(22);
var pickBy_default = /*#__PURE__*/__webpack_require__.n(pickBy);

// CONCATENATED MODULE: ./lib/modules/filteReddit/Case.js



class Case_Case {
  static async getSelectedEntryValue() {
    const selected = selectedThing_namespaceObject.current;
    if (!selected) throw new Error('No entry is currently selected.');
    let conditions;

    if (this.defaultConditions) {
      if (!this.thingToCriterion) throw Error('Case does not have method `thingToCriterion`');
      conditions = this.criterionToConditions((await this.thingToCriterion(selected)));
    }

    const cased = this.fromConditions(conditions);
    const state = await cased.evaluate(selected);
    if (typeof state !== 'boolean') throw new Error('Could not evaluate case against selected thing');
    return {
      conditions,
      state
    };
  }

  static criterionToConditions(criterion) {
    const parse = this.parseCriterion && this.parseCriterion.bind(this);

    if (!parse) {
      throw new Error('Does not accept criterion');
    }

    if (!criterion && this.pattern && !this.pattern.startsWith('[')) {
      throw new Error('Requires criterion');
    }

    const parts = criterion.split(' & ');

    if (this.criterionOperators && criterion && parts.length > 1) {
      return getGroup('all', parts.map(v => cases_getConditions(this.type, parse(v))));
    } else {
      return parse(criterion);
    }
  }

  static fromConditions(from, propagateError = false) {
    let cased;
    const conditions = cases_getConditions(from && from.type || this.type, from);
    const type = conditions.type;

    try {
      const CaseClass = cases_get(type);
      if (CaseClass.disabled) throw new Error(`${CaseClass.type} is disabled`);
      cased = new CaseClass(conditions);
    } catch (e) {
      if (propagateError) throw e;
      console.error(`Could not build case: ${e.message}. Ignoring.`, e);
      cased = new cases_Inert(conditions);
    }

    return cased;
  }

  static buildRegex(val, {
    fullMatch = true
  } = {}) {
    if (!val) throw new Error('Pattern cannot be empty');

    if (string_namespaceObject.regexRegex.test(val)) {
      const [, str, flags] = string_namespaceObject.regexRegex.exec(val);
      return new RegExp(str, flags);
    } else {
      const patt = escapeRegExp_default()(val);

      return new RegExp(fullMatch ? `^${patt}$` : patt, 'i');
    }
  }

  static get disabled() {
    return false;
  }

  static validate(conditions) {
    const cased = Case_Case.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');
    return true;
  }

  static getCustomFilter() {
    if (this._customFilter) return this._customFilter;
    throw new Error('Source not found');
  }

  constructor(conditions) {
    this.trueText = void 0;
    this.falseText = void 0;
    this.conditions = void 0;
    this.value = void 0;
    this.observers = new Set();
    this.conditions = this.value = conditions;
  }

  isValid() {
    return true;
  }

  isEvaluatable() {
    return !(this instanceof cases_Inert || this.constructor.disabled);
  }

  hasType(type) {
    return this.constructor.type === type;
  }

  evaluate(thing, values) {
    throw new Error('evaluate() must be implemented for all Case subclasses');
  }

  onObserve() {}

  observe(observer) {
    if (!this.observers.has(observer) && this.onObserve()) {
      this.observers.add(observer);
      return true;
    }
  }

  refresh(thing) {
    for (const o of this.observers) o.refresh(thing);
  }

}
Case_Case.type = void 0;
Case_Case.text = void 0;
Case_Case.thingToCriterion = void 0;
Case_Case.parseCriterion = void 0;
Case_Case.defaultConditions = void 0;
Case_Case.fields = void 0;
Case_Case.slow = 0;
Case_Case.reconcile = void 0;
Case_Case.contexts = void 0;
Case_Case.unique = false;
Case_Case.variant = 'basic';
Case_Case.pattern = '';
Case_Case.criterionOperators = false;
Case_Case._customFilter = void 0;
class Case_PatternCase extends Case_Case {
  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static reconcile(values) {
    const variants = [];

    for (const v of values) {
      let variant;

      variantLoop: for (const possibleVariant of variants) {
        for (const key of Object.keys(v)) {
          if (key === 'patt') continue;
          if (possibleVariant[key] !== v[key]) continue variantLoop;
        }

        variant = possibleVariant;
        break;
      }

      if (!variant) {
        variant = { ...v,
          patt: []
        };
        variants.push(variant);
      }

      variant.patt.push(v.patt);
    }

    return variants;
  }

  build(fullMatchDefault, pattIfEmpty) {
    const {
      patt,
      fullMatch = fullMatchDefault
    } = this.conditions;
    const raw = Array.isArray(patt) ? patt : [patt];
    const plain = new Set();
    const variants = {};

    for (let _patt of raw) {
      if (!_patt) {
        if (typeof pattIfEmpty === 'string') _patt = pattIfEmpty;else if (raw.length === 1) throw new Error('Pattern cannot be empty');else continue;
      }

      if (string_namespaceObject.regexRegex.test(_patt)) {
        const [, str, flags = ''] = string_namespaceObject.regexRegex.exec(_patt);
        if (!variants[flags]) variants[flags] = [];
        variants[flags].push(str);
      } else {
        plain.add(escapeRegExp_default()(_patt));
      }
    }

    if (plain.size) {
      const str = Array.from(plain).join('|');
      if (!variants.i) variants.i = [];
      variants.i.push(fullMatch ? `^(${str})$` : str);
    }

    return Object.entries(variants).map(([flags, sources]) => new RegExp(sources.join('|'), flags));
  }

}
Case_PatternCase.defaultConditions = {
  patt: ''
};
Case_PatternCase.pattern = 'RegEx';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentCount.js


class CommentCount_CommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `comment count ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `comment count ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getCommentCount() || 0);
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const commentCount = thing.getCommentCount();
    if (isNaN(commentCount)) return null;
    return numericalCompare(this.value.op, commentCount, this.value.val);
  }

}
CommentCount_CommentCount.text = 'Comment count';
CommentCount_CommentCount.defaultConditions = {
  op: '>',
  val: 0
};
CommentCount_CommentCount.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' comments'];
CommentCount_CommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/newCommentCount.js






const newCommentCount_module = new Module('newCommentCount');
newCommentCount_module.moduleName = 'newCommentCountName';
newCommentCount_module.category = 'submissionsCategory';
newCommentCount_module.description = 'newCommentCountDesc';
newCommentCount_module.options = {
  hideWhenUnchanged: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountHideWhenUnchangedDesc',
    title: 'newCommentCountHideWhenUnchangedTitle'
  },
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'newCommentCountCleanCommentsDesc',
    title: 'newCommentCountCleanCommentsTitle',
    advanced: true
  },
  subscriptionLength: {
    type: 'text',
    value: '2',
    description: 'newCommentCountSubscriptionLengthDesc',
    title: 'newCommentCountSubscriptionLengthTitle'
  },
  showSubscribeButton: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountShowSubscribeButtonDesc',
    title: 'newCommentCountShowSubscribeButtonTitle'
  },
  notifyEditedPosts: {
    dependsOn: options => options.showSubscribeButton.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountNotifyEditedPostsDesc',
    title: 'newCommentCountNotifyEditedPostsTitle',
    advanced: true
  },
  monitorPostsVisited: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountMonitorPostsVisitedDesc',
    title: 'newCommentCountMonitorPostsVisitedTitle',
    advanced: true
  },
  monitorPostsVisitedIncognito: {
    dependsOn: options => options.monitorPostsVisited.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountMonitorPostsVisitedIncognitoDesc',
    title: 'newCommentCountMonitorPostsVisitedIncognitoTitle',
    advanced: true
  }
};
const newCommentCount_entryStorage = storage_namespaceObject.wrapPrefix('newCommentCount.', () => {
  throw new Error('Default value should never be retrieved');
}, undefined, true);
const subscriptionStorage = storage_namespaceObject.wrapBlob('RESmodules.newCommentCount.subscriptions', () => {
  throw new Error('Subscription not found');
});
let subscriptionButton;

newCommentCount_module.beforeLoad = () => {
  if (isPageType('comments') && newCommentCount_module.options.showSubscribeButton.value) {
    subscriptionButton = string_namespaceObject.html`<span id="REScommentSubToggle" class="RESSubscriptionButton"></span>`;
    refreshSubscriptionButton();
  }

  watchForThings(['post'], getNewCount, {
    immediate: true
  });
  watchForThings(['post'], displayNewCommentCount);
};

newCommentCount_module.contentStart = () => {
  if (subscriptionButton) {
    jquery_default()('.commentarea .panestack-title').append(subscriptionButton);
  }

  addDashboardTab('newCommentsContents', 'My Subscriptions', newCommentCount_module.moduleID, addDashboardFunctionality);
  maybePruneOldEntries('newCommentCount', newCommentCount_entryStorage, parseInt(newCommentCount_module.options.cleanComments.value, 10));
};

let listingThing;
let currentCommentCount;

newCommentCount_module.afterLoad = () => {
  if (!document.hidden) {
    checkSubscriptions();
  }

  if (isPageType('comments')) {
    listingThing = Thing_Thing.from(document.querySelector('#siteTable a.comments'));

    if (listingThing) {
      currentCommentCount = listingThing.getCommentCount();

      if (typeof currentCommentCount === 'number') {
        setEntry(getId(listingThing), currentCommentCount);
        watchForThings(['comment'], updateCurrentCommentCountFromMyComment);
      }
    }
  }
};

const getId = thing => thing.getFullname().split('_').slice(-1)[0];

const hasEntry = thing => newCommentCount_entryStorage.has(getId(thing));

function setEntry(id, newCommentCount) {
  if (!newCommentCount_module.options.monitorPostsVisited.value) return false;
  if (!newCommentCount_module.options.monitorPostsVisitedIncognito.value && isPrivateBrowsing()) return false;
  newCommentCount_entryStorage.set(id, {
    count: newCommentCount,
    updateTime: Date.now()
  });
}

const getNewCount = memoize_default()(async thing => {
  const currentCount = thing.getCommentCount();
  if (typeof currentCount !== 'number') return;
  const {
    count: lastOpenedCount
  } = (await newCommentCount_entryStorage.getNullable(getId(thing))) || {};
  if (typeof lastOpenedCount !== 'number') return;
  return Math.max(currentCount - lastOpenedCount, 0);
});

async function displayNewCommentCount(thing) {
  const newCount = await getNewCount(thing);
  if (typeof newCount !== 'number') return;
  if (!newCount && newCommentCount_module.options.hideWhenUnchanged.value) return;
  if (newCount) thing.element.classList.add('res-hasNewComments');
  jquery_default()(thing.getCommentCountElement()).append(`<span class="newComments">&nbsp;(${newCount} new)</span>`);
}

function updateCurrentCommentCountFromMyComment(thing) {
  const timestamp = thing.getTimestamp();
  const isRecent = timestamp && Date.now() - timestamp.getTime() < 10000;
  const isMine = loggedInUser() === thing.getAuthor();

  if (isRecent && isMine && listingThing && typeof currentCommentCount === 'number') {
    setEntry(getId(listingThing), ++currentCommentCount);
  }
}

const refreshSubscriptionButton = mutex(async () => {
  const id = (execRegexes.comments(location.pathname) || [])[2];
  const button = subscriptionButton;
  if (!id || !button) return;
  const subscriptions = await subscriptionStorage.getAll();

  if (subscriptions.hasOwnProperty(id)) {
    jquery_default()(button).html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');
    waitForEvent(button, 'click').then(async () => {
      await unsubscribe(id);
      notifications_showNotification({
        notificationID: 'newCommentCountUnsubscribe',
        moduleID: 'newCommentCount',
        message: 'You are now unsubscribed from this thread.'
      }, 3000);
    }).then(refreshSubscriptionButton);
  } else {
    jquery_default()(button).html('<span class="res-icon">&#xF03B;</span> subscribe').attr('title', 'notify me of new comments').removeClass('unsubscribe');
    waitForEvent(button, 'click').then(async () => {
      await newCommentCount_subscribe(id, currentCommentCount || 0, listingThing && listingThing.getPostEditTimestamp() || 0);
      notifications_showNotification({
        notificationID: 'newCommentCountSubscribe',
        moduleID: 'newCommentCount',
        optionKey: 'subscriptionLength',
        message: `
					<p>
						You are now subscribed to this thread for ${newCommentCount_module.options.subscriptionLength.value} days.
						When new comments are posted you'll receive a notification.
					</p>
					<p><a href="/r/Dashboard#newCommentsContents">Manage subscriptions</a></p>
				`
      }, 5000);
    }).then(refreshSubscriptionButton);
  }
});

function newCommentCount_subscribe(id, newCommentCount, newEditedTime) {
  const now = Date.now();
  return subscriptionStorage.set(id, {
    count: newCommentCount,
    subscriptionDate: now,
    updateTime: now,
    editedTime: newEditedTime,
    url: location.href.replace(location.hash, ''),
    title: document.title
  });
}

function unsubscribe(id) {
  return subscriptionStorage.delete(id);
}

async function checkSubscriptions() {
  const now = Date.now();

  for (const [id, subscription] of Object.entries((await subscriptionStorage.getAll()))) {
    const {
      subscriptionDate,
      updateTime
    } = subscription;

    if (now - subscriptionDate > DAY * parseInt(newCommentCount_module.options.subscriptionLength.value, 10)) {
      unsubscribe(id);
    } else if (now - updateTime > 5 * MINUTE) {
      subscriptionStorage.patch(id, {
        updateTime: now
      });
      checkThread(id, subscription);
    }
  }
}

async function checkThread(id, subscription) {
  const {
    num_comments: newCount,
    edited: newEditedTime
  } = await getPostMetadata({
    id
  });
  const {
    count,
    editedTime,
    url,
    title
  } = subscription;

  if (newCount > count) {
    subscriptionStorage.patch(id, {
      count: newCount
    });
    const notification = notifications_showNotification({
      header: 'New comments',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, 10000);
    jquery_default()(notification.element).find('.RESNotificationContent').append(createButton(id, 'unsubscribe', notification.close));
  }

  if (newCommentCount_module.options.notifyEditedPosts.value && newEditedTime > editedTime) {
    subscriptionStorage.patch(id, {
      editedTime: newEditedTime
    });
    const notification = notifications_showNotification({
      header: 'Post edited',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      optionKey: 'notifyEditedPosts',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, 10000);
    jquery_default()(notification.element).find('.RESNotificationContent').append(createButton(id, 'unsubscribe', notification.close));
  }
}

function createButton(id, type, onClick) {
  const $button = jquery_default()('<span class="RESSubscriptionButton">');
  let action;

  switch (type) {
    case 'unsubscribe':
      $button.html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');

      action = () => unsubscribe(id);

      break;

    case 'renew':
      $button.html('<span class="res-icon">&#xF03B;</span> renew').attr('title', `renew for ${newCommentCount_module.options.subscriptionLength.value} days`);

      action = async () => {
        await subscriptionStorage.patch(id, {
          subscriptionDate: Date.now()
        });
        notifications_showNotification({
          notificationID: 'newCommentCountRenew',
          moduleID: 'newCommentCount',
          optionKey: 'subscriptionLength',
          message: `Subscription renewed for ${newCommentCount_module.options.subscriptionLength.value} days.`
        });
      };

      break;

    default:
      break;
  }

  const button = $button.get(0);
  waitForEvent(button, 'click').then(action).then(onClick);
  return button;
}

async function addDashboardFunctionality(tabPage) {
  const subscriptions = Object.entries((await subscriptionStorage.getAll()));
  const rows = subscriptions.map(([id, {
    subscriptionDate,
    updateTime,
    url,
    title
  }]) => {
    const [, subreddit] = url && new URL(url).pathname.match(regexes.subreddit) || [];
    if (!subreddit) return;
    const updated = new Date(updateTime);
    const expires = new Date(subscriptionDate + DAY * parseInt(newCommentCount_module.options.subscriptionLength.value, 10));
    return string_namespaceObject._html`
				<tr subscription-id="${id}">
					<td><a href="${url}">${escapeHTML(title)}</a></td>
					<td><a href="/r/${subreddit}">/r/${subreddit}</a></td>
					<td><abbr title="${formatDateTime(updated)}">${formatRelativeTime(updated)}</abbr></td>
					<td><abbr title="${formatDateTime(expires)}">${formatRelativeTime(expires)}</abbr></td>
					<td></td>
				</tr>
			`;
  });
  const ele = string_namespaceObject.html`<div>
			<a href="/by_id/${subscriptions.map(([id]) => `t3_${id}`).join(',')}">as reddit link listing</a>
			<table id="newCommentsTable">
				<thead>
					<tr>
						<th>Submission</th>
						<th>Subreddit</th>
						<th>Last viewed</th>
						<th>Expires in</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${rows.length ? rows : string_namespaceObject._html`<td colspan="5">You are currently not subscribed to any threads. To subscribe to a thread, click the "subscribe" button found near the top of the comments page.</td>`}
				</tbody>
			</table>
		</div>`;
  jquery_default()(ele).on('click', 'th', table_namespaceObject.sortByColumn);

  for (const row of ele.querySelectorAll('[subscription-id]')) {
    const id = row.getAttribute('subscription-id');
    row.querySelector('td:last-of-type').append(createButton(id, 'unsubscribe', () => addDashboardFunctionality(tabPage)), createButton(id, 'renew', () => addDashboardFunctionality(tabPage)));
  }

  empty(tabPage);
  tabPage.append(ele);
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/NewCommentCount.js




class NewCommentCount_NewCommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `new comments ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `new comments ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    return String(((await hasEntry(thing)) ? await getNewCount(thing) : thing.getCommentCount()) || 0);
  }

  static get disabled() {
    return !modules_isEnabled(newCommentCount_namespaceObject);
  }

  isValid() {
    return parseInt(this.value.val, 10) >= 0;
  }

  async evaluate(thing) {
    const newCount = await getNewCount(thing);
    const count = typeof newCount === 'number' ? newCount : thing.getCommentCount();
    return numericalCompare(this.value.op, count, this.value.val);
  }

}
NewCommentCount_NewCommentCount.text = 'New comment count';
NewCommentCount_NewCommentCount.defaultConditions = {
  op: '>',
  val: 0
};
NewCommentCount_NewCommentCount.fields = ['has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' new comments'];
NewCommentCount_NewCommentCount.slow = 1;
NewCommentCount_NewCommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentsOpened.js



class CommentsOpened_CommentsOpened extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'comments opened';
  }

  async evaluate(thing) {
    if (await hasEntry(thing)) return true;
    const link = thing.getCommentsLink();
    if (!link) return null;
    return isURLVisited(link.href);
  }

}
CommentsOpened_CommentsOpened.text = 'Comments opened';
CommentsOpened_CommentsOpened.fields = ['comments page has been visited'];
CommentsOpened_CommentsOpened.slow = 2;
CommentsOpened_CommentsOpened.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Domain.js

class Domain_Domain extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `domain ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getPostDomain();
  }

  evaluate(thing) {
    const domain = thing.getPostDomain();
    if (!domain) return null;
    return this.value.some(v => v.test(domain));
  }

}
Domain_Domain.text = 'Link domain name';
Domain_Domain.fields = ['post links to the domain ', {
  type: 'text',
  id: 'patt'
}];
// EXTERNAL MODULE: ./node_modules/lodash/compact.js
var compact = __webpack_require__(53);
var compact_default = /*#__PURE__*/__webpack_require__.n(compact);

// EXTERNAL MODULE: ./node_modules/lodash/intersection.js
var intersection = __webpack_require__(54);
var intersection_default = /*#__PURE__*/__webpack_require__.n(intersection);

// CONCATENATED MODULE: ./lib/core/host.js
class Host {
  constructor(moduleID, {
    name,
    domains,
    permissions,
    logo,
    landingPage,
    attribution = true,
    options,
    detect,
    handleLink,
    getVideoData
  }) {
    this.moduleID = void 0;
    this.name = void 0;
    this.domains = void 0;
    this.permissions = void 0;
    this.logo = void 0;
    this.landingPage = void 0;
    this.attribution = void 0;
    this.options = void 0;
    this.detect = void 0;
    this.handleLink = void 0;
    this.getVideoData = void 0;
    this.moduleID = moduleID;
    this.name = name;
    this.domains = domains;
    this.permissions = permissions;
    this.logo = logo;
    this.landingPage = landingPage;
    this.attribution = attribution;
    this.options = options;
    this.detect = detect;
    this.handleLink = handleLink;
    this.getVideoData = getVideoData;
  }

}
// CONCATENATED MODULE: ./lib/modules/showImages/templates.js


const audioTemplate = ({
  loop,
  sources
}) => string_namespaceObject.html`
	<div>
		<audio controls ${loop && 'loop'}>
			${sources.map(({
  file,
  type
}) => string_namespaceObject._html`
				<source src="${file}" type="${type}">
			`)}
		</audio>
	</div>
`;
const galleryTemplate = ({
  title,
  caption,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-gallery">
		${title && string_namespaceObject._html`
		<h3 class="res-title res-gallery-title">${title}</h3>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption res-gallery-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-step-container">
			<div class="res-step res-step-previous"></div>
			<div class="res-step-progress">
				<span class="res-step-position">1</span> of ${src.length}
			</div>
			<div class="res-step res-step-next"></div>
			<div class="res-gallery-to-filmstrip" title="View as filmstrip"></div>
		</div>
		<div class="res-gallery-pieces"></div>
		<div class="res-gallery-below">
			<div>
				<div class="res-expando-siteAttribution"></div>
				<div class="res-gallery-increase-concurrent"></div>
			</div>
		</div>
	</div>
`;
const imageTemplate = ({
  title,
  caption,
  credits,
  src,
  href,
  openInNewWindow
}) => string_namespaceObject.html`
	<div class="res-image">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<a class="res-expando-link noKeyNav" href="${href}" ${openInNewWindow && string_namespaceObject._html`target="_blank" rel="noopener noreferrer"`}>
			<img class="res-image-media" src="${src}">
		</a>
	</div>
`;
const iframeTemplate = ({
  url,
  width,
  height
}) => string_namespaceObject.html`
	<div class="res-iframe-expando">
		<div>
			<iframe src="${url}" style="width: ${width}; height: ${height}" allowFullscreen="true"></iframe>
			<div class="res-iframe-expando-drag-handle">
				<div class="res-icon"></div>
				<div class="res-expando-siteAttribution"></div>
			</div>
		</div>
	</div>
`;
const textTemplate = ({
  title,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-text usertext-body">
		${title && string_namespaceObject._html`
		<h3 class="res-title">${title}</h3>
		`}
		<div class="res-text-media md">${string_namespaceObject.safe(src)}</div>
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
	</div>
`;
const videoTemplate = ({
  title,
  caption,
  credits,
  href,
  source,
  poster,
  hasAudio,
  loop,
  reversable,
  formattedPlaybackRate,
  openInNewWindow
}) => string_namespaceObject.html`
	<div class="res-video">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-video-container">
			<a class="noKeyNav" href="${href}" ${openInNewWindow && string_namespaceObject._html`target="_blank" rel="noopener noreferrer"`}>
				<video ${!hasAudio && 'muted'} ${loop && 'loop'} poster="${poster}"></video>
			</a>
			<div class="res-video-interface">
				<div class="res-video-progress">
					<div class="res-video-position"></div>
					<div class="res-video-position-thumb"></div>
				</div>
				<div class="res-video-main">
					<div class="res-video-controls">
						<div title="Toggle pause" class="res-icon res-video-button res-video-toggle-pause"></div>
						${reversable && string_namespaceObject._html`
						<div title="Reverse video" class="res-icon res-video-button res-video-reverse"></div>
						`}
						${hasAudio && string_namespaceObject._html`
							<div title="Adjust volume" class="res-icon res-video-button res-video-volume">
								<div class="res-video-volume-level">
									<div class="res-video-volume-percentage"></div>
								</div>
							</div>
						`}
						<div class="res-video-controls-group res-video-current-time">
							<div title="Select previous frame" class="res-icon res-video-button res-video-time-decrease"></div>
							<div class="res-video-time">0.00s</div>
							<div title="Select next frame" class="res-icon res-video-button res-video-time-increase"></div>
						</div>
						<div class="res-video-controls-group res-video-playback-rate">
							<div title="Decrease speed by 10%" class="res-icon res-video-button res-video-speed-decrease"></div>
							<div class="res-video-speed">${string_namespaceObject.safe(formattedPlaybackRate)}</div>
							<div title="Increase speed by 10%" class="res-icon res-video-button res-video-speed-increase"></div>
						</div>
					</div>
					<div hidden class="res-video-error">
						<div class="res-icon">&#xf15b</div>
					</div>
					<div class="res-video-info">
						${source && string_namespaceObject._html`
						<a class="res-video-link res-video-source" href="${source}">source</a>
						`}
						<div class="res-expando-siteAttribution"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
`;
const mediaControlsTemplate = ({
  x,
  y,
  downloadUrl,
  lookupUrl,
  clippy
}) => string_namespaceObject.html`
	<div class="res-media-with-controls-wrapper">
		<div class="res-media-controls res-media-controls-${x} res-media-controls-${y}">
			<button class="res-icon gearIcon" title="Settings" data-action="showImageSettings"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-left res-icon" title="Rotate image counter-clockwise" data-action="rotateLeft"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-right res-icon" title="Rotate image clockwise" data-action="rotateRight"></button>
			${downloadUrl && string_namespaceObject._html`
			<button class="res-media-controls-download res-icon title="Download image" data-action="download"></button>
			`}
			${lookupUrl && string_namespaceObject._html`
			<button class="res-media-controls-lookup res-icon" title="Reverse image search" data-action="imageLookup"></button>
			`}
			${clippy && string_namespaceObject._html`
			<button class="res-media-controls-clippy" title="Show educational info" data-action="clippy"></button>
			`}
		</div>
	</div>
`;
const siteAttributionTemplate = ({
  url,
  name,
  logoUrl,
  settingsLink
}) => string_namespaceObject.html`
	<cite class="res-expando-siteAttribution">
		<a href="${url}" target="_blank" rel="noopener noreferer">
			${logoUrl && string_namespaceObject._html`<img src="${logoUrl}" alt="Hosted on ${name}" title="Hosted on ${name}" />`}
			<span>hosted on ${name}</span>
			<a href="${settingsLink}" class="gearIcon" title="Disable or change settings for ${name}"></a>
		</a>
	</cite>
`;
const crosspostMetadataTemplate = data => string_namespaceObject.html`
	<div class="crosspost-preview res-crosspost-preview">
		<div class="crosspost-preview-header">
			<a href="${data.url}" class="content-link may-blank" data-event-action="title" tabindex="1"></a>
			<div class="text-content">
				<p class="title">${data.crosspostRootTitle}</p>
				<div class="crosspost-preview-tagline tagline">
					<span>${i18n('numPoints', parseInt(data.crosspostRootScore, 10))}</span>
					<span class="dot"></span>
					<a href="/r/${data.crosspostRootSubreddit}/comments/${(data.targetParentFullname || '').slice(3)}" class="comments may-blank">${i18n('numComments', parseInt(data.crosspostRootNumComments, 10))}</a>
					<span class="dot"></span>
					${i18n('submittedAtTime')} <time>${data.crosspostRootTime}</time>
					${i18n('submittedByAuthor')} <a href="/user/${data.crosspostRootAuthor}/" class="author may-blank">${data.crosspostRootAuthor}</a>
					${i18n('submittedToSubreddit')} <a href="/r/${data.crosspostRootSubreddit}/" class="subreddit hover may-blank">r/${data.crosspostRootSubreddit}</a>
				</div>
			</div>
		</div>
	</div>
`;
// CONCATENATED MODULE: ./lib/modules/showImages/expando.js



const expando_expandos = new Map();
const activeExpandos = new Set();
const opened = new Set();
class expando_Expando {
  static getEntryExpandoFrom(thing) {
    if (!thing) return null;
    const button = thing.entry.querySelector('.expando-button');
    if (!button) return null;
    let expando = expando_expandos.get(button);

    if (!expando) {
      const box = thing.entry.querySelector('.expando');
      if (!box) return null;
      const buttonPlaceholder = document.createElement('span');
      const boxPlaceholder = document.createElement('span');
      expando = {
        button,

        get open() {
          return button.classList.contains('expanded');
        },

        collapse() {
          if (this.open) this.toggle();
        },

        expand() {
          if (!this.open) this.toggle();
        },

        toggle() {
          click(button);
        },

        detach() {
          button.replaceWith(buttonPlaceholder);
          box.replaceWith(boxPlaceholder);
        },

        reattach() {
          buttonPlaceholder.replaceWith(button);
          boxPlaceholder.replaceWith(box);
        },

        types: flatten_default()(['native', button.classList.contains('selftext') ? 'selftext' : (box.dataset.cachedhtml || '').match(/\bvideo-player\b/) ? ['video', 'non-muted'] : (box.dataset.cachedhtml || '').match(/\<iframe\b/) ? ['iframe', 'non-muted'] : ['image', 'muted']]).filter(Boolean),
        ready: true
      };
      expando_expandos.set(button, expando);
    }

    return expando;
  }

  static getTextExpandosFrom(thing) {
    if (!thing) return [];
    const md = thing.entry.querySelector('.md');
    if (!md) return [];
    return filterMap(Array.from(md.querySelectorAll(expando_Expando.expandoSelector)), v => {
      const exp = expando_expandos.get(v);
      if (exp) return [exp];
    });
  }

  static getAllExpandosFrom(thing) {
    return compact_default()([...expando_Expando.getTextExpandosFrom(thing), expando_Expando.getEntryExpandoFrom(thing)]);
  }

  constructor(href) {
    this.href = void 0;
    this.inText = void 0;
    this.ready = false;
    this.lock = null;
    this.box = void 0;
    this.button = void 0;
    this.open = false;
    this.expandWanted = false;
    this.expandCallbacks = [];
    this.media = void 0;
    this.generateMedia = void 0;
    this.types = [];
    this.buttonInfo = {
      title: 'Expando is not yet ready',
      mediaClass: ''
    };
    this.href = href;
    this.box = document.createElement('div');
    this.box.classList.add('res-expando-box');
    this.box.hidden = true;
    this.button = document.createElement('a');
    this.button.addEventListener('click', () => this.toggle());
    this.updateButton();
    new MutationObserver(() => {
      this.updateButton();
    }).observe(this.button, {
      attributes: true
    });
    expando_expandos.set(this.button, this);
  }

  onExpand(callback) {
    this.expandCallbacks.push(callback);
  }

  updateButton() {
    let {
      mediaClass,
      title
    } = this.buttonInfo;

    if (this.lock) {
      mediaClass = 'expando-button-requires-permission';
      title = 'Click to request required permissions';
    }

    const classList = ['expando-button', ...(mediaClass.split(' ') || ['expando-button-loading']), this.open || this.expandWanted ? 'expanded' : 'collapsed'].filter(Boolean);

    if (!this.expandWanted && !this.open && opened.has(this.href)) {
      classList.push('expando-button-duplicate');
      title += ' (link has already been opened)';
    }

    const btn = this.button;

    for (const v of btn.classList) if (!classList.includes(v)) btn.classList.remove(v);

    for (const v of classList) if (!btn.classList.contains(v)) btn.classList.add(v);

    if (btn.title !== title) btn.title = title;
  }

  initialize(options) {
    this.generateMedia = options.generateMedia;
    this.buttonInfo = options.buttonInfo;
    this.types = options.types;
    this.ready = true;
    if (this.expandWanted) this.expand();else this.updateButton();
  }

  getDuplicates() {
    return Array.from(expando_expandos.values()).filter(v => v !== this && v.href === this.href);
  }

  async setLock(lock) {
    this.lock = lock;
    this.updateButton();
    await lock.promise;
    this.lock = null;
    this.updateButton();
  }

  toggle() {
    if (this.open) this.collapse();else this.expand();
  }

  expand() {
    if (this.lock || !this.ready) {
      this.expandWanted = true;
      if (this.lock) this.lock.open();
      this.updateButton();
      return;
    }

    this.box.hidden = false;
    this.attachMedia();
    if (this.media) this.media.expand();
    this.open = true;
    this.expandWanted = false;
    this.updateButton();

    for (const callback of this.expandCallbacks) callback();

    opened.add(this.href);

    for (const duplicate of this.getDuplicates()) duplicate.updateButton();
  }

  collapse() {
    this.box.hidden = true;
    this.open = false;
    this.expandWanted = false;
    this.updateButton();

    if (this.media) {
      this.media.collapse();
    }
  }

  attachMedia() {
    const wrapper = this.box.firstElementChild || document.createElement('div');
    if (!this.generateMedia) throw new Error('Cannot attach media without `generateMedia`');
    this.media = this.media || this.generateMedia();
    wrapper.append(this.media.element);
    wrapper.classList.add('res-expando-box-inner');
    this.box.append(wrapper);
    if (this.media.onAttach) this.media.onAttach();
    activeExpandos.add(this);
  }

  isAttached() {
    return document.body.contains(this.button) && document.body.contains(this.box);
  }

  destroy() {
    if (this.box) {
      this.box.remove();
      delete this.box;
    }

    if (this.button) {
      expando_expandos.delete(this.button);
      this.button.remove();
      delete this.button;
    }

    this.empty();
  }

  empty() {
    if (this.media) {
      this.media.element.remove();
      delete this.media;
    }

    if (this.button) {
      if (this.open) this.collapse();else this.updateButton();
    }

    activeExpandos.delete(this);
  }

}
expando_Expando.expandoSelector = '.expando-button, .search-expando-button';
// CONCATENATED MODULE: ./lib/modules/hosts/aarli.js



/* harmony default export */ var aarli = (new Host('aarli', {
  name: 'AAR Library',
  domains: ['aar.li'],
  logo: 'https://aar.li/favicon.ico',
  detect: ({
    pathname
  }) => /^\/a\/(\w+)/i.exec(pathname),

  async handleLink(href, [, aarId]) {
    const info = await ajax({
      url: 'https://aar.li/api.php',
      query: {
        aarId
      },
      type: 'json'
    });

    if (info.errors) {
      throw new Error(info.errors);
    }

    return {
      type: 'GALLERY',
      title: info.title,
      caption: info.description + (info.previousurl ? string_namespaceObject.escape`<br/><a href="${info.previousurl}">Previous part.</a>` : ''),
      credits: string_namespaceObject.escape`AAR by <a href="${info.authorurl}">${info.author}</a>`,
      src: info.slides.map(({
        desc,
        imglink
      }) => ({
        type: 'IMAGE',
        caption: desc,
        src: imglink
      }))
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/adultswim.js

/* harmony default export */ var adultswim = (new Host('adultswim', {
  name: 'Adult Swim',
  domains: ['adultswim.com'],
  logo: 'https://www.adultswim.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/videos\/([^\/]+\/[^\/]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://www.adultswim.com/utilities/embed/${path}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archilogic.js

/* harmony default export */ var archilogic = (new Host('archilogic', {
  name: 'archilogic',
  domains: ['spaces.archilogic.com'],
  logo: 'https://about.archilogic.com/wp-content/uploads/2017/01/favicon-96x96.png',
  detect: ({
    pathname
  }) => /^\/(3d|model)/.exec(pathname),

  handleLink(href) {
    const formattedUrl = href.replace('/model/', '/3d/').replace('http:', 'https:');
    return {
      type: 'IFRAME',
      embed: formattedUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archiveis.js

/* harmony default export */ var archiveis = (new Host('archive.is', {
  name: 'archive.is',
  domains: ['archive.is'],
  logo: 'https://archive.is/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://archive.fo/${code}/scr.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/bime.js

/* harmony default export */ var bime = (new Host('bime', {
  name: 'Bime Analytics Dashboards',
  domains: ['bime.io'],
  logo: 'https://a.bime.io/assets/favicons/favicon.ico',
  detect: ({
    href
  }) => /https?:\/\/([^.]+)\.bime\.io(?:\/([a-z0-9_-]+))+/i.exec(href),
  handleLink: (href, [, user, dashboardId]) => ({
    type: 'IFRAME',
    embed: `https://${user}.bime.io/dashboard/${dashboardId}`,
    expandoClass: 'selftext',
    width: '960px',
    height: '540px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/clyp.js

/* harmony default export */ var clyp = (new Host('clyp', {
  name: 'clyp',
  domains: ['clyp.it'],
  logo: 'https://d2cjvbryygm0lr.cloudfront.net/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(playlist\/)?([A-Za-z0-9]+)/i.exec(pathname),

  handleLink(href, [, playlist, id]) {
    return {
      type: 'IFRAME',
      embed: `https://clyp.it/${playlist ? 'playlist/' : ''}${id}/widget`,
      height: '160px',
      width: '600px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/codepen.js

/* harmony default export */ var codepen = (new Host('codepen', {
  name: 'CodePen',
  domains: ['codepen.io'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?!anon)([a-z0-9_-]+)\/(?:pen|full|details|debug)\/([a-z]+)\b/i.exec(pathname),

  handleLink(href, [, user, hash]) {
    return {
      type: 'IFRAME',
      muted: true,
      height: '500px',
      width: '700px',
      expandoClass: 'selftext',
      embed: `https://codepen.io/${user}/embed/${hash}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/coub.js

/* harmony default export */ var coub = (new Host('coub', {
  name: 'Coub',
  domains: ['coub.com'],
  detect: ({
    pathname
  }) => /^\/(?:view|embed)\/(\w+)(\.gifv)?/i.exec(pathname),

  handleLink(href, [, hash, isGifv]) {
    const src = isGifv ? `https://coub.com/view/${hash}.gifv?res=true` : `https://coub.com/embed/${hash}?autoplay=true&res=true`;
    return {
      type: 'IFRAME',
      muted: !!isGifv,
      embed: src,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dailymotion.js

/* harmony default export */ var dailymotion = (new Host('dailymotion', {
  name: 'dailymotion',
  domains: ['dailymotion.com'],
  logo: 'https://static1.dmcdn.net/images/favicons/favicon-32x32.png.vb5b47df6329123929',
  detect: ({
    href
  }) => /^https?:\/\/(?:(?:www|touch)\.)?dailymotion.com[\w\-\/:#]+video[\/=]([a-z0-9]+)/i.exec(href),

  handleLink(href, [, hash]) {
    const embed = `https://www.dailymotion.com/embed/video/${hash}?api=postMessage`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}&autoplay=1`,
      pause: 'pause',
      play: 'play',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/default.js

/* harmony default export */ var hosts_default = (new Host('default', {
  name: 'default',
  domains: [],
  detect: ({
    pathname
  }) => /\.(gif|jpe?g|png|svg)$/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultAudio.js

/* harmony default export */ var defaultAudio = (new Host('defaultAudio', {
  name: 'defaultAudio',
  domains: [],
  detect: ({
    pathname
  }) => /\.(opus|weba|ogg|wav|mp3|flac)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'weba') extension = 'webm';
    if (extension === 'opus') extension = 'ogg';
    const format = `audio/${extension}`;
    return {
      type: 'AUDIO',
      autoplay: true,
      loop: false,
      sources: [{
        file: href,
        type: format
      }]
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultVideo.js

/* harmony default export */ var defaultVideo = (new Host('defaultVideo', {
  name: 'defaultVideo',
  domains: [],
  detect: ({
    pathname
  }) => /\.(webm|mp4|ogv|3gp|mkv)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'ogv') extension = 'ogg';
    const format = `video/${extension}`;
    return {
      type: 'VIDEO',
      sources: [{
        source: href,
        type: format
      }]
    };
  }

}));
// EXTERNAL MODULE: ./node_modules/lodash/keyBy.js
var lodash_keyBy = __webpack_require__(73);
var lodash_keyBy_default = /*#__PURE__*/__webpack_require__.n(lodash_keyBy);

// CONCATENATED MODULE: ./lib/modules/hosts/derpibooru.js




/* harmony default export */ var derpibooru = (new Host('derpibooru', {
  name: 'Derpibooru',
  logo: 'https://derpibooru.org/favicon.ico',
  domains: ['derpibooru.org', 'trixiebooru.org', 'derpiboo.ru', 'derpicdn.net'],
  detect: ({
    hostname,
    pathname
  }) => hostname === 'derpicdn.net' ? /^\/img\/view\/\d+\/\d+\/\d+\/(\d+)[._]/i.exec(pathname) : /^\/(?:images\/)?(\d+)$/i.exec(pathname),
  handleLink: (() => {
    const fetchInfo = batch(async requests => {
      const maxDepth = 10;
      const {
        images
      } = await ajax({
        url: 'https://derpibooru.org/api/v2/images/show.json',
        query: {
          ids: requests.map(r => r.id).join(',')
        },
        type: 'json'
      });

      const responseById = lodash_keyBy_default()(images, img => img.id);

      return requests.map(({
        id,
        depth = 0
      }) => {
        const result = responseById[id];

        if (!result) {
          return new Error('No result');
        } else if (result.duplicate_of) {
          if (depth > maxDepth) {
            return new Error(`Exceeded max duplicate depth: ${maxDepth}`);
          }

          return fetchInfo({
            id: result.duplicate_of,
            depth: depth + 1
          });
        } else if (result.image) {
          return result;
        } else {
          return new Error('Image deleted or other error');
        }
      });
    }, {
      size: 50
    });
    return async (href, [, id]) => {
      const {
        image,
        description,
        source_url: source
      } = await fetchInfo({
        id
      });
      return {
        type: 'IMAGE',
        src: image,
        caption: description,
        credits: source ? string_namespaceObject.escape`Source: <a href="${source}">${source}</a>` : undefined
      };
    };
  })()
}));
// CONCATENATED MODULE: ./lib/modules/hosts/deviantart.js


/* harmony default export */ var deviantart = (new Host('deviantart', {
  name: 'deviantART',
  logo: 'https://i.deviantart.net/icons/da_favicon.ico',
  domains: ['deviantart.com', 'fav.me', 'sta.sh'],
  permissions: ['https://backend.deviantart.com/oembed'],
  detect: ({
    href
  }) => /^https?:\/\/(?:fav\.me\/.*|sta\.sh.*|(?:.+\.)?deviantart\.com\/(?:(?:[\w-]+\/)?art\/.*|[^#]*#\/d.*))$/i.test(href),

  async handleLink(href) {
    const info = await ajax({
      url: 'https://backend.deviantart.com/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
      case 'link':
        let src;

        if (info.fullsize_url) {
          src = info.fullsize_url;
        } else if (/\.(jpg|jpeg|gif|png)/i.test(info.url)) {
          src = info.url;
        } else {
          src = info.thumbnail_url;
        }

        return {
          type: 'IMAGE',
          title: info.title,
          credits: `Art by: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`,
          src
        };

      case 'rich':
        return {
          type: 'TEXT',
          title: info.title,
          src: info.html + (/[^\s\.]\s*$/.test(info.html) ? '...' : ''),
          credits: `<a href="${href}">Click here to read the full text</a> - Written By: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`
        };

      default:
        throw new Error(`Unsupported deviantART post type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dropbox.js


/* harmony default export */ var dropbox = (new Host('dropbox', {
  name: 'dropbox',
  domains: ['dropbox.com'],
  logo: 'https://cfl.dropboxstatic.com/static/images/favicon-vflk5FiAC.ico',

  detect(url) {
    for (const host of genericHosts) {
      const result = host.detect(url);
      if (result) return [host.handleLink, result];
    }
  },

  handleLink(href, [handler, result]) {
    const originalURL = new URL(href);
    return handler(`${originalURL.origin}${originalURL.pathname}?raw=1`, result);
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/fiveHundredPx.js

/* harmony default export */ var fiveHundredPx = (new Host('fiveHundredPx', {
  name: 'fiveHundredPx',
  domains: ['500px.org', '500px.net', '500px.com'],
  logo: 'https://assetcdn.500px.org/assets/favicon-1e8257b93fb787f8ceb66b5522ee853c.ico',
  detect: ({
    href
  }) => /^https?:\/\/\w*cdn\.500px\.(?:net|com|org)\/(?:photo\/)?([0-9]+)\//.exec(href),

  handleLink(href, [, photoId]) {
    return {
      type: 'IMAGE',
      src: href.replace(/\/[0-9]+\.jpg$/, '/5.jpg'),
      credits: `View original and details at: <a href="https://500px.com/photo/${photoId}">500px.com</a>`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/flickr.js



function base58Encode(num) {
  let enc = '';
  let acc = num;

  do {
    const div = Math.floor(acc / 58);
    const mod = acc - 58 * div;
    enc = `${'123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'[mod]}${enc}`;
    acc = div;
  } while (acc);

  return enc;
}

/* harmony default export */ var flickr = (new Host('flickr', {
  name: 'flickr',
  domains: ['flickr.com', 'flic.kr', 'staticflickr.com'],
  permissions: ['https://www.flickr.com/services/oembed'],
  logo: 'https://s.yimg.com/pw/favicon.ico',

  detect({
    origin,
    href,
    pathname
  }) {
    if (origin.endsWith('staticflickr.com')) {
      const [, id] = /(?:.+\/)?\d{4}\/(\d{10,})_/i.exec(pathname) || [];
      if (id) return `https://flic.kr/p/${base58Encode(parseInt(id, 10))}`;
    } else {
      return href;
    }
  },

  async handleLink(href, oembedTarget) {
    const info = await ajax({
      url: 'https://www.flickr.com/services/oembed',
      query: {
        format: 'json',
        url: oembedTarget
      },
      type: 'json'
    });
    const validSuffix = /\.(jpg|jpeg|gif|png)/i;
    const src = validSuffix.test(oembedTarget) ? oembedTarget : validSuffix.test(info.url) ? info.url : validSuffix.test(info.thumbnail_url) ? info.thumbnail_url : undefined;

    if (!src) {
      throw new Error('No image found.');
    }

    return {
      type: 'IMAGE',
      title: info.title,
      credits: `Picture by: <a href="${info.author_url}">${info.author_name}</a> @ Flickr`,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/getyarn.js

/* harmony default export */ var getyarn = (new Host('getyarn', {
  name: 'getyarn.io',
  logo: 'https://getyarn.io/favicon.ico',
  domains: ['getyarn.io'],
  detect: ({
    pathname
  }) => /\/yarn-clip\/(?:embed\/)?([\w\-]+)/i.exec(pathname),

  handleLink(href, [, code]) {
    const embed = `https://getyarn.io/yarn-clip/embed/${code}`;
    return {
      type: 'IFRAME',
      embed: `${embed}?autoplay=false`,
      embedAutoplay: `${embed}?autoplay=true`,
      height: '600px',
      width: '768px',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gfycat.js



/* harmony default export */ var gfycat = (new Host('gfycat', {
  name: 'gfycat',
  domains: ['gfycat.com'],
  logo: 'https://gfycat.com/favicon.ico',
  options: {
    useMobileGfycat: {
      title: 'gfycatUseMobileGfycatTitle',
      description: 'gfycatUseMobileGfycatDesc',
      value: false,
      type: 'boolean'
    }
  },
  detect: ({
    pathname
  }) => /^\/(?:(?:ifr|gifs\/detail)\/)?(\w+)(?:\.gif)?/i.exec(pathname),

  async handleLink(href, [, id]) {
    const isMobileResolution = this.options.useMobileGfycat.value;
    const info = (await ajax({
      url: string_namespaceObject.encode`https://api.gfycat.com/v1/gfycats/${id}`,
      type: 'json',
      cacheFor: DAY
    })).gfyItem;
    return {
      type: 'VIDEO',
      frameRate: info.frameRate,
      loop: true,
      muted: !info.hasAudio,
      playbackRate: +(href.match(/[?|&]speed=([\d\.]+)/i) || [undefined, 1])[1],
      poster: isMobileResolution ? info.mobilePosterUrl : info.posterUrl,
      sources: [isMobileResolution && {
        source: info.mobileUrl,
        type: 'video/mp4'
      }, {
        source: info.webmUrl,
        type: 'video/webm'
      }, {
        source: info.mp4Url,
        type: 'video/mp4'
      }].filter(x => x),
      time: +(href.match(/[?|&]frameNum=([\d]+)/i) || [undefined, 0])[1] / info.frameRate
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gifyoutube.js



/* harmony default export */ var gifyoutube = (new Host('gifs', {
  name: 'gifs.com',
  domains: ['gifs.com', 'gifyoutube.com', 'gifyt.com'],
  logo: 'https://cdn.gifs.com/resources/favicon.png',
  detect: ({
    href
  }) => /^https?:\/\/(?:beta\.|www\.)?(?:gifyoutube|gifyt)\.com\/gif\/(\w+)\.?/i.exec(href) || /^https?:\/\/share\.gifyoutube\.com\/(\w+)\.gif/i.exec(href),

  async handleLink(href, [, id]) {
    const {
      sauce
    } = await ajax({
      url: `https://gifs.com/api/${id}`,
      type: 'json',
      cacheFor: DAY
    });
    return {
      type: 'VIDEO',
      loop: true,
      fallback: `https://share.gifyoutube.com/${id}.gif`,
      muted: true,
      source: sauce,
      sources: [{
        source: `https://share.gifyoutube.com/${id}.webm`,
        type: 'video/webm'
      }, {
        source: `https://share.gifyoutube.com/${id}.mp4`,
        type: 'video/mp4'
      }]
    };
  }

}));
// EXTERNAL MODULE: ./lib/images/hosts/giphy-logo.png
var giphy_logo = __webpack_require__(123);
var giphy_logo_default = /*#__PURE__*/__webpack_require__.n(giphy_logo);

// CONCATENATED MODULE: ./lib/modules/hosts/giphy.js



/* harmony default export */ var giphy = (new Host('giphy', {
  name: 'giphy',
  domains: ['giphy.com'],
  logo: giphy_logo_default.a,
  detect: ({
    pathname
  }) => /^(?:\/gifs|\/media|)\/(?:\w+-)*([^/.]+)(?:\/|\.gif|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      data
    } = await ajax({
      url: `https://api.giphy.com/v1/gifs/${id}`,
      query: {
        api_key: 'dc6zaTOxFJmzC'
      },
      type: 'json'
    });
    return {
      type: 'VIDEO',
      fallback: data.images.original.url,
      loop: true,
      muted: true,
      sources: [{
        source: data.images.original.mp4,
        type: 'video/mp4'
      }]
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/snudown-js/dist/snudown_es.js
var snudown_es_r;function snudown_es_e(r){for(;0<r.length;){var e=r.shift();if("function"==typeof e)e();else{var i=e.m;"number"==typeof i?void 0===e.l?n.dynCall_v(i):n.dynCall_vi(i,e.l):i(void 0===e.l?null:e.l);}}}function snudown_es_i(r){return r.replace(/\b__Z[\w\d_]+/g,function(r){return r==r?r:r+" ["+r+"]";});}function snudown_es_a(){var e=Error();if(!e.stack){try{throw Error(0);}catch(r){e=r;}if(!e.stack)return"(no stack trace available)";}return""+e.stack;}function l(r){var e=1+(r.length<<2),i=snudown_es_x(e),a=snudown_es_b,f=i;if(0<e){e=f+e-1;for(var n=0;n<r.length;++n){var t=r.charCodeAt(n);if(55296<=t&&t<=57343&&(t=65536+((1023&t)<<10)|1023&r.charCodeAt(++n)),t<=127){if(e<=f)break;a[f++]=t;}else{if(t<=2047){if(e<=f+1)break;a[f++]=192|t>>6;}else{if(t<=65535){if(e<=f+2)break;a[f++]=224|t>>12;}else{if(e<=f+3)break;a[f++]=240|t>>18,a[f++]=128|t>>12&63;}a[f++]=128|t>>6&63;}a[f++]=128|63&t;}}a[f]=0;}return i;}function f(r,e,i){var a=I();"string"!=typeof e&&(e="");for(var f=l(e),n=0,t=0;t<e.length;++t){var o=e.charCodeAt(t);55296<=o&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++t)),o<=127?++n:n=o<=2047?n+2:o<=65535?n+3:n+4;}if("object"==typeof i&&null!==i||(i={}),r=r(f,e=n,n=i.nofollow?1:0,t="string"==typeof i.target?l(i.target):0,o="string"==typeof i.tocIdPrefix?l(i.tocIdPrefix):0,i.enableToc?1:0)){for(f=(i=r)+NaN,e="";!(f<=i)&&(n=snudown_es_b[i++]);)128&n?(t=63&snudown_es_b[i++],192==(224&n)?e+=String.fromCharCode((31&n)<<6|t):(o=63&snudown_es_b[i++],(n=224==(240&n)?(15&n)<<12|t<<6|o:(7&n)<<18|t<<12|o<<6|63&snudown_es_b[i++])<65536?e+=String.fromCharCode(n):e+=String.fromCharCode(55296|(n-=65536)>>10,56320|1023&n))):e+=String.fromCharCode(n);i=e;}else i="";return A(r),E(a),i;}snudown_es_r||(snudown_es_r={});var n={},snudown_es_t={};for(snudown_es_y in n)n.hasOwnProperty(snudown_es_y)&&(snudown_es_t[snudown_es_y]=n[snudown_es_y]);var o=console.log.bind(console),snudown_es_c=console.warn.bind(console);for(snudown_es_y in snudown_es_t)snudown_es_t.hasOwnProperty(snudown_es_y)&&(n[snudown_es_y]=snudown_es_t[snudown_es_y]);snudown_es_t=null;var s,u,snudown_es_b,k,snudown_es_v,snudown_es_d=0,h=!1;s=snudown_es_v=s=n.buffer?n.buffer:new ArrayBuffer(16777216),n.HEAP8=u=new Int8Array(snudown_es_v),n.HEAP16=new Int16Array(snudown_es_v),n.HEAP32=k=new Int32Array(snudown_es_v),n.HEAPU8=snudown_es_b=new Uint8Array(snudown_es_v),n.HEAPU16=new Uint16Array(snudown_es_v),n.HEAPU32=new Uint32Array(snudown_es_v),n.HEAPF32=new Float32Array(snudown_es_v),n.HEAPF64=new Float64Array(snudown_es_v),k[2296]=5252256;var w=[],m=[],_=[],p=[];n.preloadedImages={},n.preloadedAudios={},snudown_es_t=null,snudown_es_t='\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\0\v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\0\0-\0\x005\0\0A\0\0M\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\0\0S\0\0\\\0\0c\0\0m\0\0o\0\0v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\r\0\0#\0\0\0\0#\0\0\0\0\0\0#\0\0#\0\0 \0\0\'\0\0*\0\0#\0\0~\0\x003\0\0:\0\0=\0\0#\0\0#\0\0#\0\0A\0\0#\0\0#\0\0#\0\0#\0\0D\0\0G\0\0\0\0\0\0&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\b\n&&&&&&&&&&\0&\0&\0&&\0\n\0&&\0&&&&&&&&&&&&\0&\0&\0&&\0\n\0&&\0&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\t\0\0\0\n\0\0\0\v\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000123456789ABCDEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0v\0\0|\0\0\0\0R\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0$\0\0#\0\0#\0\0#\0\0#\0\0*\0\0#\0\0#\0\0#\0\0#\0\x000\0\x006\0\0=\0\0#\0\0#\0\0E\0\0#\0\0#\0\0#\0\0#\0\0K\0\0Q\0\0#\0\0#\0\0#\0\0X\0\0^\0\0e\0\0m\0\0#\0\0v\0\0#\0\0#\0\0#\0\0#\0\0#\0\0|\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0#\0\0\0\0\0\0#\0\0\0\0\0\0#\0\0\0\0#\0\0#\0\0\0\0\0\0#\0\0\0\0#\0\0\0\0\b\0\0\0\0\0\0#\0\0#\0\0 \0\0#\0\0%\0\0.\0\x008\0\0>\0\0C\0\0#\0\0K\0\0#\0\0P\0\0U\0\0#\0\0#\0\0]\0\0c\0\0j\0\0#\0\0#\0\0r\0\0#\0\0}\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\b\0\0\0\0#\0\0#\0\0\0\0\0\0%\0\0-\0\0#\0\x004\0\0#\0\0:\0\0#\0\0#\0\0B\0\0I\0\0#\0\0#\0\0#\0\0P\0\0V\0\0[\0\0c\0\0#\0\0#\0\0l\0\0#\0\0s\0\0#\0\0|\0\0\0\0\0\0\0\0#\0\0\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\v\0\0#\0\0#\0\0#\0\0\0\0\0\0%\0\0#\0\0#\0\0-\0\x005\0\0#\0\0#\0\0#\0\0#\0\0#\0\0>\0\0#\0\0#\0\0#\0\0E\0\0N\0\0S\0\0Y\0\0`\0\0f\0\0#\0\0#\0\0o\0\0v\0\0~\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0#\0\0#\0\0%\0\0-\0\0#\0\x004\0\0=\0\0E\0\0K\0\0#\0\0#\0\0R\0\0W\0\0]\0\0d\0\0#\0\0n\0\0v\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0\0\0\0#\0\0\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0\0\0\f\0\0#\0\0\0\0#\0\0\0\0&\0\0-\0\x005\0\0>\0\0E\0\0M\0\0T\0\0\\\0\0#\0\0b\0\0j\0\0q\0\0y\0\0#\0\0\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0#\0\0\0\0\0\0\0\0#\0\0\0\0\n\0\0\0\0\0\0#\0\0#\0\0$\0\0+\0\x003\0\0#\0\0<\0\0#\0\0C\0\0#\0\0#\0\0#\0\0#\0\0K\0\0S\0\0#\0\0#\0\0#\0\0\\\0\0#\0\0#\0\0#\0\0#\0\0d\0\0n\0\0#\0\0#\0\0w\0\0#\0\0~\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0#\0\0#\0\0\0\0\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\0\0#\0\0\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0\b \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0# \0\0+ \0\0#\0\0#\0\0#\0\0#\0\0#\0\x003 \0\0< \0\0#\0\0#\0\0#\0\0D \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0M \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0V \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0_ \0\0#\0\0#\0\0#\0\0g \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0p \0\0y \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0#\0\0 \0\0\0\0\0\0\0\0_\0Z\0\0\0\0\0s\0^\x007\0\0\0\0\0\0\0\0\0\0\0\0#\0-\0-\0\n\0\0\x002\0}\0\0U\0K\0(\0A\0\0\0<\0\0\0\0\n\0f\0\0#\0\0\0\0\0\n\0\0\0\0\0\x002\0K\0\n\0K\0\0U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\t\n\v\f\r !"#\n\v\f\r !"#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 rel="nofollow"\0 target="\0tr\0th\0td\0tbody\0thead\0tfoot\0caption\0colspan\0rowspan\0cellspacing\0cellpadding\0scope\0https://\0ftp://\0mailto://\0/\0git://\0steam://\0irc://\0news://\0mumble://\0ssh://\0ircs://\0ts3server://\0#\0www.\0?!.,\0.+-_\0all-\0reddit.com\0t:\0p\0dl\0div\0math\0table\0ul\0del\0form\0blockquote\0figure\0ol\0fieldset\0h1\0h6\0pre\0script\0h5\0noscript\0iframe\0h4\0ins\0h3\0h2\0span\0http://\0\\`*_{}[]()#+-.!:|&<>/^~\0&#x27;\0&#39;\0&#47;\0</li>\n</ul>\n\0</div>\n\0<sup>\0</sup>\0<del>\0</del>\0<strong><em>\0</em></strong>\0<em>\0</em>\0<strong>\0</strong>\0<span class="md-spoiler-text">\0</span>\0<code>\0</code>\0<div class="toc">\n\0<ul>\n<li>\n\0</li>\n\0</ul>\n</li>\n\0<li>\n\0</li>\n<li>\n\0<a href="#\0toc_\0">\0</a>\n\0style\0a\0img\0="\0<a href="\0" title="\0</a>\0<br>\n\0<br/>\n\0<img src="\0" alt="\0"/>\0mailto:\0<th\0<td\0 colspan="\0" \0 align="center">\0 align="left">\0 align="right">\0>\0</th>\n\0</td>\n\0<tr>\n\0</tr>\n\0<table><thead>\n\0</thead><tbody>\n\0</tbody></table>\n\0<p>\0</p>\n\0<li>\0<ol>\n\0<ul>\n\0</ol>\n\0</ul>\n\0<hr>\n\0<hr/>\n\0<h\0 id="\0</h\0>\n\0<blockquote class="md-spoiler-text">\n\0</blockquote>\n\0<blockquote>\n\0<pre><code class="\0<pre><code>\0</code></pre>\n\0&or;\0&not;\0&int;\0&psi;\0&isin;\0&notin;\0&Rho;\0&phi;\0&prop;\0&rho;\0&nbsp;\0&thorn;\0&thinsp;\0&chi;\0&prod;\0&amp;\0&Psi;\0&iota;\0&omicron;\0&Phi;\0&and;\0&sdot;\0&nu;\0&Chi;\0&emsp;\0&Mu;\0&ensp;\0&ocirc;\0&lt;\0&uml;\0&icirc;\0&sup;\0&sup1;\0&Scaron;\0&cap;\0&part;\0&pound;\0&scaron;\0&ni;\0&lowast;\0&Omicron;\0&cup;\0&Xi;\0&crarr;\0&Nu;\0&pi;\0&theta;\0&tau;\0&nsub;\0&acirc;\0&thetasym;\0&Ocirc;\0&rarr;\0&ucirc;\0&loz;\0&darr;\0&trade;\0&para;\0&ecirc;\0&larr;\0&radic;\0&sub;\0&Pi;\0&kappa;\0&iquest;\0&eta;\0&supe;\0&rceil;\0&there4;\0&rArr;\0&uarr;\0&Kappa;\0&dArr;\0&euro;\0&Theta;\0&circ;\0&Tau;\0&lceil;\0&lArr;\0&ordm;\0&lrm;\0&xi;\0&acute;\0&ccedil;\0&sup3;\0&ntilde;\0&uArr;\0&sup2;\0&piv;\0&otilde;\0&shy;\0&Acirc;\0&curren;\0&Ucirc;\0&oacute;\0&sube;\0&nabla;\0&iacute;\0&mu;\0&bull;\0&oline;\0&Ccedil;\0&sum;\0&copy;\0&equiv;\0&Ntilde;\0&prime;\0&atilde;\0&tilde;\0&Ecirc;\0&Otilde;\0&apos;\0&aacute;\0&ne;\0&Eta;\0&macr;\0&sim;\0&Oacute;\0&Iota;\0&empty;\0&uacute;\0&ouml;\0&exist;\0&iuml;\0&Prime;\0&eacute;\0&rsquo;\0&cent;\0&zwj;\0&zwnj;\0&quot;\0&sbquo;\0&sect;\0&infin;\0&otimes;\0&cong;\0&Icirc;\0&brvbar;\0&le;\0&lsquo;\0&ordf;\0&clubs;\0&oplus;\0&perp;\0&Yacute;\0&micro;\0&ang;\0&auml;\0&gt;\0&rlm;\0&Ouml;\0&upsilon;\0&minus;\0&middot;\0&uuml;\0&aring;\0&Atilde;\0&divide;\0&rsaquo;\0&epsilon;\0&times;\0&ETH;\0&euml;\0&szlig;\0&frac14;\0&diams;\0&oslash;\0&Aacute;\0&lsaquo;\0&Delta;\0&rdquo;\0&spades;\0&Uacute;\0&raquo;\0&rang;\0&frasl;\0&rfloor;\0&harr;\0&ndash;\0&Yuml;\0&cedil;\0&eth;\0&ldquo;\0&real;\0&THORN;\0&plusmn;\0&laquo;\0&lang;\0&delta;\0&lfloor;\0&beta;\0&omega;\0&Eacute;\0&Oslash;\0&image;\0&weierp;\0&Zeta;\0&OElig;\0&hArr;\0&Auml;\0&asymp;\0&Lambda;\0&bdquo;\0&zeta;\0&Upsilon;\0&lambda;\0&Uuml;\0&Aring;\0&yacute;\0&Beta;\0&Gamma;\0&iexcl;\0&forall;\0&Omega;\0&Epsilon;\0&Iacute;\0&Euml;\0&frac34;\0&frac12;\0&yen;\0&yuml;\0&ograve;\0&AElig;\0&igrave;\0&Iuml;\0&alpha;\0&permil;\0&agrave;\0&mdash;\0&Ograve;\0&ugrave;\0&upsih;\0&ge;\0&egrave;\0&fnof;\0&reg;\0&deg;\0&Sigma;\0&sigma;\0&Alpha;\0&hearts;\0&oelig;\0&Agrave;\0&Ugrave;\0&hellip;\0&aelig;\0&Egrave;\0&Igrave;\0&gamma;\0&Dagger;\0&dagger;\0&alefsym;\0&sigmaf;\0\0';var snudown_es_y=function(r,e,i){function t(r,e,i){e|=0;var a=112+(r|=0)|0;if(0|i){i=0|r;var f=0|a;for(ze[f>>2]=0,ze[f+4>>2]=0,ze[f+8>>2]=0,ze[f+12>>2]=0,ze[f+16>>2]=0,ze[f+20>>2]=0,ze[f+24>>2]=0,ze[f+28>>2]=0,ze[f+16>>2]=65,f=5128,e=i+112|0;ze[i>>2]=ze[f>>2],f=f+4|0,(0|(i=i+4|0))<(0|e););}else{i=0|r,e|=0,ze[(f=0|a)>>2]=0,ze[f+4>>2]=0,ze[f+8>>2]=0,ze[f+12>>2]=0,ze[f+16>>2]=0,ze[f+20>>2]=0,ze[f+24>>2]=0,ze[f+28>>2]=0,ze[f+16>>2]=e;for(var n=5240,t=(f=i)+112|0;ze[f>>2]=ze[n>>2],n=n+4|0,(0|(f=f+4|0))<(0|t););4&e|0&&(ze[i+68>>2]=0),8&e|0&&(ze[i+76>>2]=0,ze[i+48>>2]=0),513&e|0&&(ze[i+12>>2]=0);}if(ze[r+140>>2]=7,ze[r+132>>2]=16,ze[r+136>>2]=64,r|=0,a|=0,i=0|L(444)){for(f=(e=i)+112|0;ze[e>>2]=ze[r>>2],r=r+4|0,(0|(e=e+4|0))<(0|f););u(i+404|0,4),u(i+416|0,8),nr(i+148|0,0,256),(0!=(0|ze[i+64>>2])||0!=(0|ze[i+60>>2])||0|ze[i+84>>2])&&(je[i+190>>0]=1,je[i+243>>0]=1,je[i+210>>0]=1,je[i+274>>0]=1),0|ze[i+52>>2]&&(je[i+244>>0]=2),0|ze[i+72>>2]&&(je[i+158>>0]=3),(0!=(0|ze[i+68>>2])||0|ze[i+76>>2])&&(je[i+239>>0]=4),je[i+208>>0]=5,je[i+240>>0]=6,je[i+186>>0]=7,je[i+212>>0]=9,je[i+206>>0]=8,je[i+267>>0]=10,je[i+195>>0]=11,je[i+242>>0]=12,ze[i+428>>2]=155,ze[i+112>>2]=a,ze[i+432>>2]=16,ze[i+436>>2]=64,ze[i+440>>2]=0;}else i=0;return 0|i;}function o(r,e,i,a,f,n,t){r|=0,e|=0,f|=0,t|=0;var o=0|ze[8368+((n|=0)<<4)>>2],l=0|ze[8372+(n<<4)>>2],c=0|ze[8376+(n<<4)>>2],s=0|ze[8380+(n<<4)>>2];ze[c+144>>2]=0|i,ze[c+148>>2]=0|a;var u=0|C(128);return i=0|ze[(n=c+128|0)>>2],0|t&&(ze[(t=s+124|0)>>2]=f,b(u,r,e,l),ze[t>>2]=0,ze[n>>2]|=64),ze[(a=c+124|0)>>2]=f,b(u,r,e,o),ze[a>>2]=0,ze[n>>2]=i,i=0|L(1+(n=0|ze[u+4>>2])|0),(je[i+n>>0]=0)|(a=0|ze[u>>2])&&fr(0|i,0|a,0|n),S(u),0|i;}function k(r,e){r|=0,e|=0;var i=0;r:for(;;){if(14<=i>>>0){var a=0;break;}var f=0|D(a=0|ze[96+(i<<2)>>2]);if(f>>>0<e>>>0&&0==(0|F(r,a,f))){if(0|Ke(255&(a=0|je[r+f>>0]))){a=1;break;}switch(a<<24>>24){case 35:case 47:case 63:a=1;break r;}}i=i+1|0;}return 0|a;}function v(r,e){var i;if(!(0|Ke(0|Be[(r|=0)>>0])))return 0;var a=(0|e)-1|0;for(e=0,i=1;!(a>>>0<=i>>>0);){var f=0|je[r+i>>0];if(46!=f<<24>>24){if(!(45==f<<24>>24|0!=(0|Ke(255&f))))break;}else e=e+1|0;i=i+1|0;}return 0|(0==(0|e)?0:i);}function h(r,e){r|=0,e|=0;var i,a,f=0,n=0,t=0,o=0;for(i=0;;){if(e>>>0<=i>>>0){i=e;break;}if(60==(0|je[r+i>>0]))break;i=i+1|0;}r:for(;;){if(!i){i=0;break;}if(!((e=0|je[r+(o=i+-1|0)>>0])<<24>>24))break;do{if(!(0|z(5563,255&e,5))){switch(e<<24>>24){case 34:f=20;break r;case 39:f=21;break r;case 41:n=40,t=41,f=22;break r;case 93:f=18;break r;case 125:f=19;break r;case 59:break;default:break r;}for(i=e=i+-2|0;;){if(!i){i=0;break;}if(!(((32|Be[r+i>>0])-97|0)>>>0<26|0))break;i=i+-1|0;}if(i>>>0<e>>>0&&38==(0|je[r+i>>0]))break;}i=o;}while(0);}if(18==(0|f)?(n=91,t=93,f=22):19==(0|f)?(n=123,t=125,f=22):20==(0|f)?(t=n=34,f=22):21==(0|f)&&(t=n=39,f=22),22==(0|f)){for(a=f=e=0;(0|e)!=(0|i);){var l=0|je[r+e>>0],c=(0|n)==(255&l|0);e=e+1|0,f=f+(1&c)|0,a=a+(l<<24>>24==t<<24>>24&(1^c)&1)|0;}i=(0|a)==(0|f)?i:o;}return 0|i;}function g(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0,f|=0;do{if(0==(0|e)|a>>>0<2||(0|Be[r+-1>>0])!=(f<<24>>24|0))r=0;else{if(1<e>>>0){if(47==(r=(f=0|je[r+-2>>0])<<24>>24)){r=2;break;}if(0|B(r)){r=1;break;}return 0!=(0|R(r))|0;}r=2<i>>>0&&47==(0|je[r+-2>>0])&&92==(0|je[r+-3>>0])?0:1;}}while(0);return 0|r;}function A(r,e){if(r|=0,(e|=0)>>>0<=16777216){var i=r+8|0,a=0|ze[i>>2];if(a>>>0<e>>>0){for(var f=0|ze[r+12>>2],n=a;(n=n+f|0)>>>0<e>>>0;);a=(a=0|V(0|ze[r>>2],n))?(ze[r>>2]=a,ze[i>>2]=n,0):-1;}else a=0;}else a=-1;return 0|a;}function C(r){r|=0;var e=0|L(16);return 0|e&&(ze[e>>2]=0,ze[e+8>>2]=0,ze[e+4>>2]=0,ze[e+12>>2]=r),0|e;}function de(r,e,i){e|=0;var a=0,f=4+(r|=0)|0,n=0|ze[f>>2],t=n+(i|=0)|0;(0|ze[r+8>>2])>>>0<t>>>0?0<=(0|A(r,t))&&(n=0|ze[f>>2],a=4):a=4,4==(0|a)&&(fr((0|ze[r>>2])+n|0,0|e,0|i),ze[f>>2]=(0|ze[f>>2])+i);}function y(r,e){de(0|r,e|=0,0|D(e));}function he(r,e){e|=0;var i=0,a=4+(r|=0)|0,f=0|ze[a>>2],n=f+1|0;(0|ze[r+8>>2])>>>0<n>>>0?0<=(0|A(r,n))&&(f=0|ze[a>>2],i=4):i=4,4==(0|i)&&(je[(0|ze[r>>2])+f>>0]=e,ze[a>>2]=1+(0|ze[a>>2]));}function l(r,e){r|=0,e|=0;var i=De;De=De+16|0;for(var a=i,f=a+14|0;(0|(a=a+1|(je[a>>0]=0)))<(0|f););var n=(0|e)<0,t=0;for(f=n?0|-e:e;a=t+1|0,je[i+t>>0]=(e=f)+(0|lr(f=(0|f)/10|0,-10))+48,!((0|e)<=9);)t=a;for(n&&(je[i+a>>0]=45,a=t+2|0),f=0;!((0|(a=a+-1|0))<=(0|f));)e=0|je[(t=i+f|0)>>0],je[t>>0]=0|je[(n=i+a|0)>>0],je[n>>0]=e,f=f+1|0;y(r,i),De=i;}function S(r){0|(r|=0)&&(Me(0|ze[r>>2]),Me(r));}function x(r){0|(r|=0)&&(Me(0|ze[r>>2]),ze[r>>2]=0,ze[r+8>>2]=0,ze[r+4>>2]=0);}function E(r,e){(e|=0)>>>0<=(0|ze[(r=4+(0|r)|0)>>2])>>>0&&(ze[r>>2]=e);}function b(r,e,i,a){r|=0,e|=0,i|=0,a|=0;var f=0,n=De;De=De+16|0;var t=0|C(64);if(0|t){A(t,i);var o=a+116|0;ze[o>>2]=0,ze[o+4>>2]=0,ze[o+8>>2]=0,ze[o+12>>2]=0,ze[o+16>>2]=0,ze[o+20>>2]=0,ze[o+24>>2]=0;for(var l=2<i>>>(ze[o+28>>2]=0)&&(l=0==(0|j(e,5708,3)))?3:0;!(i>>>0<=l>>>0);)r:do{var c=e,s=l,u=i,b=n,k=o;c|=0,u|=0,b|=0,k|=0;var v,d,h=0,w=3+(s|=0)|0;e:do{if(w>>>0<u>>>0){if(32==(0|je[c+s>>0])){if(32==(0|je[c+(s+1)>>0])){if(32==(0|je[c+(s+2)>>0])){if(32==(0|je[c+w>>0])){w=0;break;}w=3;}else w=2;}else w=1;}else w=0;if(91==(0|je[c+(w=w+s|0)>>0])){var m=d=w+1|0;i:for(;;){if(u>>>0<=m>>>0){w=0;break e;}switch(0|je[c+m>>0]){case 13:case 10:w=0;break e;case 93:break i;}m=m+1|0;}var _=m+1|0;if(_>>>0<u>>>0&&58==(0|je[c+_>>0])){w=m+2|0;i:for(;!(u>>>0<=w>>>0);){switch((s=0|je[c+w>>0])<<24>>24){case 13:case 10:h=17;break i;case 32:break;default:break i;}w=w+1|0;}if(17==(0|h)){var p=w+1|0;w=p>>>0<u>>>0&&10==s<<24>>24&&13==(0|je[c+p>>0])?w+2|0:p;}for(;;){if(u>>>0<=w>>>0){w=0;break e;}if(32!=(s=0|je[c+w>>0])<<24>>24)break;w=w+1|0;}w=_=w+(60==s<<24>>24&1)|0;i:for(;!(u>>>0<=w>>>0);){switch(0|je[c+w>>0]){case 13:case 10:case 32:break i;}w=w+1|0;}var y=w+-1|0;y=62==(0|je[c+y>>0])?y:w;i:for(;;){if(u>>>0<=w>>>0){h=31;break;}switch(0|je[c+w>>0]){case 10:case 13:h=31;break i;case 40:case 39:case 34:s=0;break i;case 32:break;default:w=0;break e;}w=w+1|0;}if(31==(0|h)&&(s=w),v=(p=w+1|0)>>>0<u>>>0&&10==(0|je[c+w>>0])&&13==(0|je[c+p>>0])?p:s){for(s=v;!(u>>>0<=(w=s+1|0)>>>0)&&32==(0|je[c+w>>0]);)s=w;p=s+2|0;}i:do{if(p>>>0<u>>>0){switch(0|je[c+w>>0]){case 40:case 34:case 39:break;default:p=u=0,w=v;break i;}s=p;a:for(;;){if(u>>>0<=s>>>0){h=44;break;}switch(w=s+1|0,0|je[c+s>>0]){case 10:case 13:break a;default:s=w;}}44==(0|h)&&(w=s+1|0),w>>>0<u>>>0&&10==(0|je[c+s>>0])&&13==(0|je[c+w>>0])||(w=s);a:for(;;){if((s=s+-1|0)>>>0<=p>>>0){u=p,p=w,w=v;break i;}switch(0|je[c+s>>0]){case 32:break;case 41:case 34:case 39:break a;default:u=p,p=w,w=v;break i;}}u=p,p=s;}else p=u=0,w=v;}while(0);w=(0|y)==(0|_)|0==(0|w)?0:(0|b&&(ze[b>>2]=w),k?(s=k,w=c+d|0,d=m-d|0,s|=0,w|=0,d|=0,(m=0|Re(1,16))?(d=0|U(w,d),ze[m>>2]=d,ze[m+12>>2]=ze[(d=s+((7&d)<<2)|0)>>2],ze[d>>2]=m):m=0,(s=0|m)?(k=0|C(w=y-_|0),de(ze[s+4>>2]=k,c+_|0,w),w=p-u|0,u>>>0<p>>>0&&(k=0|C(w),de(ze[s+8>>2]=k,c+u|0,w)),1):0):1);}else w=0;}else w=0;}else w=0;}while(0);if(0|w)l=0|ze[n>>2];else{b=l;e:for(;!(i>>>0<=b>>>0);){switch(0|je[e+b>>0]){case 10:case 13:break e;}b=b+1|0;}if(l>>>0<(ze[n>>2]=b)>>>0){for(c=t,u=e+l|0,l=b-l|0,c|=0,u|=0,l|=0,b=p=0;!(l>>>0<=p>>>0);){for(y=p;;){if(l>>>0<=y>>>0){k=0;break;}if(9==(0|je[u+y>>0])){k=1;break;}y=y+1|0,b=b+1|0;}if(p>>>0<y>>>0&&de(c,u+p|0,y-p|0),!k)break;for(;he(c,32),0!=(3&(b=b+1|0)|0););p=y+1|0;}l=0|ze[n>>2];}else l=b;for(;;){if(i>>>0<=l>>>0)break r;switch(0|je[e+l>>0]){case 10:f=20;break;case 13:(l=l+1|0)>>>0<i>>>0&&10!=(0|je[e+l>>0])&&(f=20);break;default:break r;}20==(0|f)&&(f=0,he(t,10),l=1+(0|ze[n>>2])|0),ze[n>>2]=l;}}}while(0);if(A(r,((l=0|ze[(e=t+4|0)>>2])>>>1)+l|0),(b=0|ze[a+104>>2])&&(Fe[3&b](r,0|ze[a+112>>2]),l=0|ze[e>>2]),0|l){switch(0|je[(b=0|ze[t>>2])+(l+-1)>>0]){case 13:case 10:break;default:he(t,10),b=0|ze[t>>2],l=0|ze[e>>2];}we(r,a,b,l);}for(0|(l=0|ze[a+108>>2])&&Fe[3&l](r,0|ze[a+112>>2]),S(t),r=0|o,e=0;8!=(0|e);){for(i=0|ze[r+(e<<2)>>2];i;)a=0|ze[i+12>>2],S(0|ze[i+4>>2]),S(0|ze[i+8>>2]),Me(i),i=a;e=e+1|0;}}De=n;}function we(r,e,i,a){r|=0,e|=0,i|=0,a|=0;var f=0,n=0,t=0,o=0,l=0,c=0,s=0,u=0,b=0,k=0;r:do{if(((0|ze[e+408>>2])+(0|ze[e+420>>2])|0)>>>0<=(0|ze[e+432>>2])>>>0)for(l=e+12|0,c=e+428|0,s=e+20|0,u=e+112|0,f=0;;){if(a>>>0<=f>>>0)break r;t=i+f|0,o=a-f|0;e:do{if(0|me(e,t,o)){var v=r,d=e,h=t,w=o;v|=0,d|=0,h|=0,w|=0;var m=0,_=0,p=0,y=0,g=0;for(y=0;y>>>0<w>>>0&y>>>0<6&&35==(0|je[h+y>>0]);)y=y+1|0;for(p=y;!(w>>>0<=p>>>0)&&32==(0|je[h+p>>0]);)p=p+1|0;for(g=p;!(w>>>0<=g>>>0)&&10!=(0|je[h+g>>0]);)g=g+1|0;for(w=g;;){if(!w){w=0;break;}if(35!=(0|je[h+(m=w+-1|0)>>0]))break;w=m;}for(;w;){if(32!=(0|je[h+(m=w+-1|0)>>0])){_=19;break;}w=m;}19==(0|_)&&p>>>0<w>>>0&&(Pe(m=0|qe(d,1),d,h+p|0,w-p|0),0|(w=0|ze[d+16>>2])&&Ye[7&w](v,m,y,0|ze[d+112>>2]),Oe(d,1)),f=(0|g)+f|0;}else if(60==(0|je[t>>0])&&0|ze[l>>2]&&0|(b=0|_e(r,e,t,o,1)))f=b+f|0;else if(0|(n=0|pe(t,o)))f=n+f|0;else if(0|ye(t,o)){for(0|(n=0|ze[s>>2])&&Fe[3&n](r,0|ze[u>>2]);!(a>>>0<=f>>>0);){if(n=f+1|0,10==(0|je[i+f>>0])){f=n;break e;}f=n;}f=f+1|0;}else{if(4&(n=0|ze[c>>2])){var A=r,C=e,S=t,x=o;A|=0,C|=0,S|=0,x|=0;var E,I,U,q=0,P=0,O=0,H=0,T=0,K=0,M=0;if(De=(U=De)+32|0,ze[(I=(E=U)+16|0)>>2]=0,ze[I+4>>2]=0,ze[I+8>>2]=0,q=(ze[I+12>>2]=0)|Ue(S,x,I)){for(M=0|qe(C,0),T=E+4|0;!(x>>>0<=q>>>0);){if(ze[E>>2]=0,ze[E+4>>2]=0,ze[E+8>>2]=0,(ze[E+12>>2]=0)!=(0|(P=0|Ue(H=S+q|0,x-q|0,E)))&0==(0|ze[T>>2])){K=12;break;}for(P=q;!(x>>>0<=(O=P+1|0)>>>0)&&10!=(0|je[S+P>>0]);)P=O;q>>>0<=P>>>0&&(0|pe(H,q=O-q|0)?he(M,10):de(M,H,q)),q=O;}12==(0|K)&&(q=P+q|0),0|(K=0|ze[M+4>>2])&&10!=(0|je[(0|ze[M>>2])+(K+-1)>>0])&&he(M,10),0|(P=0|ze[C>>2])&&Ye[7&P](A,M,0==(0|ze[I+4>>2])?0:I,0|ze[C+112>>2]),Oe(C,0);}else q=0;if(De=U,n=0|q){f=n+f|0;break e;}n=0|ze[c>>2];}var R;if(R=2&n|0){var N=r,j=e,z=t,B=o;N|=0,j|=0,z|=0,B|=0;var D,F,L,Y=0,Z=0,G=0,V=0,W=0,X=0;De=(L=De)+16|0,Y=L+4|0,D=(ze[(G=L)>>2]=0)|qe(j,1),F=0|qe(j,0);var $=void 0,Q=void 0,J=void 0,rr=void 0,er=void 0,ir=void 0,ar=D,fr=j,nr=z,tr=B,or=Y,lr=G;ar|=0,fr|=0,nr|=0,tr|=0,or|=0,lr|=0;var cr=0,sr=0,ur=0;for(rr=J=0;!(tr>>>0<=J>>>0)&&10!=(ir=0|je[nr+J>>0])<<24>>24;)J=J+1|0,rr=rr+(124==ir<<24>>24&1)|0;i:do{if(0==(0|rr)|(0|J)==(0|tr))ir=0;else{for(er=J;;){if(!er){sr=0,er=rr,ir=nr;break;}if(!(0|He(0|Be[(ir=nr+(cr=er+-1|0)|0)>>0]))){ur=9;break;}er=cr;}if(9==(0|ur)&&(sr=er,er=rr+((124==(0|je[nr>>0]))<<31>>31)|0),($=er+((124==(0|je[ir>>0]))<<31>>31)+1|0)>>>0<=(0|ze[fr+436>>2])>>>0){for(Q=0|Re(ze[or>>2]=$,4),ze[lr>>2]=Q,(ir=J+1|0)>>>0<tr>>>0&&(ir=124==(0|je[nr+ir>>0])?J+2|0:ir),or=ir;!(tr>>>0<=or>>>0)&&10!=(0|je[nr+or>>0]);)or=or+1|0;for(rr=0;ir>>>0<or>>>0&(er=rr>>>0<$>>>0);){for(;ir>>>0<or>>>0&32==(er=0|je[nr+ir>>0])<<24>>24;)ir=ir+1|0;58==er<<24>>24?(ze[(er=Q+(rr<<2)|0)>>2]|=1,ir=ir+(er=1)|0):er=0;a:for(;!(or>>>0<=ir>>>0);){switch(0|je[nr+ir>>0]){case 58:ur=28;break a;case 45:break;default:break a;}er=er+1|0,ir=ir+1|0;}for(28==(0|ur)&&(ze[(ur=Q+(rr<<2)|0)>>2]|=2,er=er+1|0,ir=ir+1|0);;){if(or>>>0<=ir>>>0){ur=34;break;}if(32!=(cr=0|je[nr+ir>>0])<<24>>24){ur=33;break;}ir=ir+1|0;}if(33==(0|ur)){if((ur=0)==(0|er)|124!=cr<<24>>24){ir=0;break i;}}else if(34==(0|ur)&&(ur=0)==(0|er)){ir=0;break i;}rr=rr+1|0,ir=ir+1|0;}ir=er?0:(Te(ar,fr,nr,sr,$,Q,4),or+1|0);}else ir=0;}}while(0);if(Z=0|ir){for(X=0|ze[Y>>2],Y=0|ze[G>>2];!(B>>>0<=Z>>>0);){for(G=0,V=Z;!(B>>>0<=V>>>0)&&10!=(W=0|je[z+V>>0])<<24>>24;)G=G+(124==W<<24>>24&1)|0,V=V+1|0;if((0|V)==(0|B)|0==(0|G))break;Te(F,j,z+Z|0,V-Z|0,X,Y,0),Z=V+1|0;}(G=0|ze[j+36>>2])&&Ye[7&G](N,D,F,0|ze[j+112>>2]);}else Y=(Z=0)|ze[G>>2];Me(Y),Oe(j,1),Oe(j,0),De=L,R=0|(k=0|Z);}if(R)var br=k+f|0;else{if(0|ge(t,o)){var kr=r,vr=e,dr=t,hr=o;kr|=0,dr|=0,hr|=0;var wr,mr=0,_r=0,pr=0,yr=0,gr=0,Ar=0,Cr=0,Sr=0,xr=0;wr=0|qe(vr|=0,0),_r=xr=mr=0;i:for(;;){for(;;){if(hr>>>0<=_r>>>0)break i;for(Cr=_r;;){if(hr>>>0<=(Sr=Cr+1|0)>>>0){pr=0;break;}if(10==(0|je[dr+Cr>>0])){pr=1;break;}Cr=Sr;}if(Ar=0|ge(yr=dr+_r|0,gr=Sr-_r|0))_r=Ar+_r|0;else if(0|pe(yr,gr)){if(!pr){_r=Sr;break i;}if(0==(0|ge(pr=dr+Sr|0,yr=hr-Sr|0))&&0==(0|pe(pr,yr))){_r=Sr;break i;}}if(!(Cr>>>0<_r>>>0))break;_r=Sr;}pr=dr+_r|0,mr?(0|pr)!=(0|(yr=mr+xr|0))&&Ne(0|yr,0|pr,Sr-_r|0):mr=pr,xr=Sr+xr-_r|0,_r=Sr;}we(wr,vr,mr,xr),0|(mr=0|ze[vr+4>>2])&&Le[7&mr](kr,wr,0|ze[vr+112>>2]),Oe(vr,0);var Er=(0|_r)+f|0;}else{if(0|Ae(t,o)){var Ir=r,Ur=e,qr=t,Pr=o;Ir|=0,qr|=0,Pr|=0;var Or,Hr=0,Tr=0,Kr=0,Mr=0,Rr=0,Nr=0,jr=0,zr=0,Br=0;Or=0|qe(Ur|=0,0),Tr=Br=Hr=0;i:for(;;){for(;;){if(Pr>>>0<=Tr>>>0)break i;for(jr=Tr;;){if(Pr>>>0<=(zr=jr+1|0)>>>0){Kr=0;break;}if(10==(0|je[qr+jr>>0])){Kr=1;break;}jr=zr;}if(Nr=0|Ae(Mr=qr+Tr|0,Rr=zr-Tr|0))Tr=Nr+Tr|0;else if(0|pe(Mr,Rr)){if(!Kr){Tr=zr;break i;}if(0==(0|Ae(Kr=qr+zr|0,Mr=Pr-zr|0))&&0==(0|pe(Kr,Mr))){Tr=zr;break i;}}if(!(jr>>>0<Tr>>>0))break;Tr=zr;}Kr=qr+Tr|0,Hr?(0|Kr)!=(0|(Mr=Hr+Br|0))&&Ne(0|Mr,0|Kr,zr-Tr|0):Hr=Kr,Br=zr+Br-Tr|0,Tr=zr;}we(Or,Ur,Hr,Br),0|(Hr=0|ze[Ur+8>>2])&&Le[7&Hr](Ir,Or,0|ze[Ur+112>>2]),Oe(Ur,0);var Dr=(0|Tr)+f|0;}else{if(0|Ce(t,o)){var Fr=r,Lr=e,Yr=t,Zr=o;Fr|=0,Yr|=0,Zr|=0;var Gr,Vr=0,Wr=0,Xr=0,$r=0,Qr=0,Jr=0;for(Gr=0|qe(Lr|=0,0),Jr=0;!(Zr>>>0<=Jr>>>0);){for($r=Jr;!(Zr>>>0<=(Qr=$r+1|0)>>>0)&&10!=(0|je[Yr+$r>>0]);)$r=Qr;if(Xr=0|Ce(Vr=Yr+Jr|0,Wr=Qr-Jr|0))Vr=Xr+Jr|0;else{if(!(0|pe(Vr,Wr)))break;Vr=Jr;}Vr>>>0<=$r>>>0&&(0|pe(Wr=Yr+Vr|0,Vr=Qr-Vr|0)?he(Gr,10):de(Gr,Wr,Vr)),Jr=Qr;}for(Vr=0|ze[(Wr=Gr+4|0)>>2];Vr&&10==(0|je[(0|ze[Gr>>2])+(Vr=Vr+-1|0)>>0]);)ze[Wr>>2]=Vr;he(Gr,10),0|(Vr=0|ze[Lr>>2])&&Ye[7&Vr](Fr,Gr,0,0|ze[Lr+112>>2]),Oe(Lr,0);var re=(0|Jr)+f|0;}else{if(0|Se(t,o))var ee=(0|xe(r,e,t,o,0))+f|0;else{if(0|Ee(t,o))var ie=(0|xe(r,e,t,o,1))+f|0;else{var ae=r,fe=e,ne=t,te=o;ae|=0,ne|=0,te|=0;var oe,le,ce=0,se=0,ue=0,be=0,ke=0,ve=0;for(oe=428+(fe|=0)|0,le=fe+12|0,ce=0;;){if(te>>>0<=ce>>>0){ke=0,ve=ce;break;}ve=ce;do{if(te>>>0<=(ve=(se=ve)+1|0)>>>0)break;}while(10!=(0|je[ne+se>>0]));if(0|ge(ue=ne+ce|0,ve-ce|0)){ke=0,ve=ce;break;}if(0|pe(ue,be=te-ce|0)){ke=0;break;}if(0|(se=0|Ie(ue,be))){ke=se;break;}if(0|me(fe,ue,be)){ke=0,ve=ce;break;}if(0|ye(ue,be)){ke=0,ve=ce;break;}if(0|ge(ue,be)){ke=0,ve=ce;break;}if(256&(se=0|ze[oe>>2])|0&&0==(0|Ke(255&(ke=0|je[ue>>0])))){if(0|Ee(ue,be)){ke=0,ve=ce;break;}if(0|Se(ue,be)){ke=0,ve=ce;break;}if(60==ke<<24>>24&&0!=(0|ze[le>>2])){if(0|_e(ae,fe,ue,be,0)){ke=0,ve=ce;break;}se=0|ze[oe>>2];}if(4&se|0&&0|Ue(ue,be,0)){ke=0,ve=ce;break;}}ce=ve;}for(;;){if(!ce){ce=se=0;break;}if(10!=(0|je[ne+(se=ce+-1|0)>>0])){se=1;break;}ce=se;}if(ke){i:do{if(se){for(be=ce;;){if(!(se=be+-1|0)){se=0;break;}if(10==(0|je[ne+se>>0]))break;be=se;}for(;;){if(!se)break i;if(10!=(0|je[ne+(ue=se+-1|0)>>0]))break;se=ue;}Pe(ue=0|qe(fe,0),fe,ne,se),0|(se=0|ze[fe+32>>2])&&Le[7&se](ae,ue,0|ze[fe+112>>2]),Oe(fe,0),ne=ne+be|0,ce=ce-be|0;}else ce=0;}while(0);Pe(se=0|qe(fe,1),fe,ne,ce),0|(ce=0|ze[fe+16>>2])&&Ye[7&ce](ae,se,ke,0|ze[fe+112>>2]),Oe(fe,1);}else Pe(se=0|qe(fe,0),fe,ne,ce),0|(ce=0|ze[fe+32>>2])&&Le[7&ce](ae,se,0|ze[fe+112>>2]),Oe(fe,0);ie=(0|ve)+f|0;}ee=ie;}re=ee;}Dr=re;}Er=Dr;}br=Er;}f=br;}}while(0);}}while(0);}function me(r,e,i){r|=0,e|=0,i|=0;var a,f=0;do{if(35==(0|je[e>>0])){if(64&ze[r+428>>2]){for(a=0;;){var n=a>>>0<i>>>0;if(!(n&a>>>0<6)){r=7;break;}if(35!=(r=0|je[e+a>>0])<<24>>24){f=r,r=9;break;}a=a+1|0;}if(7==(0|r)&&n&&(f=0|je[e+a>>0],r=9),9==(0|r)&&32!=f<<24>>24){r=0;break;}}r=1;}else r=0;}while(0);return 0|r;}function _e(r,e,i,a,f){r|=0,e|=0,a|=0,f|=0;var n=0,t=0,o=0,l=0,c=0,s=De;De=De+16|0,ze[s>>2]=i|=0;var u=s+4|0;ze[u>>2]=0,ze[s+8>>2]=0,ze[s+12>>2]=0;r:do{if(2<=a>>>0&&60==(0|je[i>>0])){var b,k=1;e:for(;!(a>>>0<=k>>>0);){switch(0|je[i+k>>0]){case 32:case 62:l=7;break e;}k=k+1|0;}if(b=7==(0|l)){b=i+1|0;var v=k+-1|0;b|=0,v|=0;var d=0;do{if((v+-1|0)>>>0<10){var h=b,w=v;if(h|=0,(h=(w=1==(0|(w|=0))?1:(0|Be[1+(0|Be[h+1>>0])+320>>0])+w|0)+(0|Be[320+(0|Be[h>>0])>>0])|0)>>>0<38&&0==(-33&(je[(d=0|ze[160+(h<<2)>>2])>>0]^je[b>>0]))<<24>>24&&0==(0|F(b,d,v))&&0==(0|je[d+v>>0]))break;}d=0;}while(0);b=0|(n=0|d);}if(b){if(!(k=0|P(n,i,a,1))){if(!(0|N(n,5693))){k=0;break;}if(!(0|N(n,5615))){k=0;break;}if(!(k=0|P(n,i,a,0))){k=0;break;}}ze[u>>2]=k,f&&(n=0|ze[e+12>>2])&&Le[7&n](r,s,0|ze[e+112>>2]);}else{if(5<a>>>0){if(33==(k=0|je[i+1>>0])<<24>>24){if(45!=(0|je[i+2>>0])){k=0;break;}if(45!=(0|je[i+3>>0])){k=0;break;}for(k=5;;){if(a>>>0<=k>>>0){l=19;break;}if(45==(0|je[i+(k+-2)>>0])&&45==(0|je[i+(k+-1)>>0])){if(n=k+1|0,62==(0|je[i+k>>0])){k=n;break;}k=n;}else k=k+1|0;}if(19==(0|l)&&(k=k+1|0),k>>>0<a>>>0&&0!=(0|(t=0|pe(i+k|0,a-k|0)))){if(ze[u>>2]=k=t+k|0,!f)break;if(!(n=0|ze[e+12>>2]))break;Le[7&n](r,s,0|ze[e+112>>2]),k=0|ze[u>>2];break;}l=25;}}else l=25;if(25==(0|l)){if(a>>>0<=4){k=0;break;}k=0|je[i+1>>0];}switch(k<<24>>24){case 72:case 104:break;default:k=0;break r;}switch(0|je[i+2>>0]){case 82:case 114:break;default:k=0;break r;}for(n=3;;){if(a>>>0<=n>>>0){l=31;break;}if(k=n+1|0,62==(0|je[i+n>>0]))break;n=k;}31==(0|l)&&(k=n+1|0),k>>>0<a>>>0&&0!=(0|(o=0|pe(i+k|0,a-k|0)))?(ze[u>>2]=k=o+k|0,0!=(0|f)&&0!=(0|(c=0|ze[e+12>>2]))&&(Le[7&c](r,s,0|ze[e+112>>2]),k=0|ze[u>>2])):k=0;}}else k=0;}while(0);return De=s,0|k;}function pe(r,e){r|=0,e|=0;var i=0,a=0;r:for(;;){if(e>>>0<=a>>>0){i=5;break;}switch(0|je[r+a>>0]){case 10:i=5;break r;case 32:break;default:a=0;break r;}a=a+1|0;}return 5==(0|i)&&(a=a+1|0),0|a;}function ye(r,e){var i;r|=0,e|=0;r:do{if(3<=e>>>0){var a=32==(0|je[r>>0])?32==(0|je[r+1>>0])?32==(0|je[r+2>>0])?3:2:1:0;if((a+2|0)>>>0<e>>>0){var f=0|je[r+a>>0];switch(f<<24>>24){case 95:case 45:case 42:break;default:a=0;break r;}for(i=0;!(e>>>0<=a>>>0);){var n=0|je[r+a>>0];if(10==n<<24>>24)break;if(n<<24>>24!=f<<24>>24){if(32!=n<<24>>24){a=0;break r;}}else i=i+1|0;a=a+1|0;}a=2<i>>>0&1;}else a=0;}else a=0;}while(0);return 0|a;}function ge(r,e){r|=0;var i=0,a=0,f=(e|=0)?32==(0|je[r>>0])&1:0;f>>>0<e>>>0&&(f=f+(32==(0|je[r+f>>0])&1)|0),f>>>0<e>>>0&&(f=f+(32==(0|je[r+f>>0])&1)|0);r:do{if(f>>>0<e>>>0&&62==(0|je[r+f>>0])&&(i=f+1|0)>>>0<e>>>0){switch(0|je[r+i>>0]){case 33:a=12;break r;case 32:break;default:break r;}i=f+2|0;}else a=12;}while(0);return 12==(0|a)&&(i=0),0|i;}function Ae(r,e){r|=0;var i=0,a=(e|=0)?32==(0|je[r>>0])&1:0;a>>>0<e>>>0&&(a=a+(32==(0|je[r+a>>0])&1)|0);var f=a>>>0<e>>>0?a+(32==(0|je[r+a>>0])&1)|0:a;if((a=f+1|0)>>>0<e>>>0&&62==(0|je[(i=r+f|0)>>0])&&33==(0|je[r+a>>0])){if(0!=(0|(a=0|q(i+1|0,e+-1-f|0,60)))&(i=a+f|0)>>>0<e>>>0&&33==(0|je[r+i>>0]))a=0;else if((a=f+2|0)>>>0<e>>>0)return 0|(32==(0|je[r+a>>0])?f+3|0:a);}else a=0;return 0|a;}function Ce(r,e){return r|=0,0|(3<(0|e)>>>0&&32==(0|je[r>>0])&&32==(0|je[r+1>>0])&&32==(0|je[r+2>>0])&&32==(0|je[r+3>>0])?4:0);}function Se(r,e){r|=0;var i=(e|=0)?32==(0|je[r>>0])&1:0;i>>>0<e>>>0&&(i=i+(32==(0|je[r+i>>0])&1)|0),i>>>0<e>>>0&&(i=i+(32==(0|je[r+i>>0])&1)|0);var a=i+1|0;r:do{if(a>>>0<e>>>0){var f=r+i|0;switch(0|je[f>>0]){case 45:case 43:case 42:break;default:break r;}if(32==(0|je[r+a>>0]))return 0|((e=0==(0|c(f,e-i|0)))?i+2|0:0);}}while(0);return 0;}function xe(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0;var n=De;De=De+16|0,ze[n>>2]=0|f;var t=0|qe(e,0);f=0;do{if(a>>>0<=f>>>0)break;var o=t,l=e,c=i+f|0,s=a-f|0,u=n;o|=0,l|=0,c|=0,s|=0,u|=0;var b,k,v,d,h,w,m,_=0,p=0;for(m=0;m>>>0<3&m>>>0<s>>>0&&32==(0|je[c+m>>0]);)m=m+1|0;if((b=0|Se(c,s))?(_=b,p=7):(b=0|Ee(c,s))?(_=b,p=7):b=0,7==(0|p)){for(b=_;!(s>>>0<=b>>>0)&&10!=(0|je[c+(b+-1)>>0]);)b=b+1|0;var y=0|qe(l,1),g=0|qe(l,1);de(y,c+_|0,b-_|0);var A=l+428|0,C=y+4|0,S=k=d=0;r:for(;;){for(h=0;;){if(s>>>0<=b>>>0)break r;for(v=b;;){var x=v+1|0;if(s>>>0<=x>>>0)break;if(10==(0|je[c+v>>0]))break;v=x;}var E=c+b|0,I=x-b|0;if(!(0|pe(E,I)))break;h=1,b=x;}for(w=0;!(4<=w>>>0||v>>>0<(_=w+b|0)>>>0||32!=(0|je[c+_>>0]));)w=w+1|0;var U=E+w|0,q=I-w|0,P=4&ze[A>>2]?(P=0==(0|Ue(U,q,0)))?d:0==(0|d)&1:d;if(P?E=v=0:(E=0|Se(U,q),v=0|Ee(U,q)),I=0!=(0|h)){if(0!=(0|E)&0!=(0|(_=1&(d=0|ze[u>>2])))){p=30;break;}if(0!=(0|v)&0==(0|_)){p=30;break;}}if(34==(0|(p=E?0!=(0|v)|0==(0|ye(U,q))?34:37:v?34:37))){if(k=I?1:k,((p=0)|w)==(0|m))break;b=S||0|ze[C>>2];}else if(37==(0|p)){if(I&(p=0)==(0|w)){p=38;break;}I?(he(y,10),b=S,k=1):b=S;}de(y,U,q),d=P,S=b,b=x;}30==(0|p)?ze[u>>2]=8|d:38==(0|p)&&(ze[u>>2]|=8),_=0|ze[u>>2],k&&(ze[u>>2]=_|=2),E=0!=(0|S)&S>>>0<(k=0|ze[C>>2])>>>0,v=0|ze[y>>2],2&_?E?(we(g,l,v,S),we(g,l,(0|ze[y>>2])+S|0,(0|ze[C>>2])-S|0)):we(g,l,v,k):E?(Pe(g,l,v,S),we(g,l,(0|ze[y>>2])+S|0,(0|ze[C>>2])-S|0)):Pe(g,l,v,k),0|(_=0|ze[l+28>>2])&&Ye[7&_](o,g,0|ze[u>>2],0|ze[l+112>>2]),Oe(l,1),Oe(l,1);}if(f=(o=0|b)+f|0,!o)break;}while(0==(8&ze[n>>2]|0));return 0|(i=0|ze[e+24>>2])&&Ye[7&i](r,t,0|ze[n>>2],0|ze[e+112>>2]),Oe(e,0),De=n,0|f;}function Ee(r,e){r|=0;var i=0,a=0,f=0,n=(e|=0)?32==(0|je[r>>0])&1:0;if(n>>>0<e>>>0&&(n=n+(32==(0|je[r+n>>0])&1)|0),n>>>0<e>>>0&&(n=n+(32==(0|je[r+n>>0])&1)|0),n>>>0<e>>>0&&((0|je[r+n>>0])-48&255)<=9){for(;;){if(e>>>0<=n>>>0){f=11;break;}if(i=n+1|0,!(((0|je[r+n>>0])-48&255)<10))break;n=i;}if(11==(0|f)&&(i=n+1|0),i>>>0<e>>>0&&46==(0|je[(a=r+n|0)>>0])&&32==(0|je[r+i>>0]))return 0|((f=0==(0|c(a,e-n|0)))?n+2|0:0);}return 0;}function Ie(r,e){var i;r|=0,e|=0;r:do{switch(0|je[r>>0]){case 61:for(i=1;!(e>>>0<=i>>>0)&&61==(0|je[r+i>>0]);)i=i+1|0;for(;;){if(e>>>0<=i>>>0){i=1;break r;}var a=0|je[r+i>>0];if(32!=a<<24>>24)break;i=i+1|0;}i=10==a<<24>>24&1;break;case 45:for(i=1;!(e>>>0<=i>>>0)&&45==(0|je[r+i>>0]);)i=i+1|0;for(;;){if(e>>>0<=i>>>0){i=2;break r;}if(32!=(a=0|je[r+i>>0])<<24>>24)break;i=i+1|0;}i=10==a<<24>>24?2:0;break;default:i=0;}}while(0);return 0|i;}function Ue(r,e,i){i|=0;var a,f=0,n=0|(r|=0),t=0|(e|=0);r:{if(3<=t>>>0){var o=32==(0|je[n>>0])?32==(0|je[n+1>>0])?32==(0|je[n+2>>0])?3:2:1:0;if((o+2|0)>>>0<t>>>0){var l=0|je[n+o>>0];switch(l<<24>>24){case 96:case 126:break;default:o=0;break r;}for(a=0;!(t>>>0<=o>>>0)&&(0|je[n+o>>0])==l<<24>>24;)a=a+1|0,o=o+1|0;o=a>>>0<3?0:o;}else o=0;}else o=0;}n=0|o;r:do{if(n){e:for(;;){if(o=r+n|0,e>>>0<=n>>>0){t=6;break;}switch(0|je[o>>0]){case 123:t=5;break e;case 32:break;default:t=6;break e;}n=n+1|0;}e:do{if(5==(0|t)){t=0;i:for(;!(e>>>0<=(f=n+1|0)>>>0);){switch(0|je[r+f>>0]){case 10:case 125:break i;}t=t+1|0,n=f;}if((0|f)==(0|e)){n=0;break r;}if(125!=(0|je[r+f>>0])){n=0;break r;}for(f=t,t=o;;){if(o=t+1|0,!f){f=0;break;}if(!(0|He(0|Be[o>>0])))break;f=f+-1|0,t=o;}for(;;){if(!f){f=0;break;}if(!(0|He(0|Be[t+f>>0])))break;f=f+-1|0;}n=n+2|0;}else if(6==(0|t))for(f=0;;){if(e>>>0<=n>>>0)break e;if(0|He(0|Be[r+n>>0]))break e;n=n+1|0,f=f+1|0;}}while(0);for(0|i&&(ze[i>>2]=o,ze[i+4>>2]=f);!(e>>>0<=n>>>0)&&10!=(f=0|je[r+n>>0])<<24>>24;){if(!(0|He(255&f))){n=0;break r;}n=n+1|0;}n=n+1|0;}else n=0;}while(0);return 0|n;}function qe(r,e){var i=0,a=404+(r|=0)+(12*(e|=0)|0)|0,f=r+404+(12*e|0)+4|0,n=0|ze[f>>2];return n>>>0<(0|ze[r+404+(12*e|0)+8>>2])>>>0&&0!=(0|(i=0|ze[(0|ze[a>>2])+(n<<2)>>2]))?(ze[f>>2]=n+1,ze[i+4>>2]=0):(e=0|(i=0|C(0|ze[5120+(e<<2)>>2])),0<=(0|s(r=0|a,ze[(a=r+4|0)>>2]<<1))&&(f=0|ze[r>>2],ze[a>>2]=1+(r=0|ze[a>>2]),ze[f+(r<<2)>>2]=e)),0|i;}function Pe(r,e,i,a){var f,n,t,o;r|=0,e|=0,i|=0,a|=0;var l=De;De=De+16|0,ze[l>>2]=0,ze[l+4>>2]=0,ze[l+8>>2]=0,ze[l+12>>2]=0;r:do{if(((0|ze[e+408>>2])+(0|ze[e+420>>2])|0)>>>0<=(0|ze[e+432>>2])>>>0){var c=e+100|0,u=e+112|0;for(o=n=t=f=0;;){if(a>>>0<=o>>>0)break r;for(;;){if(a>>>0<=n>>>0){var b=0;break;}if((f=0|je[(0|Be[i+n>>0])+(e+148)>>0])<<24>>24){b=1;break;}n=n+1|(f=0);}var k=0|ze[c>>2],v=i+o|0;if(k?(ze[l>>2]=v,ze[(l+4|0)>>2]=n-o,Le[7&k](r,l,0|ze[u>>2])):de(r,v,n-o|0),!b)break r;v=0==(0|(o=0|pr[15&ze[592+((255&f)<<2)>>2]](r,e,i+n|0,n-t|0,n,a-n|0))),o=o+n|0,t=v?t:o,n=v?n+1|0:o;}}}while(0);De=l;}function Oe(r,e){ze[(e=404+(0|r)+(12*(0|e)|0)+4|0)>>2]=(0|ze[e>>2])-1;}function He(r){return 1&(32==(0|(r|=0))|10==(0|r))|0;}function p(r,e){var i,a;r|=0;var f=4+(e|=0)|0;for(i=0;;){var n=0|ze[f>>2];if(n>>>0<=i>>>0)break;for(a=i;!(n>>>0<=a>>>0)&&92!=(0|je[(0|ze[e>>2])+a>>0]);)a=a+1|0;if(i>>>0<a>>>0&&(de(r,(0|ze[e>>2])+i|0,a-i|0),n=0|ze[f>>2]),n>>>0<=(i=a+1|0)>>>0)break;he(r,0|Be[(0|ze[e>>2])+i>>0]),i=a+2|0;}}function I(r,e,i){for(e=(0|r)+((7&(i=0|U(0|e,0|i)))<<2)|0;;){if(!(e=0|ze[e>>2])){e=0;break;}if((0|ze[e>>2])==(0|i))break;e=e+12|0;}return 0|e;}function U(r,e){var i,a;for(r|=0,e|=0,a=i=0;(0|a)!=(0|e);)i=(65599*i|0)+(0|T(0|Be[r+a>>0]))|0,a=a+1|0;return 0|i;}function m(r,e,i,a,f){var n;r|=0,i|=0,a|=0,f|=0;var t=64+(e|=0)|0;r:do{if(0|ze[t>>2]){var o=1<a>>>0&&(0|je[i>>0])==f<<24>>24?(0|je[i+1>>0])==f<<24>>24&1:0,l=e+428|0;for(n=95!=f<<24>>24;;){if(a>>>0<=o>>>0){o=0;break r;}var c=0|q(i+o|0,a-o|0,f);if(!c){o=0;break r;}if(a>>>0<=(o=c+o|0)>>>0){o=0;break r;}if((0|je[i+o>>0])==f<<24>>24&&0==(0|He(0|Be[i+(o+-1)>>0]))){if(0==(1&ze[l>>2]|0)|n|(0|(c=o+1|0))==(0|a))break;var s=0|Be[i+c>>0];if(0|He(s))break;if(0|B(s))break;}}Pe(f=0|qe(e,1),e,i,o),o=0|wr[15&ze[t>>2]](r,f,0|ze[e+112>>2]),Oe(e,1),o=0==(0|o)?0:c;}else o=0;}while(0);return 0|o;}function _(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0;var n=0|ze[(126==(f|=0)<<24>>24?e+88|0:e+60|0)>>2];r:do{if(n){var t=0;do{if(a>>>0<=t>>>0){t=0;break r;}var o=0|q(i+t|0,a-t|0,f);if(!o){t=0;break r;}t=1+(o=o+t|0)|0;}while(!(t>>>0<a>>>0&&(0|je[i+o>>0])==f<<24>>24&&0|o&&(0|je[i+t>>0])==f<<24>>24&&0==(0|He(0|Be[i+(o+-1)>>0]))));Pe(t=0|qe(e,1),e,i,o),t=0|wr[15&n](r,t,0|ze[e+112>>2]),Oe(e,1),t=0==(0|t)?0:o+2|0;}else t=0;}while(0);return 0|t;}function q(r,e,i){r|=0,e|=0;var a,f=0,n=60==(i|=0)<<24>>24,t=1,o=0;r:for(;;){var l=t;e:for(;;){for(;;){if(e>>>0<=l>>>0){l=0;break r;}i:for(;;){if(e>>>0<=l>>>0){t=0;break;}if((t=0|je[r+l>>0])<<24>>24==i<<24>>24){t=1;break;}switch(t<<24>>24){case 91:case 96:t=1;break i;}l=l+1|0;}if((0|l)==(0|e)){l=0;break r;}var c=0|je[r+l>>0];if(n&t&60==c<<24>>24){if(33==(0|je[r+(l+-1)>>0]))break r;c=60;}if(c<<24>>24==i<<24>>24)break r;if(!l){t=0;break;}if(92!=(0|je[r+(l+-1)>>0])){t=l;break;}l=l+1|0;}switch(c<<24>>24){case 91:break e;case 96:for(f=0;;){if(e>>>0<=t>>>0){l=0;break r;}if(96!=(0|je[r+t>>0]))break;f=f+1|0,t=t+1|0;}for(a=l=0;(c=t>>>0<e>>>0)&a>>>0<f>>>0;)c=0|je[r+t>>0],l=0==(0|l)?c<<24>>24==i<<24>>24?t:0:l,a=96==c<<24>>24?a+1|0:0,t=t+1|0;if(!c)break r;l=t;break;default:l=t;}}for(l=0;!(e>>>0<=(c=t+1|0)>>>0)&&93!=(a=0|je[r+c>>0])<<24>>24;)l=0==(0|l)&&a<<24>>24==i<<24>>24?c:l,t=c;t=t+2|0;e:for(;;){if(e>>>0<=t>>>0)break r;switch(0|je[r+t>>0]){case 91:f=93,c=36;break e;case 40:c=35;break e;case 10:case 32:break;default:c=41;break e;}t=t+1|0;}if(35==(0|c))f=41,c=36;else if(41==(0|c)&&(l=(f=(c=0)==(0|l))?o:l,!f))break;if(36==(0|c)){for(;;){if(e>>>0<=(c=t+1|0)>>>0)break r;if((0|f)==(255&(a=0|je[r+c>>0])|0))break;l=0==(0|l)&&a<<24>>24==i<<24>>24?c:l,t=c;}l=o,t=t+2|0;}o=l;}return 0|l;}function c(r,e){r|=0,e|=0;var i,a=0,f=0;for(i=0;;){if(e>>>0<=i>>>0){f=3;break;}if(a=i+1|0,10==(0|je[r+i>>0]))break;i=a;}return 3==(0|f)&&(a=i+1|0),0|(a>>>0<e>>>0?0|Ie(r+a|0,e-a|0):0);}function Te(r,e,i,a,f,n,t){r|=0,i|=0,a|=0,f|=0,n|=0,t|=0;var o,l,c,s,u=0,b=De;De=De+16|0;var k=44+(e|=0)|0;if(0|ze[k>>2]&&0|ze[(u=e+40|0)>>2]){var v=0|qe(e,1),d=a?124==(0|je[i>>0])&1:0,h=e+112|0;for(s=0;s>>>0<f>>>0&d>>>0<a>>>0;){for(c=0|qe(e,1);!(a>>>0<=d>>>0)&&0|He(0|Be[i+d>>0]);)d=d+1|0;for(l=d;!(a>>>0<=l>>>0)&&124!=(0|je[i+l>>0]);)l=l+1|0;for(o=l;;){var w=o+-1|0;if(w>>>0<=d>>>0)break;if(!(0|He(0|Be[i+w>>0])))break;o=w;}Pe(c,e,i+d|0,o-d|0),yr[1&ze[k>>2]](v,c,ze[n+(s<<2)>>2]|t,0|ze[h>>2],0),Oe(e,1),s=s+1|0,d=l+1|0;}0|(d=f-s|0)&&(ze[b>>2]=0,ze[b+4>>2]=0,ze[b+8>>2]=0,ze[b+12>>2]=0,yr[1&ze[k>>2]](v,b,ze[n+(s<<2)>>2]|t,0|ze[h>>2],d)),Le[7&ze[u>>2]](r,v,0|ze[h>>2]),Oe(e,1);}De=b;}function P(r,e,i,a){e|=0,i|=0;var f,n=0,t=0,o=0,l=0|D(r|=0),c=0!=(0|a),u=i+1|0;for(a=0,f=1;;){if(i>>>0<=f>>>0){a=0;break;}for(t=f;!(i>>>0<=(f=t+1|0)>>>0||47==(n=0|je[e+f>>0])<<24>>24&&60==(0|je[e+t>>0]));)a=a+(10==n<<24>>24&1)|0,t=f;if(!(c&0<(0|a)&&10!=(0|je[e+(t+-1)>>0]))){if(i>>>0<=((l+3|0)+t|0)>>>0){a=0;break;}n=r;var b=l,k=e+t|0,v=u+~t|0;k|=0;var d=0,h=3+(b|=0)|0;if(n=h>>>0<(v|=0)>>>0&&0==(0|F(k+2|0,0|n,b))&&62==(0|je[k+(b+2)>>0])&&0!=(0|(d=0|pe(k+h|0,v-h|0)))?(n=(b=d+h|0)>>>0<v>>>0?0|pe(k+b|0,v-b|0):0)+b|0:0,0|(n|=0)){o=12;break;}}}return 12==(0|o)&&(a=n+t|0),0|a;}function s(r,e){var i,a=8+(r|=0)|0;if((0|ze[a>>2])>>>0<(e|=0)>>>0){if(i=0|V(0|ze[r>>2],e<<2)){var f=0|ze[a>>2];nr(i+(f<<2)|0,0,e-f<<2|0),ze[r>>2]=i,(ze[a>>2]=e)>>>0<(0|ze[(r=r+4|0)>>2])>>>0&&(ze[r>>2]=e),r=0;}else r=-1;}else r=0;return 0|r;}function u(r,e){ze[(r|=0)>>2]=0,ze[r+4>>2]=0,s(r,(ze[r+8>>2]=0)|e);}function d(r,e,i){var a,f;e|=0;var n=De;De=De+16|0,A(r|=0,((12*(i|=0)|0)>>>0)/10|0),je[n>>0]=37;for(a=0;!(i>>>0<=a>>>0);){for(f=a;;){if(i>>>0<=f>>>0){var l=0;break;}if(1!=(0|je[656+(0|Be[e+f>>0])>>0])){l=1;break;}f=f+1|0;}if(a>>>0<f>>>0&&de(r,e+a|0,f-a|0),!l)break;l=255&(a=0|je[e+f>>0]);r:do{if(2!=(0|je[656+l>>0]))switch(a<<24>>24){case 38:de(r,6531,5);break r;case 39:de(r,5743,6);break r;default:je[(n+1|0)>>0]=0|je[912+(l>>>4)>>0],je[(n+2|0)>>0]=0|je[912+(15&a)>>0],de(r,n,3);break r;}}while(0);a=f+1|0;}De=n;}function O(r,e,i){var a,f;r|=0,e|=0,i|=0;r:do{if(3<=e>>>0&&60==(0|je[r>>0])){for(a=f=47==(0|je[r+1>>0])?2:1;!(e>>>0<=a>>>0);){var n=0|je[i>>0];if(!(n<<24>>24))break;if((0|Be[r+a>>0])!=(n<<24>>24|0))break r;i=i+1|0,a=a+1|0;}if((0|a)!=(0|e))return 0|((e=62==(e=0|je[r+a>>0])<<24>>24|0!=(0|R(255&e)))?f:0);}}while(0);return 0;}function n(r,e){ze[(e|=0)>>2]=0,ze[e+4>>2]=0,ze[e+8>>2]=0;}function H(r,e,i){e|=0;var a,f,n,t=0,o=0;for(A(r|=0,((12*(i|=0)|0)>>>0)/10|0),f=a=0;!(i>>>0<=f>>>0);){for(n=f;;){if(i>>>0<=n>>>0){t=0;break;}if((a=0|je[944+(0|Be[e+n>>0])>>0])<<24>>24){o=7;break;}n=n+1|(a=0);}if(7==(0|o)&&(o=0,a=a<<24>>24,t=1),f>>>0<n>>>0&&de(r,e+f|0,n-f|0),!t)break;47!=(t=0|je[e+n>>0])<<24>>24?7!=(0|je[944+(255&t)>>0])&&y(r,0|ze[1200+(a<<2)>>2]):he(r,47),f=n+1|0;}}function w(r,e){return y(0|r,0==(256&ze[16+(0|e)>>2]|0)?6054:6060),1;}function T(r){return 0|(0==(((0|(r|=0))-65|0)>>>0<26|0)?r:32|r);}function K(r){var e=112+(r|=0)|0;ze[e>>2]=0;var i=(e=(ze[e+4>>2]=0)|ze[r+8>>2])-(0|ze[r+4>>2])|0,a=r+120|0;ze[a>>2]=i,ze[a+4>>2]=((0|i)<0)<<31>>31,ze[r+104>>2]=e;}function M(r){var e,i=0,a=0,f=0,n=e=112+(r|=0)|0,t=0|ze[n>>2];if(0==(0|t)&0==(0|(n=0|ze[n+4>>2]))||(0|(i=0|ze[4+(a=r+120|0)>>2]))<(0|n)|((0|i)==(0|n)?(0|ze[a>>2])>>>0<t>>>0:0)){De=(n=De)+16|0;var o=t=0|r;if(je[(i=74+(o|=0)|0)>>0]=255+(a=0|je[i>>0])|a,(0|ze[(a=o+28|0)>>2])>>>0<(0|ze[(i=o+20|0)>>2])>>>0&&wr[15&ze[o+36>>2]](o,0,0),ze[o+16>>2]=0,ze[a>>2]=0,t=(ze[i>>2]=0)==(0|(i=4&(i=0|ze[o>>2])?(ze[o>>2]=32|i,-1):(ze[o+8>>2]=a=(0|ze[o+44>>2])+(0|ze[o+48>>2])|0,ze[o+4>>2]=a,i<<27>>31)))&&1==(0|wr[15&ze[t+32>>2]](t,n,1))?0|Be[n>>0]:-1,De=n,0<=(0|(t|=0))){if(a=0|ze[r+8>>2],0==(0|(n=0|ze[(o=e)>>2]))&0==(0|(o=0|ze[o+4>>2])))e=r+4|0,n=a,f=9;else{var l=a-(i=0|ze[(e=r+4|0)>>2])|0,c=((0|l)<0)<<31>>31,s=r+120|0;o=0|Q(0|n,0|o,0|ze[s>>2],0|ze[s+4>>2]),n=a,(0|c)<(0|(s=0|br()))|(0|s)==(0|c)&l>>>0<o>>>0?f=9:ze[r+104>>2]=i+(o+-1);}9==(0|f)&&(ze[r+104>>2]=a),n=n?(l=n+1-(s=0|ze[e>>2])|0,c=n=r+120|0,l=0|$(0|ze[c>>2],0|ze[c+4>>2],0|l,((0|l)<0)<<31>>31|0),c=0|br(),ze[n>>2]=l,ze[n+4>>2]=c,s):0|ze[e>>2],(0|t)!=(0|Be[(n=n+-1|0)>>0])&&(je[n>>0]=t);}else f=4;}else f=4;return 4==(0|f)&&(ze[r+104>>2]=0,t=-1),0|t;}function R(r){return 1&(32==(0|(r|=0))|(r+-9|0)>>>0<5)|0;}function N(r,e){var i=0|je[(r|=0)>>0],a=0|je[(e|=0)>>0];if(0!=i<<24>>24&&i<<24>>24==a<<24>>24)for(;i=0|je[(r=r+1|0)>>0],a=0|je[(e=e+1|0)>>0],0!=i<<24>>24&&i<<24>>24==a<<24>>24;);return(255&i)-(255&a)|0;}function j(r,e,i){r|=0,e|=0,i|=0;for(var a,f,n=0;;){if((a=0|je[r>>0])<<24>>24!=(f=0|je[e>>0])<<24>>24){n=4;break;}if(!(i=i+-1|0)){r=0;break;}r=r+1|0,e=e+1|0;}return 4==(0|n)&&(r=(255&a)-(255&f)|0),0|r;}function z(r,e,i){r|=0,i|=0;var a=255&(e|=0),f=255&e;r:{if(3&r){do{if((0|je[r>>0])==f<<24>>24){var n=6;break r;}r=r+1|0,e=0!=(0|(i=i+-1|0));}while(e&0!=(3&r|0));n=e?6:16;}else n=6;}r:do{if(6==(0|n))if((0|je[r>>0])==f<<24>>24)i||(n=16);else{e=0|lr(a,16843009);e:do{if(3<i>>>0)for(;;){if((-2139062144&(a=ze[r>>2]^e)^-2139062144)&a+-16843009|0)break e;if(r=r+4|0,(i=i+-4|0)>>>0<=3){n=11;break;}}else n=11;}while(0);if(11!=(0|n)||i)for(;;){if((0|je[r>>0])==f<<24>>24)break r;if(!(i=i+-1|0)){n=16;break;}r=r+1|0;}else n=16;}}while(0);return 16==(0|n)&&(r=0),0|r;}function Ke(r){return 0|(((32|(r|=0))-97|0)>>>0<26|0?1:0!=(((0|r)-48|0)>>>0<10|0)&1);}function B(r){return 0|(((0|(r|=0))-33|0)>>>0<94|0?0==(0|Ke(r))&1:0);}function D(r){var e,i=0,a=r|=0;r:do{if(3&a)for(e=a;;){if(!(0|je[r>>0])){r=e;break r;}if(!(3&(e=r=r+1|0))){i=5;break;}}else i=5;}while(0);if(5==(0|i)){for(;!((-2139062144&(e=0|ze[r>>2])^-2139062144)&e+-16843009);)r=r+4|0;if((255&e)<<24>>24)for(;0!=(0|je[(r=r+1|0)>>0]););}return r-a|0;}function F(r,e,i){if(r|=0,e|=0,i|=0){var a=0|je[r>>0];r:do{if(a<<24>>24){var f=r;for(r=a,a&=255;;){var n=0|je[e>>0];if(!(0!=(0|(i=i+-1|0))&0!=n<<24>>24))break r;if(r<<24>>24!=n<<24>>24&&(0|(a=0|T(a)))!=(0|T(255&n)))break r;if(e=e+1|0,!((a=0|je[(f=f+1|0)>>0])<<24>>24)){r=0;break;}r=a,a&=255;}}else r=0;}while(0);r=(r=0|T(255&r))-(0|T(0|Be[e>>0]))|0;}else r=0;return 0|r;}function L(r){var e,i=0,a=0,f=0,n=0==(0|(r|=0))?1:r;r=(r=31-(0|cr(0|(8<n>>>0?n:8)))|0)+(1!=(0|ar(0|n))&1)|0;r:{if(3<r>>>0&n>>>0<1<<r>>>0&&0!=(0|(i=0|ze[8400+(r+-1<<2)>>2]))){for(e=0;!(n>>>0<=(((0|ze[i+-8>>2])>>>1)-8|0)>>>0);)if(!((e=e+1|0)>>>0<32&0!=(0|(i=0|ze[i+4>>2])))){a=7;break r;}r=0|Y(i,n);}else a=7;}r:do{if(7==(0|a)){e:do{if(r>>>0<32){for(;i=0|ze[8400+(r<<2)>>2],r=r+1|0,!(0|i);)if(32<=r>>>0)break e;r=0|Y(i,n);break r;}}while(0);if(0|(r=0|ze[2287])&&0==(1&(f=0|ze[r>>2])|0)){if(ze[r>>2]=1|f,i=31-(0|cr(0|(e=8<(e=(f>>>1)-8|0)>>>0?e:8)))|0,i=8400+((0==(0|e)?1:i)<<2)|0,e=r+12|0,(0|ze[i>>2])==(0|(a=r+8|0))&&(ze[i>>2]=ze[e>>2]),0|(r=0|ze[a>>2])&&(ze[r+4>>2]=ze[e>>2]),0|(r=0|ze[e>>2])&&(ze[r>>2]=ze[a>>2]),n=0==(0|Z(n)),r=0|ze[2287],n)return ze[r>>2]&=-2,(n=0)|n;if(r)break;return(r=0)|r;}if(-1==(0|(i=0|W(a=n+15&-8))))return(n=0)|n;if((0|(e=i))!=(0|(f=r=e+7&-8))&&-1==(0|W(r-e|0)))return(n=0)|n;(i=0|ze[2287])?ze[r+4>>2]=i:ze[2286]=f,ze[2287]=f,ze[r>>2]=a<<1|1;}}while(0);return r+8|0;}function Y(r,e){e|=0;var i=(r|=0)-8|0,a=((0|ze[i>>2])>>>1)-8|0,f=31-(0|cr(0|(a=8<a>>>0?a:8)))|0;if(f=8400+((0==(0|a)?1:f)<<2)|0,a=r+4|0,(0|ze[f>>2])==(0|r)&&(ze[f>>2]=ze[a>>2]),0|(f=0|ze[r>>2])&&(ze[f+4>>2]=ze[a>>2]),0|(f=0|ze[a>>2])&&(ze[f>>2]=ze[r>>2]),ze[i>>2]=1|(a=0|ze[i>>2]),(0|ze[2287])==(0|i)&8==(-8&(f=(a>>>=1)+(-8-e)|0)|0)){if(!(0|Z(a)))return 0|i;f=f+8|0;}return f>>>0<=15||(e=a=r=r+e+7&-8,ze[i>>2]=1&(f=0|ze[i>>2])|r-i<<1,ze[e>>2]=(r=i+(f>>>1)-r|0)<<1|1&ze[e>>2],ze[e+4>>2]=i,ze[((0|ze[2287])==(0|i)?9148:a+(2147483647&r)+4|0)>>2]=a,G(e)),0|i;}function Z(r){var e=(15+(0|r)&-8)-((0|ze[ze[2287]>>2])>>>1)|0;if(-1==(0|W(e)))return 0;var i=0|ze[2287];if(!(1&(r=0|ze[i>>2]))){var a=(r>>>1)-8|0;r=31-(0|cr(0|(a=8<a>>>0?a:8)))|0;var f=i+8|0;r=8400+((0==(0|a)?1:r)<<2)|0,a=i+12|0,(0|ze[r>>2])==(0|f)&&(ze[r>>2]=ze[a>>2]),0|(r=0|ze[f>>2])&&(ze[r+4>>2]=ze[a>>2]),0|(r=0|ze[a>>2])&&(ze[r>>2]=ze[f>>2]);}return 1&(ze[i>>2]=r=(0|ze[i>>2])+(e<<1)|0)|0||(e=31-(0|cr(0|(a=8<(a=(r>>>1)-8|0)>>>0?a:8)))|0,a=0|ze[(e=8400+((0==(0|a)?1:e)<<2)|0)>>2],ze[e>>2]=r=i+8|0,ze[r>>2]=0,(ze[i+12>>2]=a)&&(ze[a>>2]=r)),1;}function G(r){var e=0,i=0,a=0,f=0|ze[(r|=0)>>2];ze[r>>2]=-2&f;var n=0|ze[r+4>>2],t=0|ze[2287],o=(0|t)==(0|r),l=r+(f>>>=1)|0,c=o?0:l;if(l=o?0:l,0|n&&0==(1&(e=0|ze[n>>2])|0)){e=31-(0|cr(0|(o=8<(o=(e>>>1)-8|0)>>>0?o:8)))|0;var s=n+8|0;e=8400+((0==(0|o)?1:e)<<2)|0,o=n+12|0,(0|ze[e>>2])==(0|s)&&(ze[e>>2]=ze[o>>2]),0|(e=0|ze[s>>2])&&(ze[e+4>>2]=ze[o>>2]),0|(e=0|ze[o>>2])&&(ze[e>>2]=ze[s>>2]),ze[n>>2]=(0|ze[n>>2])+(-2&ze[r>>2]),l?(ze[l+4>>2]=n,1&(e=0|ze[l>>2])||(e=31-(0|cr(0|(f=8<(f=(e>>>1)-8|0)>>>0?f:8)))|0,e=8400+((0==(0|f)?1:e)<<2)|0,f=l+12|0,(0|ze[e>>2])==(0|(i=l+8|0))&&(ze[e>>2]=ze[f>>2]),0|(e=0|ze[i>>2])&&(ze[e+4>>2]=ze[f>>2]),(e=0|ze[f>>2])&&(ze[e>>2]=ze[i>>2],t=0|ze[2287]),ze[n>>2]=(0|ze[n>>2])+(-2&ze[l>>2]),e=(0|l)==(0|t)?9148:c+((0|ze[l>>2])>>>1)+4|0,a=19)):(e=9148,a=19),19==(0|a)&&(ze[e>>2]=n),l=31-(0|cr(0|(e=8<(e=((0|ze[n>>2])>>>1)-8|0)>>>0?e:8)))|0,e=0|ze[(l=8400+((0==(0|e)?1:l)<<2)|0)>>2],ze[l>>2]=s,ze[s>>2]=0,(ze[o>>2]=e)&&(ze[e>>2]=s);}else t=0|l&&0==(1&(i=0|ze[l>>2])|0)?(e=31-(0|cr(0|(f=8<(f=(i>>>1)-8|0)>>>0?f:8)))|0,e=8400+((0==(0|f)?1:e)<<2)|0,f=l+12|0,(0|ze[e>>2])==(0|(i=l+8|0))&&(ze[e>>2]=ze[f>>2]),0|(e=0|ze[i>>2])&&(ze[e+4>>2]=ze[f>>2]),(e=0|ze[f>>2])&&(ze[e>>2]=ze[i>>2],t=0|ze[2287]),ze[r>>2]=e=(0|ze[r>>2])+(-2&ze[l>>2])|0,(0|l)==(0|t)?ze[2287]=r:(ze[c+((0|ze[l>>2])>>>1)+4>>2]=r,e=0|ze[r>>2]),(e>>>1)-8|0):f+-8|0,l=31-(0|cr(0|(t=8<t>>>0?t:8)))|0,t=0|ze[(l=8400+((0==(0|t)?1:l)<<2)|0)>>2],ze[l>>2]=e=r+8|0,ze[e>>2]=0,(ze[r+12>>2]=t)&&(ze[t>>2]=e);}function Me(r){(r|=0)&&G(r+-8|0);}function Re(r,e){var i=0,a=0,f=0,n=0|lr(0|e,0|r),t=0==(0|n)?1:n;r=(r=31-(0|cr(0|(8<t>>>0?t:8)))|0)+(1!=(0|ar(0|t))&1)|0;r:{if(3<r>>>0&t>>>0<1<<r>>>0&&0!=(0|(i=0|ze[8400+(r+-1<<2)>>2]))){var o=0;for(e=i;!(t>>>0<=(((0|ze[e+-8>>2])>>>1)-8|0)>>>0);)if(!((o=o+1|0)>>>0<32&0!=(0|(e=0|ze[e+4>>2])))){a=7;break r;}r=0|Y(e,t);}else a=7;}r:do{if(7==(0|a)){e:do{if(r>>>0<32){for(;e=0|ze[8400+(r<<2)>>2],r=r+1|0,!(0|e);)if(32<=r>>>0)break e;r=0|Y(e,t);break r;}}while(0);if(0|(r=0|ze[2287])&&0==(1&(f=0|ze[r>>2])|0)){if(ze[r>>2]=1|f,e=31-(0|cr(0|(o=8<(o=(f>>>1)-8|0)>>>0?o:8)))|0,e=8400+((0==(0|o)?1:e)<<2)|0,o=r+12|0,(0|ze[e>>2])==(0|(i=r+8|0))&&(ze[e>>2]=ze[o>>2]),0|(r=0|ze[i>>2])&&(ze[r+4>>2]=ze[o>>2]),0|(r=0|ze[o>>2])&&(ze[r>>2]=ze[i>>2]),t=0==(0|Z(t)),r=0|ze[2287],t)return ze[r>>2]&=-2,(n=0)|n;if(r)break;return(r=0)|r;}if(-1==(0|(e=0|W(i=t+15&-8))))return(n=0)|n;if((0|(o=e))!=(0|(a=r=o+7&-8))&&-1==(0|W(r-o|0)))return(n=0)|n;(e=0|ze[2287])?ze[r+4>>2]=e:ze[2286]=a,ze[2287]=a,ze[r>>2]=i<<1|1;}}while(0);return nr(0|(t=r+8|0),0,0|n),0|t;}function V(r,e){var i,a=0,f=0,n=0,t=0,o=0,l=0==(0|(e|=0));if(!(r|=0)){var c=l?1:e;l=(l=31-(0|cr(0|(8<c>>>0?c:8)))|0)+(1!=(0|ar(0|c))&1)|0;r:{if(3<l>>>0&c>>>0<1<<l>>>0&&0!=(0|(a=0|ze[8400+(l+-1<<2)>>2]))){for(i=0;!(c>>>0<=(((0|ze[a+-8>>2])>>>1)-8|0)>>>0);)if(!((i=i+1|0)>>>0<32&0!=(0|(a=0|ze[a+4>>2])))){o=8;break r;}l=0|Y(a,c);}else o=8;}r:do{if(8==(0|o)){e:do{if(l>>>0<32){for(;a=0|ze[8400+(l<<2)>>2],l=l+1|0,!(0|a);)if(32<=l>>>0)break e;l=0|Y(a,c);break r;}}while(0);if(0|(l=0|ze[2287])&&0==(1&(f=0|ze[l>>2])|0)){if(ze[l>>2]=1|f,a=31-(0|cr(0|(i=8<(i=(f>>>1)-8|0)>>>0?i:8)))|0,a=8400+((0==(0|i)?1:a)<<2)|0,i=l+12|0,(0|ze[a>>2])==(0|(f=l+8|0))&&(ze[a>>2]=ze[i>>2]),0|(l=0|ze[f>>2])&&(ze[l+4>>2]=ze[i>>2]),0|(l=0|ze[i>>2])&&(ze[l>>2]=ze[f>>2]),e=0==(0|Z(c)),l=0|ze[2287],e)return ze[l>>2]&=-2,(e=0)|e;if(l)break;return(l=0)|l;}if(-1==(0|(a=0|W(f=c+15&-8))))return(e=0)|e;if((0|(i=a))!=(0|(c=l=i+7&-8))&&-1==(0|W(l-i|0)))return(e=0)|e;(a=0|ze[2287])?ze[l+4>>2]=a:ze[2286]=c,ze[2287]=c,ze[l>>2]=f<<1|1;}}while(0);return l+8|0;}var s=r+-8|0;if(l)return G(s),0;if(e>>>0<=((a=(l=0|ze[s>>2])>>>1)-8|0)>>>0){if(ze[s>>2]=1|l,8==(-8&(l=a+(-8-e)|0)|0)&(0|ze[2287])==(0|s)){if(!(0|Z(a)))return 0|r;l=l+8|0;}return l>>>0<=15||(e=t=o=r+e+7&-8,ze[s>>2]=1&(n=0|ze[s>>2])|o-s<<1,ze[e>>2]=(o=s+(n>>>1)-o|0)<<1|1&ze[e>>2],ze[e+4>>2]=s,ze[((0|ze[2287])==(0|s)?9148:t+(2147483647&o)+4|0)>>2]=t,G(e)),0|r;}if(f=(0|(c=0|ze[2287]))!=(0|s)?1&(a=0|ze[(f=s+a|0)>>2])?c:(l=31-(0|cr(0|(a=8<(a=(a>>>1)-8|0)>>>0?a:8)))|0,l=8400+((0==(0|a)?1:l)<<2)|0,a=f+12|0,(0|ze[l>>2])==(0|(i=f+8|0))&&(ze[l>>2]=ze[a>>2]),0|(l=0|ze[i>>2])&&(ze[l+4>>2]=ze[a>>2]),0|(l=0|ze[a>>2])&&(ze[l>>2]=ze[i>>2]),ze[s>>2]=l=(0|ze[s>>2])+(-2&ze[f>>2])|0,(0|c)==(0|f)?ze[2287]=s:(ze[f+((0|ze[f>>2])>>>1)+4>>2]=s,c)):s,e>>>0<=((a=l>>>1)-8|0)>>>0){if(ze[s>>2]=1|l,(0|f)==(0|s)&8==(-8&(l=a+(-8-e)|0)|0)){if(!(0|Z(a)))return 0|r;l=l+8|0;}return l>>>0<=15||(e=t=o=r+e+7&-8,ze[s>>2]=1&(n=0|ze[s>>2])|o-s<<1,ze[e>>2]=(o=s+(n>>>1)-o|0)<<1|1&ze[e>>2],ze[e+4>>2]=s,ze[((0|ze[2287])==(0|s)?9148:t+(2147483647&o)+4|0)>>2]=t,G(e)),0|r;}l=31-(0|cr(0|(c=8<e>>>0?e:8)))|0,l=(0==(0|c)?1:l)+(1!=(0|ar(0|e))&1)|0;r:{if(3<l>>>0&e>>>0<1<<l>>>0&&0!=(0|(n=0|ze[8400+(l+-1<<2)>>2]))){for(i=0,a=n;!(e>>>0<=(((0|ze[a+-8>>2])>>>1)-8|0)>>>0);)if(!((i=i+1|0)>>>0<32&0!=(0|(a=0|ze[a+4>>2])))){o=63;break r;}l=0|Y(a,e);}else o=63;}r:do{if(63==(0|o)){e:do{if(l>>>0<32){for(;a=0|ze[8400+(l<<2)>>2],l=l+1|0,!(0|a);)if(32<=l>>>0)break e;l=0|Y(a,e);break r;}}while(0);if((0|f)==(0|s)){if(0|Z(e))return 0|r;l=0|ze[2287];}else l=f;if(0|l&&0==(1&(t=0|ze[l>>2])|0)){if(ze[l>>2]=1|t,a=31-(0|cr(0|(i=8<(i=(t>>>1)-8|0)>>>0?i:8)))|0,a=8400+((0==(0|i)?1:a)<<2)|0,i=l+12|0,(0|ze[a>>2])==(0|(f=l+8|0))&&(ze[a>>2]=ze[i>>2]),0|(l=0|ze[f>>2])&&(ze[l+4>>2]=ze[i>>2]),0|(l=0|ze[i>>2])&&(ze[l>>2]=ze[f>>2]),o=0==(0|Z(e)),l=0|ze[2287],o)return ze[l>>2]&=-2,(e=0)|e;if(l)break;return(l=0)|l;}if(-1==(0|(a=0|W(f=e+15&-8))))return(e=0)|e;if((0|(i=a))!=(0|(c=l=i+7&-8))&&-1==(0|W(l-i|0)))return(e=0)|e;(a=0|ze[2287])?ze[l+4>>2]=a:ze[2286]=c,ze[2287]=c,ze[l>>2]=f<<1|1;}}while(0);return fr(0|(o=l+8|0),0|r,0|(e>>>0<(t=((0|ze[s>>2])>>>1)-8|0)>>>0?e:t)),G(s),0|o;}function W(r){var e=0|ze[2296];return(r=e+(0|r)|0)>>>0>(0|kr())>>>0&&0==(0|dr(0|r))?-1:(ze[2296]=r,0|e);}function X(r,e,i,a){e|=0,a|=0;var f=0|r,n=0|i,t=65535&(r=0|f),o=65535&(i=0|n),l=0|lr(o,t),c=r>>>16;return r=(l>>>16)+(0|lr(o,c))|0,i=0|lr(o=i>>>16,t),i=0|(ur((r>>>16)+(0|lr(o,c))+(((65535&r)+i|0)>>>16)|0),r+i<<16|65535&l|0),r=0|br(),0|(ur((0|lr(e,n))+(0|lr(a,f))+r|0&r|0),0|i);}function $(r,e,i,a){return 0|(ur((0|e)+(0|a)+((i=(r|=0)+(0|i)>>>0)>>>0<r>>>0|0)>>>0|0),0|i);}function Q(r,e,i,a){return 0|(ur((0|e)-(0|a)-((r|=0)>>>0<(i|=0)>>>0|0)>>>0|0),r-i>>>0|0);}function J(r){return 0|((r|=0)?31-(0|cr(r^r-1))|0:32);}function rr(r,e,i,a){return 0|function(r,e,i,a,f){var n,t;f|=0;var o=r|=0,l=n=e|=0,c=i|=0,s=t=a|=0;if(!l){var u=0!=(0|f);if(s){if(!u)return(f=0)|(ur(0),f);ze[f>>2]=0|r,ze[f+4>>2]=0&e,f=t=0;}else u&&(ze[f>>2]=(o>>>0)%(c>>>0),ze[f+4>>2]=0),f=(o>>>(t=0))/(c>>>0)>>>0;return 0|(ur(0|t),f);}u=0==(0|s);do{if(c){if(!u){if((u=(0|cr(0|s))-(0|cr(0|l))|0)>>>0<=31){var b=u+1|0;r=o>>>((c=b)>>>0)&(e=u-31>>31)|l<<(s=31-u|0),e&=l>>>(b>>>0),u=0,s=o<<s;break;}return f&&(ze[f>>2]=0|r,ze[f+4>>2]=n|0&e),f=t=0,0|(ur(0|t),f);}if((u=c-1|0)&c|0){var k=64-(s=33+(0|cr(0|c))-(0|cr(0|l))|0)|0,v=s-32|0;r=(b=32-s|0)-1>>31&l>>>(v>>>0)|(l<<b|o>>>((c=s)>>>0))&(e=v>>31),e&=l>>>(s>>>0),u=o<<k&(n=b>>31),s=(l<<k|o>>>(v>>>0))&n|o<<b&s-33>>31;break;}0|f&&(ze[f>>2]=u&o,ze[f+4>>2]=0),k=1==(0|c)?(v=n|0&e,0|r):(v=l>>>((k=0|J(0|c))>>>0)|0,l<<32-k|o>>>(k>>>0)|0);}else{if(u)return 0|f&&(ze[f>>2]=(l>>>0)%(c>>>0),ze[f+4>>2]=0),k=(l>>>(v=0))/(c>>>0)>>>0,0|(ur(0|v),k);if(!o)return 0|f&&(ze[f>>2]=0,ze[f+4>>2]=(l>>>0)%(s>>>0)),k=(l>>>(v=0))/(s>>>0)>>>0,0|(ur(0|v),k);if(!((u=s-1|0)&s))return 0|f&&(ze[f>>2]=0|r,ze[f+4>>2]=u&l|0&e),k=l>>>(((v=0)|J(0|s))>>>0),0|(ur(0|v),k);if((u=(0|cr(0|s))-(0|cr(0|l))|0)>>>0<=30){r=l<<(s=31-u|0)|o>>>((c=e=u+1|0)>>>0),e=l>>>(e>>>0),u=0,s=o<<s;break;}if(!f)return k=v=0,0|(ur(0|v),k);ze[f>>2]=0|r,ze[f+4>>2]=n|0&e,k=v=0;}return 0|(ur(0|v),k);}while(0);if(c){for(l=0|$(0|(b=0|i),0|(o=t|0&a),-1,-1),i=0|br(),n=s,s=0;n=u>>>31|(a=n)<<1,u=s|u<<1,Q(0|l,0|i,0|(a=r<<1|a>>>31|0),0|(t=r>>>31|e<<1|0)),s=1&(v=(k=0|br())>>31|((0|k)<0?-1:0)<<1),r=0|Q(0|a,0|t,v&b|0,(((0|k)<0?-1:0)>>31|((0|k)<0?-1:0)<<1)&o|0),e=0|br(),0!=(0|(c=c-1|0)););l=n,n=0;}else l=s,s=n=0;return(c=0)|f&&(ze[f>>2]=r,ze[f+4>>2]=e),k=-2&(u<<1|0)|s,0|(ur((0|u)>>>31|(l|c)<<1|0&(c<<1|u>>>31)|n|0),k);}(0|r,0|e,0|i,0|a,0);}function er(r,e,i){return r|=0,e|=0,(0|(i|=0))<32?(ur(e>>>i|0),r>>>i|(e&(1<<i)-1)<<32-i):(ur(0),e>>>i-32|0);}function ir(r,e,i){return r|=0,(0|(i|=0))<32?(ur((e|=0)<<i|(r&(1<<i)-1<<32-i)>>>32-i|0),r<<i):(ur(r<<i-32|0),0);}function ar(r){return lr((r=(858993459&(r=(r|=0)-(r>>>1&1431655765)|0))+(r>>>2&858993459)|0)+(r>>>4)&252645135,16843009)>>>24|0;}function fr(r,e,i){if(r|=0,e|=0,8192<=(0|(i|=0)))return vr(0|r,0|e,0|i),0|r;var a=0|r,f=r+i|0;if((3&r)==(3&e)){for(;3&r;){if(!i)return 0|a;je[r>>0]=0|je[e>>0],r=r+1|0,e=e+1|0,i=i-1|0;}for(i=-4&f|0;(0|r)<(0|i);)ze[r>>2]=ze[e>>2],r=r+4|0,e=e+4|0;}else for(i=f-4|0;(0|r)<(0|i);)je[r>>0]=0|je[e>>0],je[r+1>>0]=0|je[e+1>>0],je[r+2>>0]=0|je[e+2>>0],je[r+3>>0]=0|je[e+3>>0],r=r+4|0,e=e+4|0;for(;(0|r)<(0|f);)je[r>>0]=0|je[e>>0],r=r+1|0,e=e+1|0;return 0|a;}function Ne(r,e,i){if((0|(e|=0))<(0|(r|=0))&(0|r)<(e+(i|=0)|0)){var a=r;for(e=e+i|0,r=r+i|0;0<(0|i);)i=i-1|0,je[(r=r-1|0)>>0]=0|je[(e=e-1|0)>>0];r=a;}else fr(r,e,i);return 0|r;}function nr(r,e,i){var a,f=(r|=0)+(i|=0)|0;if(e=255&(0|e),67<=(0|i)){for(;3&r;)je[r>>0]=e,r=r+1|0;for(a=e|e<<8|e<<16|e<<24;(0|r)<(0|(-4&f|0));)ze[r>>2]=a,r=r+4|0;}for(;(0|r)<(0|f);)je[r>>0]=e,r=r+1|0;return f-i|0;}function a(){return sr(1),0;}function f(){return sr(4),0;}function tr(){sr(7);}var je=new r.Int8Array(i);new r.Int16Array(i);var ze=new r.Int32Array(i),Be=new r.Uint8Array(i),or=new r.Uint16Array(i),lr=r.Math.imul,cr=r.Math.clz32,sr=e.a,ur=e.b,br=e.c,kr=e.d,vr=e.e,dr=e.f,De=9376,hr=[function(){return sr(0),0;},w],wr=[a,function(r,e){return e|=0,de(r|=0,5906,6),0|e&&H(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,5913,7),1;},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5867,30),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5898,7),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5848,8),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5857,9),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5837,4),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5842,5),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5809,12),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5822,14),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5796,5),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5802,6),1):0);},function(r,e){r|=0;var i=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(i=e+4|0)>>2])?(de(r,5783,5),de(r,0|ze[e>>2],0|ze[i>>2]),de(r,5789,6),1):0);},function(r,e,i){r|=0,e|=0;var a,f,n=0,t=0|ze[20+(i|=0)>>2],o=0|ze[i+16>>2];r:do{if(0!=(0|t)&0!=(1024&o|0)){var l=e+4|0;for(a=0;;){var c=0|ze[t+(a<<2)>>2];if(!c){n=6;break r;}if(f=0|O(0|ze[e>>2],0|ze[l>>2],c))break;a=a+1|0;}a=r,l=e;var s=0|ze[i+24>>2];l|=0,c|=0,s|=0,f|=0;var u,b,k=0;if(he(a|=0,60),2==(0|f))he(a,47),y(a,c);else{y(a,c),c=0|D(c);var v=0|C(16),d=0|C(16),h=l+4|0,w=v+4|0,m=d+4|0;for(f=1,u=b=0;;){var _=c+1|0;if(!(f&_>>>0<(0|ze[h>>2])>>>0))break;var p=0|je[(0|ze[l>>2])+_>>0];e:do{switch(0|p){case 62:f=0;break;case 34:case 39:if(b){if(u){if((0|u)!=(0|p)){he(d,p),f=1;break e;}for(f=0;;){if(!(u=0|ze[s+(f<<2)>>2])){k=27;break e;}if((0|(p=0|D(u)))==(0|ze[w>>2])){for(c=0;!(p>>>0<=c>>>0)&&(0|(k=0|T(0|je[u+c>>0])))==(0|T(0|Be[(0|ze[v>>2])+c>>0]));)c=c+1|0;if((0|c)==(0|p))break;}f=f+1|0;}0==(0|p)|0==(0|ze[m>>2])||(he(a,32),H(a,0|ze[v>>2],0|ze[w>>2]),y(a,6026),H(a,0|ze[d>>2],0|ze[m>>2]),he(a,34)),k=27;}else f=1,u=p;}else k=27;break;case 32:u?(he(d,32),f=1):k=27;break;case 61:b?k=27:b=f=1;break;default:0==(0|u)&(c=0!=(0|b))?(f=1,u=0):(he(c?d:v,p),f=1);}}while(0);27==(0|k)&&(k=0,x(v),x(d),f=1,u=b=0),c=_;}S(v),S(d);}he(a,62);}else n=6;}while(0);return 6==(0|n)&&(512&o|0?H(r,0|ze[e>>2],0|ze[e+4>>2]):1&o||2&o|0&&0|O(0|ze[e>>2],0|ze[e+4>>2],6014)||(l=0|ze[e>>2],a=0|ze[e+4>>2],8&o|0&&0|O(l,a,6020)||4&o|0&&0|O(l,a,6022)||de(r,l,a))),1;},a,a,a,a,a,a,a],mr=[function(){return sr(2),0;},function(r,e,i,a){r|=0,i|=0,a|=0;var f=0,n=0;if(0!=(0|(e|=0))&&0!=(0|(f=0|ze[(n=e+4|0)>>2]))){if(32&ze[a+16>>2]|0&&2!=(0|i)&0==(0|k(0|ze[e>>2],f)))i=0;else{de(r,6029,9),2==(0|i)&&de(r,6090,7),d(0|r,0|ze[e>>2],0|ze[n>>2]),0|ze[(i=a+28|0)>>2]?(he(r,34),Le[7&ze[i>>2]](r,e,a),he(r,62)):de(r,6005,2);var t=f=0,o=0,l=0|ze[4+(i=0|e)>>2];for(a=0;;){if(l>>>0<=a>>>0){a=0;break;}if(t=0|je[6090+a>>0],7==(0|a)){a=0;break;}if((0|(f=0|Be[(0|ze[i>>2])+a>>0]))!=(0|t)){o=5;break;}a=a+1|0;}5==(0|o)&&(a=f-t|0),i=0|ze[e>>2],0==(0|a)?H(r,i+7|0,(0|ze[n>>2])-7|0):H(r,i,0|ze[n>>2]),de(r,6049,4),i=1;}}else i=0;return 0|i;}],_r=[function(){return sr(3),0;},function(r,e,i,a){return(e=0)|(a|=0)&&0|(e=0|ze[a+4>>2])&&de(0|r,0|ze[a>>2],e),1;},function(r,e,i,a,f){r|=0,i|=0,a|=0,f|=0;var n=0,t=0,o=0;return 0|(0!=(0|(e|=0))&&0!=(0|ze[(o=e+4|0)>>2])?(de(r,6067,10),d(0|r,0|ze[e>>2],0|ze[o>>2]),de(r,6078,7),0|a&&0|(n=0|ze[a+4>>2])&&H(r,0|ze[a>>2],n),0|i&&0|ze[(t=i+4|0)>>2]&&(de(r,6039,9),H(r,0|ze[i>>2],0|ze[t>>2])),y(r,0==(256&ze[f+16>>2]|0)?6005:6086),1):0);},function(r,e,i,a,f){r|=0,e|=0,i|=0,a|=0,f|=0;var n=0,t=0,o=0,l=0;do{if(e){if(32&ze[f+16>>2]){if(!(0|k(0|ze[e>>2],0|ze[(n=e+4|0)>>2]))){n=0;break;}}else n=e+4|0;de(r,6029,9),(n=0|ze[n>>2])&&d(0|r,0|ze[e>>2],0|n);}else de(r,6029,9);t=8;}while(0);return 8==(0|t)&&(0|i&&0|ze[(o=i+4|0)>>2]&&(de(r,6039,9),H(r,0|ze[i>>2],0|ze[o>>2])),0|ze[(n=f+28|0)>>2]?(he(r,34),Le[7&ze[n>>2]](r,e,f),he(r,62)):de(r,6005,2),0|a&&0|(l=0|ze[a+4>>2])&&de(r,0|ze[a>>2],l),de(r,6049,4),n=1),0|n;}],pr=[f,function(r,e,i,a,f,n){r|=0,e|=0,a|=0,f|=0;var t=0,o=0,l=0,c=0|je[(i|=0)>>0],s=3<(n|=0)>>>0;if(s&62==c<<24>>24){if(33==(f=0|je[(a=i+1|0)>>0])<<24>>24){if(!(0|He(0|Be[(a=i+2|0)>>0]))){r:{r|=0,i=0|a,n=n+-2|0,o=(t=0)|ze[56+(e|=0)>>2];e:do{if(0|o){for(s=0;;){if(n>>>0<=s>>>0)break e;if(!(c=0|q(i+s|0,n-s|0,60)))break e;if((s=c+s|0)>>>0<n>>>0&&60==(0|je[i+s>>0])&&33==(0|je[i+(t=s+-1|0)>>0]))break;s=s+1|0;}Pe(n=0|qe(e,1),e,i,t),o=0|wr[15&o](r,n,0|ze[e+112>>2]),Oe(e,1),n=0|(0==(0|o)?0:s+1|0);break r;}}while(0);n=0;}return 0|(0==(0|(n|=0))?0:n+2|0);}a=0;}else l=7;}else l=2<n>>>0?(a=f=i+1|0,f=0|je[f>>0],7):11;r:{if(7==(0|l)){var u=255&f;if(f<<24>>24!=c<<24>>24){switch(c<<24>>24){case 62:case 126:a=0;break r;}a=0|He(u)?0:0==(0|(a=0|m(r,e,a,n+-1|0,c)))?0:a+1|0;}else l=11;}}r:do{if(11==(0|l))if(s&&(0|je[i+1>>0])==c<<24>>24){if((f=0|je[(a=i+2|0)>>0])<<24>>24!=c<<24>>24)a=0|He(255&f)?0:0==(0|(a=0|_(r,e,a,n+-2|0,c)))?0:a+2|0;else if(5<=n>>>0&&(o=255&(l=0|je[(t=i+3|0)>>0]),l<<24>>24!=c<<24>>24)){switch(c<<24>>24){case 62:case 126:a=0;break r;}if(0|He(o))a=0;else{e:{a=r,f=e,u=t;var b=n+-3|0,k=c;a|=0,f|=0,u|=0,b|=0,k|=0;var v,d=0,h=0,w=0;for(v=0;;){if(b>>>0<=v>>>0){v=0;break;}if(!(d=0|q(u+v|0,b-v|0,k))){v=0;break;}if((0|je[u+(d=d+v|0)>>0])==k<<24>>24&&0==(0|He(0|Be[u+(d+-1)>>0]))){w=7;break;}v=d;}if(7==(0|w))if(v=d+1|0,(w=d+2|0)>>>0<b>>>0&&(0|je[u+v>>0])==k<<24>>24&&(0|je[u+w>>0])==k<<24>>24&&0|ze[(h=f+84|0)>>2])Pe(v=0|qe(f,1),f,u,d),v=0|wr[15&ze[h>>2]](a,v,0|ze[f+112>>2]),Oe(f,1),v=0==(0|v)?0:d+3|0;else{if(v>>>0<b>>>0&&(0|je[u+v>>0])==k<<24>>24){a=0|(0==(0|(w=0|m(a,f,u+-2|0,b+2|0,k)))?0:w+-2|0);break e;}v=0==(0|(v=0|_(a,f,u+-1|0,b+1|0,k)))?0:v+-1|0;}a=0|v;}a=0==(0|(a|=0))?0:a+3|0;}}else a=0;}else a=0;}while(0);return 0|a;},function(r,e,i,a,f,n){var t,o;r|=0,e|=0,i|=0,n|=0;var l=De;for(De=De+16|0,t=0;!(n>>>0<=t>>>0)&&96==(0|je[i+t>>0]);)t=t+1|0;for(a=0,o=t;(f=o>>>0<n>>>0)&a>>>0<t>>>0;)a=96==(0|je[i+o>>0])?a+1|0:0,o=o+1|0;if(f|t>>>0<=a>>>0){for(f=t;!(o>>>0<=f>>>0)&&32==(0|je[i+f>>0]);)f=f+1|0;for(a=o-t|0;!(a>>>0<=t>>>0)&&32==(0|je[i+(n=a+-1|0)>>0]);)a=n;if(!(f>>>0<a>>>0))return i=0==(0|wr[15&ze[e+52>>2]](r,0,0|ze[e+112>>2])),De=l,0|(i?0:o);ze[l>>2]=i+f,ze[l+4>>2]=a-f,ze[l+8>>2]=0,a=(a=(ze[l+12>>2]=0)==(0|wr[15&ze[e+52>>2]](r,l,0|ze[e+112>>2])))?0:o;}else a=0;return De=l,0|a;},function(r,e,i,a){if(r|=0,e|=0,i|=0,2<=(0|a)>>>0&&32==(0|je[i+-1>>0])&&32==(0|je[i+-2>>0])){for(i=0|ze[(a=r+4|0)>>2];i&&32==(0|je[(0|ze[r>>2])+(i=i+-1|0)>>0]);)ze[a>>2]=i;i=0!=(0|hr[1&ze[e+72>>2]](r,0|ze[e+112>>2]))&1;}else i=0;return 0|i;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=0,o=0,l=0,c=0,s=0,u=0,b=0;if(0|a){if(f=0|ze[(a=e+420|0)>>2],33==(0|je[i+-1>>0])){if(0|ze[e+68>>2]){u=f,s=a,c=1;var k=6;}else k=89;}else k=5;}else f=0|ze[(a=e+420|0)>>2],k=5;5==(0|k)&&(k=0|ze[e+76>>2]?(u=f,s=a,c=0,6):89);r:do{if(6==(0|k)){var v=a=1;f=0;e:for(;;){if(n>>>0<=v>>>0){f=u,a=s,k=89;break r;}var d=0|je[i+v>>0];i:do{if(10!=d<<24>>24){var h=v+-1|0;if(92!=(0|je[i+h>>0]))switch(d<<24>>24){case 91:a=a+1|0;break i;case 93:if((0|a)<2)break e;a=a+-1|0;break i;default:break i;}}else f=1;}while(0);v=v+1|0;}for(d=a=v+1|0;;){if(n>>>0<=d>>>0){k=66;break;}if(!(0|He(255&(t=0|je[i+d>>0])))){k=18;break;}d=d+1|0;}e:do{if(18==(0|k)){switch(t<<24>>24){case 40:break;case 91:for(t=a=d+1|0;;){if(n>>>0<=t>>>0){f=u,a=s,k=89;break r;}if(93==(0|je[i+t>>0]))break;t=t+1|0;}if((0|t)==(0|a)){if(f){for(d=0|qe(e,1),a=1;!(v>>>0<=a>>>0);)10==(f=0|je[i+a>>0])<<24>>24?32!=(0|je[i+(a+-1)>>0])&&he(d,32):he(d,255&f),a=a+1|0;f=0|ze[d>>2],a=0|ze[d+4>>2];}else f=i+1|0,a=h;}else f=i+a|0,a=t-a|0;if(!(f=0|I(e+116|0,f,a))){f=u,a=s,k=89;break r;}a=t+1|0,o=0|ze[f+8>>2],d=0|ze[f+4>>2];break e;default:k=66;break e;}for(;;){var w=d+1|0;if(n>>>0<=w>>>0)break;if(!(0|He(0|Be[i+w>>0])))break;d=w;}var m=w;i:for(;;){if(n>>>0<=m>>>0){f=u,a=s,k=89;break r;}switch((t=0|je[i+m>>0])<<24>>24){case 41:n=l=0,o=a=m;break i;case 92:a=2;break;default:if(0!=(0|m)&&0!=(0|He(0|Be[i+(m+-1)>>0])))switch(t<<24>>24){case 34:case 39:k=29;break i;default:a=1;}else a=1;}m=m+a|0;}i:do{if(29==(0|k)){var _=m+1|0;for(a=1,o=_;;){if(n>>>0<=o>>>0){f=u,a=s,k=89;break r;}if(92!=(f=0|je[i+o>>0])<<24>>24){if(f<<24>>24!=t<<24>>24){if(!(0!=(0|a)|41!=f<<24>>24))break;f=1;}else a=0,f=1;}else f=2;o=o+f|0;}f=o;do{if(a=0|je[i+(f=f+-1|0)>>0],f>>>0<=_>>>0)break;}while(0!=(0|He(255&a)));switch(a<<24>>24){case 34:case 39:a=m,l=_,n=f;break i;}a=o,n=l=0;}}while(0);for(;_=0|je[i+(t=a+-1|0)>>0],!(a>>>0<=w>>>0)&&0|He(255&_);)a=t;(f=60==(0|je[i+w>>0])?d+2|0:w)>>>0<(a=62==_<<24>>24?t:a)>>>0?de(d=0|qe(e,1),i+f|0,a-f|0):d=0,l>>>0<n>>>0?de(f=0|qe(e,1),i+l|0,n-l|0):f=0,a=o+1|0,o=f;}}while(0);if(66==(0|k)){if(f){for(t=0|qe(e,1),f=1;!(v>>>0<=f>>>0);)10==(d=0|je[i+f>>0])<<24>>24?32!=(0|je[i+(f+-1)>>0])&&he(t,32):he(t,255&d),f=f+1|0;d=0|ze[t>>2],f=0|ze[t+4>>2];}else d=i+1|0,f=h;if(!(f=0|I(e+116|0,d,f))){f=u,a=s,k=89;break;}o=0|ze[f+8>>2],d=0|ze[f+4>>2];}t=1<v>>>0?(f=0|qe(e,1),c?de(f,i+1|0,h):(Pe(f,e,i+(ze[(t=e+440|0)>>2]=1)|0,h),ze[t>>2]=0),f):0,d?(p(_=0|qe(e,1),d),f=c?(0|(d=0|ze[(f=r+4|0)>>2])&&33==(0|je[(0|ze[r>>2])+(b=d+-1|0)>>0])&&(ze[f>>2]=b),0|_r[3&ze[e+68>>2]](r,_,o,t,0|ze[e+112>>2])):0|_r[3&ze[e+76>>2]](r,_,o,t,0|ze[e+112>>2]),ze[s>>2]=u,f||(k=91)):(f=u,a=s,k=89);}}while(0);return 89==(0|k)&&(ze[a>>2]=f,k=91),91==(0|k)&&(a=0),0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0;var t=0,o=De;De=De+32|0,a=(ze[(f=o+16|0)>>2]=0)|i,n|=0;var l=0|f,c=0,s=0,u=0;r:do{if(3<=n>>>0&&60==(0|je[a>>0])&&0!=(0|Ke(0|Be[a+(c=47==(0|je[a+1>>0])?2:1)>>0]))){ze[l>>2]=0;e:for(;!(n>>>0<=c>>>0);){var b=0|je[a+c>>0];if(!(0|Ke(255&b)))switch(b<<24>>24){case 45:case 43:case 46:break;default:break e;}c=c+1|0;}if(1<c>>>0){var k,v=0|je[(b=a+c|0)>>0];if(k=64==v<<24>>24){var d,h=b,w=n-c|0;h|=0,w|=0;var m=0;b=d=0;e:for(;;){if(w>>>0<=b>>>0){d=0;break;}k=0|je[h+b>>0];i:do{if(!(0|Ke(255&k))){switch(k<<24>>24){case 62:m=6;break e;case 95:case 46:case 45:break i;case 64:break;default:d=0;break e;}d=d+1|0;}}while(0);b=b+1|0;}6==(0|m)&&(d=1==(0|d)?b+1|0:0),k=0|(s=0|d);}if(k){ze[l>>2]=2,b=s+c|0;break;}b=2<c>>>0?58==v<<24>>24?(c=c+(ze[l>>2]=1)|0,1):0:(c=2,0);}else b=0;if(c>>>0<n>>>0){if(b){v=c;e:for(;;){if(n>>>0<=v>>>0){b=0;break r;}switch((b=0|je[a+v>>0])<<24>>24){case 10:case 32:case 34:case 39:case 62:break e;case 92:b=2;break;default:b=1;}v=v+b|0;}if(c>>>0<v>>>0&62==b<<24>>24){b=v+1|0;break;}c=v,u=25;}}else u=25;for(25==(0|u)&&(ze[l>>2]=0);;){if(n>>>0<=c>>>0){b=0;break r;}if(b=c+1|0,62==(0|je[a+c>>0]))break;c=b;}}else b=0;}while(0);a=0|b,ze[o>>2]=i,ze[(l=o+4|0)>>2]=a,ze[o+8>>2]=0,ze[o+12>>2]=0;do{if(2<a>>>0){if(0!=(0|ze[(n=e+48|0)>>2])&0!=(0|(f=0|ze[f>>2])))c=0|qe(e,1),ze[o>>2]=i+1,ze[l>>2]=a+-2,p(c,o),f=0|mr[1&ze[n>>2]](r,c,f,0|ze[e+112>>2]),Oe(e,1);else{if(!(f=0|ze[e+80>>2])){t=7;break;}f=0|wr[15&f](r,o,0|ze[e+112>>2]);}f||(t=7);}else t=7;}while(0);return 7==(0|t)&&(a=0),De=o,0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=De;return De=De+16|0,ze[t>>2]=0,ze[t+4>>2]=0,ze[t+8>>2]=0,a=1<n>>>(ze[t+12>>2]=0)?0|z(5719,a=0|Be[(i=i+1|0)>>0],24)?((f=0|ze[e+100>>2])?(ze[t>>2]=i,ze[t+4>>2]=1,Le[7&f](r,t,0|ze[e+112>>2])):he(r,a),2):0:(1==(0|n)&&he(r,0|Be[i>>0]),2),De=t,0|a;},function(r,e,i,a,f,n){r|=0,e|=0,i|=0,n|=0;var t=0,o=De;if(De=De+16|0,ze[o>>2]=0,ze[o+4>>2]=0,ze[o+8>>2]=0,1<n>>>(ze[o+12>>2]=0)){if(f=(a=35==(0|je[i+1>>0]))?2:1,a&f>>>0<n>>>0){var l=120==(0|T(0|Be[i+f>>0])),c=1^l,s=1;l=f+(1&l)|0;}else c=1,s=a,l=f;}else s=0,l=c=1;var u=l;r:for(;;){if(n>>>0<=u>>>0){a=0;break;}if(f=(a=0|je[i+u>>0])<<24>>24,c){if(s){if(!((f+-48|0)>>>0<10)){t=12;break r;}}else if(!(0|Ke(f))){t=12;break r;}}else if(!(1&(((32|(f|=0))-97|0)>>>0<6|0!=(((0|f)-48|0)>>>0<10|0))|0)){t=12;break r;}u=u+1|0;}do{if(12==(0|t))if(l>>>0<u>>>0&59==a<<24>>24){if(a=u+1|0,s){if(7<(u-l|0)>>>0){a=0;break;}f=i+l|0;var b=0|(n=c?10:16);f|=0,b|=0,De=(n=De)+144|0;var k,v=n;ze[v>>2]=0,ze[v+4>>2]=f,ze[v+44>>2]=f,ze[v+8>>2]=(0|f)<0?-1:f+2147483647|0,ze[v+76>>2]=-1,K(v),f=v;var d=b;f|=0,d|=0;var h=0;r:do{if(36<d>>>0)var w=k=0;else{for(v=f+4|0,b=f+104|0;0!=(0|R(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f))););e:{switch(0|k){case 43:case 45:if(k=(45==(0|k))<<31>>31,(w=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0){ze[v>>2]=w+1;var m=k;k=0|Be[w>>0];}else m=k,k=0|M(f);break e;default:m=0;}}if(w=0==(0|d),16==(16|d)&48==(0|k)){if(120!=(32|(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f)))){if(w){w=8;var _=42;}else w=d,_=27;}else{if(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),15<(0|Be[4849+k>>0])){if(!(0|ze[b>>2])){w=k=0;break r;}ze[v>>2]=(0|ze[v>>2])-2,w=k=0;break r;}w=16,_=42;}}else{if(!((0|Be[4849+k>>0])>>>0<(w=w?10:d)>>>0)){0|ze[b>>2]&&(ze[v>>2]=(0|ze[v>>2])-1),K(f),w=k=0;break r;}_=27;}e:{if(27==(0|_))if(10==(0|w)){if((k=k+-48|0)>>>0<10){d=0;for(var p=k;d=(10*d|0)+p|0,(w=(p=(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f))-48|0)>>>0<10)&d>>>0<429496729;);if(w){var y=d;d=0;do{w=0|X(0|y,0|d,10,0);var g=((0|p)<0)<<31>>31,A=~g;if(A>>>0<(h=0|br())>>>0|(0|h)==(0|A)&~p>>>0<w>>>0){w=10,h=y,_=71;break e;}y=0|$(0|w,0|h,0|p,0|g),d=0|br(),p=(k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f))-48|0;}while(p>>>0<10&(d>>>0<429496729|429496729==(0|d)&y>>>0<2576980378));9<p>>>0?(w=d,k=y):(w=10,h=y,_=71);}else w=0,k=d;}else k=w=0;}else _=42;}e:do{if(42==(0|_)){if(!(w+-1&w)){if(A=0|je[8358+((23*w|0)>>>5&7)>>0],(d=255&(p=0|je[4849+k>>0]))>>>0<w>>>0){for(h=0;h=d|h<<A,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),h>>>0<134217728&(d=255&(p=0|je[4849+k>>0]))>>>0<w>>>0;);g=d,d=0;}else g=d,h=d=0;if(y=0|er(-1,-1,0|A),w>>>0<=g>>>0|(_=0|br())>>>0<d>>>0|(0|_)==(0|d)&y>>>0<h>>>0){_=71;break;}for(;;)if(h=0|ir(0|h,0|d,0|A),d=0|br(),h|=255&p,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),w>>>0<=(255&(p=0|je[4849+k>>0]))>>>0|_>>>0<d>>>0|(0|d)==(0|_)&y>>>0<h>>>0){_=71;break e;}}if((p=255&(d=0|je[4849+k>>0]))>>>0<w>>>0){for(h=0;h=p+(0|lr(h,w))|0,k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),h>>>0<119304647&(p=255&(d=0|je[4849+k>>0]))>>>0<w>>>0;);g=d;}else g=d,h=0;if(p>>>(d=0)<w>>>0)for(_=0|rr(-1,-1,0|w,0),A=0|br(),p=g;;){if(A>>>0<d>>>0|(0|d)==(0|A)&_>>>0<h>>>0){_=71;break e;}if(g=0|X(0|h,0|d,0|w,0),4294967295<(y=0|br())>>>0|-1==(0|y)&~(p&=255)>>>0<g>>>0){_=71;break e;}if(h=0|$(0|g,0|y,0|p,0),d=0|br(),k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),w>>>0<=(255&(p=0|je[4849+k>>0]))>>>0){_=71;break;}}else _=71;}}while(0);if(71==(0|_))if((0|Be[4849+k>>0])>>>0<w>>>0){for(;k=(k=0|ze[v>>2])>>>0<(0|ze[b>>2])>>>0?(ze[v>>2]=k+1,0|Be[k>>0]):0|M(f),(0|Be[4849+k>>0])>>>0<w>>>0;);w=0,k=-2147483648;}else w=d,k=h;if(0|ze[b>>2]&&(ze[v>>2]=(0|ze[v>>2])-1),!(w>>>0<0|0==(0|w)&k>>>0<2147483648)){if(!m){k=0,w=2147483647;break;}if(0<w>>>0|0==(0|w)&2147483648<k>>>0){k=0,w=-2147483648;break;}}w=0|Q(k^m|0,w^(b=((0|m)<0)<<31>>31)|0,0|m,0|b),k=0|br();}}while(0);if(ur(0|k),b=0|w,ur(0|br()),De=n,n=0|b,br(),n|=0,!(0|(17<((n|=0)-14|0)>>>0&8<n>>>0&1<(n+-11|0)>>>0?n>>>0<1114112&65535!=(1|n)&55296!=(-2048&n|0)&1|0:0))){a=0;break;}}else{n=i,f=a,n|=0,f|=0,b=0;do{if((f+-4|0)>>>0<7){switch(v=n,m=f,v|=0,(A=0)|(m|=0)){case 6:m=6,A=3;break;case 5:m=5,A=4;break;case 4:m=4,A=5;break;case 3:m=3,A=6;break;case 2:m=2;break;default:m=(0|or[4320+((0|Be[v+6>>0])<<1)>>1])+m|0,A=3;}if(3==(0|A)&&(m=m+(0|or[4320+((0|Be[v+5>>0])<<1)>>1])|0,A=4),4==(0|A)&&(m=m+(0|or[4320+((0|Be[v+4>>0])<<1)>>1])|0,A=5),5==(0|A)&&(m=m+(0|or[4320+((0|Be[v+3>>0])<<1)>>1])|0,A=6),6==(0|A)&&(m=m+(0|or[4320+(1+(0|Be[v+2>>0])<<1)>>1])|0),v=(v=m+(0|or[4320+((0|Be[v+1>>0])<<1)>>1])|0)>>>0<771&&(0|je[n>>0])==(0|je[(b=0|ze[1232+(v<<2)>>2])>>0])){if(A=n+1|0,_=b+1|0,y=f+-1|0,A|=0,_|=0,y|=0){m=0|je[A>>0];r:do{if(m<<24>>24)for(;;){if(!(m<<24>>24==(v=0|je[_>>0])<<24>>24&0!=(0|(y=y+-1|0))&0!=v<<24>>24))break r;if(_=_+1|0,!((m=0|je[(A=A+1|0)>>0])<<24>>24)){m=0;break;}}else m=0;}while(0);m=(255&m)-(0|Be[_>>0])|0;}else m=0;v=0==(0|m);}if(v&&0==(0|je[b+f>>0]))break;}b=0;}while(0);if(!(0|b)){a=0;break;}}0|(f=0|ze[e+96>>2])?(ze[o>>2]=i,ze[o+4>>2]=a,Le[7&f](r,o,0|ze[e+112>>2])):(he(r,38),s&&he(r,35),c||he(r,120),de(r,i+l|0,a-l|0));}else a=0;}while(0);return De=o,0|a;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=De;De=De+16|0;var o=48+(e|=0)|0;if(0!=(0|ze[o>>2])&&0==(0|ze[e+440>>2])){var l=0|qe(e,1);f=0|t;i|=0,a|=0;var s,u=0;if(4<=(n|=0)>>>0&&47==(0|je[i+1>>0])&&47==(0|je[i+2>>0])){for(s=0;!(a>>>0<=s>>>0)&&((32|Be[i+~s>>0])-97|0)>>>0<26|0;)s=s+1|0;var b=i+-s|0;if(0!=(0|k(b,s+n|0))&&0!=(0|(u=0|v(i+3|0,n+-3|0)))){for(a=u+3|0;!(n>>>0<=a>>>0||0|R(0|Be[i+a>>0]));)a=a+1|0;(a=0|h(i,a))?(de(0|l,b,a+s|0),ze[f>>2]=s):a=0;}else a=0;}else a=0;0|(f=0|a)&&(E(r,(0|ze[r+4>>2])-(0|ze[t>>2])|0),mr[1&ze[o>>2]](r,l,1,0|ze[e+112>>2])),Oe(e,1);}else f=0;return De=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=De;De=De+16|0;var o=48+(e|=0)|0;if(0!=(0|ze[o>>2])&&0==(0|ze[e+440>>2])){var l=0|qe(e,1);f=0|t;i|=0,a|=0,n|=0;var s,u,b=0;for(u=0;!(a>>>0<=u>>>0);){var k=0|je[i+~u>>0],v=255&k;if(!(k<<24>>24))break;if(0==(0|Ke(v))&&0==(0|z(5568,v,5)))break;u=u+1|0;}if(u){k=n+-1|0,v=a=s=0;r:for(;!(n>>>0<=s>>>0);){var d=0|je[i+s>>0];e:do{if(!(0|Ke(255&d))){switch(d<<24>>24){case 95:case 45:break e;case 64:v=v+1|0;break e;case 46:break;default:break r;}if(k>>>0<=s>>>0)break r;a=a+1|0;}}while(0);s=s+1|0;}0==(0|a)|1!=(0|v)|s>>>0<2||0==(0|(b=0|h(i,s)))?b=0:(de(0|l,i+-u|0,b+u|0),ze[f>>2]=u);}else b=0;0|(f=0|b)&&(E(r,(0|ze[r+4>>2])-(0|ze[t>>2])|0),mr[1&ze[o>>2]](r,l,2,0|ze[e+112>>2])),Oe(e,1);}else f=0;return De=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,n|=0;var t=De;De=De+16|0;var o=t,l=76+(e|=0)|0;if(0!=(0|ze[l>>2])&&0==(0|ze[e+440>>2])){var c=0|qe(e,1);f=0|o;i|=0,n|=0;var u=0,b=0,k=0;if(0!=(0|a)&&0==(0|B(b=0|Be[i+-1>>0]))?n>>>0<4|0==(0|R(b))?u=0:k=5:n>>>0<4?u=0:k=5,5==(0|k))if(0==(0|j(i,5558,4))&&0!=(0|(u=0|v(i,n)))){for(;!(n>>>0<=u>>>0||0|R(0|Be[i+u>>0]));)u=u+1|0;(u=0|h(i,u))?(de(0|c,i,u),ze[f>>2]=0):u=0;}else u=0;0|(f=0|u)&&(de(a=0|qe(e,1),5711,7),de(a,0|ze[c>>2],0|ze[c+4>>2]),E(r,(0|ze[r+4>>2])-(0|ze[o>>2])|0),0|ze[(i=e+100|0)>>2]?(n=0|qe(e,1),Le[7&ze[i>>2]](n,c,0|ze[(o=e+112|0)>>2]),_r[3&ze[l>>2]](r,a,0,n,0|ze[o>>2]),Oe(e,1)):_r[3&ze[l>>2]](r,a,0,c,0|ze[e+112>>2]),Oe(e,1)),Oe(e,1);}else f=0;return De=t,0|f;},function(r,e,i,a,f,n){r|=0,i|=0,a|=0,f|=0,n|=0;var t=0,o=De;De=De+16|0;var l=o+4|0,c=o;if(0!=(0|ze[48+(e|=0)>>2])&&0==(0|ze[e+440>>2])){var s,u=0|qe(e,1),b=0|l,k=0|u,v=0|i,d=0|n,h=0|c,w=0,m=0|g(v,0|a,0|f,d,114);r:do{if(m){for(w=4<d>>>0?0==(0|F(v+1|0,5573,4)):0,s=1;;){var _=s+10|0;if(_>>>0<=d>>>0&&0==(0|F(v+s|0,5578,10)))var p=10;else{if(_=(_=s+2|0)>>>0<d>>>0&&(p=0==(0|F(v+s|0,5589,2)))?_:s,!(0|Ke(0|Be[v+_>>0]))){_=0;break r;}p=24,_=_+1|0;}for(;;){if(d>>>0<=_>>>0){var y=0;break;}if(!(95==(y=0|je[v+_>>0])<<24>>24|0!=(0|Ke(255&y)))){y=1;break;}_=_+1|0;}if(!((s=_-s|0)>>>0<=p>>>0&1<s>>>0)){_=0;break r;}if(!y)break;if(!(43==(s=0|je[v+_>>0])<<24>>24|w&45==s<<24>>24))break;if(!_){_=1;break;}s=_+1|0;}e:do{if(_>>>0<d>>>0&&47==(0|je[v+_>>0]))for(;;){if(d>>>0<=_>>>0)break e;if(!(0|Ke(255&(y=0|je[v+_>>0]))))switch(y<<24>>24){case 45:case 47:case 95:break;default:break e;}_=_+1|0;}}while(0);de(k,v+-m|0,_+m|0),ze[h>>2]=1==(0|m)&1,ze[b>>2]=m;}else _=0;}while(0);if(b=0|_)t=5;else{b=0|l,k=0|u,i|=0,a|=0,f|=0,n|=0,v=0|c,_=0;r:do{if(3<=n>>>0&&0!=(0|(_=0|g(i,a,f,n,117)))){if(!(0|Ke(255&(a=0|je[i+1>>0]))))switch(a<<24>>24){case 45:case 95:break;default:a=0;break r;}a=2;e:for(;!(n>>>0<=a>>>0);){if(!(0|Ke(255&(f=0|je[i+a>>0]))))switch(f<<24>>24){case 45:case 47:case 95:break;default:break e;}a=a+1|0;}de(k,i+-_|0,a+_|0),ze[v>>2]=1==(0|_)&1,ze[b>>2]=_;}else a=0;}while(0);(b=0|a)?t=5:b=0;}5==(0|t)&&(a=0|qe(e,1),0|ze[c>>2]&&he(a,47),de(a,0|ze[u>>2],0|ze[u+4>>2]),E(r,(0|ze[r+4>>2])-(0|ze[l>>2])|0),0|ze[(i=e+100|0)>>2]?(c=0|qe(e,1),Le[7&ze[i>>2]](c,u,0|ze[(t=e+112|0)>>2]),_r[3&ze[e+76>>2]](r,a,0,c,0|ze[t>>2]),Oe(e,1)):_r[3&ze[e+76>>2]](r,a,0,u,0|ze[e+112>>2]),Oe(e,1)),Oe(e,1);}else b=0;return De=o,0|b;},function(r,e,i,a,f,n){r|=0,i|=0,n|=0;var t=92+(e|=0)|0;r:do{if(n>>>0<2|0==(0|ze[t>>2]))a=0;else{e:do{if(40==(0|je[i+1>>0])){for(a=2;!(n>>>0<=a>>>0)&&41!=(0|je[i+a>>0])&&92!=(0|je[i+(a+-1)>>0]);)a=a+1|0;if((0|a)==(0|n)){a=0;break r;}n=2;}else for(a=1;;){if(n>>>0<=a>>>0){n=1;break e;}if(0|He(0|Be[i+a>>0])){n=1;break e;}a=a+1|0;}}while(0);if(f=a-n|0){var o=0|qe(e,1);Pe(o,e,i+n|0,f),wr[15&ze[t>>2]](r,o,0|ze[e+112>>2]),Oe(e,1),a=a+(2==(0|n)&1)|0;}else a=2==(0|n)?3:0;}}while(0);return 0|a;},f,f,f],Fe=[function(){sr(5);},function(r,e){var i;r|=0;var a=4+(e|=0)|0,f=0;for(i=0|ze[a>>2];!((0|i)<=0);)de(r,5762,12),ze[a>>2]=i=(0|ze[a>>2])-1|0,f=1;f&&de(r,5775,7),n(0,e);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),y(r,0==(256&ze[e+16>>2]|0)?6289:6295);},n],Le=[function(){sr(6);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6371,13),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6356,14);},function(r,e){e|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6318,37),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6356,14);},function(r,e,i){var a;r|=0,e|=0;r:do{if(0|e){for(i=0|ze[e+4>>2];;){if(!i){i=0;break;}var f=i+-1|0;if(10!=(0|je[(0|ze[e>>2])+f>>0]))break;i=f;}for(a=0;;){if(i>>>0<=a>>>0)break r;if(10!=(0|je[(f=(0|ze[e>>2])+a|0)>>0]))break;a=a+1|0;}0|ze[r+4>>2]&&(he(r,10),f=(0|ze[e>>2])+a|0),de(r,f,i-a|0),he(r,10);}}while(0);},function(r,e,i){e|=0,i|=0;var a,f,n=0,t=0;if(0|ze[4+(r|=0)>>2]&&he(r,10),0|e&&0|(n=0|ze[(t=e+4|0)>>2])){for(a=0;!(n>>>0<=a>>>0)&&0|R(0|Be[(0|ze[e>>2])+a>>0]);)a=a+1|0;if((0|a)!=(0|n)){de(r,6248,3);r:do{if(128&ze[i+16>>2])for(;;){if((n=0|ze[t>>2])>>>0<=a>>>0)break r;for(f=a;!(n>>>0<=f>>>0)&&10!=(0|je[(0|ze[e>>2])+f>>0]);)f=f+1|0;if(((a=a>>>0<f>>>0?(de(r,(0|ze[e>>2])+a|0,f-a|0),0|ze[t>>2]):n)+-1|0)>>>0<=f>>>0)break r;w(r,i),a=f+1|0;}else de(r,(0|ze[e>>2])+a|0,(0|ze[t>>2])-a|0);}while(0);de(r,6252,5);}}},function(r,e){e|=0,de(r|=0,6184,5),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6190,6);},function(r,e){0|(e|=0)&&H(0|r,0|ze[e>>2],0|ze[e+4>>2]);},function(r,e,i){r|=0,0|ze[32+(i|=0)>>2]&&de(r,5352,15),0|ze[(e=i+36|0)>>2]&&(de(r,5368,9),y(r,0|ze[e>>2]),he(r,34));}],Ye=[tr,function(r,e,i,a){r|=0,e|=0,i|=0;var f=4+(a|=0)|0,n=0|ze[f>>2],t=a+8|0;n?t=0|ze[t>>2]:(n=i+-1|0,de(r,5921,18),t=ze[t>>2]=n,n=0|ze[f>>2]),t=i-t|0;r:do{if((0|n)<(0|t))for(;;){if((0|t)<=(0|n))break r;de(r,5940,10),ze[f>>2]=n=1+(0|ze[f>>2])|0;}else if((0|n)<=(0|t))de(r,5977,11);else{for(de(r,5951,6),n=0|ze[f>>2];!((0|n)<=(0|t));)de(r,5958,12),ze[f>>2]=n=(0|ze[f>>2])-1|0;de(r,5971,5);}}while(0);de(r,5989,10),0|(n=0|ze[a+12>>2])&&y(r,n),de(r,6e3,4),ze[a>>2]=1+(f=0|ze[a>>2]),l(r,f),de(r,6005,2),0|e&&H(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6008,5);},function(r,e,i,a){e|=0,i|=0;var f,n,t=0,o=0,l=0,c=0;if(0|ze[4+(r|=0)>>2]&&he(r,10),0!=(0|i)&&0!=(0|ze[(l=i+4|0)>>2])){for(de(r,6385,18),a=n=0;;){var s=0|ze[l>>2];if(s>>>0<=a>>>0)break;for(;!(s>>>0<=a>>>0);){if(!(0|R(255&(t=0|je[(o=0|ze[i>>2])+a>>0])))){c=10;break;}a=a+1|0;}if(10==(0|c)){for(c=0,f=a;!(s>>>0<=f>>>0||0|R(0|Be[o+f>>0]));)f=f+1|0;t=a+(46==t<<24>>24&1)|0,H(r,(a=n?(he(r,32),0|ze[i>>2]):o)+t|0,f-t|0),a=f;}n=n+1|0,a=a+1|0;}de(r,6005,2);}else de(r,6404,11);0|e&&H(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6416,14);},function(r,e,i,a){e|=0,i|=0,a|=0,0|ze[4+(r|=0)>>2]&&he(r,10);var f=0==(64&ze[a+16>>2]|0);de(r,6302,2),l(r,i),f?de(r,6168,1):(de(r,6305,5),0|(f=0|ze[a+12>>2])&&y(r,f),de(r,6e3,4),ze[a>>2]=1+(f=0|ze[a>>2]),l(r,f),de(r,6005,2)),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6311,3),l(r,i),de(r,6315,2);},function(r,e,i){e|=0,i|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,(i=0!=(1&i|0))?6263:6269,5),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,i?6275:6282,6);},function(r,e,i,a){if(e|=0,de(r|=0,6258,4),0|e){var f=0|ze[e>>2];for(i=0|ze[e+4>>2];;){if(!i){i=0;break;}if(10!=(0|je[f+(a=i+-1|0)>>0]))break;i=a;}de(r,f,i);}de(r,5951,6);},function(r,e,i){e|=0,i|=0,0|ze[4+(r|=0)>>2]&&he(r,10),de(r,6197,15),0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,6213,16),0|i&&de(r,0|ze[i>>2],0|ze[i+4>>2]),de(r,6230,17);},tr],yr=[function(){sr(8);},function(r,e,i,a,f){switch(r|=0,e|=0,f|=0,(a=0!=(4&(i|=0)|0))?de(r,6098,3):de(r,6102,3),1<(0|f)&&(de(r,6106,10),l(r,f),de(r,6117,2)),3&i){case 3:de(r,6120,16);break;case 1:de(r,6137,14);break;case 2:de(r,6152,15);break;default:de(r,6168,1);}0|e&&de(r,0|ze[e>>2],0|ze[e+4>>2]),de(r,a?6170:6177,6);}];return{___muldi3:X,___udivdi3:rr,_bitshift64Lshr:er,_bitshift64Shl:ir,_default_renderer:function(r,e,i,a,f,n){return r|=0,e|=0,i|=0,a|=0,f|=0,n|=0,0|ze[2284]||(ze[2284]=1,ze[2092]=0|t(8528,805,0),ze[2093]=0|t(8680,805,1),ze[2094]=8528,ze[2095]=8680),0|o(r,e,i,a,f,0,n);},_emscripten_get_sbrk_ptr:function(){return 9184;},_free:Me,_i64Add:$,_i64Subtract:Q,_llvm_ctpop_i32:ar,_malloc:L,_memcpy:fr,_memmove:Ne,_memset:nr,_wiki_renderer:function(r,e,i,a,f,n){return r|=0,e|=0,i|=0,a|=0,f|=0,n|=0,0|ze[2285]||(ze[2285]=1,ze[2096]=0|t(8832,1825,0),ze[2097]=0|t(8984,1825,1),ze[2098]=8832,ze[2099]=8984),0|o(r,e,i,a,f,1,n);},dynCall_iii:function(r,e,i){return 0|hr[1&(0|r)](0|e,0|i);},dynCall_iiii:function(r,e,i,a){return 0|wr[15&(0|r)](0|e,0|i,0|a);},dynCall_iiiii:function(r,e,i,a,f){return 0|mr[1&(0|r)](0|e,0|i,0|a,0|f);},dynCall_iiiiii:function(r,e,i,a,f,n){return 0|_r[3&(0|r)](0|e,0|i,0|a,0|f,0|n);},dynCall_iiiiiii:function(r,e,i,a,f,n,t){return 0|pr[15&(0|r)](0|e,0|i,0|a,0|f,0|n,0|t);},dynCall_vii:function(r,e,i){Fe[3&(0|r)](0|e,0|i);},dynCall_viii:function(r,e,i,a){Le[7&(0|r)](0|e,0|i,0|a);},dynCall_viiii:function(r,e,i,a,f){Ye[7&(0|r)](0|e,0|i,0|a,0|f);},dynCall_viiiii:function(r,e,i,a,f,n){yr[1&(0|r)](0|e,0|i,0|a,0|f,0|n);},establishStackSpace:function(r){De=0|r;},stackAlloc:function(r){var e=De;return De=15+(De=De+(0|r)|0)&-16,0|e;},stackRestore:function(r){De=0|r;},stackSave:function(){return 0|De;}};}({Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array},{a:function(r){throw o(r),snudown_es_c(r),h=!0,"abort("+r+"). Build with -s ASSERTIONS=1 for more info.";},b:function(r){snudown_es_d=r;},c:function(){return snudown_es_d;},d:function(){return u.length;},e:function(r,e,i){snudown_es_b.set(snudown_es_b.subarray(e,e+i),r);},f:function(){return!1;},g:function(r){return r;},h:snudown_es_i,i:snudown_es_a,j:function(){var r=snudown_es_a();return n.extraStackTrace&&(r+="\n"+n.extraStackTrace()),snudown_es_i(r);},k:9360},s);n.___muldi3=snudown_es_y.___muldi3,n.___udivdi3=snudown_es_y.___udivdi3,n._bitshift64Lshr=snudown_es_y._bitshift64Lshr,n._bitshift64Shl=snudown_es_y._bitshift64Shl;var snudown_es_g=n._default_renderer=snudown_es_y._default_renderer;n._emscripten_get_sbrk_ptr=snudown_es_y._emscripten_get_sbrk_ptr;var A=n._free=snudown_es_y._free;n._i64Add=snudown_es_y._i64Add,n._i64Subtract=snudown_es_y._i64Subtract,n._llvm_ctpop_i32=snudown_es_y._llvm_ctpop_i32,n._malloc=snudown_es_y._malloc,n._memcpy=snudown_es_y._memcpy,n._memmove=snudown_es_y._memmove,n._memset=snudown_es_y._memset;var C=n._wiki_renderer=snudown_es_y._wiki_renderer;n.establishStackSpace=snudown_es_y.establishStackSpace;var S,snudown_es_x=n.stackAlloc=snudown_es_y.stackAlloc,E=n.stackRestore=snudown_es_y.stackRestore,I=n.stackSave=snudown_es_y.stackSave;n.dynCall_iii=snudown_es_y.dynCall_iii,n.dynCall_iiii=snudown_es_y.dynCall_iiii,n.dynCall_iiiii=snudown_es_y.dynCall_iiiii,n.dynCall_iiiiii=snudown_es_y.dynCall_iiiiii,n.dynCall_iiiiiii=snudown_es_y.dynCall_iiiiiii,n.dynCall_vii=snudown_es_y.dynCall_vii,n.dynCall_viii=snudown_es_y.dynCall_viii,n.dynCall_viiii=snudown_es_y.dynCall_viiii,n.dynCall_viiiii=snudown_es_y.dynCall_viiiii,n.asm=snudown_es_y,snudown_es_t&&function(r){var e,i=r.length;for(e=0;e<i;++e)snudown_es_b[8+e]=r.charCodeAt(e);}(snudown_es_t),(n.run=function(){snudown_es_e(w),S||(S=!0,h||(snudown_es_e(m),snudown_es_e(_),snudown_es_e(p)));})();function snudown_es_markdown(r,e){return f(snudown_es_g,r,e);}function markdownWiki(r,e){return f(C,r,e);}
// CONCATENATED MODULE: ./lib/modules/hosts/github.js




/* harmony default export */ var github = (new Host('github', {
  domains: ['gist.github.com'],
  logo: 'https://assets-cdn.github.com/favicon.ico',
  name: 'github gists',
  detect: ({
    pathname
  }) => /^\/(?:[\w-]+\/)?([a-z0-9]{20,}|\d+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      files,
      description
    } = await ajax({
      url: `https://api.github.com/gists/${id}`,
      type: 'json',
      cacheFor: DAY
    });
    let src = '';

    for (const [filename, {
      content,
      language,
      truncated
    }] of Object.entries(files)) {
      src += string_namespaceObject.escape`<h5>${filename}:</h5>`;

      if (language === 'Markdown') {
        src += snudown_es_markdown(content);
      } else {
        src += string_namespaceObject.escape`<pre><code>${content}</code></pre>`;
      }

      if (truncated) {
        src += '<p>&lt;file truncated&gt;</p>';
      }
    }

    return {
      type: 'TEXT',
      title: description,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/googlemaps.js

/* harmony default export */ var googlemaps = (new Host('googlemaps', {
  domains: ['maps.google.ca', 'maps.google.com', 'google.co.uk', 'google.com', 'google.ca'],
  logo: 'https://maps.google.com/favicon.ico',
  name: 'Google Maps',
  detect: ({
    host,
    searchParams,
    pathname
  }) => {
    if (host.startsWith('maps.') || pathname.startsWith('/maps')) {
      const coords = searchParams.get('ll') || searchParams.get('q');

      if (coords) {
        return [coords, searchParams.get('z'), searchParams.has('maptype') ? searchParams.get('maptype') : 'roadmap'];
      } else {
        const location = pathname.split('/').find(part => part.startsWith('@'));

        if (location) {
          const [long, lat, zoom] = location.substring(1).split(',');
          return [`${long},${lat}`, zoom.endsWith('z') ? zoom : 16, zoom.endsWith('z') ? 'roadmap' : 'satellite'];
        }
      }
    }
  },

  handleLink(href, [coords, zoom, mapType]) {
    let embed = `https://www.google.com/maps/embed/v1/view?center=${coords}&key=AIzaSyCtnLZP1XwkgIK53Asx_5qtZa2k9eZcdDc`;
    if (zoom) embed += `&zoom=${zoom}`;
    if (mapType) embed += `&maptype=${mapType}`;
    return {
      type: 'IFRAME',
      embed,
      muted: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gyazo.js


/* harmony default export */ var gyazo = (new Host('gyazo', {
  name: 'gyazo',
  domains: ['gyazo.com'],
  permissions: ['https://api.gyazo.com/api/oembed'],
  logo: 'https://gyazo.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w{32})\b/i.exec(pathname),

  async handleLink(href, [, id]) {
    const info = await ajax({
      url: 'https://api.gyazo.com/api/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
        return {
          type: 'IMAGE',
          src: info.url
        };

      case 'video':
        return {
          type: 'VIDEO',
          muted: true,
          loop: true,
          fallback: `https://i.gyazo.com/${id}.gif`,
          sources: [{
            source: `https://i.gyazo.com/${id}.mp4`,
            type: 'video/mp4'
          }]
        };

      default:
        throw new Error(`Invalid media type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/hastebin.js

/* harmony default export */ var hastebin = (new Host('hastebin', {
  name: 'hastebin',
  domains: ['hastebin.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:raw\/)?([^\/]+)/i.exec(pathname),

  handleLink(href, [, filename]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://hastebin.com/${filename}`,
      height: '500px',
      width: '800px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/iloopit.js

/* harmony default export */ var iloopit = (new Host('iloopit', {
  name: 'iLoopit - gif maker',
  domains: ['iloopit.net'],
  logo: 'https://iloopit.net/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(\w+\.)?iloopit\.net\/.+?\/\?type=looplayer&loopid=(\d+)/i.exec(href) || /^https?:\/\/(\w+\.)?iloopit\.net(\/tube)?\/(\d+)\/.+?\/(\?type=(looplayer)|(embed))?/i.exec(href),

  handleLink(href) {
    let link = '';
    const testWithTitle = /iloopit\.net(?:\/tube)?\/(\d+)\/(.+)?\//;
    const titleResult = testWithTitle.exec(href);

    if (titleResult) {
      link = `https://iloopit.net/${titleResult[1]}/${titleResult[2]}/?type=embed`;
    } else {
      link = href.replace('type=looplayer', 'type=embed');
    }

    return {
      type: 'IFRAME',
      muted: true,
      embed: link,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgflip.js

/* harmony default export */ var imgflip = (new Host('imgflip', {
  name: 'imgflip',
  domains: ['imgflip.com'],
  logo: 'https://imgflip.com/favicon02.png',
  detect: ({
    pathname
  }) => /^\/(i|gif)\/([a-z0-9]+)/.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IMAGE',
      src: `https://i.imgflip.com/${id}.${type === 'gif' ? 'gif' : 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgur.js



/* harmony default export */ var imgur = (new Host('imgur', {
  name: 'imgur',
  domains: ['imgur.com'],
  logo: 'https://i.imgur.com/favicon.ico',
  options: {
    preferResAlbums: {
      title: 'imgurPreferResAlbumsTitle',
      description: 'imgurPreferResAlbumsDesc',
      value: true,
      type: 'boolean'
    },
    useGifOverGifv: {
      title: 'imgurUseGifOverGifVTitle',
      description: 'imgurUseGifOverGifVDesc',
      value: false,
      type: 'boolean'
    },
    preferredImgurLink: {
      title: 'imgurPreferredImgurLinkTitle',
      description: 'imgurPreferredImgurLinkDesc',
      type: 'enum',
      value: 'share',
      values: [{
        name: 'full page (imgur.com)',
        value: 'share'
      }, {
        name: 'direct image (i.imgur.com)',
        value: 'direct'
      }]
    },
    imgurImageResolution: {
      title: 'imgurImageResolutionTitle',
      description: 'imgurImageResolutionDesc',
      type: 'enum',
      value: '',
      values: [{
        name: 'Full Resolution',
        value: ''
      }, {
        name: 'Retina (1360px)',
        value: 'r'
      }, {
        name: 'Huge (1024px)',
        value: 'h'
      }, {
        name: 'Giant (680px)',
        value: 'g'
      }, {
        name: 'Large (640px)',
        value: 'l'
      }]
    }
  },

  detect({
    pathname,
    href
  }) {
    const hashRe = /^https?:\/\/(?:i\.|m\.|edge\.|www\.)*imgur\.com\/(r\/\w+\/)*(?!gallery)(?!removalrequest)(?!random)(?!memegen)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gifv?|png))?(\?.*)?$/i;
    const hostedHashRe = /^https?:(\/\/i\.\w+\.*imgur\.com\/)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gif|png))?(\?.*)?$/i;
    const galleryHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/gallery\/(\w+)(?:[/#]|$)/i;
    const albumHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/a\/(\w+)(?:[/#]|$)/i;
    if (pathname === '/rules' || pathname === '/inbox') return null;
    href = href.split('?')[0];
    let groups;

    if (groups = galleryHashRe.exec(href)) {
      const hash = groups[1];
      return () => _api(string_namespaceObject.encode`gallery/${hash}`).catch(() => _api(string_namespaceObject.encode`album/${hash}`));
    } else if (groups = albumHashRe.exec(href)) {
      if (this.options.preferResAlbums.value) {
        const hash = groups[1];
        return () => _api(string_namespaceObject.encode`album/${hash}`);
      }
    } else if (groups = hostedHashRe.exec(href)) {
      const hash = groups[2];
      return () => _handleImage(hash, href);
    } else if (groups = hashRe.exec(href)) {
      const [, subreddit, hash] = groups;
      if (subreddit) return () => _api(string_namespaceObject.encode`gallery/${subreddit}${hash}`);

      if (hash.search(/[&,]/) > -1) {
        return () => _handleImageCollection(hash.split(/[&,]/), href);
      } else {
        return () => _handleImage(hash, href);
      }
    }

    return false;

    async function _api(endpoint) {
      const {
        data
      } = await ajax({
        url: 'https://api.imgur.com/3/' + endpoint,
        type: 'json',
        headers: {
          Authorization: `Client-ID ${'1d8d9b36339e0e2'}`
        }
      });

      if (data.error) {
        throw new Error(`Imgur API error: ${data.error}`);
      }

      return data;
    }

    function _mockImageAPI(hash, url) {
      let thisCdnUrl = 'https://i.imgur.com/';
      let matches, extension;

      if (matches = hostedHashRe.exec(url)) {
        thisCdnUrl = matches[1];
        extension = matches[3];
      } else if (matches = hashRe.exec(url)) {
        extension = matches[3];
      }

      if (!extension) {
        extension = '.jpg';
      }

      return {
        id: hash,
        animated: false,
        looping: false,
        has_sound: false,
        link: `${thisCdnUrl}${hash}${extension}`,
        gifv: undefined,
        title: '',
        description: ''
      };
    }

    function _handleImage(hash, url) {
      const [,,, extension] = hashRe.exec(url) || [];

      if (['.png', '.jpg', '.jpeg'].includes(extension)) {
        return _mockImageAPI(hash, url);
      } else if (hostedHashRe.test(url)) {
        return _mockImageAPI(hash, url);
      } else {
        return _api(`image/${hash}`);
      }
    }

    function _handleImageCollection(hashes, url) {
      return {
        is_album: true,
        images: hashes.map(hash => _mockImageAPI(hash, url)),
        title: '',
        description: ''
      };
    }
  },

  async handleLink(href, getInfo) {
    const baseUrl = 'https://imgur.com/';
    const shareLinkPreferred = this.options.preferredImgurLink.value === 'share';
    const resolutionSuffix = this.options.imgurImageResolution.value;
    const useGif = this.options.useGifOverGifv.value;
    const info = await getInfo();

    if (info.images && info.images.length) {
      return _handleAlbum(href, info);
    } else if (info.gifv && !useGif) {
      return _handleGifv(info);
    } else if (info.link) {
      return _handleSingleImage(info);
    }

    throw new Error('could not handle info');

    function _handleAlbum(href, info) {
      return {
        type: 'GALLERY',
        title: info.title,
        caption: info.description,
        src: info.images.map(info => {
          const media = info.gifv && !useGif ? _handleGifv(info) : _handleSingleImage(info);
          media.href = shareLinkPreferred ? `${href.split('#')[0]}#${info.id}` : `${info.link}`;
          return media;
        })
      };
    }

    function _handleSingleImage(info) {
      const src = info.link.replace('http:', 'https:').replace(`/${info.id}.`, `/${info.id}${resolutionSuffix}.`);
      return {
        src,
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        type: 'IMAGE',
        caption: info.description,
        title: info.title
      };
    }

    function _handleGifv(info) {
      return {
        type: 'VIDEO',
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        fallback: info.link.replace('http:', 'https:'),
        caption: info.description,
        title: info.title,
        loop: info.looping !== false,
        muted: !info.has_sound,
        sources: [{
          source: info.mp4.replace('http:', 'https:'),
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/instagram.js

/* harmony default export */ var instagram = (new Host('instagram', {
  name: 'Instagram',
  domains: ['instagram.com', 'instagr.am'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/p\/([a-z0-9_\-]{10,})(?:\/|$)/i.exec(pathname),
  handleLink: (href, [, id]) => ({
    type: 'IFRAME',
    expandoClass: 'image',
    embed: `https://instagram.com/p/${id}/embed/captioned/`,
    width: '600px',
    height: '700px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/ireddit.js


/* harmony default export */ var ireddit = (new Host('ireddit', {
  name: 'i.redd.it',
  domains: ['i.redd.it'],
  attribution: false,

  detect({
    pathname
  }, thing) {
    return pathname.endsWith('.gif') && thing && thing.isLinkPost() && thing.getFullname();
  },

  async handleLink(href, fullname) {
    const postMetadata = await getPostMetadata({
      id: fullname.replace('t3_', '')
    });
    if (!postMetadata.preview) throw new Error('Post has no preview.');
    const preview = postMetadata.preview.images[0];

    if (preview.variants.mp4) {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        fallback: preview.variants.gif && preview.variants.gif.source.url,
        sources: [{
          source: preview.variants.mp4.source.url,
          type: 'video/mp4'
        }]
      };
    } else {
      return {
        type: 'IMAGE',
        src: preview.source.url
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/jsfiddle.js

/* harmony default export */ var jsfiddle = (new Host('jsfiddle', {
  name: 'jsfiddle',
  domains: ['jsfiddle.net'],
  logo: 'https://jsfiddle.net/favicon.png',
  detect: ({
    pathname
  }) => /^(\/(?:\w+\/(?!embedded\/))?[a-z0-9]{5,}(?:\/\d+)?(?=\/|$))(\/embedded\/[\w,]+\/)?/i.exec(pathname),

  handleLink(href, [, path, categories]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://jsfiddle.net${path}${categories || '/embedded/result,js,resources,html,css/'}`,
      width: '800px',
      height: '500px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/liveleak.js

/* harmony default export */ var liveleak = (new Host('liveleak', {
  name: 'LiveLeak',
  domains: ['liveleak.com'],
  logo: 'https://www.liveleak.com/favicon.ico',
  detect: ({
    pathname,
    search
  }) => pathname === '/view' && search,
  handleLink: (href, query) => ({
    type: 'IFRAME',
    embed: `https://www.liveleak.com/ll_embed${query}`,
    embedAutoplay: `https://www.liveleak.com/ll_embed${query}&autostart=true`,
    fixedRatio: true
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/livememe.js

/* harmony default export */ var livememe = (new Host('livememe', {
  name: 'livememe',
  domains: ['livememe.com'],
  logo: 'https://livememe.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?!edit)(\w{7})(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://e.lvme.me/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/makeameme.js

/* harmony default export */ var makeameme = (new Host('makeameme', {
  name: 'makeameme',
  domains: ['makeameme.org'],
  logo: 'https://makeameme.org/images/favicons/favicon-32x32.png',
  detect: ({
    pathname
  }) => /^\/meme\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://makeameme.org/media/created/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memecrunch.js

/* harmony default export */ var memecrunch = (new Host('memecrunch', {
  name: 'memecrunch',
  domains: ['memecrunch.com'],
  logo: 'https://memecrunch.com/static/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9A-Z]+)\/([\w\-]+)(\/image\.(png|jpg))?/i.exec(pathname),

  handleLink(href, [, id, format]) {
    return {
      type: 'IMAGE',
      src: `https://memecrunch.com/meme/${id}/${format || 'null'}/image.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memedad.js

/* harmony default export */ var memedad = (new Host('memedad', {
  name: 'memedad',
  domains: ['memedad.com'],
  logo: 'https://memedad.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://memedad.com/memes/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/mixer.js

/* harmony default export */ var mixer = (new Host('mixer', {
  name: 'Mixer',
  domains: ['beam.pro', 'mixer.com'],
  logo: 'https://mixer.com/_latest/assets/favicons/favicon-32x32.png',
  detect: ({
    pathname
  }) => /^\/(\w+)$/.exec(pathname),

  handleLink(href, [, clipId]) {
    return {
      type: 'IFRAME',
      muted: true,
      embed: `https://mixer.com/embed/player/${clipId}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/onedrive.js



/* harmony default export */ var onedrive = (new Host('onedrive', {
  domains: ['onedrive.live.com', '1drv.ms'],
  name: 'Microsoft OneDrive',
  detect: () => true,

  async handleLink(href) {
    const encodedUrl = `u!${btoa(href)}`.replace(/=+$/g, '').replace(/\//g, '_').replace(/\+/g, '-');
    const json = await ajax({
      url: `https://api.onedrive.com/v1.0/shares/${encodedUrl}/root?expand=children`,
      type: 'json',
      cacheFor: DAY
    });

    if (json.children.length) {
      return {
        type: 'GALLERY',
        src: json.children.map(processFile)
      };
    } else {
      return processFile(json);
    }

    function processFile({
      name,
      description,
      webUrl,
      '@content.downloadUrl': src,
      file: {
        mimeType
      }
    }) {
      const type = mimeType.slice(0, mimeType.indexOf('/'));

      switch (type) {
        case 'image':
          return {
            type: 'IMAGE',
            title: name,
            caption: description,
            src,
            href: webUrl
          };

        case 'video':
          return {
            type: 'VIDEO',
            title: name,
            caption: description,
            loop: false,
            sources: [{
              source: src,
              type: mimeType
            }]
          };

        case 'audio':
          return {
            type: 'AUDIO',
            loop: false,
            sources: [{
              file: src,
              type: mimeType
            }]
          };

        default:
          throw new Error(`Invalid type: ${type}`);
      }
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pastebin.js

/* harmony default export */ var pastebin = (new Host('pastebin', {
  name: 'pastebin',
  domains: ['pastebin.com'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?pastebin\.com\/(?:raw\.php\?i=|index\/)?([a-z0-9]{8})/i.exec(href),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://pastebin.com/embed_iframe.php?i=${id}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/peertube.js

/* harmony default export */ var peertube = (new Host('peertube', {
  name: 'peertube',
  domains: ['peervideo.net', 'peertube.social', 'peertube.mastodon.host', 'evertron.tv', 'mplayer.demouliere.eu', 'cloud.allplayer.tk', 'video.tedomum.net', 'peertube.fr', 'hostyour.tv', 'videobit.cc', 'videoshare.cc', 'peertube.openstreetmap.fr', 'video.ploud.fr', 'tube.kdy.ch', 'lostpod.space', 'pe.ertu.be', 'peertube.live', 'peer.tube', 'watching.cypherpunk.observer', 'queertube.org', 'exode.me', 'framatube.org', 'peervideo.net'],
  attribution: false,
  detect: ({
    hostname,
    pathname
  }) => {
    const [, route,, id] = pathname.split('/');

    if (route === 'videos') {
      return [hostname, id];
    }
  },

  handleLink(href, [hostname, id]) {
    const embed = `https://${hostname}/videos/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/photobucket.js


/* harmony default export */ var photobucket = (new Host('photobucket', {
  name: 'photobucket',
  domains: ['photobucket.com'],
  logo: 'https://pic2.pbsrc.com/common/favicon.ico',
  detect: ({
    href
  }) => /([is]?)[0-9]+|media|smg|img(?=.photobucket.com)/i.exec(href),

  async handleLink(href, [, prefix]) {
    let src = href.replace('.html', '');

    if (prefix !== 'i') {
      const {
        imageUrl
      } = await ajax({
        url: 'https://api.photobucket.com/v2/media/fromurl',
        query: {
          url: src
        },
        type: 'json'
      });
      src = imageUrl.replace('http:', 'https:');
    }

    return {
      type: 'IMAGE',
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pixiv.js

/* harmony default export */ var pixiv = (new Host('pixiv', {
  name: 'pixiv',
  domains: ['pixiv.net'],
  logo: 'https://www.pixiv.net/favicon.ico',
  detect: ({
    pathname,
    search
  }) => pathname === '/member_illust.php' && /illust_id=(\d+)/.exec(search) || /(?:\/en|^)\/artworks\/(\d+)\/?$/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'image',
      muted: true,
      embed: `https://embed.pixiv.net/embed_mk2.php?id=${id}&size=large`,
      width: '700px',
      height: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/poly.js

/* harmony default export */ var poly = (new Host('poly', {
  name: 'Poly',
  domains: ['poly.google.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/view\/([a-zA-Z0-9-]+)\/?$/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://poly.google.com/view/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pornhub.js

/* harmony default export */ var pornhub = (new Host('pornhub', {
  name: 'Pornhub',
  domains: ['www.pornhub.com', 'www.pornhubpremium.com'],
  attribution: false,
  detect: ({
    searchParams
  }) => searchParams.get('viewkey'),

  handleLink(href, path) {
    const url = `https://www.pornhub.com/embed/${path}`;
    return {
      type: 'IFRAME',
      embed: url,
      embedAutoplay: `${url}?autoplay=1`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ppy.js

/* harmony default export */ var ppy = (new Host('ppy.sh', {
  name: 'ppy.sh',
  domains: ['osu.ppy.sh'],
  logo: 'https://s.ppy.sh/favicon.ico',
  detect: ({
    pathname
  }) => /^\/ss\/(\d+(?:\/[0-9a-f]+)?)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://osu.ppy.sh/ss/${code}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditbooru.js


/* harmony default export */ var redditbooru = (new Host('redditbooru', {
  name: 'redditbooru',
  domains: ['redditbooru.com'],
  logo: 'https://redditbooru.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/gallery\/([\w]+)(\/[\w\-]+)?/i.exec(pathname),

  async handleLink(href, [, id, base36]) {
    if (base36) {
      id = parseInt(id, 36);
    }

    const info = await ajax({
      url: 'https://redditbooru.com/images/',
      query: {
        postId: id
      },
      type: 'json'
    });

    if (!info.length) {
      throw new Error('Gallery was empty.');
    }

    const src = info.map(({
      caption,
      cdnUrl,
      sourceUrl
    }) => ({
      type: 'IMAGE',
      title: caption,
      src: cdnUrl,
      caption: sourceUrl ? `Source: <a href="${sourceUrl}">${sourceUrl}</a>` : ''
    }));
    return {
      type: 'GALLERY',
      title: info[0].title,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditmedia.js

/* harmony default export */ var redditmedia = (new Host('redditmedia', {
  name: 'redditmedia',
  domains: ['redditmedia.com'],
  attribution: false,
  detect: ({
    hostname,
    searchParams
  }) => hostname !== 'pixel.redditmedia.com' && searchParams,

  handleLink(href, searchParams) {
    if (searchParams.get('fm') === 'mp4') {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: href,
          type: 'video/mp4'
        }]
      };
    }

    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/reddituploads.js

/* harmony default export */ var reddituploads = (new Host('reddituploads', {
  name: 'reddituploads',
  domains: ['reddituploads.com'],
  attribution: false,
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redgifs.js



/* harmony default export */ var redgifs = (new Host('redgifs', {
  name: 'redgifs',
  domains: ['redgifs.com'],
  logo: 'https://redgifs.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:(?:ifr|watch)\/)(\w+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const info = (await ajax({
      url: string_namespaceObject.encode`https://api.redgifs.com/v1/gfycats/${id}`,
      type: 'json',
      cacheFor: DAY
    })).gfyItem;
    return {
      type: 'VIDEO',
      frameRate: info.frameRate,
      loop: true,
      muted: !info.hasAudio,
      playbackRate: +(href.match(/[?|&]speed=([\d\.]+)/i) || [undefined, 1])[1],
      poster: info.posterUrl,
      sources: [{
        source: info.webmUrl,
        type: 'video/webm'
      }, {
        source: info.mp4Url,
        type: 'video/mp4'
      }],
      time: +(href.match(/[?|&]frameNum=([\d]+)/i) || [undefined, 0])[1] / info.frameRate
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ridewithgps.js

/* harmony default export */ var ridewithgps = (new Host('ridewithgps', {
  name: 'ridewithgps',
  domains: ['ridewithgps.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(trips|routes)\/(\d+)/i.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IFRAME',
      embed: `https://ridewithgps.com/${type}/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/simplecove.js


/* harmony default export */ var simplecove = (new Host('simplecove', {
  name: 'SimpleCove',
  domains: ['simplecove.com'],
  logo: 'https://simplecove.com/static/images/reslogo.jpg',
  detect: ({
    pathname
  }) => /^\/(\d+)/i.exec(pathname),

  async handleLink(elem, [, id]) {
    const data = await ajax({
      url: `https://www.simplecove.com/resapi/${id}`,
      type: 'json'
    });
    const images = data.map(x => ({
      src: x.photo_src.replace('http:', 'https:'),
      caption: x.photo_caption,
      type: 'IMAGE'
    }));
    return {
      type: 'GALLERY',
      src: images
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/snag.js

/* harmony default export */ var snag = (new Host('snag', {
  name: 'snag.gy',
  logo: 'https://snaggys3static-snaggy.netdna-ssl.com/favicon.png',
  domains: ['snag.gy'],
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\.(\w+))?$/i.exec(pathname),

  handleLink(href, [, id, extension]) {
    return {
      type: 'IMAGE',
      src: `https://i.snag.gy/${id}.${extension || 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/soundcloud.js


/* harmony default export */ var soundcloud = (new Host('soundcloud', {
  name: 'soundcloud',
  domains: ['soundcloud.com'],
  logo: 'https://a-v2.sndcdn.com/assets/images/sc-icons/favicon-2cadd14b.ico',
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IFRAME',
      embed: string_namespaceObject.encode`https://w.soundcloud.com/player/?url=${href}`,
      height: '166px',
      width: '700px',
      pause: '{"method":"pause"}',
      play: '{"method":"play"}'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/spotify.js

/* harmony default export */ var spotify = (new Host('spotify', {
  name: 'spotify',
  domains: ['spotify.com'],
  logo: 'https://spotify.com/favicon.ico',
  detect: ({
    href
  }) => /^https:\/\/(?:open|play)\.spotify\.com\/((?:track|artist|album|user\/\w+\/playlist)\/[a-zA-z0-9]+)$/i.exec(href),

  handleLink(href, [, uri]) {
    return {
      type: 'IFRAME',
      embed: `https://embed.spotify.com/?uri=spotify:${uri.replace(/\//g, ':')}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steamcommunity.js


/* harmony default export */ var steamcommunity = (new Host('steamcommunity', {
  name: 'Steam Community',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steamcommunity.com'],
  detect: ({
    pathname,
    searchParams
  }) => pathname.startsWith('/sharedfiles/filedetails') && searchParams.get('id'),
  permissions: ['https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/*'],

  async handleLink(href, id) {
    const {
      response: {
        publishedfiledetails: [{
          title,
          description: caption,
          preview_url: previewUrl,
          file_url: fileUrl,
          filename
        }]
      }
    } = await ajax({
      method: 'POST',
      url: 'https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v0001/?format=json',
      data: {
        itemcount: '1',
        'publishedfileids[0]': id
      },
      type: 'json'
    });
    if (!filename) throw new Error('Response missing filename. (Private Steam Community profile?)');
    return {
      type: 'IMAGE',
      title,
      caption,
      src: ['.png', '.jpg', '.gif'].some(ext => filename.endsWith(ext)) ? fileUrl : previewUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steampowered.js

/* harmony default export */ var steampowered = (new Host('steampowered', {
  name: 'Steam',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steampowered.com', 'steamusercontent.com'],
  detect: ({
    pathname
  }) => /^\/ugc\/(\d{15,20}\/\w{40})(?:$|\/)/i.exec(pathname),

  handleLink(href, [pathname]) {
    return {
      type: 'IMAGE',
      src: `http://images.akamai.steamusercontent.com${pathname}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollcom.js

/* harmony default export */ var strawpollcom = (new Host('strawpoll.com', {
  name: 'strawpoll.com',
  domains: ['strawpoll.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed\/)?([a-z0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.strawpoll.com/embed/${id}`,
      height: '450px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollme.js

/* harmony default export */ var strawpollme = (new Host('strawpoll', {
  name: 'strawpoll.me',
  domains: ['strawpoll.me'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed_\d\/)?(\d+)/i.exec(pathname),

  handleLink(href, [, uid]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.strawpoll.me/embed_1/${uid}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamable.js


/* harmony default export */ var streamable = (new Host('streamable', {
  name: 'streamable',
  domains: ['streamable.com'],
  logo: 'https://cdn-e2.streamable.com/static/14a98f7cb1ddc5213329c039dc39cac543ba410f/img/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:[es]\/)?(\w+)(?:\/\w+)?$/i.exec(pathname),

  async handleLink(href, [, hash]) {
    const {
      title,
      files: {
        mp4: {
          url
        }
      },
      thumbnail_url: thumbnail,
      source
    } = await ajax({
      url: `https://api.streamable.com/videos/${hash}`,
      type: 'json'
    });
    return {
      type: 'VIDEO',
      title,
      loop: true,
      sources: [{
        source: url,
        type: 'video/mp4'
      }],
      poster: thumbnail,
      source
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamja.js

/* harmony default export */ var streamja = (new Host('streamja', {
  name: 'streamja',
  domains: ['streamja.com'],
  logo: 'https://streamja.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([^\/]+)$/i.exec(pathname),

  handleLink(href, [, code]) {
    const short = code.substring(0, 2).toLowerCase();
    return {
      type: 'VIDEO',
      loop: true,
      sources: [{
        source: `https://upload.streamja.com/mp4/${short}/${code}.mp4`,
        type: 'video/mp4'
      }],
      poster: `https://upload.streamja.com/i/${short}/${code}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamvi.js

/* harmony default export */ var streamvi = (new Host('streamvi', {
  name: 'streamvi',
  domains: ['streamvi.com'],
  logo: 'https://streamvi.com/assets/logo.png',
  detect: ({
    searchParams
  }) => {
    const code = searchParams.get('video');
    if (code) return [code.toString()];
  },

  handleLink(href, [code]) {
    return {
      type: 'VIDEO',
      loop: true,
      sources: [{
        source: `https://cdn.streamvi.com/uploads/${code}.mp4`,
        type: 'video/mp4'
      }],
      poster: `https://cdn.streamvi.com/uploads/${code}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supgif.js

/* harmony default export */ var supgif = (new Host('supgif', {
  name: 'Supgif',
  domains: ['supgif.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/c\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://www.supgif.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supload.js



/* harmony default export */ var supload = (new Host('supload', {
  name: 'supload',
  domains: ['supload.com'],
  logo: 'https://supload.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([A-Za-z0-9_-]+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const data = await ajax({
      url: 'https://www.supload.com/oembed',
      query: {
        url: `https://supload.com/${id}`,
        format: 'json'
      },
      type: 'json',
      cacheFor: DAY
    });

    if (data.type === 'photo') {
      return {
        type: 'IMAGE',
        src: data.url
      };
    } else {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: data.webmUrl,
          type: 'video/webm'
        }, {
          source: data.mp4Url,
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tenor.js


/* harmony default export */ var tenor = (new Host('tenor', {
  name: 'tenor',
  domains: ['tenor.co'],
  logo: 'https://www.tenor.co/favicon.ico',
  detect: (() => {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const alphabetMap = alphabet.split('').reduce((obj, c, i) => {
      obj[c] = i;
      return obj;
    }, {});

    function parseViewShortId(s) {
      return s.split('').reduce((n, c) => n * alphabet.length + alphabetMap[c], 0);
    }

    return ({
      hostname,
      pathname
    }) => {
      if (hostname === 'tenor.co') {
        const pathMatch = /^\/([a-zA-Z0-9]+)\.gif$/i.exec(pathname);
        return pathMatch && {
          id: parseViewShortId(pathMatch[1])
        };
      } else if (hostname === 'media.tenor.co') {
        return {
          id: null
        };
      } else {
        const pathMatch = /^\/view\/.+\-(\d+)(\.gif)?$/i.exec(pathname);
        return pathMatch && {
          id: pathMatch[1]
        };
      }
    };
  })(),

  async handleLink(href, {
    id
  }) {
    if (id === null) {
      return {
        type: 'IMAGE',
        src: href
      };
    }

    const {
      results: [gif]
    } = await ajax({
      url: 'https://api.tenor.co/v1/gifs',
      query: {
        key: 'JJHDC7UK73EH',
        ids: id
      },
      type: 'json'
    });
    return {
      type: 'IMAGE',
      src: gif.media[0].gif.url,
      title: gif.h1_title,
      caption: gif.generatedcaption
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tumblr.js



/* harmony default export */ var tumblr = (new Host('tumblr', {
  name: 'tumblr',
  domains: ['tumblr.com'],
  permissions: ['https://api.tumblr.com/v2/blog/*/posts'],
  logo: 'https://secure.assets.tumblr.com/images/favicons/favicon.ico',

  detect({
    hostname,
    pathname
  }) {
    const pathMatch = /^\/(?:post|image)\/(\d+)(?:\/|$)/i.exec(pathname);
    return pathMatch && [hostname, pathMatch[1]];
  },

  async handleLink(href, [blog, id]) {
    const {
      response
    } = await ajax({
      url: `https://api.tumblr.com/v2/blog/${blog}/posts`,
      query: {
        api_key: 'WeJQquHCAasi5EzaN9jMtIZkYzGfESUtEvcYDeSMLICveo3XDq',
        id,
        filter: 'raw'
      },
      type: 'json'
    });
    const post = response.posts[0];

    function render(string) {
      return post.format === 'markdown' ? snudown_es_markdown(string) : string;
    }

    const defaults = {
      title: post.title,
      caption: post.caption,
      credits: `Posted by: <a href="${response.blog.url}">${response.blog.name}</a> @ Tumblr`
    };

    switch (post.type) {
      case 'photo':
        if (!post.photos.length) throw new Error('No images in gallery.');
        return {
          type: 'GALLERY',
          ...defaults,
          src: post.photos.map(photo => ({
            type: 'IMAGE',
            src: photo.original_size.url,
            caption: photo.caption
          }))
        };

      case 'text':
        return {
          type: 'TEXT',
          ...defaults,
          src: render(post.body)
        };

      case 'quote':
        return {
          type: 'TEXT',
          ...defaults,
          credits: post.source,
          src: `<blockquote><p>${render(post.text)}</p></blockquote>`
        };

      case 'link':
        return {
          type: 'TEXT',
          ...defaults,
          title: `<a href="${post.url}">${post.title}</a>`,
          src: render(post.description)
        };

      case 'chat':
        return {
          type: 'TEXT',
          ...defaults,
          src: post.dialogue.reduce((prev, {
            label,
            phrase
          }) => `${prev}<blockquote><p><b>${label}</b> ${phrase}</p></blockquote>`, '')
        };

      case 'answer':
        const asking = post.asking_url ? `<a href="${post.asking_url}">${post.asking_name}</a>` : post.asking_name;
        return {
          type: 'TEXT',
          ...defaults,
          src: `<blockquote><p>${asking} sent: ${post.question}</p></blockquote>${render(post.answer)}`
        };

      default:
        throw new Error(`Unsupported post type: ${post.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twimg.js

/* harmony default export */ var twimg = (new Host('twimg', {
  name: 'twimg',
  domains: ['pbs.twimg.com'],
  logo: 'https://twitter.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/media\/[\w\-]+\.\w+/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitch.js

/* harmony default export */ var twitch = (new Host('twitch', {
  name: 'twitch.tv',
  domains: ['twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?twitch\.tv\/(\w+)(?:\/([cbv])\/([0-9]+))?\/?(?:\?t=(?:([0-9]+)h)?(?:([0-9]+)m)?(?:([0-9]+)s)?)?$/i.exec(href),

  handleLink(href, [, channel, typeId, videoId, h, m, s]) {
    const channelOrVideo = videoId ? `video=${typeId.replace('b', 'a')}${videoId}` : `channel=${channel}`;
    const embed = `https://player.twitch.tv/?${channelOrVideo}&time=${+h || 0}h${+m || 0}m${+s || 0}s`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitchclips.js

/* harmony default export */ var twitchclips = (new Host('twitchclips', {
  name: 'twitch.tv clips',
  domains: ['twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    hostname,
    pathname
  }) => hostname === 'clips.twitch.tv' ? /^\/(\w+(?:\/[A-Z]\w+)?)(?:\/|$)/.exec(pathname) : /^\/\w+\/clip\/(\w+(?:\/[A-Z]\w+)?)(?:\/|$)/.exec(pathname),

  handleLink(href, [, clipId]) {
    const embed = `https://clips.twitch.tv/embed?clip=${clipId}`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitter.js




/* harmony default export */ var twitter = (new Host('twitter', {
  name: 'twitter',
  domains: ['twitter.com'],
  permissions: ['https://api.twitter.com/1/statuses/oembed.json'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:mobile\.)?twitter\.com\/(?:#!\/)?[\w]+\/status(?:es)?\/([\d]+)/i.exec(href),

  async handleLink(href, [, id]) {
    const {
      html
    } = await ajax({
      url: 'https://api.twitter.com/1/statuses/oembed.json',
      query: {
        id,
        omit_script: false
      },
      type: 'json'
    });
    const $dummy = jquery_default()('<div>');
    return {
      type: 'GENERIC_EXPANDO',
      muted: true,
      expandoClass: 'selftext',
      generate: () => $dummy[0],
      onAttach: lodash_once_default()(() => {
        $dummy.replaceWith(html);
      })
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vidble.js



/* harmony default export */ var vidble = (new Host('vidble', {
  name: 'vidble',
  domains: ['vidble.com'],
  logo: 'https://vidble.com/assets/ico/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(show|album)\/([a-z0-9]+)/i.exec(pathname),

  async handleLink(href, [, type, hash]) {
    switch (type) {
      case 'show':
        return {
          type: 'IMAGE',
          src: `https://vidble.com/${hash}_med.jpg`
        };

      case 'album':
        const urlObj = new URL(href);
        const {
          pics
        } = await ajax({
          url: string_namespaceObject.encode`https://vidble.com/album/album/${hash}?json=1`,
          type: 'json'
        });
        if (!pics.length) throw new Error('No images in gallery.');
        const src = pics.map((src, i) => {
          urlObj.hash = `#pic_${i}`;
          return {
            type: 'IMAGE',
            src,
            href: urlObj.href
          };
        });
        return {
          type: 'GALLERY',
          src
        };

      default:
        throw new Error(`This should never happen. Invalid type: ${type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vimeo.js

/* harmony default export */ var vimeo = (new Host('vimeo', {
  name: 'vimeo',
  domains: ['vimeo.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://player.vimeo.com/video/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      pause: '{"method":"pause"}',
      play: '{"method":"play"}',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlipsy.js

/* harmony default export */ var vlipsy = (new Host('vlipsy', {
  name: 'Vlipsy',
  domains: ['vlipsy.com'],
  logo: 'https://vlipsy.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/vlip\/(?:\w+-)*(\w+)$/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://vlipsy.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlive.js

/* harmony default export */ var vlive = (new Host('vlive', {
  name: 'VLive',
  domains: ['vlive.tv'],
  logo: 'https://www.vlive.tv/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:video)\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://vlive.tv/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoPlay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vreddit.js



/* harmony default export */ var vreddit = (new Host('vreddit', {
  name: 'v.redd.it',
  domains: ['v.redd.it'],
  permissions: ['https://v.redd.it/*/DASHPlaylist.mpd'],
  attribution: false,
  options: {
    replaceNativeExpando: {
      title: 'showImagesReplaceNativeExpandoTitle',
      description: 'showImagesReplaceNativeExpandoDesc',
      value: false,
      type: 'boolean'
    }
  },
  detect: ({
    pathname
  }) => pathname.slice(1),

  async handleLink(href, id) {
    const mpd = await ajax({
      url: `https://v.redd.it/${id}/DASHPlaylist.mpd`
    });
    const manifest = new DOMParser().parseFromString(mpd, 'text/xml');
    if (manifest.querySelector('AudioChannelConfiguration')) throw new Error('Audio is not supported');
    const reps = Array.from(manifest.querySelectorAll('Representation'));

    const sources = sortBy_default()(reps, rep => parseInt(rep.getAttribute('bandwidth'), 10)).reverse().map(rep => rep.querySelector('BaseURL')).map(baseUrl => ({
      source: `https://v.redd.it/${id}/${baseUrl.textContent}`,
      type: 'video/mp4'
    }));

    return {
      type: 'VIDEO',
      loop: true,
      muted: true,
      sources
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/exec-loader?cache!./lib/core/metadata/packageInfo.js
/* harmony default export */ var packageInfo = ({"announcementsSubreddit":"RESAnnouncements","name":"Reddit Enhancement Suite","version":"5.18.10","isBeta":false,"isPatch":true,"isMinor":false,"isMajor":false,"updatedURL":"https://redditenhancementsuite.com/releases/#v5.18.10","homepageURL":"https://redditenhancementsuite.com"});
// CONCATENATED MODULE: ./lib/core/metadata/index.js

const {
  announcementsSubreddit,
  name: metadata_name,
  version: metadata_version,
  isBeta,
  isPatch,
  isMinor,
  isMajor,
  updatedURL,
  homepageURL
} = packageInfo;
// CONCATENATED MODULE: ./lib/modules/hosts/wikipedia.js





const req = url => ajax({
  url,
  type: 'json',
  headers: {
    'Api-User-Agent': `Reddit-Enhancement-Suite/${metadata_version} ( ${homepageURL} )`
  }
});

/* harmony default export */ var wikipedia = (new Host('wikipedia', {
  name: 'wikipedia',
  domains: ['wikipedia.org', 'wikipedia.com'],
  logo: 'https://en.wikipedia.org/static/favicon/wikipedia.ico',
  detect: url => url.pathname.startsWith('/wiki/') && {
    article: url.pathname.substr(6),
    language: url.host.split('.')[0],
    hash: decodeURIComponent(url.hash.substr(1))
  },

  async handleLink(href, {
    language,
    article,
    hash
  }) {
    if (language === 'www' || language === 'wikipedia') language = 'en';
    const {
      index: sectionId = 0
    } = hash && (await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=sections&page=${article}&origin=*`)).parse.sections.find(({
      anchor
    }) => anchor === hash) || {};
    const {
      parse: html
    } = await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=text|displaytitle&section=${sectionId}&page=${article}&origin=*`);
    const cleanDoc = new DOMParser().parseFromString(html.text['*'], 'text/html');

    for (const e of cleanDoc.querySelectorAll('.metadata, .hatnote, .mw-editsection, .mwe-math-mathml-inline, .reference, .references')) e.remove();

    for (const e of cleanDoc.querySelectorAll('a')) {
      e.href = new URL(e.getAttribute('href'), `https://${language}.wikipedia.org/wiki/${article}`).href;
    }

    return {
      type: 'TEXT',
      title: jquery_default()('<div>', {
        html: html.displaytitle || html.title
      }).text(),
      src: cleanDoc.body.innerHTML
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xboxdvr.js

/* harmony default export */ var xboxdvr = (new Host('xboxdvr', {
  name: 'XboxDVR',
  domains: ['xboxdvr.com'],
  logo: 'https://xboxdvr.com/assets/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://xboxdvr.com/${path}/embed`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xkcd.js


/* harmony default export */ var xkcd = (new Host('xkcd', {
  name: 'xkcd',
  domains: ['xkcd.com'],
  permissions: ['https://xkcd.com/*/info.0.json'],
  logo: 'https://xkcd.com/favicon.ico',
  detect: ({
    hostname,
    pathname
  }) => ['xkcd.com', 'www.xkcd.com'].includes(hostname) && /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      title,
      alt,
      img
    } = await ajax({
      url: `https://xkcd.com/${id}/info.0.json`,
      type: 'json'
    });
    return {
      type: 'IMAGE',
      title,
      caption: alt,
      src: img
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/youtube.js



/* harmony default export */ var youtube = (new Host('youtube', {
  name: 'youtube',
  attribution: false,
  domains: ['youtube.com', 'youtu.be'],
  detect: ({
    pathname,
    hostname,
    searchParams
  }) => {
    const split = pathname.substring(1).split('/');
    if (split[0] === 'channel' && split[2] === 'live') return [`live_stream?channel=${split[1]}`, searchParams];
    if (hostname.endsWith('youtu.be')) return [split[0], searchParams];
    const vParam = searchParams.get('v');
    if (vParam) return [vParam, searchParams];
    if (/watch|embed|v/i.exec(split[0])) return [split[1], searchParams];
    const uParam = searchParams.get('u');

    if (split[0] === 'attribution_link' && uParam !== null) {
      const vParam = new URLSearchParams(uParam.split('?')[1]).get('v');
      if (vParam) return [vParam, searchParams];
    }
  },

  handleLink(href, [id, searchParams]) {
    const url = new URL(`https://www.youtube.com/embed/${id}`);
    url.searchParams.set('version', '3');
    url.searchParams.set('rel', '0');
    const tParam = searchParams.get('t');

    if (tParam) {
      let start = 0;
      const timeBlocks = {
        h: 3600,
        m: 60,
        s: 1
      };
      const timeRe = /[0-9]+[hms]/ig;
      const timeMatch = tParam.match(timeRe);

      if (timeMatch) {
        for (const ts of timeMatch) {
          const unit = timeBlocks[ts.slice(-1)];
          const amount = parseInt(ts.slice(0, -1), 10);
          start += unit * amount;
        }
      } else {
        start = parseInt(tParam, 10);
        if (isNaN(start)) start = 0;
      }

      url.searchParams.set('start', String(start));
    }

    for (const k of ['end', 'start', 'list']) {
      const param = searchParams.get(k);
      if (param) url.searchParams.set(k, param);
    }

    return {
      type: 'IFRAME',
      embed: url.href,
      embedAutoplay: `${url.href}&autoplay=1`,
      fixedRatio: true
    };
  },

  getVideoData: batch(async ids => {
    const {
      items
    } = await ajax({
      url: 'https://www.googleapis.com/youtube/v3/videos',
      query: {
        id: [...ids].sort().join(','),
        part: ['id', 'contentDetails', 'snippet', 'statistics'].join(','),
        fields: `items(${['id', 'contentDetails(duration)', 'snippet(title,publishedAt)', 'statistics(viewCount)'].join(',')})`,
        key: 'AIzaSyB8ufxFN0GapU1hSzIbuOLfnFC0XzJousw'
      },
      type: 'json',
      cacheFor: DAY
    });
    return ids.map(id => {
      const data = items.find(({
        id: _id
      }) => _id === id);

      try {
        const {
          contentDetails: {
            duration: rawDuration
          },
          snippet: {
            title,
            publishedAt
          },
          statistics: {
            viewCount
          }
        } = data;
        const duration = ['0'].concat(rawDuration.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i).slice(1)).map(time => `0${time || 0}`.slice(-2)).filter((time, i, {
          length
        }) => +time !== 0 || i >= length - 2).join(':');
        return {
          title,
          duration,
          publishedAt,
          viewCount
        };
      } catch (e) {}
    });
  }, {
    size: 50,
    delay: 0
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/znipe.js

/* harmony default export */ var znipe = (new Host('znipe', {
  name: 'ZnipeTV',
  domains: ['beta.znipe.tv', 'www.znipe.tv'],
  logo: 'https://assets.znipe.tv/icons/favicon.jpg',
  detect: ({
    searchParams
  }) => {
    const mParam = searchParams.get('m');
    if (mParam) return ['m', mParam];
    const vParam = searchParams.get('v');
    if (vParam) return ['v', vParam];
  },

  handleLink(href, [clipType, clipId]) {
    return {
      type: 'IFRAME',
      embed: `https://beta.znipe.tv/watch?${clipType}=${clipId}`
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=default!./lib/modules/hosts/default.js
/* generated by sibling-loader */















































































/* harmony default export */ var modules_hosts_default = ({ "aarli.js": aarli, "adultswim.js": adultswim, "archilogic.js": archilogic, "archiveis.js": archiveis, "bime.js": bime, "clyp.js": clyp, "codepen.js": codepen, "coub.js": coub, "dailymotion.js": dailymotion, "default.js": hosts_default, "defaultAudio.js": defaultAudio, "defaultVideo.js": defaultVideo, "derpibooru.js": derpibooru, "deviantart.js": deviantart, "dropbox.js": dropbox, "fiveHundredPx.js": fiveHundredPx, "flickr.js": flickr, "getyarn.js": getyarn, "gfycat.js": gfycat, "gifyoutube.js": gifyoutube, "giphy.js": giphy, "github.js": github, "googlemaps.js": googlemaps, "gyazo.js": gyazo, "hastebin.js": hastebin, "iloopit.js": iloopit, "imgflip.js": imgflip, "imgur.js": imgur, "instagram.js": instagram, "ireddit.js": ireddit, "jsfiddle.js": jsfiddle, "liveleak.js": liveleak, "livememe.js": livememe, "makeameme.js": makeameme, "memecrunch.js": memecrunch, "memedad.js": memedad, "mixer.js": mixer, "onedrive.js": onedrive, "pastebin.js": pastebin, "peertube.js": peertube, "photobucket.js": photobucket, "pixiv.js": pixiv, "poly.js": poly, "pornhub.js": pornhub, "ppy.js": ppy, "redditbooru.js": redditbooru, "redditmedia.js": redditmedia, "reddituploads.js": reddituploads, "redgifs.js": redgifs, "ridewithgps.js": ridewithgps, "simplecove.js": simplecove, "snag.js": snag, "soundcloud.js": soundcloud, "spotify.js": spotify, "steamcommunity.js": steamcommunity, "steampowered.js": steampowered, "strawpollcom.js": strawpollcom, "strawpollme.js": strawpollme, "streamable.js": streamable, "streamja.js": streamja, "streamvi.js": streamvi, "supgif.js": supgif, "supload.js": supload, "tenor.js": tenor, "tumblr.js": tumblr, "twimg.js": twimg, "twitch.js": twitch, "twitchclips.js": twitchclips, "twitter.js": twitter, "vidble.js": vidble, "vimeo.js": vimeo, "vlipsy.js": vlipsy, "vlive.js": vlive, "vreddit.js": vreddit, "wikipedia.js": wikipedia, "xboxdvr.js": xboxdvr, "xkcd.js": xkcd, "youtube.js": youtube, "znipe.js": znipe });
// CONCATENATED MODULE: ./lib/modules/showImages.js






















const siteModules = flow_default()(() => Object.values(modules_hosts_default), map_default()(host => downcast(host, Host)), keyBy_default()(host => host.moduleID))();

const genericHosts = [siteModules.default, siteModules.defaultVideo, siteModules.defaultAudio];
const showImages_module = new Module('showImages');
showImages_module.moduleName = 'showImagesName';
showImages_module.category = 'productivityCategory';
showImages_module.description = 'showImagesDesc';
showImages_module.bodyClass = true;
showImages_module.options = {
  mediaBrowse: {
    title: 'showImagesMediaBrowseTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaBrowseDesc'
  },
  browsePreloadCount: {
    title: 'showImagesBrowsePreloadCountTitle',
    type: 'text',
    value: '1',
    description: 'showImagesBrowsePreloadCountDesc',
    dependsOn: options => options.mediaBrowse.value
  },
  galleryPreloadCount: {
    title: 'showImagesGalleryPreloadCountTitle',
    type: 'text',
    value: '2',
    description: 'showImagesGalleryPreloadCountDesc'
  },
  conserveMemory: {
    title: 'showImagesConserveMemoryTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesConserveMemoryDesc'
  },
  maxWidth: {
    title: 'showImagesMaxWidthTitle',
    type: 'text',
    value: '100%',
    description: 'showImagesMaxWidthDesc',
    advanced: true
  },
  maxHeight: {
    title: 'showImagesMaxHeightTitle',
    type: 'text',
    value: '80%',
    description: 'showImagesMaxHeightDesc',
    advanced: true
  },
  displayOriginalResolution: {
    title: 'showImagesDisplayOriginalResolutionTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesDisplayOriginalResolutionDesc'
  },
  selfTextMaxHeight: {
    title: 'showImagesSelfTextMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesSelfTextMaxHeightDesc',
    advanced: true
  },
  commentMaxHeight: {
    title: 'showImagesCommentMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesCommentMaxHeightDesc',
    advanced: true
  },
  autoMaxHeight: {
    title: 'showImagesAutoMaxHeightTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesAutoMaxHeightDesc',
    dependsOn: options => !!parseInt(options.selfTextMaxHeight.value, 10) || !!parseInt(options.commentMaxHeight.value, 10),
    advanced: true
  },
  openInNewWindow: {
    title: 'showImagesOpenInNewWindowTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesOpenInNewWindowDesc'
  },
  hideNSFW: {
    title: 'showImagesHideNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHideNSFWDesc'
  },
  highlightNSFWButton: {
    title: 'showImagesHighlightNSFWButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightNSFWButtonDesc',
    bodyClass: true
  },
  highlightSpoilerButton: {
    title: 'showImagesHighlightSpoilerButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightSpoilerButtonDesc',
    bodyClass: true
  },
  imageZoom: {
    title: 'showImagesImageZoomTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageZoomDesc'
  },
  imageMove: {
    title: 'showImagesImageMoveTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageMoveDesc'
  },
  mediaControls: {
    title: 'showImagesMediaControlsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaControlsDesc'
  },
  mediaControlsPosition: {
    title: 'showImagesMediaControlsPositionTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'enum',
    value: 'top-left',
    values: [{
      name: 'Top left',
      value: 'top-left'
    }, {
      name: 'Top right',
      value: 'top-right'
    }, {
      name: 'Bottom left.',
      value: 'bottom-left'
    }, {
      name: 'Bottom right.',
      value: 'bottom-right'
    }],
    description: 'showImagesMediaControlsPositionDesc'
  },
  clippy: {
    title: 'showImagesClippyTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'boolean',
    value: true,
    description: 'showImagesClippyDesc'
  },
  crossposts: {
    title: 'showImagesCrosspostsTitle',
    description: 'showImagesCrosspostsDescription',
    type: 'enum',
    value: 'withMetadata',
    values: [{
      name: 'Do not replace Reddit crosspost expando',
      value: 'none'
    }, {
      name: 'Show with original post\'s metadata',
      value: 'withMetadata'
    }, {
      name: 'Show without metadata',
      value: 'plain'
    }]
  },
  displayImageCaptions: {
    title: 'showImagesDisplayImageCaptionsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesDisplayImageCaptionsDesc',
    advanced: true,
    bodyClass: true
  },
  captionsPosition: {
    title: 'showImagesCaptionsPositionTitle',
    dependsOn: options => options.displayImageCaptions.value,
    type: 'enum',
    value: 'titleAbove',
    values: [{
      name: 'Display all captions above image.',
      value: 'allAbove'
    }, {
      name: 'Display title and caption above image, credits below.',
      value: 'creditsBelow'
    }, {
      name: 'Display title above image, caption and credits below.',
      value: 'titleAbove'
    }, {
      name: 'Display all captions below image.',
      value: 'allBelow'
    }],
    description: 'showImagesCaptionsPositionDesc',
    advanced: true,
    bodyClass: true
  },
  markVisited: {
    title: 'showImagesMarkVisitedTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMarkVisitedDesc',
    advanced: true
  },
  markSelftextVisited: {
    title: 'showImagesMarkSelftextVisitedTitle',
    dependsOn: options => options.markVisited.value,
    type: 'boolean',
    value: false,
    description: 'showImagesMarkSelftextVisitedDesc',
    advanced: true
  },
  sfwHistory: {
    title: 'showImagesSfwHistoryTitle',
    dependsOn: options => options.markVisited.value,
    type: 'enum',
    value: 'add',
    values: [{
      name: 'Add links to history',
      value: 'add'
    }, {
      name: 'Do not add or color links.',
      value: 'none'
    }],
    description: 'showImagesSfwHistoryDesc'
  },
  galleryRememberWidth: {
    title: 'showImagesGalleryRememberWidthTitle',
    dependsOn: options => options.imageZoom.value,
    type: 'boolean',
    value: true,
    description: 'showImagesGalleryRememberWidthDesc'
  },
  galleryAsFilmstrip: {
    title: 'showImagesGalleryAsFilmstripTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesGalleryAsFilmstripDesc'
  },
  filmstripLoadIncrement: {
    title: 'showImagesFilmstripLoadIncrementTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '30',
    description: 'showImagesFilmstripLoadIncrementDesc'
  },
  useSlideshowWhenLargerThan: {
    title: 'showImagesUseSlideshowWhenLargerThanTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '0',
    description: 'showImagesUseSlideshowWhenLargerThanDesc'
  },
  showViewImagesTab: {
    title: 'showImagesShowViewImagesTabTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowViewImagesTabDesc'
  },
  autoExpandTypes: {
    title: 'showImagesAutoExpandTypesTitle',
    type: 'enum',
    value: 'any',
    values: [{
      name: 'Images (but occasionally also .gif)',
      value: 'image'
    }, {
      name: 'Images, text',
      value: 'image text'
    }, {
      name: 'Images, text, galleries, and muted videos',
      value: 'image text gallery video'
    }, {
      name: 'All muted expandos (includes iframes)',
      value: 'any'
    }],
    description: 'showImagesAutoExpandTypesDesc'
  },
  autoExpandSelfText: {
    title: 'showImagesAutoExpandSelfTextTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextDesc'
  },
  autoExpandSelfTextFirstVisibleNonMuted: {
    title: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedDesc'
  },
  autoExpandSelfTextNSFW: {
    title: 'showImagesAutoExpandSelfTextNSFWTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: false,
    description: 'showImagesAutoExpandSelfTextNSFWDesc'
  },
  showSiteAttribution: {
    title: 'showImagesShowSiteAttributionTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowSiteAttributionDesc'
  },
  expandoCommentRedirects: {
    title: 'showImagesExpandoCommentRedirectsTitle',
    type: 'enum',
    value: 'expando',
    values: [{
      name: 'Do nothing',
      value: 'nothing'
    }, {
      name: 'Create expandos',
      value: 'expando'
    }, {
      name: 'Create expandos, redirect the link back to the image',
      value: 'rewrite'
    }],
    description: 'showImagesExpandoCommentRedirectsDesc'
  },
  startVideosMuted: {
    title: 'showImagesStartVideosMutedTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesStartVideosMutedDesc'
  },
  onlyPlayMutedWhenVisible: {
    title: 'showImagesOnlyPlayMutedWhenVisibleTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesOnlyPlayMutedWhenVisibleDesc'
  },
  maxSimultaneousPlaying: {
    title: 'showImagesMaxSimultaneousPlayingTitle',
    type: 'text',
    value: '0',
    description: 'showImagesMaxSimultaneousPlayingDesc'
  },
  autoplayVideo: {
    title: 'showImagesAutoplayVideoTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoplayVideoDesc'
  },
  hidePinnedRedditVideos: {
    title: 'showImagesHidePinnedRedditVideosTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHidePinnedRedditVideosDesc',
    bodyClass: true
  },
  ...Object.values(siteModules).reduce((options, siteModule) => {
    if (genericHosts.includes(siteModule)) return options;
    options[siteModuleOptionKey(siteModule)] = {
      title: siteModule.name,
      description: 'showImagesHostToggleDesc',
      value: true,
      type: 'boolean'
    };
    Object.assign(options, siteModule.options);
    return options;
  }, {})
};
showImages_module.exclude = [/^\/ads\/[\-\w\._\?=]*/i, 'submit', /^\/subreddits/i];

showImages_module.beforeLoad = () => {
  const selfTextMaxHeight = parseInt(showImages_module.options.selfTextMaxHeight.value, 10);

  if (selfTextMaxHeight) {
    addCSS(`
			.selftext.expanded ~ * .md {
				max-height: ${selfTextMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  const commentMaxHeight = parseInt(showImages_module.options.commentMaxHeight.value, 10);

  if (commentMaxHeight) {
    addCSS(`
			.comment .md {
				max-height: ${commentMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  watchForElements(['selfText'], null, scanBody);
  watchForThings(['comment', 'message'], thing => scanBody(thing.getTextBody()), {
    id: showImages_module
  });
  watchForThings(['post'], thing => checkElementForMedia(thing.getPostLink()), {
    id: showImages_module
  });
  watchForRedditEvents('comment', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const comment = placeholder.closest('.Comment');
    scanBody(comment);
  });
  watchForRedditEvents('postAuthor', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const body = placeholder.closest('[data-test-id="post-content"]');
    if (body && body.querySelector('.media-element')) return;
    scanBody(body);
  });
};

showImages_module.contentStart = () => {
  if (showImages_module.options.showViewImagesTab.value && isAppType('r2')) {
    viewImagesButton();
  }

  if (showImages_module.options.mediaBrowse.value) {
    selectedThing_namespaceObject.addListener(mediaBrowse, 'instantly');
  }

  if (showImages_module.options.autoMaxHeight.value) {
    jquery_default()(document.body).on('mediaResize', '.thing > .entry', updateParentHeight);
  }
};

showImages_module.go = () => {
  if (isPageType('wiki')) scanBody(document.querySelector('.wiki-page-content'));
  const spotlight = document.querySelector('#siteTable_organic');

  if (spotlight) {
    const nextprev = spotlight.querySelector('.nextprev');

    if (nextprev) {
      nextprev.addEventListener('click', () => {
        const open = spotlight.querySelector('.expando-button.expanded');
        if (open) open.click();
      });
    }
  }
};

showImages_module.afterLoad = () => {
  if (showImages_module.options.conserveMemory.value) {
    enableConserveMemory();
  }
};

function siteModuleOptionKey(siteModule) {
  const id = siteModule.moduleID;
  return `display_${id}`;
}

function isSiteModuleEnabled(siteModule) {
  const key = siteModuleOptionKey(siteModule);
  return !showImages_module.options[key] || showImages_module.options[key].value;
}

const sitesMap = lodash_once_default()(() => Object.values(siteModules).filter(isSiteModuleEnabled).reduce((map, siteModule) => {
  for (const domain of siteModule.domains) {
    map.set(domain, (map.get(domain) || []).concat(siteModule));
  }

  return map;
}, new Map()));

function* modulesForHostname(hostname) {
  do {
    for (const m of sitesMap().get(hostname) || []) yield m;
  } while (hostname = hostname.replace(/^.+?(\.|$)/, ''));

  for (const m of genericHosts) yield m;
}

function enableConserveMemory() {
  const fullscreenActive = () => !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);

  const rootMargin = '50% 100000%';
  const boxMap = new WeakMap();
  const ioBox = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!isIntersecting && fullscreenActive()) return;
      const {
        media
      } = downcast(boxMap.get(target), expando_Expando);
      if (media) media.setLoaded(isIntersecting);else ioBox.unobserve(target);
    }
  }, {
    rootMargin
  });
  const buttonMap = new WeakMap();
  const ioButton = new IntersectionObserver(entries => {
    if (fullscreenActive()) return;

    for (const {
      isIntersecting,
      target
    } of entries) {
      const expando = downcast(buttonMap.get(target), expando_Expando);
      const {
        open
      } = expando;

      if (!isIntersecting && !open) {
        ioButton.unobserve(target);
        expando.empty();
      }
    }
  }, {
    rootMargin
  });
  window.addEventListener('scroll', idleThrottle(() => {
    for (const expando of activeExpandos.values()) {
      if (expando.isAttached()) {
        const {
          box,
          media,
          button
        } = expando;
        if (!media) continue;

        if (media.supportsUnload()) {
          ioBox.observe(box);
          boxMap.set(box, expando);
        } else {
          ioButton.observe(button);
          buttonMap.set(button, expando);
        }
      } else {
        expando.destroy();
      }
    }
  }));
}

let autoExpandActive = false;
let mediaBrowseModeActive = false;
const viewImagesButton = lodash_once_default()(() => createElement_namespaceObject.tabMenuItem({
  text: 'show images',
  className: 'res-show-images',
  onChange: active => {
    autoExpandActive = active;

    for (const expando of Array.from(expando_expandos.values()).filter(expando => expando instanceof expando_Expando && expando.button.offsetParent)) {
      const open = isExpandWanted(expando);
      if (open) expando.expand();else if (!autoExpandActive) expando.collapse();
    }
  }
}));
function toggleThingExpandos(thing, {
  scrollOnToggle
} = {}) {
  const expandos = expando_Expando.getAllExpandosFrom(thing);
  if (!expandos.length) return;
  const openExpandos = expandos.filter(v => v.open);

  if (openExpandos.length) {
    for (const expando of openExpandos) expando.collapse();

    if (scrollOnToggle) {
      scrollToElement(thing.entry, null, {
        scrollStyle: 'directional',
        restrictDirectionTo: 'up'
      });
    }
  } else {
    for (const expando of expandos) {
      if (!(expando instanceof expando_Expando) || isExpandWanted(expando, {
        thing,
        autoExpandFirstVisibleNonMutedInThing: true,
        autoExpand: true,
        autoExpandTypes: [],
        ignoreDuplicatesScope: thing.entry
      })) {
        expando.expand();
      }
    }

    if (scrollOnToggle) {
      scrollToElement(thing.entry, null, {
        scrollStyle: 'top',
        restrictDirectionTo: 'down'
      });
    }
  }
}
const preloadExpandos = idleThrottle((fromThing, direction, preloadCount = parseInt(showImages_module.options.browsePreloadCount.value, 10)) => {
  const pieces = [];
  let target = fromThing;

  do {
    const expando = expando_Expando.getEntryExpandoFrom(target);
    if (expando && expando instanceof expando_Expando) pieces.push(expando);
  } while ((target = target.getNext({
    direction
  })) && pieces.length <= preloadCount);

  preloadMedia(pieces);
});

function mediaBrowse(selected, unselected, options) {
  if (!selected || !options.allowMediaBrowse || autoExpandActive) return;
  const oldExpando = expando_Expando.getEntryExpandoFrom(unselected);
  const newExpando = expando_Expando.getEntryExpandoFrom(selected);

  if (oldExpando) {
    mediaBrowseModeActive = oldExpando.expandWanted || oldExpando.open;
    oldExpando.collapse();
  }

  if (mediaBrowseModeActive && newExpando) {
    newExpando.expand();
    options.scrollStyle = 'top';
    preloadExpandos(selected, options.direction);
  }
}

function hasEntryAnyExpandedNonMuted(thing) {
  return expando_Expando.getTextExpandosFrom(thing).some(expando => expando.types.includes('non-muted') && (expando.open || expando.expandWanted));
}

const showImages_types = ['selftext', 'video', 'image', 'iframe', 'gallery', 'native', 'muted', 'non-muted'];
function matchesTypes(wantedTypes, expandoTypes = showImages_types) {
  return !!expandoTypes.length && (!wantedTypes.length || !!intersection_default()(expandoTypes, wantedTypes).length);
}

function isExpandWanted(expando, {
  thing,
  autoExpand = autoExpandActive,
  autoExpandTypes = showImages_module.options.autoExpandTypes.value.replace('any', '').split(' ').filter(Boolean),
  ignoreDuplicates = true,
  ignoreDuplicatesScope,
  onlyExpandMuted = true,
  autoExpandFirstVisibleNonMutedInThing = false
} = {}) {
  if (ignoreDuplicates) {
    const duplicates = expando.getDuplicates().filter(v => activeExpandos.has(v));

    if (duplicates.length) {
      if (!ignoreDuplicatesScope) return false;
      if (duplicates.some(v => ignoreDuplicatesScope.contains(v.button))) return false;
    }
  }

  const expandoIsNonMuted = expando.types.includes('non-muted');
  const typeCriteriaOK = matchesTypes(autoExpandTypes, expando.types);
  const muteCriteriaOK = !(onlyExpandMuted && expandoIsNonMuted) || autoExpandFirstVisibleNonMutedInThing && elementInViewport(expando.button) && !hasEntryAnyExpandedNonMuted(thing);
  return autoExpand && muteCriteriaOK && typeCriteriaOK;
}

function resolveMediaUrl(element, thing) {
  if (showImages_module.options.expandoCommentRedirects.value !== 'nothing' && thing && element.classList.contains('title')) {
    const dataUrl = thing.element.getAttribute('data-url');
    const fullDataUrl = dataUrl && new URL(dataUrl, location.href);

    if (fullDataUrl && fullDataUrl.href !== thing.getCommentsLink().href) {
      return fullDataUrl;
    }
  }

  return new URL(element.href, location.href);
}

function promptSiteModulePermissions(siteModule) {
  const {
    name,
    permissions = []
  } = siteModule;
  const urlStripRe = /((?:\w+\.)+\w+)(?=\/|$)/i;
  const message = string_namespaceObject.html`<div>
		<p>In order to inline expand content from ${name}, RES needs permission to access these sites:</p>
		<p><code>${permissions.map(url => `${urlStripRe.exec(url)[0]}`).join(', \n')}</code></p>
		<p>Be assured RES does not access/modify any of your information on these domains - it only accesses the public API.</p>
		<hr>
		<p>If you prefer not to use RES' expando for these sites, you may:</p>
		<button>Disable this host</button>
	</div>`;
  const notification = notifications_showNotification({
    header: 'Permission required',
    moduleID: 'permissions',
    closeDelay: Infinity,
    message
  });
  const disableHostButton = message.querySelector('button');
  return Promise.race([permissions_namespaceObject.request(permissions).catch(() => new Promise(() => {})), waitForEvent(disableHostButton, 'click').then(() => {
    const opt = showImages_module.options[siteModuleOptionKey(siteModule)];
    opt.value = false;
    options_save(opt);
    return Promise.reject(new Error('Host disabled'));
  })]).finally(() => {
    notification.close();
  });
}

const generateSiteModuleLock = memoize_default()(async siteModule => {
  if (!siteModule.permissions || (await permissions_namespaceObject.has(siteModule.permissions))) return;
  let resolve, reject;
  return {
    promise: new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    }),
    open: () => promptSiteModulePermissions(siteModule).then(resolve, reject)
  };
});

function scanBody(element) {
  if (!element) return;

  for (const link of element.querySelectorAll('a')) {
    checkElementForMedia(downcast(link, HTMLAnchorElement));
  }
}

const linksMap = new WeakMap();
function getLinkExpando(link) {
  return linksMap.get(link);
}

const inText = element => !!element.closest('.md, .search-result-footer');

async function checkElementForMedia(element) {
  const thing = Thing_Thing.from(element);
  const entryExpando = !inText(element) && expando_Expando.getEntryExpandoFrom(thing);
  const nativeExpando = entryExpando instanceof expando_Expando ? null : entryExpando;

  if (showImages_module.options.hideNSFW.value && thing && thing.isNSFW()) {
    if (nativeExpando) nativeExpando.detach();
    return;
  }

  if (nativeExpando) {
    trackNativeExpando(nativeExpando, element, thing);

    if (nativeExpando.open) {
      console.log('Native expando has already been opened; skipping.', element.href);
      return;
    }
  }

  if (thing && thing.isCrosspost() && showImages_module.options.crossposts.value === 'none') {
    return;
  }

  const mediaUrl = resolveMediaUrl(element, thing);

  if (mediaUrl && showImages_module.options.expandoCommentRedirects.value === 'rewrite') {
    element.href = mediaUrl.href;
    element.removeAttribute('data-inbound-url');
  }

  for (const siteModule of modulesForHostname(mediaUrl.hostname)) {
    if (nativeExpando) {
      const {
        options: {
          replaceNativeExpando
        } = {}
      } = siteModule;
      if (replaceNativeExpando && !replaceNativeExpando.value) continue;
    }

    const detectResult = siteModule.detect(mediaUrl, thing);
    if (!detectResult) continue;
    const expando = new expando_Expando(mediaUrl.href);
    if (nativeExpando) nativeExpando.detach();
    placeExpando(expando, element, thing);
    expando.onExpand(() => {
      trackMediaLoad(element, thing);
    });
    linksMap.set(element, expando);
    const lock = await generateSiteModuleLock(siteModule);
    if (lock) expando.setLock(lock);

    try {
      if (lock) await lock.promise;
      await completeExpando(expando, thing, siteModule, detectResult);
      break;
    } catch (e) {
      console.error(`showImages: could not create expando for ${mediaUrl.href}`, e);
      if (nativeExpando) nativeExpando.reattach();
      expando.destroy();
      linksMap.delete(element);
    }
  }
}

function placeExpando(expando, element, thing) {
  if (!inText(element) && thing && thing.getTitleElement()) {
    if (element.parentElement) element.parentElement.after(expando.button);
    const sibling = expando.button.nextElementSibling;
    if (sibling && sibling.classList.contains('expando-button')) sibling.after(expando.button);
    thing.entry.appendChild(expando.box);
  } else {
    jquery_default()(element).add(jquery_default()(element).next('.keyNavAnnotation')).last().after(expando.box).after(jquery_default()('<span class="res-freetext-expando">').append(expando.button));
  }
}

async function completeExpando(expando, thing, siteModule, detectResult) {
  const mediaOptions = await siteModule.handleLink(expando.href, detectResult);

  if (mediaOptions.title && thing && string_namespaceObject.areSimilar(mediaOptions.title, thing.getTitle())) {
    mediaOptions.title = '';
  }

  const attribution = showImages_module.options.showSiteAttribution.value && thing && thing.isPost() && !thing.isSelfPost() && siteModule.domains.length && siteModule.attribution !== false;

  const isMuted = media => media.muted || ['IMAGE', 'TEXT'].includes(media.type);

  const muted = mediaOptions.type === 'GALLERY' ? mediaOptions.src.every(isMuted) : isMuted(mediaOptions);
  expando.initialize({
    types: [mediaOptions.type, muted ? 'muted' : 'non-muted', ...(mediaOptions.expandoClass || '').split(' ')].filter(v => v).map(s => s.toLowerCase()),
    buttonInfo: getMediaButtonInfo(mediaOptions),

    generateMedia() {
      const media = generateMedia(mediaOptions, {
        href: expando.href
      });

      if (showImages_module.options.crossposts.value === 'withMetadata' && thing && thing.isCrosspost()) {
        media.element.prepend(crosspostMetadataTemplate(thing.element.dataset));
      }

      if (attribution) addSiteAttribution(siteModule, media);
      return media;
    }

  });
  expando.button.setAttribute('data-host', siteModule.moduleID);
  expando.box.setAttribute('data-host', siteModule.moduleID);
  const hideButton = thing && thing.getHideElement();
  if (hideButton) hideButton.addEventListener('click', () => {
    expando.destroy();
  });

  if (thing && thing.isComment()) {
    expando.onExpand(lodash_once_default()(() => {
      let wasOpen;
      jquery_default()([thing, ...thing.getParents()].map(e => e.entry)).find('.tagline > .expand, > .buttons .toggleChildren').click(() => {
        if (thing.isContentVisible()) {
          if (wasOpen && expando.media) expando.expand();
        } else {
          wasOpen = expando.open;
          if (expando.open) expando.collapse();
        }
      });
    }));
  }

  expando.onExpand(() => {
    const lightbox = expando.media.element.closest('#overlayScrollContainer');
    if (lightbox) lightbox.firstChild.style.overflowY = 'initial';
  });
  expando.button.addEventListener('mousedown', () => {
    preloadMedia([expando]);
  });

  if (!expando.open) {
    let autoExpand;
    let autoExpandFirstVisibleNonMutedInThing;

    if (showImages_module.options.autoExpandSelfText.value && inText(expando.button) && thing && thing.isSelfPost() && !isPageType('comments')) {
      const dontAutoExpandNSFW = !showImages_module.options.autoExpandSelfTextNSFW.value && thing.isNSFW();
      autoExpand = !dontAutoExpandNSFW;
      autoExpandFirstVisibleNonMutedInThing = showImages_module.options.autoExpandSelfTextFirstVisibleNonMuted.value;
    }

    if (isExpandWanted(expando, {
      thing,
      autoExpand,
      autoExpandFirstVisibleNonMutedInThing
    })) {
      expando.expand();
    }
  }
}

function updateParentHeight(e) {
  const thing = Thing_Thing.checkedFrom(e.currentTarget);
  const basisHeight = thing.isSelfPost() && parseInt(showImages_module.options.selfTextMaxHeight.value, 10) || thing.isComment() && parseInt(showImages_module.options.commentMaxHeight.value, 10) || 0;

  if (basisHeight > 0) {
    const expandoHeight = Array.from(thing.entry.querySelectorAll('.res-expando-box, .expando-button.expanded')).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
    thing.element.querySelector('.md').style.maxHeight = `${basisHeight + expandoHeight}px`;
  }
}

function trackNativeExpando(expando, element, thing) {
  if (!showImages_module.options.markSelftextVisited.value && expando.button.classList.contains('selftext')) return;

  const trackLoad = lodash_once_default()(() => trackMediaLoad(element, thing));

  if (expando.open) trackLoad();else expando.button.addEventListener('click', trackLoad);
}

function getMediaButtonInfo(options) {
  let title = '';
  let type = options.type;

  if (options.type === 'GALLERY') {
    if (options.src.length === 1) {
      type = options.src[0].type;
    } else {
      title += `${options.src.length} items in gallery`;
    }
  }

  const defaultClass = {
    IMAGE: 'image',
    GALLERY: 'image gallery',
    TEXT: 'selftext',
    VIDEO: options.muted ? 'video-muted' : 'video',
    IFRAME: options.muted ? 'video-muted' : 'video',
    AUDIO: 'video',
    GENERIC_EXPANDO: 'selftext'
  }[type];
  return {
    title,
    mediaClass: options.expandoClass || defaultClass
  };
}

let lastPreloadIndex = 0;

function preloadMedia(pieces) {
  const index = ++lastPreloadIndex;
  return forEachSeq(pieces, piece => {
    if (!piece.generateMedia) return;
    if (lastPreloadIndex !== index) return;
    piece.media = piece.media || piece.generateMedia();
    return piece.media.ready;
  });
}

function generateMedia(options, context) {
  if (options.credits) options.credits = Object(purify["sanitize"])(options.credits);
  if (options.caption) options.caption = Object(purify["sanitize"])(options.caption);

  switch (options.type) {
    case 'GALLERY':
      return new showImages_Gallery(options, context);

    case 'IMAGE':
      return new showImages_Image(options, context);

    case 'TEXT':
      return new showImages_Text(options);

    case 'IFRAME':
      return new showImages_Iframe(options);

    case 'VIDEO':
      return new showImages_Video(options, context);

    case 'AUDIO':
      return new showImages_Audio(options);

    case 'GENERIC_EXPANDO':
      return new Generic(options);

    default:
      throw new Error(`Unreachable: invalid media type ${options.type}`);
  }
}

const observed = new WeakMap();
const resizeObserver = new ResizeObserver(entries => {
  for (const {
    target,
    contentRect
  } of entries) {
    const callback = observed.get(target);
    if (callback) callback(contentRect);
  }
});
class showImages_Media {
  constructor() {
    this.element = void 0;
    this.ready = void 0;
    this.onAttach = void 0;
    this.onResize = [];
    this.resizing = void 0;
    this.rotationState = 0;
    this._state = 'loaded';
  }

  isAttached() {
    return document.body.contains(this.element);
  }

  expand() {
    this.setLoaded(true);
  }

  collapse() {
    this.setLoaded(false);
  }

  supportsUnload() {
    return false;
  }

  _unload() {}

  _restore() {}

  setLoaded(state) {
    if (state) {
      this._state = 'loaded';

      this._restore();
    } else {
      this._state = 'unloaded';

      this._unload();
    }
  }

  makeIndependent(element) {
    const wrapper = document.createElement('div');
    const independent = document.createElement('div');
    element.replaceWith(wrapper);
    wrapper.appendChild(independent);
    independent.appendChild(element);
    independent.classList.add('res-media-independent');
    wrapper.style.willChange = 'height';

    this.resizing = (contentRect = element.getBoundingClientRect()) => {
      for (const callback of this.onResize) callback(contentRect);

      wrapper.style.height = `${contentRect.height}px`;
    };

    this.onResize.push(contentRect => {
      this.element.dispatchEvent(new CustomEvent('mediaResize', {
        detail: contentRect,
        bubbles: true
      }));
    });
    observed.set(element, contentRect => {
      if (this._state === 'unloaded') return;
      if (this.resizing) this.resizing(contentRect);
    });
    resizeObserver.observe(element);
    waitForEvent(element, 'mediaManuallyMovedVertically').then(() => {
      resizeObserver.unobserve(element);
    });
  }

  keepVisible(element) {
    element.classList.add('res-element-keep-visible');

    const basisLeft = lodash_once_default()(() => downcast(element.parentElement, HTMLElement).getBoundingClientRect().left);

    let isAligned = false;
    this.onResize.push(({
      width: elementWidth
    }) => {
      const {
        width: viewportWidth
      } = getViewportSize();
      if (!isAligned && basisLeft() + elementWidth < viewportWidth) return;
      const {
        left: elementLeft,
        right: elementRight
      } = element.getBoundingClientRect();
      const deltaLeft = elementLeft - basisLeft();

      if (elementWidth > viewportWidth) {
        isAligned = true;
        showImages_move(element, -elementLeft, 0);
      } else if (elementRight - deltaLeft > viewportWidth) {
        isAligned = true;
        showImages_move(element, viewportWidth - elementRight, 0);
      } else if (deltaLeft) {
        isAligned = false;
        showImages_move(element, -deltaLeft, 0);
      }
    });
  }

  setMaxSize(element) {
    let value = showImages_module.options.maxWidth.value;
    let isPercentage = value.endsWith('%');
    const maxWidth = (isPercentage ? getViewportSize().width / 100 : 1) * parseInt(value, 10);
    if (maxWidth) element.style.maxWidth = `${maxWidth}px`;
    value = showImages_module.options.maxHeight.value;
    isPercentage = value.endsWith('%');
    const maxHeight = (isPercentage ? getViewportSize().height / 100 : 1) * parseInt(value, 10);
    if (maxHeight) element.style.maxHeight = `${maxHeight}px`;
  }

  makeZoomable(element, dragInitiater = element, absoluteSizing = false) {
    if (!showImages_module.options.imageZoom.value) return;
    element.classList.add('res-media-zoomable');
    let initialWidth, initialHeight, initialDiagonal, left, top;

    function getDiagonal(x, y) {
      const w = Math.max(1, x - left);
      const h = Math.max(1, y - top);
      return Math.round(Math.hypot(w, h));
    }

    addDragListener({
      media: this.element,
      element: dragInitiater,
      atShiftKey: false,
      onStart: (x, y) => {
        ({
          left,
          top,
          width: initialWidth,
          height: initialHeight
        } = element.getBoundingClientRect());
        initialDiagonal = getDiagonal(x, y);
      },
      onMove: (x, y, deltaX, deltaY) => {
        const conversionFactor = this.rotationState % 2 ? initialHeight / initialWidth : 1;

        if (absoluteSizing) {
          const {
            width,
            height
          } = element.getBoundingClientRect();
          resize(element, (width + deltaX) * conversionFactor, (height + deltaY) / conversionFactor);
        } else {
          const newWidth = getDiagonal(x, y) / initialDiagonal * initialWidth;
          resize(element, newWidth * conversionFactor);
        }
      }
    });
  }

  makeMovable(element, dragInitiater = element) {
    if (!showImages_module.options.imageMove.value) return;
    element.classList.add('res-media-movable');
    addDragListener({
      media: this.element,
      element: dragInitiater,
      atShiftKey: true,

      onMove(x, y, deltaX, deltaY) {
        showImages_move(element, deltaX, deltaY);
      }

    });
  }

  addControls(element, lookupUrl, downloadUrl) {
    if (!showImages_module.options.mediaControls.value) return element;
    const [y, x] = showImages_module.options.mediaControlsPosition.value.split('-');
    const wrapper = mediaControlsTemplate({
      clippy: showImages_module.options.clippy.value,
      lookupUrl,
      downloadUrl,
      x,
      y
    });
    element.replaceWith(wrapper);
    wrapper.appendChild(element);
    element.classList.add('res-media-rotatable');

    const compensateTransformedSize = () => {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      Object.assign(wrapper.style, {
        width: `${width}px`,
        height: `${height}px`
      });
    };

    const compensateTransformedSizeObserver = new ResizeObserver(compensateTransformedSize);

    const updateRotation = () => {
      compensateTransformedSizeObserver.observe(element);
      element.setAttribute('rotation', String(positiveModulo(this.rotationState, 4)));
      compensateTransformedSize();
    };

    wrapper.querySelector('.res-media-controls').addEventListener('click', e => {
      switch (e.target.dataset.action) {
        case 'rotateLeft':
          --this.rotationState;
          updateRotation();
          break;

        case 'rotateRight':
          ++this.rotationState;
          updateRotation();
          break;

        case 'download':
          permissions_namespaceObject.request(['downloads']).then(() => {
            const re = /(?:\.([^.]+))?$/;
            const ext = re.exec(downloadUrl);
            const thing = Thing_Thing.from(wrapper);
            let title = thing && thing.getTitle();

            if (title && ext) {
              let extension = ext[1];
              if (extension.includes('?')) extension = extension.split('?')[0];
              title = title.replace(/[*|?:"<>\\\/]/gi, '');
              const filename = `${title}.${extension}`;
              download(downloadUrl, filename);
            } else download(downloadUrl);
          });
          break;

        case 'imageLookup':
          lookupUrl = new URL(downcast(lookupUrl, 'string'), location.href).href;
          openNewTab(string_namespaceObject.encode`https://images.google.com/searchbyimage?image_url=${lookupUrl}`);
          break;

        case 'showImageSettings':
          settingsNavigation_open(showImages_module.moduleID, 'mediaControls');
          break;

        case 'clippy':
          e.target.textContent = [showImages_module.options.imageZoom.value && 'drag to resize', showImages_module.options.imageMove.value && 'shift-drag to move'].filter(Boolean).join(' or ');
          showImages_module.options.clippy.value = false;
          options_save(showImages_module.options.clippy);
          break;

        default:
          break;
      }

      e.stopPropagation();
      e.preventDefault();
    });
    return wrapper;
  }

}

class showImages_Gallery extends showImages_Media {
  constructor(options, context) {
    super();
    this.filmstripLoadIncrement = parseInt(showImages_module.options.filmstripLoadIncrement.value, 10) || Infinity;
    this.preloadCount = parseInt(showImages_module.options.galleryPreloadCount.value, 10) || 0;
    this.individualCtrl = void 0;
    this.msgPosition = void 0;
    this.ctrlToFilmstrip = void 0;
    this.ctrlConcurrentIncrease = void 0;
    this.pieces = void 0;
    this.lastRevealedPiece = null;
    this.filmstripActive = void 0;
    this.rememberResizeWidth = void 0;
    this.lastResizedWidth = void 0;
    this.element = galleryTemplate({
      title: options.title,
      caption: options.caption,
      credits: options.credits,
      src: options.src
    });
    const piecesContainer = this.element.querySelector('.res-gallery-pieces');
    this.individualCtrl = this.element.querySelector('.res-step-container');
    const ctrlPrev = this.individualCtrl.querySelector('.res-step-previous');
    const ctrlNext = this.individualCtrl.querySelector('.res-step-next');
    this.msgPosition = this.individualCtrl.querySelector('.res-step-position');
    this.ctrlToFilmstrip = this.individualCtrl.querySelector('.res-gallery-to-filmstrip');
    this.ctrlConcurrentIncrease = this.element.querySelector('.res-gallery-increase-concurrent');
    this.pieces = options.src.map(src => ({
      generateMedia: () => generateMedia(src, context),
      media: null,
      wrapper: document.createElement('div')
    }));
    piecesContainer.append(...this.pieces.map(({
      wrapper
    }) => wrapper));
    const slideshowWhenLargerThan = parseInt(showImages_module.options.useSlideshowWhenLargerThan.value, 10) || Infinity;
    this.filmstripActive = showImages_module.options.galleryAsFilmstrip.value && this.pieces.length < slideshowWhenLargerThan;

    if (this.filmstripActive || this.pieces.length === 1) {
      this.ready = this.expandFilmstrip();
      this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
    } else {
      this.ready = this.changeSlideshowPiece(0);
      ctrlPrev.addEventListener('click', () => {
        this.changeSlideshowPiece(-1);
      });
      ctrlNext.addEventListener('click', () => {
        this.changeSlideshowPiece(1);
      });
      waitForEvent(this.ctrlToFilmstrip, 'click').then(() => {
        this.expandFilmstrip();
        this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
      });
    }
  }

  shouldRememberResizeWidth() {
    return showImages_module.options.galleryRememberWidth.value && !this.filmstripActive;
  }

  rememberWidth(piece) {
    const resizedElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    const resizedWidth = resizedElement && parseInt(resizedElement.style.width, 10);
    if (resizedWidth) this.lastResizedWidth = resizedWidth;
  }

  restoreWidth(piece) {
    if (!this.lastResizedWidth) return;
    const resizeElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    if (resizeElement) resize(resizeElement, this.lastResizedWidth);
  }

  revealPiece(piece) {
    if (this.shouldRememberResizeWidth() && this.lastRevealedPiece) this.rememberWidth(this.lastRevealedPiece);
    this.lastRevealedPiece = piece;
    piece.media = piece.media || piece.generateMedia();
    const {
      media,
      wrapper
    } = piece;
    if (!media.isAttached()) wrapper.appendChild(media.element);
    wrapper.hidden = false;
    if (this.shouldRememberResizeWidth()) this.restoreWidth(piece);
    if (this.isAttached()) media.expand();
  }

  preloadAhead() {
    const preloadFrom = this.pieces.indexOf(this.lastRevealedPiece);
    const preloadTo = Math.min(preloadFrom + this.preloadCount + 1, this.pieces.length);
    return preloadMedia(this.pieces.slice(preloadFrom, preloadTo));
  }

  async expandFilmstrip() {
    this.individualCtrl.remove();
    const revealFrom = this.lastRevealedPiece ? this.pieces.indexOf(this.lastRevealedPiece) : 0;
    const revealTo = Math.min(revealFrom + this.filmstripLoadIncrement, this.pieces.length);
    this.ctrlConcurrentIncrease.hidden = true;
    await forEachSeq(this.pieces.slice(revealFrom, revealTo), piece => {
      this.revealPiece(piece);
      return piece.media && piece.media.ready;
    });

    if (revealTo < this.pieces.length) {
      this.ctrlConcurrentIncrease.innerText = `Show next ${Math.min(this.filmstripLoadIncrement, this.pieces.length - revealTo)} pieces`;
      this.ctrlConcurrentIncrease.hidden = false;
    }

    return this.preloadAhead();
  }

  changeSlideshowPiece(step) {
    const previous = this.lastRevealedPiece;
    const previousIndex = previous ? this.pieces.indexOf(previous) : 0;
    let newIndex = previousIndex + step;
    newIndex = positiveModulo(newIndex, this.pieces.length);
    this.individualCtrl.setAttribute('first-piece', String(newIndex === 0));
    this.individualCtrl.setAttribute('last-piece', String(newIndex === this.pieces.length - 1));
    this.msgPosition.innerText = String(newIndex + 1);
    this.revealPiece(this.pieces[newIndex]);

    if (previous) {
      const {
        media,
        wrapper
      } = previous;
      if (!media) throw new Error();
      media.collapse();
      wrapper.hidden = true;
    }

    return this.preloadAhead();
  }

  supportsUnload() {
    return this.pieces.every(({
      media
    }) => !media || media.supportsUnload()) || false;
  }

  setLoaded(state) {
    for (const {
      media
    } of this.pieces) {
      if (media) media.setLoaded(state);
    }
  }

}

class showImages_Image extends showImages_Media {
  constructor({
    title,
    caption,
    credits,
    src,
    href
  }, context) {
    super();
    this.image = void 0;
    this.src = void 0;
    this.src = src;
    this.element = imageTemplate({
      title,
      caption,
      credits,
      src,
      href: href || context.href,
      openInNewWindow: showImages_module.options.openInNewWindow.value
    });
    this.image = downcast(this.element.querySelector('img.res-image-media'), HTMLImageElement);
    const anchor = this.element.querySelector('a.res-expando-link');
    this.ready = waitForEvent(this.image, 'load', 'error');
    this.image.addEventListener('error', () => {
      this.element.classList.add('res-media-load-error');
    });

    if (showImages_module.options.displayOriginalResolution.value) {
      this.image.addEventListener('load', () => {
        this.image.title = `${this.image.naturalWidth}  ${this.image.naturalHeight} px`;
      });
    }

    this.setMaxSize(this.image);
    const wrapper = this.addControls(anchor, src, src);
    this.makeZoomable(this.image);
    this.makeMovable(wrapper);
    this.keepVisible(wrapper);
    this.makeIndependent(wrapper);
  }

  supportsUnload() {
    return true;
  }

  _unload() {
    this.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
  }

  _restore() {
    this.image.src = this.src;
  }

}

class showImages_Iframe extends showImages_Media {
  constructor({
    embed,
    embedAutoplay,
    width = '640px',
    height = '360px',
    fixedRatio = false,
    pause: pauseCommand,
    play: playCommand
  }) {
    super();
    this.loaded = false;
    this.iframe = void 0;
    this.pauseCommand = void 0;
    this.playCommand = void 0;
    this.pauseCommand = pauseCommand;
    this.playCommand = playCommand;
    this.element = iframeTemplate({
      url: showImages_module.options.autoplayVideo.value && embedAutoplay ? embedAutoplay : embed,
      width,
      height
    });
    this.iframe = downcast(this.element.querySelector('iframe'), HTMLIFrameElement);
    const iframeWrapper = downcast(this.element.firstElementChild, HTMLElement);
    const dragHandle = this.element.querySelector('.res-iframe-expando-drag-handle');
    this.makeZoomable(this.iframe, dragHandle, !fixedRatio);
    this.makeMovable(iframeWrapper, dragHandle);
    this.keepVisible(iframeWrapper);
    this.makeIndependent(iframeWrapper);
  }

  async expand() {
    if (showImages_module.options.autoplayVideo.value && this.playCommand) {
      if (!this.loaded) await waitForEvent(this.iframe, 'load');
      this.loaded = true;

      try {
        this.iframe.contentWindow.postMessage(this.playCommand, '*');
      } catch (e) {
        console.error('Could not post "play" command to iframe', this, e);
      }
    }
  }

  collapse() {
    if (this.pauseCommand) {
      try {
        this.iframe.contentWindow.postMessage(this.pauseCommand, '*');
        return;
      } catch (e) {
        console.error('Could not post "pause" command to iframe', this, e);
      }
    }

    this.element.remove();
  }

}

class showImages_Text extends showImages_Media {
  constructor({
    title,
    credits,
    src
  }) {
    super();
    this.element = textTemplate({
      title,
      credits,
      src: Object(purify["sanitize"])(src)
    });
  }

}

class showImages_Audio extends showImages_Media {
  constructor({
    autoplay = false,
    loop,
    sources
  }) {
    super();
    this.autoplay = void 0;
    this.audio = void 0;
    this.autoplay = autoplay;
    this.element = audioTemplate({
      loop,
      sources
    });
    this.audio = downcast(this.element.querySelector('audio'), HTMLAudioElement);
  }

  collapse() {
    if (!this.isAttached()) return;
    this.autoplay = !this.audio.paused;
    if (!this.audio.paused) this.audio.pause();
  }

  expand() {
    if (this.autoplay) this.audio.play();
  }

}

class Generic extends showImages_Media {
  constructor(options) {
    super();
    this.onAttach = options.onAttach;
    this.element = document.createElement('div');
    this.element.appendChild(options.generate());
  }

  collapse() {
    this.element.remove();
  }

}

const trackVisitNative = batch(async things => {
  if (!document.body.classList.contains('gold')) return;
  if (isPrivateBrowsing()) return;
  await ajax({
    method: 'POST',
    url: '/api/store_visits',
    data: {
      links: things.map(t => t.getFullname()).join(',')
    }
  });
}, {
  delay: 10000,
  size: 50
});

function trackMediaLoad(link, thing) {
  if (!showImages_module.options.markVisited.value) return;
  if (thing) trackVisitNative(thing);

  if (!(thing && thing.isNSFW() && showImages_module.options.sfwHistory.value !== 'add')) {
    addURLToHistory(link.href);
  }
}

function addSiteAttribution(siteModule, media) {
  const $element = jquery_default()(siteAttributionTemplate({
    name: siteModule.name,
    url: siteModule.landingPage || `https://${siteModule.domains[0]}`,
    logoUrl: siteModule.logo,
    settingsLink: makeUrlHash(showImages_module.moduleID, siteModuleOptionKey(siteModule))
  }));
  const $replace = jquery_default()('.res-expando-siteAttribution', media.element);

  if ($replace.length) {
    $element.replaceAll($replace);
  } else {
    $element.addClass('res-expando-siteAttribution-generic').appendTo(media.element);
  }
}

function addDragListener({
  media,
  element,
  atShiftKey,
  onStart,
  onMove
}) {
  let hasFrameExecution = false;

  const setFrameExecution = (() => {
    const throttle = frameThrottle(() => {
      hasFrameExecution = false;
    });
    return () => {
      throttle();
      hasFrameExecution = true;
    };
  })();

  let isActive, hasMoved, lastX, lastY;

  const handleMove = e => {
    const movementX = e.clientX - lastX;
    const movementY = e.clientY - lastY;

    if (!movementX && !movementY) {
      return;
    } else if (1 & ~e.buttons) {
      stop();
      return;
    } else if (atShiftKey !== e.shiftKey) {
      isActive = false;
      ({
        clientX: lastX,
        clientY: lastY
      } = e);
      return;
    }

    if (!isActive) {
      if (onStart) onStart(lastX, lastY);
      isActive = true;
      hasMoved = true;
      requestAnimationFrame(() => {
        media.classList.add('res-media-dragging');
      });
    }

    if (hasFrameExecution) return;
    setFrameExecution();
    onMove(e.clientX, e.clientY, movementX, movementY);
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
  };

  function handleClick(e) {
    if (hasMoved) e.preventDefault();
  }

  function stop() {
    requestAnimationFrame(() => {
      media.classList.remove('res-media-dragging');
    });
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', stop);
    setTimeout(() => document.removeEventListener('click', handleClick));
  }

  element.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
    hasMoved = false;
    isActive = false;
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', stop);
    document.addEventListener('click', handleClick);
    e.preventDefault();
  });
}

const mutedVideoManager = lodash_once_default()(() => {
  const maxSimultaneousPlaying = parseInt(showImages_module.options.maxSimultaneousPlaying.value, 10) || Infinity;
  const videos = [];
  const updatePlay = frameThrottle(() => {
    const all = videos.map(video => {
      const thing = Thing_Thing.from(video);
      return {
        video,
        visibility: getPercentageVisibleYAxis(video),
        top: video.getBoundingClientRect().top,
        selected: Number(thing && thing.isSelected())
      };
    });
    const notVisible = all.filter(({
      visibility
    }) => visibility === 0);

    for (const {
      video
    } of notVisible) if (!video.paused) video.pause();

    without_default()(all, ...notVisible).sort((a, b) => b.selected - a.selected || b.visibility - a.visibility || a.top - b.top).forEach(({
      video
    }, index) => {
      const play = index < maxSimultaneousPlaying;

      if (play === video.paused) {
        if (play) video.play();else video.pause();
      }
    });
  });
  let intervalId = null;
  return {
    observe(video) {
      videos.push(video);
      updatePlay();
      if (intervalId === null) intervalId = setInterval(updatePlay, 100);
    },

    unobserve(video) {
      pull_default()(videos, video);

      if (!videos.length && intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    }

  };
});

class showImages_Video extends showImages_Media {
  constructor({
    title,
    caption,
    credits,
    fallback,
    frameRate = 24,
    href,
    loop = false,
    muted = false,
    playbackRate = 1,
    poster,
    reversable = false,
    reversed = false,
    source,
    sources,
    time = 0
  }, context) {
    super();
    this.video = void 0;
    this.autoplay = void 0;
    this.time = void 0;
    this.frameRate = void 0;
    this.useVideoManager = void 0;
    this.useVideoManager = showImages_module.options.onlyPlayMutedWhenVisible.value && muted;
    this.autoplay = muted || showImages_module.options.autoplayVideo.value;
    this.time = time;
    this.frameRate = frameRate;
    this.element = videoTemplate({
      title,
      caption,
      credits,
      href: href || context.href,
      source,
      poster: !this.autoplay && poster || '',
      hasAudio: !muted,
      loop,
      reversable,
      openInNewWindow: showImages_module.options.openInNewWindow.value,
      formattedPlaybackRate: this.formatMultilineNumber(playbackRate, 'x')
    });
    this.video = downcast(this.element.querySelector('video'), HTMLVideoElement);
    const container = this.element.querySelector('.res-video-container');
    const msgError = this.element.querySelector('.res-video-error');

    const displayError = error => {
      if (msgError.hidden) {
        msgError.hidden = false;
        jquery_default()('<span>').text(`Could not play video: ${error.message ? String(error.message) : 'Unknown error'}`).appendTo(msgError);
      }
    };

    const sourceElements = jquery_default()(compact_default()(sources.map(v => {
      if (!this.video.canPlayType(v.type)) return null;
      const source = document.createElement('source');
      source.src = v.source;
      source.type = v.type;
      if (v.reverse) source.dataset.reverse = v.reverse;
      return source;
    }))).appendTo(this.video).get();

    if (!sourceElements.length) {
      if (fallback) {
        return new showImages_Image({
          type: 'IMAGE',
          title,
          caption,
          credits,
          src: fallback
        }, context);
      } else {
        displayError(new Error('No playable sources were found'));
      }
    }

    const lastSource = sourceElements[sourceElements.length - 1];
    lastSource.addEventListener('error', displayError);
    if (reversed) this.reverse();
    this.ready = Promise.race([waitForEvent(this.video, 'suspend'), waitForEvent(lastSource, 'error')]);

    const setPlayIcon = () => {
      if (!this.video.paused) this.element.setAttribute('playing', '');else this.element.removeAttribute('playing');
    };

    this.video.addEventListener('pause', () => {
      setPlayIcon();
      if (this.video.controls && this.useVideoManager) mutedVideoManager().unobserve(this.video);
    });
    this.video.addEventListener('play', setPlayIcon);
    this.video.addEventListener('loadedmetadata', () => {
      if (this.time !== this.video.currentTime) this.video.currentTime = this.time;
    });
    this.video.playbackRate = playbackRate;
    this.video.addEventListener('mousedown', e => {
      if (this.video.hasAttribute('controls')) {
        const {
          height,
          top
        } = this.video.getBoundingClientRect();

        if (height - 0 < e.clientY - top) {
          e.stopImmediatePropagation();
        }
      }
    });
    Promise.all([waitForEvent(this.element, 'mouseenter'), waitForEvent(this.video, 'loadedmetadata')]).then(() => this.addVideoControls());
    new MutationObserver(() => this.element.classList.toggle('res-video-has-native-controls', this.video.hasAttribute('controls'))).observe(this.video, {
      attributes: true
    });

    if (!loop && this.autoplay) {
      waitForEvent(this.video, 'ended').then(() => this.stopAutoplay());
    }

    if (!muted) {
      if (showImages_module.options.startVideosMuted.value) this.video.muted = true;
      Promise.all([waitForEvent(this.video, 'canplay'), showImages_Video.volumeStorage.get()]).then(([, volume]) => {
        this.video.volume = volume;
      });
    }

    this.setMaxSize(this.video);
    this.makeZoomable(this.video);
    this.addControls(this.video, undefined, sources[0].source);
    this.makeMovable(container);
    this.keepVisible(container);
    this.makeIndependent(container);
  }

  reverse() {
    this.time = this.video.duration - this.video.currentTime;
    if (isNaN(this.time)) this.time = 0;

    for (const v of this.video.querySelectorAll('source')) {
      [v.src, v.dataset.reverse] = [v.dataset.reverse, v.src];
    }

    this.video.load();
    this.video.play();
    this.element.toggleAttribute('reversed');
  }

  formatMultilineNumber(value, suffix) {
    return `${value.toFixed(2).replace('.', '.\u200B')}${suffix}`;
  }

  addVideoControls() {
    const ctrlContainer = this.element.querySelector('.res-video-controls');
    const ctrlReverse = ctrlContainer.querySelector('.res-video-reverse');
    const ctrlTogglePause = ctrlContainer.querySelector('.res-video-toggle-pause');
    const ctrlSpeedDecrease = ctrlContainer.querySelector('.res-video-speed-decrease');
    const ctrlSpeedIncrease = ctrlContainer.querySelector('.res-video-speed-increase');
    const ctrlTimeDecrease = ctrlContainer.querySelector('.res-video-time-decrease');
    const ctrlTimeIncrease = ctrlContainer.querySelector('.res-video-time-increase');
    const progress = this.element.querySelector('.res-video-progress');
    const indicatorPosition = progress.querySelector('.res-video-position');
    const ctrlPosition = progress.querySelector('.res-video-position-thumb');
    const msgSpeed = ctrlContainer.querySelector('.res-video-speed');
    const msgTime = ctrlContainer.querySelector('.res-video-time');
    ctrlTogglePause.addEventListener('click', () => {
      if (this.video.paused) this.video.play();else this.video.pause();
      if (this.video.paused) this.stopAutoplay();
    });
    if (ctrlReverse) ctrlReverse.addEventListener('click', () => this.reverse());
    ctrlSpeedDecrease.addEventListener('click', () => {
      this.video.playbackRate /= 1.1;
    });
    ctrlSpeedIncrease.addEventListener('click', () => {
      this.video.playbackRate *= 1.1;
    });
    ctrlTimeDecrease.addEventListener('click', () => {
      this.video.currentTime -= 1 / this.frameRate;
    });
    ctrlTimeIncrease.addEventListener('click', () => {
      this.video.currentTime += 1 / this.frameRate;
    });
    this.video.addEventListener('ratechange', () => {
      msgSpeed.textContent = this.formatMultilineNumber(this.video.playbackRate, 'x');
    });
    this.video.addEventListener('timeupdate', () => {
      indicatorPosition.style.left = `${this.video.currentTime / this.video.duration * 100}%`;
      msgTime.textContent = this.formatMultilineNumber(this.video.currentTime, 's');
    });
    progress.addEventListener('mousemove', e => {
      let left = e.offsetX;

      if (e.target === ctrlPosition) {
        left += e.target.offsetLeft;
      }

      ctrlPosition.style.left = `${left}px`;
      if (e.buttons === 1) ctrlPosition.click();
    });
    ctrlPosition.addEventListener('click', e => {
      const percentage = (e.target.offsetLeft + e.target.clientWidth / 2) / progress.clientWidth;
      this.video.currentTime = this.video.duration * percentage;
    });
    const ctrlVolume = ctrlContainer.querySelector('.res-video-volume');

    if (ctrlVolume) {
      const ctrlVolumeLevel = ctrlVolume.querySelector('.res-video-volume-level');
      const volumePercentage = ctrlVolume.querySelector('.res-video-volume-percentage');

      const updateVolume = e => {
        const base = ctrlVolumeLevel.clientHeight;
        const click = base - e.offsetY;
        const level = Math.min(click / base, 1);

        if (level > 0.05) {
          this.video.volume = level;
          this.video.muted = false;
          showImages_Video.volumeStorage.set(level);
        } else {
          this.video.muted = true;
        }
      };

      ctrlVolume.addEventListener('click', () => {
        this.video.muted = !this.video.muted;
      });
      ctrlVolumeLevel.addEventListener('mousemove', e => {
        if (e.buttons === 1) updateVolume(e);
      });
      ctrlVolumeLevel.addEventListener('click', e => {
        updateVolume(e);
        e.stopPropagation();
      });

      const refresh = () => {
        ctrlVolume.setAttribute('level', this.video.muted || !this.video.volume ? '0' : String(Math.ceil(this.video.volume * 3)));
        volumePercentage.style.height = `${this.video.volume * 100}%`;
      };

      this.video.addEventListener('volumechange', refresh);
      refresh();
    }
  }

  stopAutoplay() {
    this.autoplay = false;
    if (this.useVideoManager) mutedVideoManager().unobserve(this.video);
  }

  supportsUnload() {
    return this.video.paused;
  }

  _unload() {
    if (!this.isAttached()) return;
    if (!this.video.paused) this.video.pause();
    this.time = this.video.currentTime;
    this.video.setAttribute('src', '');
    this.video.load();
    if (this.useVideoManager) mutedVideoManager().unobserve(this.video);
  }

  _restore() {
    if (this.video.hasAttribute('src')) {
      this.video.removeAttribute('src');
      this.video.load();
    }

    this.video.currentTime = this.time;

    if (this.autoplay) {
      if (this.useVideoManager) mutedVideoManager().observe(this.video);else this.video.play();
    }
  }

}

showImages_Video.volumeStorage = storage_namespaceObject.wrap('showImages.video.volume', 1);
function showImages_move(ele, deltaX, deltaY) {
  ele.style.marginLeft = `${((parseFloat(ele.style.marginLeft) || 0) + deltaX).toFixed(2)}px`;
  ele.style.marginTop = `${((parseFloat(ele.style.marginTop) || 0) + deltaY).toFixed(2)}px`;
  if (deltaY) ele.dispatchEvent(new CustomEvent('mediaManuallyMovedVertically', {
    bubbles: true
  }));
}
function resize(ele, newWidth, newHeight) {
  if (newWidth < 20) return;

  if (typeof newHeight === 'number') {
    ele.style.height = `${newHeight}px`;
  } else if (ele.style.height) {
    const {
      width,
      height
    } = ele.getBoundingClientRect();
    ele.style.height = `${(height / width * newWidth).toFixed(2)}px`;
  }

  ele.style.width = `${newWidth}px`;
  ele.style.maxWidth = ele.style.maxHeight = 'none';
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Expando.js



class Expando_Expando extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = this.conditions.types.length ? `expando ${this.conditions.types.join('|')}` : 'expando';
  }

  static parseCriterion(input) {
    return {
      types: input.split(/[\s|]/).filter(Boolean)
    };
  }

  static thingToCriterion(thing) {
    const expando = thing.isPost() ? expando_Expando.getEntryExpandoFrom(thing) : expando_Expando.getTextExpandosFrom(thing)[0];
    return expando && expando.types.join(' & ') || '';
  }

  isValid() {
    return matchesTypes(this.value.types);
  }

  _matches(e) {
    if (!e) return false;
    if (!e.ready) return null;
    return matchesTypes(this.value.types, e.types);
  }

  _waitTillReady(thing) {
    const completeTask = thing.tasks.byId.get(showImages_module);

    if (completeTask) {
      const promise = completeTask();
      if (!(promise instanceof Promise)) return;
      return Promise.race([promise.catch(() => {}), new Promise((res, rej) => setTimeout(rej, 1500))]).catch(() => {
        promise.finally(() => {
          this.refresh();
        });
      });
    }
  }

  async evaluate(thing) {
    await this._waitTillReady(thing);

    if (thing.isPost()) {
      const expando = expando_Expando.getEntryExpandoFrom(thing);
      return this._matches(expando);
    } else {
      const expandos = expando_Expando.getTextExpandosFrom(thing);
      const res = expandos.map(this._matches.bind(this));
      if (res.some(Boolean)) return true;
      if (res.some(v => v === null)) return null;
      return false;
    }
  }

  onObserve() {
    return true;
  }

}
Expando_Expando.text = 'Expando';
Expando_Expando.defaultConditions = {
  types: []
};
Expando_Expando.fields = ['post has expando, and (if specified) expando types intersects with ', {
  type: 'checkset',
  items: showImages_types,
  id: 'types'
}];
Expando_Expando.slow = 9;
Expando_Expando.pattern = `[(${showImages_types.join('|')})]`;
Expando_Expando.criterionOperators = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsLocked.js

class IsLocked_IsLocked extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'locked';
  }

  evaluate(thing) {
    return thing.isLocked();
  }

}
IsLocked_IsLocked.text = 'Locked';
IsLocked_IsLocked.fields = ['post is locked'];
IsLocked_IsLocked.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsNSFW.js

class IsNSFW_IsNSFW extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'nsfw';
  }

  evaluate(thing) {
    return thing.isNSFW();
  }

}
IsNSFW_IsNSFW.text = 'NSFW';
IsNSFW_IsNSFW.fields = ['post is marked NSFW'];
IsNSFW_IsNSFW.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsSpoiler.js

class IsSpoiler_IsSpoiler extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'spoiler';
  }

  evaluate(thing) {
    return thing.isSpoiler();
  }

}
IsSpoiler_IsSpoiler.text = 'Spoiler';
IsSpoiler_IsSpoiler.fields = ['post is marked spoiler'];
IsSpoiler_IsSpoiler.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsVisited.js


class IsVisited_IsVisited extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'visited';
  }

  evaluate(thing) {
    if (thing.element.classList.contains('visited')) return true;
    const link = thing.getPostLink();
    if (!link) return null;
    return isURLVisited(link.href);
  }

}
IsVisited_IsVisited.text = 'Visited';
IsVisited_IsVisited.fields = ['link has been visited'];
IsVisited_IsVisited.slow = 2;
IsVisited_IsVisited.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/LinkFlair.js

class LinkFlair_LinkFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `link flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getPostFlairText();
  }

  evaluate(thing) {
    const text = thing.getPostFlairText();
    return this.value.some(v => v.test(text));
  }

}
LinkFlair_LinkFlair.text = 'Link flair';
LinkFlair_LinkFlair.fields = ['post has link flair matching ', {
  type: 'text',
  id: 'patt'
}];
LinkFlair_LinkFlair.pattern = '[RegEx]';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAfter.js

class PostAfter_PostAfter extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `after ${this.conditions.patt}`;
    this.value = new Date(this.conditions.patt);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static thingToCriterion(thing) {
    return thing.getTimestamp().toISOString();
  }

  isValid() {
    return !isNaN(this.value);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return postTime >= this.value;
  }

}
PostAfter_PostAfter.text = 'Post after';
PostAfter_PostAfter.defaultConditions = {
  patt: new Date().toISOString()
};
PostAfter_PostAfter.fields = ['posted after date ', {
  type: 'text',
  id: 'patt'
}];
PostAfter_PostAfter.pattern = 'Date  string representing a RFC2822 or ISO 8601 date';
// EXTERNAL MODULE: ./node_modules/lodash/dropWhile.js
var dropWhile = __webpack_require__(124);
var dropWhile_default = /*#__PURE__*/__webpack_require__.n(dropWhile);

// EXTERNAL MODULE: ./node_modules/lodash/head.js
var lodash_head = __webpack_require__(74);
var head_default = /*#__PURE__*/__webpack_require__.n(lodash_head);

// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAge.js




const qualifiers = [['Y', 12], ['M', 30.44], ['d', 24], ['h', 60], ['m', 60], ['s', 1000]];
const PostAge_now = new Date();

function prettifyAge(remainder) {
  let remainderQualifier = '';

  for (const [qualifier, multiplier] of qualifiers.slice().reverse()) {
    if (remainder < multiplier) break;
    remainder /= multiplier;
    remainderQualifier = qualifier;
  }

  return remainder.toFixed(2) + remainderQualifier;
}

class PostAge_PostAge extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `age ${prettyOperator(this.conditions.op)} ${prettifyAge(this.conditions.age)}`;
    this.falseText = `age ${prettyOperator(inverseOperator(this.conditions.op))} ${prettifyAge(this.conditions.age)}`;
  }

  static parseCriterion(input) {
    let age = parseInt(input, 10);
    if (isNaN(age)) throw new Error('Invalid age');
    const ageQualifier = head_default()(input.match(/Y|M|d|h|m|s/)) || 's';
    age = dropWhile_default()(qualifiers, ([qualifier]) => qualifier !== ageQualifier).reduce((a, [, multiplier]) => a * multiplier, age);
    return {
      op: '<=',
      age
    };
  }

  static thingToCriterion(thing) {
    const remainder = PostAge_now - new Date(thing.getTimestamp());
    if (isNaN(remainder)) throw new Error('Could not determine Thing date');
    return prettifyAge(remainder);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return numericalCompare(this.value.op, PostAge_now - postTime, this.value.age);
  }

}
PostAge_PostAge.text = 'Post age';
PostAge_PostAge.defaultConditions = {
  op: '<=',
  age: 4 * 60 * 60 * 1000
};
PostAge_PostAge.fields = ['post is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'duration',
  id: 'age'
}, ' old'];
PostAge_PostAge.pattern = 'x[(Y|M|d|h|m)]  where x is the number of seconds or Y year, M month, h hour, m minute (case sensitive)';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostTitle.js

class PostTitle_PostTitle extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `title contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  evaluate(thing) {
    const title = thing.getTitle();
    return this.value.some(v => v.test(title));
  }

}
PostTitle_PostTitle.text = 'Post title';
PostTitle_PostTitle.fields = ['post\'s title contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostType.js

const PostType_options = [['link post', 'link'], ['self post', 'self']];
class PostType_PostType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `type ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return PostType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'link':
        return thing.isLinkPost();

      case 'self':
        return thing.isSelfPost();

      default:
        return null;
    }
  }

}
PostType_PostType.text = 'Post type';
PostType_PostType.defaultConditions = {
  kind: 'link'
};
PostType_PostType.fields = ['post is a ', {
  type: 'select',
  id: 'kind',
  options: PostType_options
}];
PostType_PostType.pattern = `(${PostType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Score.js


class Score_Score extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `score ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `score ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getScore());
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const score = thing.getScore();
    if (isNaN(score)) return null;
    return numericalCompare(this.value.op, score, this.value.val);
  }

}
Score_Score.text = 'Score';
Score_Score.defaultConditions = {
  op: '>',
  val: 0
};
Score_Score.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' points'];
Score_Score.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Selector.js


class Selector_Selector extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `$('${this.conditions.patt.replace(/\'/g, '\\\'')}')`;
    this.falseText = `$(':not(${this.conditions.patt.replace(/\'/g, '\\\'')}'))`;
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  isValid() {
    return this.value.patt && !!jquery_default()(this.value.patt);
  }

  evaluate(thing) {
    return jquery_default()(thing.element).is(this.value.patt) || jquery_default()(thing.entry).is(this.value.patt) || !!jquery_default()(thing.entry).has(this.value.patt).length;
  }

}
Selector_Selector.text = 'Selector';
Selector_Selector.defaultConditions = {
  patt: ''
};
Selector_Selector.fields = ['thing matches jQuery selector ', {
  type: 'text',
  id: 'patt'
}];
Selector_Selector.slow = 10;
Selector_Selector.pattern = 'string';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Subreddit.js

class Subreddit_Subreddit extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `in ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getSubreddit();
  }

  evaluate(thing) {
    const subreddit = thing.getSubreddit();
    if (!subreddit) return null;
    return this.value.some(v => v.test(subreddit));
  }

}
Subreddit_Subreddit.text = 'Subreddit';
Subreddit_Subreddit.fields = ['posted in /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserAttr.js


const UserAttr_options = [['a friend', 'friend'], ['a moderator', 'moderator'], ['an admin', 'admin'], ['me', 'me'], ['op', 'submitter']];
class UserAttr_UserAttr extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.attr}`;
  }

  static parseCriterion(input) {
    return {
      attr: input
    };
  }

  isValid() {
    return UserAttr_options.map(([, cls]) => cls).includes(this.value.attr);
  }

  evaluate(thing) {
    if (this.value.attr === 'me') {
      const myName = loggedInUser();
      const author = thing.getAuthor();
      if (!myName || !author) return null;
      return author.trim().toLowerCase() === myName.trim().toLowerCase();
    } else {
      const element = thing.getAuthorElement();
      if (!element) return null;
      return element.classList.contains(this.value.attr);
    }
  }

}
UserAttr_UserAttr.text = 'User attribute';
UserAttr_UserAttr.fields = ['user is ', {
  type: 'select',
  id: 'attr',
  options: UserAttr_options
}];
UserAttr_UserAttr.defaultConditions = {
  attr: 'friend'
};
UserAttr_UserAttr.pattern = `(${UserAttr_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserFlair.js

class UserFlair_UserFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `user flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getUserFlairText();
  }

  evaluate(thing) {
    const text = thing.getUserFlairText();
    return this.value.some(v => v.test(text));
  }

}
UserFlair_UserFlair.text = 'User flair';
UserFlair_UserFlair.fields = ['author of this post has flair matching ', {
  type: 'text',
  id: 'patt'
}];
UserFlair_UserFlair.pattern = '[RegEx]';
// EXTERNAL MODULE: ./node_modules/lodash/fp/slice.js
var slice = __webpack_require__(125);
var slice_default = /*#__PURE__*/__webpack_require__.n(slice);

// EXTERNAL MODULE: ./node_modules/lodash/fp/mapValues.js
var mapValues = __webpack_require__(126);
var mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);

// EXTERNAL MODULE: ./node_modules/lodash/fp/filter.js
var fp_filter = __webpack_require__(55);
var filter_default = /*#__PURE__*/__webpack_require__.n(fp_filter);

// EXTERNAL MODULE: ./node_modules/lodash/zip.js
var lodash_zip = __webpack_require__(127);
var zip_default = /*#__PURE__*/__webpack_require__.n(lodash_zip);

// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(128);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// CONCATENATED MODULE: ./lib/modules/customToggles.js








const customToggles_module = new Module('customToggles');
customToggles_module.moduleName = 'customTogglesName';
customToggles_module.category = 'coreCategory';
customToggles_module.description = 'customTogglesDesc';
customToggles_module.options = {
  toggle: {
    description: 'customTogglesToggleDesc',
    title: 'customTogglesToggleTitle',
    type: 'table',
    fields: [{
      key: 'key',
      name: 'key',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'enabled',
      type: 'boolean',
      value: true
    }, {
      key: 'text',
      name: 'text',
      type: 'text'
    }],
    value: []
  }
};
const toggles = new Map();
const customToggles = [];

customToggles_module.beforeLoad = () => {
  for (const instance of customToggles_module.options.toggle.value) {
    const [key, initialEnabled, text] = instance;

    if (toggles.has(key)) {
      console.error(`A toggle with key ${key} already exists`, instance);
      continue;
    }

    const toggle = new customToggles_Toggle(key, text, initialEnabled);
    customToggles.push(toggle);
    toggle.onStateChange(() => {
      instance[1] = toggle.enabled;
      jquery_default()(customToggles_module).trigger(jquery_default.a.Event('toggle'));
    });
    toggle.onToggle(() => {
      options_save(customToggles_module.options.toggle);
    });
    toggle.addMenuItem();
  }
};

customToggles_module.contentStart = () => {
  registerCommandLine();
};

class customToggles_Toggle {
  constructor(key, text, enabled) {
    this.text = void 0;
    this.enabled = void 0;
    this.stateChangeCallbacks = [];
    this.toggleCallbacks = [];
    this.multicast = void 0;
    this.text = text;
    this.enabled = enabled;
    this.multicast = multicast(frameThrottle(enabled => {
      this.toggle('multicast', enabled);
    }), {
      local: false,
      name: `toggle.${key}`
    });
    toggles.set(key, this);
  }

  toggle(type = 'manual', state = !this.enabled) {
    if (this.enabled === state) return;
    this.enabled = state;

    for (const callback of this.stateChangeCallbacks) callback();

    if (type !== 'multicast') {
      for (const callback of this.toggleCallbacks) callback(type);

      this.multicast(state);
    }
  }

  onStateChange(callback) {
    this.stateChangeCallbacks.push(callback);
  }

  onToggle(callback) {
    this.toggleCallbacks.push(callback);
  }

  addMenuItem(title = `Toggle ${this.text}`, order = 9, on, off) {
    menu_addMenuItem(lodash_once_default()(() => {
      const item = string_namespaceObject.html`<div title="${title}">${this.text || '\u00A0'}</div>`;
      const toggle = createElement_namespaceObject.toggleButton(undefined, this.text, this.enabled, on, off);
      item.append(toggle);
      this.onStateChange(() => {
        toggle.classList.toggle('enabled', this.enabled);
      });
      return item;
    }), e => {
      this.toggle();
      e.stopPropagation();
    }, order);
  }

  addCLI(commandPredicate) {
    registerCommand(commandPredicate, `${commandPredicate} - toggle ${this.text}`, () => ` ${this.enabled ? 'Disable' : 'Enable'} ${this.text}`, () => {
      this.toggle();
    });
  }

  buildCheckbox() {
    const checkbox = document.createElement('input');
    checkbox.setAttribute('type', 'checkbox');
    checkbox.checked = this.enabled;
    checkbox.addEventListener('change', () => {
      this.toggle('manual', checkbox.checked);
    });
    this.onStateChange(() => {
      checkbox.checked = this.enabled;
    });
    return checkbox;
  }

}

function registerCommandLine() {
  const getToggles = val => Array.from(toggles.values()).filter(({
    text
  }) => text.startsWith(val)).sort(({
    text: a
  }, {
    text: b
  }) => a.localeCompare(b));

  registerCommand('toggle', 'toggle - toggle any custom toggle', (command, val) => getToggles(val).length ? `Toggle ${getToggles(val).map((toggle, i) => i === 0 ? `<b>${toggle.text}</b>` : toggle.text).join('|')}` : `No toggles matching <i>${val}</i>`, (command, val) => {
    const match = getToggles(val)[0];
    if (match) match.toggle();else return `${val} does not match a valid toggle`;
  });
}

function toggleActive(key) {
  const toggle = toggles.get(key);
  return !!toggle && toggle.enabled;
}
const customToggles_getToggles = () => (stage_namespaceObject.get(customToggles_module.moduleID) || customToggles_module.options).toggle.value.map(([key,, text]) => ({
  key,
  text
}));
// EXTERNAL MODULE: ./node_modules/lodash/union.js
var union = __webpack_require__(129);
var union_default = /*#__PURE__*/__webpack_require__.n(union);

// CONCATENATED MODULE: ./lib/modules/filteReddit/Filter.js



class Filter_Filter {
  constructor(id, BaseCase, name, conditions = null, state = true, effects = {}) {
    this.id = void 0;
    this.name = void 0;
    this.parent = void 0;
    this.updatePromise = void 0;
    this.BaseCase = void 0;
    this.case = void 0;
    this.state = void 0;
    this.active = false;
    this.element = void 0;
    this.effects = {};

    this.refresh = thing => {
      if (!this.parent) return;
      this.updatePromise = this.parent.refresh(this, thing ? [thing] : undefined);
    };

    this.matches = fastAsync(function* (thing) {
      try {
        const result = yield this.case.evaluate(thing);
        return result === null ? false : this.state === !result;
      } catch (e) {
        return false;
      }
    });
    this.id = id;
    this.BaseCase = BaseCase;
    this.name = name;
    this.state = state;
    Object.assign(this.effects, pickBy_default()(effects, Boolean));
    this.setCase(BaseCase.fromConditions(conditions));
  }

  isActive() {
    return !!this.getEffects().length && this.case.isEvaluatable();
  }

  createElement() {}

  setParent(parent) {
    this.parent = parent;
  }

  getStateText(state = this.state, cased = this.case) {
    return state !== false ? this.name || cased.trueText || (this.BaseCase.text || this.BaseCase.type).toLowerCase() : this.name && ` ${this.name}` || cased.falseText || ` ${this.getStateText(true, cased)}`;
  }

  getSaveValues() {
    const values = {
      type: this.BaseCase.type,
      state: this.state,
      effects: this.effects
    };

    if (this.BaseCase.variant === 'basic') {
      values.conditions = this.case.conditions;

      if (this.name && this.name !== this.case.trueText) {
        values.name = this.name;
      }
    }

    return values;
  }

  remove() {
    for (const effect of Object.keys(this.effects)) this.effects[effect] = false;

    if (this.parent) this.parent.removeFilter(this);
  }

  getEffects() {
    return Object.entries(this.effects).filter(([, enabled]) => enabled).map(([name]) => name);
  }

  setCase(newCase) {
    this.case = newCase;
    this.active = this.isActive();
    if (this.active) this.case.observe(this);
  }

  update(state = this.state, conditions, effects = {}, describeOnly = false) {
    const cased = conditions === undefined ? this.case : this.BaseCase.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');

    if (describeOnly) {
      return `Show only posts which matches "${this.getStateText(state, cased)}"`;
    }

    this.state = state;
    Object.assign(this.effects, effects);
    this.setCase(cased);
    this.refresh();
    if (this.parent) this.parent.save();
  }

  async updateByInputConstruction({
    criterion,
    disableFilter,
    reverseActive,
    fromSelected
  }, describeOnly = false) {
    if (disableFilter) {
      if (describeOnly) return 'Disable filter';
      return this.update(undefined, undefined, {
        hide: false
      });
    }

    let state, conditions;

    if (fromSelected) {
      ({
        state,
        conditions
      } = await this.BaseCase.getSelectedEntryValue());
    } else {
      if (criterion) conditions = this.BaseCase.criterionToConditions(criterion);
      state = this.state;
    }

    if (reverseActive) state = !state;
    return this.update(state, conditions, {
      hide: true
    }, describeOnly);
  }

  getMatchingEntry(thing) {
    return this.case.conditions;
  }

  removeEntry(entry, effect) {
    this.update(undefined, undefined, {
      [effect]: false
    });
  }

  async buildReasonElement(thing, effect) {
    const entry = await this.getMatchingEntry(thing);
    const element = string_namespaceObject.html`
			<div class="res-thing-filter-remove-matching-entry" title="${JSON.stringify(entry, null, '  ')}">
				${effect}: ${this.getStateText(!this.state)}  click to remove matching filter entry
			</div>
		`;
    element.addEventListener('click', () => {
      this.removeEntry(entry, effect);
    });
    return element;
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/ExternalFilter.js





class ExternalFilter_ExternalFilter extends Filter_Filter {
  constructor(...args) {
    super(...args);
    this.toggleEffects = ['hide'];
  }

  isActive() {
    return this.case.constructor.type !== 'false' && super.isActive();
  }

  createElement() {
    this.element = string_namespaceObject.html`
			<div class="res-filterline-external-filter" type="${this.BaseCase.type}">
				<div>${this.name || this.BaseCase.type}</div>
			</div>
		`;

    if (filteReddit_module.options.hasOwnProperty(this.BaseCase.type)) {
      this.element.prepend(string_namespaceObject.html`${string_namespaceObject.safe(makeUrlHashLink(filteReddit_module.moduleID, this.BaseCase.type, ' ', 'gearIcon'))}`);
    }

    const setActive = active => {
      const effects = this.toggleEffects.reduce((acc, val) => {
        acc[val] = active;
        return acc;
      }, {});
      this.update(undefined, undefined, effects);
    };

    if (isUseful(this.case.constructor.type)) {
      const t = createElement_namespaceObject.toggleButton(setActive, null, this.isActive(), '', '');
      this.element.appendChild(t);
    }
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/LineFilter.js










class LineFilter_LineFilter extends Filter_Filter {
  constructor(id, BaseCase, name, _conditions = null, state = true, effects = {}) {
    if (BaseCase.variant === 'ondemand') {
      const externOpts = BaseCase._customFilter && BaseCase._customFilter.opts;

      if (externOpts) {
        if (!name) ({
          name
        } = externOpts);

        if (!effects.hasOwnProperty('propagate')) {
          const {
            propagate
          } = externOpts;
          Object.assign(effects, {
            propagate
          });
        }
      }
    }

    super(id, BaseCase, name, _conditions, state, effects);
    this.initialConditions = void 0;
    this.getBuilder = memoize_default()((filterline, card) => {
      const builderCases = getByContext(filterline.thingType);
      let lastConditions = this.case.conditions;

      if (this.BaseCase.variant === 'ondemand') {
        Object.assign(builderCases, getByContext('browse'));
        lastConditions = this.BaseCase.getCustomFilter().body;
      }

      if (!this.initialConditions) this.initialConditions = lastConditions;
      const $builderBlock = caseBuilder_namespaceObject.drawBuilderBlock(lastConditions, builderCases, false);
      $builderBlock.on('change input', frameThrottle(() => {
        const conditions = caseBuilder_namespaceObject.readBuilderBlock($builderBlock, builderCases);

        if (!isEqual_default()(lastConditions, conditions)) {
          lastConditions = conditions;
          this.update(undefined, conditions);
          const lastFocus = $builderBlock.get(0).contains(document.activeElement) && document.activeElement;
          if (lastFocus) card.refresh().then(() => lastFocus.focus());
        }
      }));
      sortable_core_esm.create($builderBlock.get(0), {
        handle: '.handle'
      });
      return {
        get builder() {
          return $builderBlock.get(0);
        },

        isCaseChanged: () => !isEqual_default()(this.initialConditions, lastConditions)
      };
    });
  }

  update(state = this.state, conditions, effects, describeOnly) {
    if (this.BaseCase.variant === 'ondemand' && conditions && !describeOnly) {
      updateCustomFilter(this.BaseCase.getCustomFilter(), {
        body: conditions
      });
      conditions = null;
    }

    const message = super.update(state, conditions, effects, describeOnly);
    if (this.element) this.refreshElement();
    return message;
  }

  setParent(parent) {
    super.setParent(parent);
    this.getBuilder.cache.clear();
  }

  createElement() {
    this.element = string_namespaceObject.html`<div class="res-filterline-filter" type="${this.BaseCase.type}"></div>`;
    this.refreshElement();
    this.element.addEventListener('click', () => {
      if (!this.effects.hide) this.update(undefined, undefined, {
        hide: true
      });else if (this.state) this.update(false, undefined, {
        hide: true
      });else this.update(true, undefined, {
        hide: false
      });
    });
    this.element.addEventListener('contextmenu', e => {
      if (this.effects.hide) this.update(undefined, undefined, {
        hide: false
      });else this.remove();
      e.preventDefault();
    });
    this.element.addEventListener('mouseenter', async () => {
      await new Promise(res => setTimeout(res, 150));
      if (this.element.matches(':hover')) this.showInfocard();
    });
    this.element.addEventListener('click', () => infocard('filterline-filter').resetShowTimer());
    this.element.addEventListener('contextmenu', () => infocard('filterline-filter').resetShowTimer());
  }

  showInfocard(immediately = false) {
    const card = infocard('filterline-filter');
    if (card.visible) immediately = true;
    card.target(this.element).options({
      width: 570,
      openDelay: immediately ? 0 : 550,
      pin: pin.bottom
    }).populateWith(this.populateHover.bind(this)).begin();
  }

  refreshElement() {
    this.element.setAttribute('text', this.getStateText());
    this.element.classList.toggle('res-filterline-filter-disabled', this.BaseCase.variant !== 'basic' && !this.case.isEvaluatable());
    this.element.classList.toggle('res-filterline-filter-hiding', this.case.isEvaluatable() && !!this.effects.hide);
  }

  populateHover(card) {
    const {
      parent: filterline
    } = this;
    if (!filterline) throw new Error('Filter not attached');

    const redraw = () => {
      this.getBuilder.cache.clear();
      card.refresh();
    };

    const head = string_namespaceObject.html`
			<div class="res-filterline-filter-hover-preamble">
				<span>Filter ${this.BaseCase.text}</span>
				<div class="res-filterline-filter-hover-group" group="case-actions">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
			</div>
		`;
    const body = string_namespaceObject.html`
			<div class="res-filterline-filter-hover">
				<span class="res-filterline-filter-hover-options"></span>
				<span>For posts (<span class="res-filterline-filter-hover-number-matches"></span>) ${this.state ? 'not ' : ''}matching:</span>
				<div class="builderItem"></div>
				<div class="res-filterline-filter-hover-notice">${this.BaseCase.variant === 'ondemand' && 'By adding browse context conditions such as "Date", "Logged in user", and "Custom toggle", you control where and when this filter is available.'}</div>
				<div class="res-filterline-filter-hover-group" group="match-effects">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
				<div class="res-filterline-filter-hover-group" group="match-actions" hidden>
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
		`;
    const {
      builder,
      isCaseChanged
    } = this.getBuilder(filterline, card);
    body.querySelector('.builderItem').appendChild(builder);
    setTimeout(() => {
      if (!builder.contains(document.activeElement)) {
        const e = [...builder.querySelectorAll('input'), ...builder.querySelectorAll('select')].find(e => e.offsetParent);
        if (e) e.focus();
      }
    });

    if (filterline.thingType === 'comment') {
      const options = body.querySelector('.res-filterline-filter-hover-options');
      const propagate = string_namespaceObject.html`<label style="display: flex; align-items: center;"><input style="margin-right: 3px;" type="checkbox" ${this.effects.propagate && 'checked'}>Also hide children</label>`;
      options.append(propagate);
      waitForEvent(propagate, 'change').then(() => {
        this.effects.propagate = downcast(propagate.querySelector('input'), HTMLInputElement).checked;
        this.refresh();
      }).then(redraw);
    }

    function addButton(container, text, groupName, action) {
      const button = string_namespaceObject.html`<button class="res-filterline-filter-hover-button" action="${action}">${text}</button>`;
      const group = downcast(container.querySelector(`[group=${groupName}]`), HTMLElement);
      group.hidden = false;
      const buttons = downcast(group.querySelector('.res-filterline-filter-hover-buttons'), HTMLElement);
      buttons.appendChild(button);
      return waitForEvent(button, 'click');
    }

    if (this.BaseCase.variant === 'basic' && this.BaseCase === cases_Group) {
      addButton(head, 'To on-demand', 'case-actions', 'to-ondemand').then(() => {
        const conditions = getGroup('all', [cases_getConditions('currentLocation'), getGroup(this.state ? 'all' : 'none', [this.case.conditions])]);
        if (!this.name) this.name = window.prompt('Filter name:');
        this.BaseCase = addOndemandCase(addCustomFilter({
          body: resolveGroup(conditions, false, true),
          opts: {
            ondemand: true,
            name: this.name
          }
        }));
        this.update(true, null);
      }).then(redraw);
    }

    if (isCaseChanged()) {
      addButton(head, 'Reset change', 'case-actions', 'reset').then(() => {
        this.update(undefined, this.initialConditions);
      }).then(redraw);
    }

    if (this.BaseCase.variant === 'ondemand' || this.BaseCase === cases_Group) {
      addButton(head, 'Rename', 'case-actions', 'rename').then(() => {
        const name = window.prompt('New filter name:', this.case.trueText);
        if (!name) return;

        if (this.BaseCase.variant === 'ondemand') {
          const customFilter = this.BaseCase.getCustomFilter();
          updateCustomFilter(customFilter, {
            opts: {
              name
            }
          });
        }

        this.name = name;
        this.update();
      }).then(redraw);
    }

    addButton(head, 'Invert', 'case-actions', 'invert').then(() => {
      this.update(!this.state);
    }).then(redraw);
    addButton(head, 'Remove', 'case-actions', 'remove').then(() => {
      this.remove();
    }).then(card.close.bind(card));
    addButton(body, this.effects.hide ? 'Don\'t hide' : 'Hide', 'match-effects', `hide-${this.effects.hide ? 'false' : 'true'}`).then(() => {
      this.update(undefined, undefined, {
        hide: !this.effects.hide
      });
    }).then(redraw);
    addButton(body, this.effects.highlight ? 'Don\'t highlighting' : 'Highlight', 'match-effects', 'highlight').then(() => {
      this.update(undefined, undefined, {
        highlight: !this.effects.highlight
      });
    }).then(redraw);

    if (isRunning(commentNavigator_namespaceObject) && !this.effects.hide) {
      addButton(body, 'Navigate by', 'match-actions', 'navigate-by').then(() => {
        updateCustomConditions(getGroup(this.state ? 'none' : 'all', [this.case.conditions]));
        setCategory('custom');
        card.close();
      });
    }

    asyncFilter(Array.from(filterline.things), async thing => await this.matches(thing)).then(matches => {
      const numberSpan = body.querySelector('.res-filterline-filter-hover-number-matches');
      numberSpan.textContent = String(matches.length);

      if (filterline.thingType === 'post' && matches.length) {
        addButton(body, 'Permanently hide', 'match-actions', 'native-hide').then(() => {
          filterline.hidePermanently(matches);
        });
      }
    });
    return [head, body];
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/Filterline.js




















class Filterline_Filterline {
  constructor(storage, thingType) {
    this.things = new Set();
    this.thingType = void 0;
    this.storage = void 0;
    this.filters = [];
    this.sortedFilters = [];
    this.currentMatches = new Map();
    this.permanentlyHiddenThings = new Set();
    this.displayReasons = false;
    this.element = void 0;
    this.dropdown = void 0;
    this.preamble = void 0;
    this.filterContainer = void 0;
    this.poweredElement = void 0;
    this.permanentlyHideCheckbox = void 0;
    this.initialized = false;

    this.togglePowered = (powered = !this.isPowered()) => {
      bodyClasses_namespaceObject.toggle(!powered, 'res-filters-disabled');
      this.poweredElement.checked = powered;
    };

    this.deferredFilters = {};
    this.save = idleThrottle(async () => {
      const filters = this.filters.reduce((acc, v) => {
        acc[v.id] = v.getSaveValues();
        return acc;
      }, { ...this.deferredFilters
      });
      await this.storage.deletePath('filters');
      await this.storage.patch({
        filters,
        lastUsed: Date.now()
      });
    });
    this.availableEffects = {
      propagate: (thing, match) => {
        thing.element.classList.toggle('res-thing-hide-children', !!match);

        this._refreshAfterChange();
      },
      highlight: (thing, match) => {
        thing.entry.style.backgroundColor = match ? 'rgba(255, 155, 155, .16)' : '';
      },
      hide: (thing, match) => {
        thing.setHideFilter(match);

        this._refreshAfterChange();
      },
      placeholder: (thing, match) => {
        function removePlaceholders() {
          thing.element.classList.remove('res-thing-has-placeholder');

          for (const ele of thing.entry.querySelectorAll('.res-thing-placeholder-message')) ele.remove();
        }

        function replaceWithPlaceholder(ele) {
          if (!ele) return;
          const placeholder = string_namespaceObject.html`<span class="res-thing-placeholder-message">
					<span class="res-icon">&#xF093;</span> Content ignored. Click to show anyway.
				</span>`;
          ele.after(placeholder);
          thing.element.classList.add('res-thing-has-placeholder');
          waitForEvent(placeholder, 'click').then(removePlaceholders);
        }

        if (match) {
          replaceWithPlaceholder(thing.getTitleElement());
          replaceWithPlaceholder(thing.getTextBody());
        } else {
          removePlaceholders();
        }

        this._refreshAfterChange();
      },
      collapse: (thing, match) => {
        thing.setCommentCollapse(!!match, 'filterline', true);

        this._refreshAfterChange();
      }
    };
    this._refreshAfterChange = frameThrottle(() => {
      selectedThing_namespaceObject.refresh();
      this.checkEmptyState();
    });
    this.refreshThing = keyedMutex(fastAsync(function* (thing, invokedByFilter) {
      if (!this.currentMatches.has(thing)) this.currentMatches.set(thing, {});
      const currentMatches = this.currentMatches.get(thing);
      const effectsToRefresh = Object.keys(this.availableEffects);

      const filtersToTest = union_default()(...effectsToRefresh.map(effect => this.getFiltersToTest(currentMatches[effect], invokedByFilter))).sort((a, b) => this.sortedFilters.indexOf(a) - this.sortedFilters.indexOf(b));

      remove_default()(effectsToRefresh, effect => invokedByFilter && !invokedByFilter.effects.hasOwnProperty(effect) || currentMatches[effect] && !filtersToTest.includes(currentMatches[effect]));

      const updateEffect = (effect, filter) => {
        const old = currentMatches[effect];
        if (filter == old) return;
        currentMatches[effect] = filter;
        this.availableEffects[effect](thing, filter);
        if (this.displayReasons) this.refreshDisplayReasonsChunked([thing]);
      };

      for (const filter of filtersToTest.filter(v => this.getActiveFilters().includes(v))) {
        const effects = filter.getEffects().filter(v => effectsToRefresh.includes(v));

        if (effects.length && (yield filter.matches(thing))) {
          for (const effect of effects) updateEffect(effect, filter);

          pull_default()(effectsToRefresh, ...effects);
        }
      }

      for (const effect of effectsToRefresh) {
        updateEffect(effect, null);
      }
    }));

    this.checkEmptyState = (() => {
      let notification;

      const showNotification = debounce_default()(() => {
        const info = jquery_default()('<p>').text(i18n('filteRedditEmptyNotificationInfo'));
        const toggle = jquery_default()('<button>').text(i18n('filteRedditEmptyNotificationToggleShowReason')).click(() => {
          this.toggleDisplayReasons();
        });
        notification = notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'everyThingHidden',
          header: i18n('filteRedditEmptyNotificationHeader'),
          message: jquery_default()('<div>').append(info).append(toggle).get(0),
          closeDelay: Infinity
        });
      }, 3000);

      return () => {
        if (Array.from(this.things).some(v => v.isVisible())) {
          showNotification.cancel();
          if (notification) notification.close();
        } else if (!this.displayReasons && Array.from(this.currentMatches.values()).some(v => v.hide)) {
            showNotification();
          }
      };
    })();

    this.refreshDisplayReasonsChunked = forEachChunked(this.refreshDisplayReasons.bind(this));
    this.storage = storage;
    this.thingType = thingType;
  }

  isInitialized() {
    if (this.initialized) return true;
    if (!this.things.size || !this.getActiveFilters().length) return false;
    this.initialized = true;
    this.sortedFilters = sortBy_default()(this.filters, ({
      case: {
        constructor: {
          slow
        }
      }
    }) => slow);

    if (this.thingType === 'post') {
      delete this.availableEffects.collapse;
      delete this.availableEffects.propagate;
    }

    return true;
  }

  isPowered() {
    return !document.documentElement.classList.contains('res-filters-disabled');
  }

  createElement() {
    const element = this.element = string_namespaceObject.html`
			<div class="res-filterline">
				<div class="res-filterline-preamble"></div>
				<div class="res-filterline-filters">
					<input type="checkbox" ${this.isPowered() && 'checked'} class="res-filterline-toggle-powered" title="Stop filtering temporarily"></input>
				</div>
			</div>
		`;
    this.preamble = element.querySelector('.res-filterline-preamble');
    this.filterContainer = element.querySelector('.res-filterline-filters');
    this.addFilterElements(this.filters);
    waitForEvent(this.preamble, 'mouseenter', 'click').then(() => this.createDropdown());
    this.poweredElement = downcast(element.querySelector('.res-filterline-toggle-powered'), HTMLInputElement);
    this.poweredElement.addEventListener('change', () => {
      this.togglePowered();
    });
  }

  addFilterElements(filters) {
    for (const filter of filters) {
      if (filter instanceof ExternalFilter_ExternalFilter) continue;
      filter.createElement();
      this.filterContainer.appendChild(filter.element);
    }
  }

  getFiltersOfCase(CaseClass) {
    return this.filters.filter(v => v.BaseCase === CaseClass);
  }

  getPickable() {
    return Object.values(getByContext(this.thingType, false)).filter(v => !v.disabled && v.variant !== 'external');
  }

  createDropdown() {
    const element = string_namespaceObject.html`
			<div class="res-filterline-dropdown">
				<div class="res-filterline-dropdown-other"></div>
				<div class="res-filterline-dropdown-toggles">
					<div class="res-filterline-display-match-reason">
						<label>
							<input type="checkbox" ${this.displayReasons && 'checked'}">
							<span>Show matching filters</span>
						</label>
					</div>
				</div>
				<div class="res-filterline-show-help">
					Usage information
				</div>
			</div>
		`;
    this.preamble.append(element);
    this.preamble.addEventListener('mouseenter', () => {
      infocard('filterline-filter').close();
    });

    function addDetails(summary, className, ...elements) {
      const e = string_namespaceObject.html`<details class="${className}"><summary>${summary}</summary></details>`;
      e.append(...elements);
      element.querySelector('.res-filterline-dropdown-other').append(e);
    }

    addDetails('Modify external filters', 'res-filterline-external', ...this.filters.filter(filter => filter instanceof ExternalFilter_ExternalFilter).map(filter => {
      filter.createElement();
      return filter.element;
    }));

    const dp = groupBy_default()(without_default()(this.getPickable(), cases_Group), v => v.variant);

    for (const [name, CaseClasses] of Object.entries(dp)) {
      addDetails(`New ${name} filter`, `res-filterline-new-${name}`, ...CaseClasses.sort((a, b) => a.type.localeCompare(b.type)).map(CaseClass => this.createNewFilterElement(CaseClass)));
    }

    const _getAsConditions = this.getAsConditions.bind(this);

    addDetails('New complex filter', 'res-filterline-new-group', this.createNewFilterElement(cases_Group, 'Copy active filters', {
      get conditions() {
        return _getAsConditions();
      }

    }), ...cases_Group.fields[0].options.map(op => this.createNewFilterElement(cases_Group, `Matches ${op}`, {
      conditions: {
        op,
        of: []
      }
    })));
    addDetails('Use as default', 'res-filterline-set-default', ...defaultFilters.map(({
      type,
      text
    }) => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">${text}</div>`;
      e.addEventListener('click', () => saveFilterlineStateAsDefault(type));
      return e;
    }), (() => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">Reset this Filterline</div>`;
      e.addEventListener('click', () => {
        this.storage.delete();
        if (confirm('Reload page to restore default')) location.reload();
      });
      return e;
    })());
    const displayReasonsCheckbox = downcast(element.querySelector('.res-filterline-display-match-reason input'), HTMLInputElement);
    displayReasonsCheckbox.addEventListener('change', () => {
      this.toggleDisplayReasons(displayReasonsCheckbox.checked);
    });

    if (this.thingType === 'post' && loggedInUser()) {
      const permanentlyHide = string_namespaceObject.html`
				<div class="res-filterline-permanently-hide">
					<label>
						<input type="checkbox">
						<span>Permanently hide</span>
					</label>
				</div>
			`;
      const checkbox = this.permanentlyHideCheckbox = downcast(permanentlyHide.querySelector('input'), HTMLInputElement);
      this.updatePermanentlyHideCheckbox();
      permanentlyHide.addEventListener('click', async () => {
        checkbox.disabled = true;
        await (this.permanentlyHiddenThings.size ? this.unhidePermanently() : this.hidePermanently());
        checkbox.disabled = false;
      });
      element.querySelector('.res-filterline-dropdown-toggles').append(permanentlyHide);
    }

    downcast(element.querySelector('.res-filterline-show-help'), HTMLElement).addEventListener('click', () => {
      showFeatureTip('filterlineVisible');
    });
  }

  updatePermanentlyHideCheckbox() {
    if (!this.permanentlyHideCheckbox) return;
    this.permanentlyHideCheckbox.checked = this.permanentlyHideCheckbox.indeterminate = false;
    if (!this.permanentlyHiddenThings.size) return;
    if (this.getThings('hide').length === this.permanentlyHiddenThings.size) this.permanentlyHideCheckbox.checked = true;else this.permanentlyHideCheckbox.indeterminate = true;
  }

  createNewFilterElement(CaseClass, text = CaseClass.text, newOpts) {
    let fromSelected = false;
    const element = string_namespaceObject.html`<div class="res-filterline-dropdown-action res-filterline-filter-new" type="${CaseClass.type}">${text}</div>`;
    element.addEventListener('click', () => {
      const existing = CaseClass.unique && this.getFiltersOfCase(CaseClass)[0];
      let filter;

      if (existing) {
        if (!(existing instanceof LineFilter_LineFilter)) throw new Error();
        filter = existing;
      } else {
        filter = downcast(this.createFilter({
          type: CaseClass.type,
          add: true,
          ...newOpts
        }), LineFilter_LineFilter);
      }

      if (fromSelected) filter.updateByInputConstruction({
        fromSelected
      });else filter.showInfocard(true);
    });

    if (CaseClass.thingToCriterion || !CaseClass.defaultConditions) {
      const c = string_namespaceObject.html`<div class="res-filterline-filter-new-from-selected" title="From selected entry"></div>`;
      c.addEventListener('click', () => {
        fromSelected = true;
        setTimeout(() => {
          fromSelected = false;
        });
      });
      element.append(c);
    }

    return element;
  }

  async hidePermanently(things = this.getThings('hide')) {
    await Promise.all(difference_default()(things, Array.from(this.permanentlyHiddenThings)).map(thing => thingHide_hide(thing)));

    for (const v of things) this.permanentlyHiddenThings.add(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'hideThings',
      message: string_namespaceObject.html`<div><p>Reddit has now hidden ${things.length} things. Undo by unchecking the checkbox in the menu.</p><p><a href="/user/me/hidden/">See all hidden posts</a></p>`
    });
  }

  async unhidePermanently(things = [...this.permanentlyHiddenThings]) {
    await Promise.all(intersection_default()(things, Array.from(this.permanentlyHiddenThings)).map(thing => unhide(thing)));

    for (const v of things) this.permanentlyHiddenThings.delete(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'unhideThings',
      message: `${things.length} things are no longer hidden.`
    });
  }

  getAsConditions(hasEffect = 'hide') {
    const extracted = filterMap(this.filters, v => v.effects[hasEffect] && v instanceof LineFilter_LineFilter && [v] || undefined);
    return resolveGroup(getGroup('all', extracted.map(v => v.state ? v.case.conditions : getGroup('none', [v.case.conditions]))), false, true);
  }

  resumeDeferredTypes(types) {
    Object.entries(this.deferredFilters).filter(([, {
      type
    }]) => types.includes(type)).forEach(([id]) => this.createFilterFromStateValues(id));
  }

  restoreState(filters) {
    for (const [id, opts] of Object.entries(filters)) {
      try {
        if (opts.type === 'inert') throw new Error('Requested inert filter. This state is likely due to a bug. Ignoring.');
        const filter = this.getFilter(id);
        if (filter) throw new Error(`Filter with id ${id} already exists`);

        if (cases_has(opts.type) && !(cases_get(opts.type).variant === 'external')) {
          this.createFilterFromStateValues(id, opts);
        } else {
          this.deferredFilters[id] = opts;
        }
      } catch (e) {
        console.error('Could not create filter', id, opts);
        this.storage.deletePath('filters', id);
      }
    }
  }

  createFilterFromStateValues(id, opts) {
    const deferredOpts = this.deferredFilters[id];
    delete this.deferredFilters[id];
    return this.createFilter({
      id,
      ...opts,
      ...deferredOpts,
      add: true,
      save: false
    });
  }

  getCLI() {
    const deconstruct = val => {
      const [, modifiers, key, criterion] = val.match(/^([^\w]*)(\w*)(.*)/);
      return {
        key,
        criterion: criterion.trim(),
        disableFilter: !!modifiers.match('/'),
        reverseActive: !!modifiers.match('!'),
        asNewFilter: !!modifiers.match('\\+'),
        fromSelected: !!modifiers.match('=')
      };
    };

    const findMatchingCases = val => this.getPickable().sort((a, b) => a.variant.localeCompare(b.variant) || a.type.localeCompare(b.type)).map(CaseClass => ({
      name: CaseClass.variant === 'ondemand' ? CaseClass.text : CaseClass.type,
      cls: CaseClass
    })).filter(({
      name
    }) => name.toLowerCase().match(val.toLowerCase()));

    let filter;

    async function getTip(val) {
      const deconstructed = deconstruct(val);
      const {
        key,
        asNewFilter
      } = deconstructed;

      const bestMatch = key && sortBy_default()(findMatchingCases(key), ({
        name
      }) => name.toLowerCase().indexOf(key.toLowerCase()))[0];

      const {
        cls: MatchedCase
      } = bestMatch || {};
      let message;

      if (bestMatch) {
        try {
          const lastFilter = last_default()(this.getFiltersOfCase(MatchedCase));

          filter = lastFilter && !asNewFilter ? lastFilter : this.createFilter({
            type: MatchedCase.type
          });
          const actionDescription = await filter.updateByInputConstruction(deconstructed, true);
          message = `${filter.parent ? `Modify "${filter.getStateText(filter.state)}"` : 'New filter'}: ${actionDescription}`;
        } catch (e) {
          message = `Error: ${e.message}`;
        }
      } else {
        filter = null;
        message = 'No filter selected.';
      }

      return ['<pre>', 'Syntax: [modifiers] filterName [criterion]', '', message, '', 'Filters:', ...findMatchingCases('').map(v => ` ${MatchedCase === v.cls ? `<b>${v.name}</b>` : v.name} ${v.cls.pattern}`), '', 'Modifiers:', ' /  disable the filter', ' !  reverse the active state', ' +  create as new filter', ' =  use the currently selected post\'s data as criterion', '', 'Examples:', ' =postAfter    filter posts older than selected', ' +=!postAfter  new filter, filter posts younger than selected', '</pre>'].join('\n');
    }

    function executeCommand(val) {
      if (!filter) return;
      if (!filter.parent) this.addFilter(filter);
      filter.updateByInputConstruction(deconstruct(val));
      filter = null;
    }

    return {
      getTip: getTip.bind(this),
      executeCommand: executeCommand.bind(this)
    };
  }

  createFilter(opts) {
    const {
      Filter = LineFilter_LineFilter,
      id = `~${performance.timing.navigationStart + performance.now()}`,
      add = false,
      save = true,
      type,
      criterion,
      effects,
      name,
      state
    } = opts;
    let {
      conditions
    } = opts;
    if (this.deferredFilters.hasOwnProperty(id)) return this.createFilterFromStateValues(id, opts);
    const CaseClass = cases_get(type);

    if (CaseClass.unique) {
      const [existing] = this.getFiltersOfCase(CaseClass);
      if (existing) return existing;
    }

    if (!conditions && criterion) {
      conditions = CaseClass.criterionToConditions(criterion);
    }

    const filter = new Filter(id, CaseClass, name, conditions, state, effects);

    if (add) {
      this.addFilter(filter);
      if (save) this.save();
    }

    return filter;
  }

  addFilter(filter) {
    filter.setParent(this);
    this.filters.push(filter);

    if (this.isInitialized()) {
      this.sortedFilters.push(filter);
      this.refresh(filter);
    }

    if (this.filterContainer) this.addFilterElements([filter]);
  }

  async removeFilter(filter) {
    if (filter.element) filter.element.remove();
    if (this.isInitialized()) await this.refresh(filter);

    pull_default()(this.filters, filter);

    pull_default()(this.sortedFilters, filter);

    this.save();
  }

  getFilter(id) {
    return this.filters.find(filter => filter.id === id);
  }

  getActiveFilters() {
    return this.filters.filter(v => v.active);
  }

  getFiltersToTest(currentFilter, invokedByFilter) {
    if (!invokedByFilter) return this.sortedFilters;
    const invokedByFilterIndex = this.sortedFilters.indexOf(invokedByFilter);
    const currentFilterIndex = this.sortedFilters.indexOf(currentFilter);

    if (!currentFilter) {
      return [invokedByFilter];
    } else if (currentFilter === invokedByFilter) {
      return this.sortedFilters.slice(invokedByFilterIndex);
    } else if (currentFilterIndex > invokedByFilterIndex) {
      return [invokedByFilter, currentFilter];
    } else {
      return [];
    }
  }

  refresh(invokedByFilter, things = Array.from(this.things)) {
    return Promise.all(things.map(thing => this.refreshThing(thing, invokedByFilter)));
  }

  addThing(thing) {
    this.things.add(thing);
    if (this.isInitialized()) return this.refreshThing(thing);
  }

  getThings(withEffect) {
    return Array.from(this.currentMatches.entries()).filter(([, effects]) => effects[withEffect]).map(([thing]) => thing);
  }

  toggleDisplayReasons(newState = !this.displayReasons) {
    this.displayReasons = newState;
    this.refreshDisplayReasonsChunked(this.things);
    bodyClasses_namespaceObject.toggle(this.displayReasons, 'res-display-match-reason');
  }

  async refreshDisplayReasons(thing) {
    const reasons = this.displayReasons ? await Promise.all(Object.entries(this.currentMatches.get(thing) || {}).map(([effect, filter]) => filter && filter.buildReasonElement(thing, effect)).filter(Boolean)) : [];
    thing.setFilterReasons(reasons);
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit.js




























const filteReddit_module = new Module('filteReddit');
filteReddit_module.moduleName = 'filteRedditName';
filteReddit_module.category = 'subredditsCategory';
filteReddit_module.description = 'filteRedditDesc';
filteReddit_module.keywords = ['filterreddit'];
filteReddit_module.options = {
  hideUntilProcessed: {
    type: 'boolean',
    value: true,
    description: 'filteRedditHideUntilProcessedDesc',
    title: 'filteRedditHideUntilProcessedTitle',
    advanced: true
  },
  NSFWfilter: {
    type: 'boolean',
    value: false,
    description: 'filteRedditNSFWfilterDesc',
    title: 'filteRedditNSFWfilterTitle'
  },
  allowNSFW: {
    type: 'table',
    addRowText: 'filteRedditAddSubreddits',
    description: 'filteRedditAllowNSFWDesc',
    title: 'filteRedditAllowNSFWTitle',
    fields: [{
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'where',
      name: 'filteRedditAllowNSFWWhere',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditAllowNSFWWhenBrowsingSubreddit',
        value: 'visit'
      }],
      value: 'everywhere'
    }],
    value: []
  },
  NSFWQuickToggle: {
    type: 'boolean',
    value: true,
    description: 'filteRedditNSFWQuickToggleDesc',
    title: 'filteRedditNSFWQuickToggleTitle',
    advanced: true
  },
  showFilterline: {
    type: 'boolean',
    value: false,
    description: 'filteRedditShowFilterlineDesc',
    title: 'filteRedditShowFilterlineTitle'
  },
  excludeOwnPosts: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeOwnPostsDesc',
    title: 'filteRedditExcludeOwnPostsTitle'
  },
  excludeModqueue: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeModqueueDesc',
    title: 'filteRedditExcludeModqueueTitle'
  },
  excludeUserPages: {
    type: 'boolean',
    value: false,
    description: 'filteRedditExcludeUserPagesDesc',
    title: 'filteRedditExcludeUserPagesTitle'
  },
  keywords: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'subreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'unlessKeyword',
      name: 'unlessKeyword',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditKeywordsDesc',
    title: 'filteRedditKeywordsTitle'
  },
  subreddits: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'subreddit',
      name: 'filteRedditSubredditsSubreddits',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditSubredditsDesc',
    title: 'filteRedditSubredditsTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  filterSubredditsFrom: {
    type: 'enum',
    value: 'everywhere-except-subreddit',
    values: [{
      name: 'filteRedditFilterSubredditsEverywhereButSubreddit',
      value: 'everywhere-except-subreddit'
    }, {
      name: 'filteRedditEverywhere',
      value: 'everywhere'
    }, {
      name: 'filteRedditFilterSubredditsAllPopularAndDomain',
      value: 'legacy'
    }],
    description: 'filteRedditFilterSubredditsFromDesc',
    title: 'filteRedditFilterSubredditsFromTitle'
  },
  useRedditFilters: {
    type: 'boolean',
    value: false,
    description: 'filteRedditUseRedditFiltersDesc',
    title: 'filteRedditUseRedditFiltersTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  forceSyncFilters: {
    type: 'button',
    text: 'filteRedditForceSyncFiltersLabel',
    description: 'filteRedditForceSyncFiltersDesc',
    title: 'filteRedditForceSyncFiltersTitle',

    callback() {
      return reconcileNativeFilters({
        warnNotLoggedIn: true
      });
    }

  },
  users: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'username',
      name: 'filteRedditUsername',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditUsersDesc',
    title: 'filteRedditUsersTitle'
  },
  usersMatchAction: {
    type: 'enum',
    value: 'hide',
    values: [{
      name: 'Hidden',
      value: 'hide'
    }, {
      name: 'Replaced with placeholder',
      value: 'placeholder'
    }],
    description: 'filteRedditUsersMatchActionDesc',
    title: 'filteRedditUsersMatchActionTitle'
  },
  usersMatchRepliesAction: {
    type: 'enum',
    value: 'collapse',
    values: [{
      name: 'Kept visible',
      value: ''
    }, {
      name: 'Collapsed',
      value: 'collapse'
    }, {
      name: 'Hidden',
      value: 'propagate'
    }],
    description: 'filteRedditUsersMatchRepliesActionDesc',
    title: 'filteRedditUsersMatchRepliesActionTitle'
  },
  domains: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditDomainsDesc',
    title: 'filteRedditDomainsTitle'
  },
  flair: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditFlairDesc',
    title: 'filteRedditFlairTitle'
  },
  customFiltersP: {
    type: 'builder',
    advanced: true,
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersPTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: ''
        }
      };
    },

    customOptionsFields: [[{
      type: 'check',
      id: 'ondemand',
      label: 'Only filter when added to Filterline (on-demand)'
    }], ['Filterline name: ', {
      type: 'text',
      id: 'name'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('post'),
        ...getByContext('browse')
      };
    }

  },
  customFiltersC: {
    type: 'builder',
    advanced: true,
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersCTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: '',
          propagate: false
        }
      };
    },

    customOptionsFields: [[{
      type: 'check',
      id: 'ondemand',
      label: 'Only filter when added to Filterline (on-demand)'
    }], ['Filterline name: ', {
      type: 'text',
      id: 'name'
    }], [{
      type: 'check',
      id: 'propagate',
      label: 'Hide child commments'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('comment'),
        ...getByContext('browse')
      };
    }

  }
};
filteReddit_module.include = ['linklist', 'modqueue', 'profile', 'comments', 'commentsLinklist', 'search'];
const featureTips = {
  filterline: {
    message: `
RES allows you to easily apply complex filters to post listings and comments. To toggle Filterline, click on the tab.
	`,
    title: 'Filterline',
    position: 6,
    quiet: true
  },
  filterlineVisible: {
    message: () => snudown_es_markdown(`
* Click once on a filter to enable it (e.g. clicking \`expando\` will only show posts with embedded media).
* Click again to only show posts which do not not match.
* A third click makes the filter inactive.
* To clear a filter, right-click on it.
* **Hover** on it to modify conditions, highlight or permanently hide all matches.

To find more filters and options, hover on icon to the left.

You can use the currently selected post as a basis for a new filter. To do this, click on **=** to the right of the filter name.

**Complex filter** creates filters which matches when \`none\`, \`one\`, \`any\`, or \`all\` of the subfilters matches. Click \`To on-demand\` to make these filters available on other pages.

**Use as default** lets you store the current filters to be used on other pages.

To see why a post is hidden, open dropdown and check **Show filter-reason**. This also gives you the opportunity to remove an external filter so that you don't have to look for it in the settings console.

You can use the command line to manipulate Filterline. Enter it by pressing the key \`f\`.
		`),
    title: 'Filterline  how to use it',
    position: 7,
    options: [{
      moduleID: 'filteReddit',
      key: 'showFilterline'
    }]
  }
};
const pageID = fullLocation();
const filterlineStorage = storage_namespaceObject.wrap(`filterline.${pageID}`, {});
const filteReddit_thingType = isPageType('comments', 'commentsLinklist') ? 'comment' : 'post';
const customFilterVariant = filteReddit_thingType === 'post' ? 'customFiltersP' : 'customFiltersC';

const createStateFromTypes = types => types.reduce((acc, v, i) => {
  if (v) acc[`!${i}`] = {
    type: v
  };
  return acc;
}, {});

const defaultFilters = [];

if (filteReddit_thingType === 'comment') {
  if (currentSubreddit()) {
    defaultFilters.push({
      type: 'subreddit',
      text: 'This subreddit',
      storage: storage_namespaceObject.wrap(`RESmodules.filteReddit.commentDefault-${String(currentSubreddit())}`, null)
    });
  }

  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.commentDefault', createStateFromTypes(['hasExpando', 'score', 'isRead']))
  });
} else if (filteReddit_thingType === 'post') {
  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.postDefault', createStateFromTypes(['isNSFW', 'isSpoiler', 'isVisited', 'commentsOpened', 'hasExpando', 'score']))
  });
}

let nsfwToggle;
let filteReddit_filterline;
let filteReddit_visible;

let _filterlineResolve;

const filterlinePromise = new Promise(res => {
  _filterlineResolve = res;
});
let ensureFilterlineVisible;

const filteReddit_initial = (async () => {
  const state = filterlineStorage.get();

  const _default = Promise.all(defaultFilters.map(({
    storage
  }) => storage.get())).then(v => v.find(Boolean));

  let {
    filters,
    visible,
    lastUsed
  } = await state;
  if (!filters || !Object.values(filters).length) filters = await _default;
  return {
    filters,
    visible,
    lastUsed
  };
})();

filteReddit_module.beforeLoad = async () => {
  updateNsfwBodyClass(filteReddit_module.options.NSFWfilter.value);
  nsfwToggle = new customToggles_Toggle('nsfwMode', i18n('nsfwSwitchToggleText'), filteReddit_module.options.NSFWfilter.value);
  nsfwToggle.onToggle(() => {
    filteReddit_module.options.NSFWfilter.value = nsfwToggle.enabled;
    options_save(filteReddit_module.options.NSFWfilter);
  });
  nsfwToggle.onStateChange(() => {
    updateNsfwBodyClass(nsfwToggle.enabled);
  });
  nsfwToggle.addCLI('nsfw');
  watchForThings(['post'], updateNsfwThingClass, {
    immediate: true
  });
  populatePrimitives(['browse', filteReddit_thingType]);
  filteReddit_filterline = new Filterline_Filterline(filterlineStorage, filteReddit_thingType);
  const {
    filters,
    visible: _visible,
    lastUsed
  } = await filteReddit_initial;
  filteReddit_filterline.restoreState(filters);
  populateFromOptions();

  _filterlineResolve(filteReddit_filterline);

  const hideUntilProcessed = filteReddit_module.options.hideUntilProcessed.value && filteReddit_filterline.getActiveFilters().length;
  watchForThings([filteReddit_thingType], async thing => {
    if (!shouldFilter(thing)) return;
    if (hideUntilProcessed) thing.element.classList.add('res-thing-filter-unprocessed');

    try {
      await filteReddit_filterline.addThing(thing);
    } catch (e) {
      console.error(e);
    }

    if (hideUntilProcessed) thing.element.classList.remove('res-thing-filter-unprocessed');
  }, {
    immediate: true,
    id: 'filter'
  });
  if (filteReddit_module.options.excludeModqueue.value && isPageType('modqueue') || filteReddit_module.options.excludeUserPages.value && isPageType('profile')) filteReddit_filterline.togglePowered(false);
  filteReddit_visible = typeof _visible === 'boolean' ? _visible : filteReddit_module.options.showFilterline.value || filteReddit_filterline.getActiveFilters().some(v => !(v instanceof ExternalFilter_ExternalFilter));
  if (lastUsed) requestIdleCallback(() => {
    filterlineStorage.patch({
      lastUsed: Date.now()
    });
  });
};

filteReddit_module.contentStart = () => {
  makeFilterlineInteractable();

  if (filteReddit_module.options.NSFWQuickToggle.value) {
    nsfwToggle.addMenuItem(i18n('nsfwSwitchToggleTitle'), 8);
  }

  registerSubredditFilterCommand();
};

const shouldFilter = thing => !(filteReddit_module.options.excludeOwnPosts.value && context_data.username && currentUserProfile() !== context_data.username && context_data.username === thing.getAuthor());

function makeFilterlineInteractable() {
  const insertFilterline = lodash_once_default()(() => {
    filteReddit_filterline.createElement();

    if (isAppType('r2')) {
      if (isPageType('comments')) {
        document.querySelector('.comments-page .nestedlisting').before(filteReddit_filterline.element);
      } else {
        document.querySelector('#siteTable, .search-result-listing').before(filteReddit_filterline.element);
      }
    } else {
      filterlineTab.append(filteReddit_filterline.element);
    }

    addFeatureTip('filterlineVisible', { ...featureTips.filterlineVisible,
      attachTo: filteReddit_filterline.element
    });
  });

  const filterlineTab = createElement_namespaceObject.tabMenuItem({
    text: '',
    title: 'Toggle Filterline visibility',
    className: 'res-toggle-filterline-visibility',
    checked: filteReddit_visible,
    onChange: active => {
      filteReddit_visible = active;

      if (filteReddit_visible) {
        insertFilterline();
        scrollToElement(filteReddit_filterline.element, null, {
          scrollStyle: 'legacy'
        });
      }

      if (filteReddit_filterline.element) filteReddit_filterline.element.hidden = !filteReddit_visible;
      filterlineStorage.patch({
        visible: filteReddit_visible
      });
    }
  });

  ensureFilterlineVisible = () => {
    if (!filteReddit_visible) filterlineTab.click();
  };

  const {
    getTip,
    executeCommand
  } = filteReddit_filterline.getCLI();
  registerCommand(/(fl|filterline)/, 'fl - modify Filterline', (cmd, val) => getTip(val), (cmd, val) => {
    ensureFilterlineVisible();
    executeCommand(val);
  });
  registerCommand(/fp/, 'fp - toggle filtering', () => 'Toggle filtering', () => {
    ensureFilterlineVisible();
    filteReddit_filterline.poweredElement.click();
  });
  addFeatureTip('filterline', { ...featureTips.filterline,
    attachTo: filterlineTab,
    continuation: () => {
      ensureFilterlineVisible();
      return 'filterlineVisible';
    }
  });
  if (filteReddit_visible) insertFilterline();
}

class filteReddit_ListFilter {
  get list() {
    return filteReddit_module.options[this.externalKey].value;
  }

  constructor(externalKey) {
    this.externalKey = void 0;
    this.filter = void 0;
    this.externalKey = externalKey;
  }

  initialize(caseType, additionalCriteria, useEffects = ['hide']) {
    const _listFilter = this;

    const sources = new Map();
    this.filter = addExternalFilter(this.externalKey, i18n(filteReddit_module.options[this.externalKey].title), () => {
      sources.clear();
      return resolveGroup(getGroup('any', this.list.map(v => {
        const c = getStringMatchConditions(v, caseType, additionalCriteria);
        sources.set(c, v);
        return c;
      })));
    }, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects = {}) {
        const _effects = useEffects.reduce((acc, val) => {
          acc[val] = typeof effects[val] === 'boolean' ? effects[val] : true;
          return acc;
        }, {});

        super(id, BaseCase, name, conditions, state, _effects);
        this.toggleEffects = useEffects;
      }

      async getMatchingEntry(thing) {
        const matching = Array.from(sources.keys()).map(v => Case_Case.fromConditions(v).evaluate(thing) && sources.get(v));
        return (await Promise.all(matching)).filter(Boolean);
      }

      removeEntry(entries) {
        _listFilter.toggleEntry(false, ...entries);
      }

    });
  }

  findEntry(matchString) {
    return this.list.find(([str]) => str.toLowerCase() === matchString.toLowerCase());
  }

  toggleEntry(newState, ...entries) {
    if (newState) {
      this.list.push(...entries);
    } else {
      pull_default()(this.list, ...entries);
    }

    options_save(filteReddit_module.options[this.externalKey]);
    if (this.filter) return this.filter.update(undefined, null);
  }

  includesString(matchString) {
    return !!this.findEntry(matchString);
  }

  async toggleString(matchString, newState = !this.includesString(matchString)) {
    if (selectedThing_namespaceObject.current) selectedThing_namespaceObject.current.anchor();
    await this.toggleEntry(newState, this.findEntry(matchString) || [matchString]);
  }

}

const listFilters = {
  users: new filteReddit_ListFilter('users'),
  subreddits: new filteReddit_ListFilter('subreddits'),
  keywords: new filteReddit_ListFilter('keywords'),
  domains: new filteReddit_ListFilter('domains'),
  flair: new filteReddit_ListFilter('flair')
};
function addExternalFilter(id, name, getConditions, Filter = ExternalFilter_ExternalFilter) {
  const cased = createAdHoc(id, getConditions, 'external', filteReddit_thingType);
  return filteReddit_filterline.createFilter({
    Filter,
    id,
    name,
    type: cased.type,
    state: false,
    add: true,
    save: false
  });
}

function populateFromOptions() {
  const customFilters = groupBy_default()(filteReddit_module.options[customFilterVariant].value, ({
    opts: {
      ondemand
    } = {}
  }) => ondemand ? 'ondemand' : 'always');

  if (customFilters.ondemand) {
    const cases = customFilters.ondemand.map(v => addOndemandCase(v, true));
    filteReddit_filterline.resumeDeferredTypes(cases.map(({
      type
    }) => type));
  }

  addExternalFilter(customFilterVariant, i18n(filteReddit_module.options[customFilterVariant].title), () => ({
    type: 'false'
  }));

  for (const customFilter of customFilters.always || []) {
    const conditions = resolveGroup(customFilter.body);
    if (!isUseful(conditions.type)) continue;
    addExternalFilter(customFilter.id, (customFilter.opts || {}).name, () => conditions, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects) {
        const propagate = !!(customFilter.opts && customFilter.opts.propagate);
        super(id, BaseCase, name, conditions, state, {
          hide: true,
          propagate,
          ...effects
        });
      }

    });
  }

  if (!isPageType('profile')) {
    const effects = [filteReddit_module.options.usersMatchAction.value, filteReddit_module.options.usersMatchRepliesAction.value].filter(Boolean);
    listFilters.users.initialize('username', undefined, effects);
  }

  if (filteReddit_thingType === 'post') {
    listFilters.keywords.initialize('postTitle');
    listFilters.domains.initialize('domain', {
      fullMatch: false
    });

    if (filteReddit_module.options.filterSubredditsFrom.value === 'everywhere' || filteReddit_module.options.filterSubredditsFrom.value === 'everywhere-except-subreddit' && !currentSubreddit() || isCurrentSubreddit('all') || isCurrentSubreddit('popular') || currentDomain() || isCurrentMultireddit('me/f/all')) {
      listFilters.subreddits.initialize('subreddit');
    }

    listFilters.flair.initialize('linkFlair');
  }
}

function addOndemandCase(customFilter, onlyUseful = false) {
  const getConditions = () => resolveGroup(customFilter.body);

  if (!onlyUseful || isUseful(getConditions().type)) {
    return createAdHoc(customFilter.id, getConditions, 'ondemand', filteReddit_thingType, customFilter);
  } else {
    return cases_Inert;
  }
}
function addCustomFilter({
  body,
  opts
}) {
  const customFilter = {
    note: `From ${fullLocation()}`,
    ver: 3,
    id: `customFilter-${Date.now()}`,
    body,
    opts
  };
  filteReddit_module.options[customFilterVariant].value.unshift(customFilter);
  options_save(filteReddit_module.options[customFilterVariant]);
  return customFilter;
}
function updateCustomFilter(customFilter, val) {
  extendDeep(customFilter, val);
  options_save(filteReddit_module.options[customFilterVariant]);
}
async function saveFilterlineStateAsDefault(type) {
  const {
    storage
  } = defaultFilters.find(v => v.type === type) || {};
  if (!storage) throw new Error(`Could not find storage for type ${type}`);
  const v = await filterlineStorage.get();
  let {
    filters
  } = cloneDeep_default()(v) || {};
  if (isEmpty_default()(filters)) filters = null;
  await storage.set(filters);
  notifications_showNotification('Saved.', 1000);
}

function getStringMatchConditions(source, caseType, additionalCriteria) {
  const [matchString = '', applyTo = 'everywhere', applyList = '', except = ''] = source;
  const mainFilter = {
    type: caseType,
    patt: matchString,
    ...additionalCriteria
  };
  if (source.length === 1) return mainFilter;
  let applyToConditions;

  if (applyTo !== 'everywhere') {
    const subreddits = applyList.split(',');

    if (subreddits.findIndex(v => !v) !== -1) {
      console.error('Filter must have subreddits specified', source);
      return {
        type: 'false'
      };
    }

    applyToConditions = getGroup(applyTo === 'exclude' ? 'none' : 'any', [subreddits.includes('all') ? {
      type: 'currentSub',
      patt: 'all'
    } : null, subreddits.includes('popular') ? {
      type: 'currentSub',
      patt: 'popular'
    } : null, ...subreddits.map(sr => ({
      type: 'subreddit',
      patt: sr
    }))].filter(Boolean));
  }

  return getGroup('all', [applyToConditions || null, mainFilter, except && except.length && getGroup('none', [{
    type: caseType,
    patt: except,
    ...additionalCriteria
  }]) || null].filter(Boolean));
}

const reconcileNativeFilters = (() => {
  const getTopScore = batch(async requests => {
    const resp = await ajax({
      url: `/r/${requests.map(r => r.sub).join('+')}/top.json`,
      query: {
        t: 'day',
        limit: 100
      },
      type: 'json'
    });

    if (!resp.data.children.length) {
      return requests.map(() => 0);
    }

    const topScoreBySub = flow_default()(() => resp.data.children.reverse(), keyBy_default()(post => post.data.subreddit.toLowerCase()), mapValues_default()(post => post.data.score))();

    return requests.map(({
      sub,
      depth = 0
    }) => {
      const score = topScoreBySub[sub.toLowerCase()];

      if (score !== undefined) {
        return score;
      } else if (depth > 5) {
        return 0;
      } else {
        return getTopScore({
          sub,
          depth: depth + 1
        });
      }
    });
  }, {
    size: 100,
    delay: 2000
  });

  async function sortByPopularity(subreddits) {
    const scores = await Promise.all(subreddits.map(sub => getTopScore({
      sub
    })));
    return sortBy_default()(zip_default()(subreddits, scores), ([, score]) => score).map(([sub]) => sub).filter(Boolean).reverse();
  }

  return mutex(async ({
    warnNotLoggedIn = false
  } = {}) => {
    const user = context_data.username;

    if (!user) {
      if (warnNotLoggedIn) {
        notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'filterSyncNotLoggedIn',
          header: 'Filters not synced',
          message: 'You must log in to sync filters.'
        });
      }

      console.warn('Not syncing filters, not logged in...');
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'filterSyncStarted',
      message: 'Filter sync started...'
    });
    const {
      data: {
        subreddits
      }
    } = await ajax({
      url: `/api/filter/user/${user}/f/all`,
      type: 'json'
    });
    const existing = subreddits.map(({
      name
    }) => name.toLowerCase());
    const desired = await asyncFlow(map_default()(([sr]) => sr), filter_default()(sr => !string_namespaceObject.regexRegex.test(sr)), map_default()(name => name.toLowerCase()), sortByPopularity, slice_default()(0, 100))(filteReddit_module.options.subreddits.value);

    const toRemove = difference_default()(existing, desired).length;

    const toAdd = difference_default()(desired, existing).length;

    if (!toRemove && !toAdd) {
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncNoneAddedOrRemoved',
        closeDelay: 5000,
        header: 'No filters synced',
        message: `
					Either no subreddit filters were changed, or you have more than 100 subreddits filtered.
					Reddit's native /r/all filtering is limited to 100 subreddits.
				`
      });
      return;
    }

    try {
      await ajax({
        method: 'PUT',
        url: `/api/filter/user/${user}/f/all`,
        data: {
          model: JSON.stringify({
            subreddits: desired.map(name => ({
              name
            }))
          })
        }
      });
    } catch (e) {
      console.error(e);
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncError',
        header: 'Error syncing filters',
        message: `Filters could not be synced: ${e}`
      });
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      optionKey: 'useRedditFilters',
      notificationID: 'filterSyncSuccess',
      header: 'Successfully synced filters',
      message: `Removed ${toRemove} and added ${toAdd} filters.`
    });
  });
})();

const subredditAllowNsfwOption = lodash_once_default()(() => indexOptionTable(filteReddit_module.options.allowNSFW, 0, key => key.toLowerCase()));

const allowAllNsfw = memoize_default()(subreddit => {
  const currOptionValue = subredditAllowNsfwOption()[subreddit.toLowerCase()];
  return currOptionValue && currOptionValue[0][1] === 'visit';
});

function allowNSFW(postSubreddit, currSubreddit = currentSubreddit()) {
  if (!filteReddit_module.options.allowNSFW.value || !filteReddit_module.options.allowNSFW.value.length) return false;

  if (currSubreddit && allowAllNsfw(currSubreddit)) {
    return true;
  }

  if (!postSubreddit) postSubreddit = currSubreddit;
  if (!postSubreddit) return false;
  const postOptionValue = subredditAllowNsfwOption()[postSubreddit.toLowerCase()];

  if (postOptionValue) {
    if (postOptionValue[0][1] === 'everywhere') {
      return true;
    } else {
      return (currSubreddit || '').split('+').includes(postSubreddit);
    }
  }

  return false;
}

function updateNsfwThingClass(thing) {
  if (thing.isNSFW()) {
    if (allowNSFW(thing.getSubreddit(), currentSubreddit())) {
      thing.element.classList.add('allowOver18');
    }

    thing.element.classList.add('over18');
  }
}

function updateNsfwBodyClass(filterOn) {
  bodyClasses_namespaceObject.toggle(filterOn, 'hideOver18');
}

function registerSubredditFilterCommand() {
  const getSubreddit = val => val || selectedThing_namespaceObject.current && selectedThing_namespaceObject.current.getSubreddit() || currentSubreddit() || '';

  registerCommand(/^f(?:ilter)?/, 'f[ilter] [subreddit] - toggle subreddit filter', (cmd, val) => {
    const subreddit = getSubreddit(val);
    return `toggle subreddit filter for: ${subreddit}`;
  }, (cmd, val) => {
    const subreddit = getSubreddit(val);
    if (!subreddit) return 'no subreddit specified or post selected';
    listFilters.subreddits.toggleString(subreddit);
  });
}
// EXTERNAL MODULE: ./node_modules/suncalc/suncalc.js
var suncalc = __webpack_require__(130);

// CONCATENATED MODULE: ./lib/modules/subredditStyleToggle.js







const subredditStyleToggle_module = new Module('subredditStyleToggle');
subredditStyleToggle_module.moduleName = 'subredditStyleToggleName';
subredditStyleToggle_module.category = 'appearanceCategory';
subredditStyleToggle_module.description = 'subredditStyleToggleDesc';
subredditStyleToggle_module.alwaysEnabled = true;
subredditStyleToggle_module.options = {
  browserToolbarButton: {
    title: 'subredditStyleToggleBrowserToolbarButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleBrowserToolbarButtonDesc',
    keywords: ['css'],
    noconfig: true
  },
  checkbox: {
    title: 'subredditStyleToggleCheckboxTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleCheckboxDesc',
    keywords: ['css']
  }
};
const ignoredStorage = storage_namespaceObject.wrap('RESmodules.subredditStyleToggle.ignored', []);
let subredditStyleToggle_toggle;
let subredditStyleToggle_refresh;

subredditStyleToggle_module.onInit = () => {
  pageAction_namespaceObject.hide();
  const ready = Promise.all([shouldDisable(), hasToggleableElements()]).then(([disable, has]) => {
    if (has) {
      bodyClasses_namespaceObject.add('res-srstyle-enabled');
      createToggle(!disable);
    }
  });

  subredditStyleToggle_refresh = nightmodeCompatible => ready.then(async () => {
    if (subredditStyleToggle_toggle) subredditStyleToggle_toggle.toggle('auto', !(await shouldDisable(nightmodeCompatible)));
  });
};

function createToggle(initialState) {
  const subreddit = (currentSubreddit() || '').toLowerCase();
  if (subredditStyleToggle_toggle || !subreddit) return;
  subredditStyleToggle_toggle = new customToggles_Toggle(`${subredditStyleToggle_module.moduleID}.${subreddit}`, 'Custom subreddit style', true);
  subredditStyleToggle_toggle.onToggle(async type => {
    if (type !== 'manual') return;
    await toggledSubredditStyle(subredditStyleToggle_toggle.enabled);
    const ignoredSubreddits = new Set((await ignoredStorage.get()));

    if (subredditStyleToggle_toggle.enabled) {
      ignoredSubreddits.delete(subreddit);
    } else if (await isNightmodeCompatible()) {
      ignoredSubreddits.add(subreddit);
    }

    ignoredStorage.set(Array.from(ignoredSubreddits));
  });
  subredditStyleToggle_toggle.onStateChange(() => {
    toggleElements(subredditStyleToggle_toggle.enabled);
    bodyClasses_namespaceObject.toggle(subredditStyleToggle_toggle.enabled, 'res-srstyle-enabled');
    bodyClasses_namespaceObject.toggle(!subredditStyleToggle_toggle.enabled, 'res-srstyle-disabled');
  });
  subredditStyleToggle_toggle.toggle('auto', initialState);
  makeInteractable();
}

function makeInteractable() {
  if (subredditStyleToggle_module.options.checkbox.value) {
    pagePhases_namespaceObject.sitetableStarted.then(() => {
      const place = document.body.querySelector('.titlebox h1.redditname');
      if (place) insertCheckbox(place);
    });
  }

  if (subredditStyleToggle_module.options.browserToolbarButton.value) {
    pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    subredditStyleToggle_toggle.onStateChange(() => {
      pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    });
    pageAction_namespaceObject.onClick(() => {
      subredditStyleToggle_toggle.toggle('manual');
    });
  }

  subredditStyleToggle_toggle.addCLI('srstyle');

  if (jquery_default()('#show_stylesheets').length) {
    jquery_default()('label[for=show_stylesheets]').after(string_namespaceObject.escape` <span class="little gray">(${i18n('subredditStyleToggleRedditPrefsMessage')} <a href="/r/Enhancement/wiki/srstyle">${i18n('subredditStyleToggleClickToLearnMore')}</a>)</span>`);
  }
}

function insertCheckbox(place) {
  const container = string_namespaceObject.html`
		<form class="toggle res-sr-style-toggle">
			<label for="res-style-checkbox">${i18n('subredditStyleToggleUse')}</label>
		</form>
	`;
  const checkbox = subredditStyleToggle_toggle.buildCheckbox();
  checkbox.setAttribute('id', 'res-style-checkbox');
  checkbox.setAttribute('name', 'res-style-checkbox');
  container.prepend(checkbox);
  place.after(container);
}

const shouldDisable = (nightmodeCompatible = isNightmodeCompatible(true)) => asyncSome([async () => (await ignoredStorage.get()).includes((currentSubreddit() || '').toLowerCase()), async () => !(await nightmodeCompatible)], f => f());

const hasToggleableElements = () => asyncSome([getStylesheet, async () => !!(await getHeaderImg()).headerImg], f => f());

const getStylesheet = lodash_once_default()(async () => {
  const query = () => (document.head || document.documentElement).querySelector('link[title=applied_subreddit_stylesheet]');

  return query() || (await pagePhases_namespaceObject.bodyStart.then(query)) || null;
});

const getHeaderImg = lodash_once_default()(async () => {
  const query = () => document.getElementById('header-img-a');

  const imgWrapper = (await pagePhases_namespaceObject.bodyStart.then(query)) || (await waitForChild(document.body, '#header').then(query)) || (await pagePhases_namespaceObject.contentLoaded.then(query));
  return {
    imgWrapper,
    headerImg: imgWrapper && (() => document.getElementById('header-img'))()
  };
});

const toggleElements = (() => {
  const toggleStylesheet = mutex(async shouldRestore => {
    const subredditStylesheet = await getStylesheet();
    if (!subredditStylesheet) return;

    if (shouldRestore) {
      if (!subredditStylesheet.parentNode) {
        document.head.appendChild(subredditStylesheet);
      }
    } else {
      if (subredditStylesheet.parentNode) {
        subredditStylesheet.remove();
      }
    }
  });
  const toggleHeaderImg = mutex(async shouldRestore => {
    const {
      imgWrapper,
      headerImg
    } = await getHeaderImg();
    if (!imgWrapper || !headerImg) return;

    if (shouldRestore) {
      if (!headerImg.parentNode) {
        imgWrapper.id = 'header-img-a';
        imgWrapper.classList.remove('default-header');
        imgWrapper.appendChild(headerImg);
      }
    } else {
      if (headerImg.parentNode) {
        headerImg.remove();
        imgWrapper.id = 'header-img';
        imgWrapper.classList.add('default-header');
      }
    }
  });
  return shouldRestore => Promise.all([toggleStylesheet(shouldRestore), toggleHeaderImg(shouldRestore)]);
})();
// CONCATENATED MODULE: ./lib/modules/nightMode.js











const nightMode_module = new Module('nightMode');
nightMode_module.moduleName = 'nightModeName';
nightMode_module.category = 'appearanceCategory';
nightMode_module.description = 'nightModeDesc';
nightMode_module.options = {
  nightModeOn: {
    type: 'boolean',
    value: false,
    description: 'nightModeNightModeOnDesc',
    title: 'nightModeNightModeOnTitle'
  },
  nightSwitch: {
    type: 'boolean',
    value: true,
    description: 'nightModeNightSwitchDesc',
    title: 'nightModeNightSwitchTitle',
    advanced: true
  },
  automaticNightMode: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'nightModeAutomaticNightModeNone',
      value: 'none'
    }, {
      name: 'nightModeAutomaticNightModeAutomatic',
      value: 'automatic'
    }, {
      name: 'nightModeAutomaticNightModeUser',
      value: 'user'
    }],
    description: 'nightModeAutomaticNightModeDesc',
    title: 'nightModeAutomaticNightModeTitle'
  },
  nightModeStart: {
    type: 'text',
    value: '20:00',
    description: 'nightModeNightModeStartDesc',
    title: 'nightModeNightModeStartTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeEnd: {
    type: 'text',
    value: '6:00',
    description: 'nightModeNightModeEndDesc',
    title: 'nightModeNightModeEndTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeOverrideHours: {
    type: 'text',
    value: '8',
    description: 'nightModeNightModeOverrideHoursDesc',
    title: 'nightModeNightModeOverrideHoursTitle',
    dependsOn: options => options.automaticNightMode.value !== 'none'
  },
  useSubredditStyles: {
    type: 'boolean',
    value: false,
    description: 'nightModeUseSubredditStylesDesc',
    title: 'nightModeUseSubredditStylesTitle',
    advanced: true
  },
  subredditStylesWhitelist: {
    type: 'list',
    value: '',
    listType: 'subreddits',
    description: 'nightModeSubredditStylesWhitelistDesc',
    title: 'nightModeSubredditStylesWhitelistTitle'
  },
  coloredLinks: {
    type: 'boolean',
    bodyClass: true,
    value: false,
    description: 'nightModeColoredLinksDesc',
    title: 'nightModeColoredLinksTitle'
  }
};
const localStorageKey = 'RES_nightMode';

const nightModeActive = () => typeof localStorage === 'object' && !!localStorage.getItem(localStorageKey);

const nightmodeOverrideStorage = storage_namespaceObject.wrap('RESmodules.nightMode.nightModeOverrideStart', null);
let nightMode_toggle;

nightMode_module.onToggle = enabled => {
  if (nightMode_toggle && nightMode_toggle.enabled && !enabled) nightMode_toggle.toggle();
};

nightMode_module.onInit = () => {
  if (nightModeActive()) addNightMode();
};

nightMode_module.beforeLoad = () => {
  if (isNightModeOn()) {
    addNightMode();
  } else {
    removeNightMode();
  }

  nightMode_toggle = new customToggles_Toggle('nightMode', i18n('nightModeToggleText'), nightMode_module.options.nightModeOn.value);
  nightMode_toggle.onToggle(type => {
    if (type === 'manual') overrideNightMode();
    nightMode_module.options.nightModeOn.value = nightMode_toggle.enabled;
    options_save(nightMode_module.options.nightModeOn);
  });
  nightMode_toggle.onStateChange(() => {
    if (nightMode_toggle.enabled) addNightMode();else removeNightMode();
    isNightmodeCompatible();
  });
  nightMode_toggle.addCLI('ns');
  if (nightMode_module.options.nightSwitch.value) nightMode_toggle.addMenuItem(i18n('nightModeToggleTitle'), 7, '', '');
  handleAutomaticNightMode();
};

nightMode_module.always = () => {
  if (!isRunning(nightMode_module)) {
    removeNightMode();
  }
};

function isNightModeOn() {
  if (!isRunning(nightMode_module)) return false;
  return nightMode_toggle ? nightMode_toggle.enabled : nightMode_module.options.nightModeOn.value;
}
async function isNightmodeCompatible(useCache = false) {
  const subreddit = currentSubreddit();

  if (!subreddit) {
    return true;
  }

  if (['all', 'popular', 'friends', 'mod'].includes(subreddit)) {
    return true;
  }

  const isAllowedByOptions = async () => {
    await loadOptions;

    if (!isNightModeOn()) {
      return true;
    }

    if (nightMode_module.options.useSubredditStyles.value) {
      return true;
    }

    const isWhitelisted = nightMode_module.options.subredditStylesWhitelist.value.split(',').includes(subreddit.toLowerCase());

    if (isWhitelisted) {
      return true;
    }
  };

  const isSubredditCompatible = async () => {
    const query = () => !!document.querySelector('.side a[href$="#/RES_SR_Config/NightModeCompatible"]');

    return query() || (await pagePhases_namespaceObject.bodyStart.then(query)) || (await waitForChild(document.body, '.side').then(query)) || pagePhases_namespaceObject.sitetableStarted.then(query);
  };

  const id = `isNightmodeCompatible.${subreddit.toLowerCase()}`;

  const updatePromise = async function () {
    const compatible = (await isAllowedByOptions()) || (await isSubredditCompatible());
    await session_namespaceObject.set(id, compatible);
    if (cached !== compatible && subredditStyleToggle_refresh) subredditStyleToggle_refresh(compatible);
    return compatible;
  }();

  const stored = await session_namespaceObject.get(id);
  const cached = typeof stored === 'boolean' ? stored : !nightModeActive();
  return useCache ? cached : updatePromise;
}
async function toggledSubredditStyle(toggledOn) {
  const currSub = currentSubreddit();

  if (!isNightModeOn() || !currSub) {
    return;
  }

  const subreddit = currSub.toLowerCase();
  const whitelist = nightMode_module.options.subredditStylesWhitelist.value.split(',');

  if (toggledOn && !(await isNightmodeCompatible())) {
    if (!whitelist.includes(subreddit)) {
      whitelist.push(subreddit);
    }
  } else if (!toggledOn) {
    pull_default()(whitelist, subreddit);
  }

  nightMode_module.options.subredditStylesWhitelist.value = whitelist.join(',');
  return options_save(nightMode_module.options.subredditStylesWhitelist);
}

const handleAutomaticNightMode = lodash_once_default()(async function check() {
  if (nightMode_module.options.automaticNightMode.value === 'none') {
    return;
  }

  const nightModeOverrideStart = await nightmodeOverrideStorage.get();
  const nightModeOverrideLength = HOUR * parseFloat(nightMode_module.options.nightModeOverrideHours.value);
  const nightModeOverrideEnd = (parseInt(nightModeOverrideStart, 10) || 0) + nightModeOverrideLength;
  const isOverrideActive = Date.now() <= nightModeOverrideEnd;
  const needsNightModeToggle = !isOverrideActive && isNightModeOn() !== (await isTimeForNightMode());

  if (needsNightModeToggle) {
    nightMode_toggle.toggle('auto');
  }

  setTimeout(() => requestAnimationFrame(check), 5 * MINUTE);
});

function overrideNightMode() {
  if (nightMode_module.options.automaticNightMode.value === 'none') {
    return;
  }

  nightmodeOverrideStorage.set(Date.now());
}

function getGeolocation() {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(position => resolve(position.coords), reject);
  });
}

async function getNightModeTimes() {
  switch (nightMode_module.options.automaticNightMode.value) {
    case 'automatic':
      try {
        const {
          latitude,
          longitude
        } = await getGeolocation();
        const {
          sunrise,
          sunset
        } = Object(suncalc["getTimes"])(new Date(), latitude, longitude);
        return {
          startingTime: sunset,
          endingTime: sunrise
        };
      } catch (err) {
        console.warn('Failed to init automatic night mode:', err);

        switch (err.code) {
          case err.PERMISSION_DENIED:
            return alert_namespaceObject.open(i18n('nightModeAutomaticNightModeDenied', 'confirm'), {
              cancelable: true
            }).then(() => {
              nightMode_module.options.automaticNightMode.value = 'none';
              options_save(nightMode_module.options.automaticNightMode);
              return {
                startingTime: new Date(0),
                endingTime: new Date(0)
              };
            });

          case err.POSITION_UNAVAILABLE:
          case err.TIMEOUT:
          case err.UNKNOWN_ERROR:
          default:
            throw err;
        }
      }

    case 'user':
      return {
        startingTime: timeStringToDate(nightMode_module.options.nightModeStart.value),
        endingTime: timeStringToDate(nightMode_module.options.nightModeEnd.value)
      };

    default:
      throw new Error(`Invalid automaticNightMode value: ${nightMode_module.options.automaticNightMode.value}`);
  }
}

async function isTimeForNightMode() {
  const currentTime = new Date();
  const {
    startingTime,
    endingTime
  } = await getNightModeTimes();

  if (startingTime <= endingTime) {
    return startingTime <= currentTime && currentTime < endingTime;
  } else {
    return startingTime <= currentTime || currentTime < endingTime;
  }
}

function timeStringToDate(timeString) {
  const [hour, minute] = timeString.split(':').map(s => parseInt(s, 10));
  const date = new Date();
  date.setHours(hour, minute, 0, 0);
  return date;
}

const nightMode_className = () => {
  switch (appType()) {
    case 'r2':
    case 'options':
      return 'res-nightmode';

    case 'd2x':
      return 'res-d2x-nightmode';

    default:
      throw new Error(`Impossible appType: ${appType()}`);
  }
};

const addNightMode = () => {
  bodyClasses_namespaceObject.add(nightMode_className());
  localStorage.setItem(localStorageKey, 'true');
};

const removeNightMode = () => {
  bodyClasses_namespaceObject.remove(nightMode_className());
  localStorage.removeItem(localStorageKey);
};
// CONCATENATED MODULE: ./lib/modules/userTagger.js













const userTagger_module = new Module('userTagger');
const bgToTextColorMap = {
  none: 'inherit',
  aqua: 'black',
  black: 'white',
  blue: 'white',
  cornflowerblue: 'white',
  fuchsia: 'white',
  gray: 'white',
  green: 'white',
  lime: 'black',
  maroon: 'white',
  navy: 'white',
  olive: 'white',
  orange: 'white',
  orangered: 'white',
  pink: 'black',
  purple: 'white',
  red: 'white',
  silver: 'black',
  teal: 'white',
  white: 'black',
  yellow: 'black'
};
userTagger_module.moduleName = 'userTaggerName';
userTagger_module.category = 'usersCategory';
userTagger_module.description = 'userTaggerDesc';
userTagger_module.options = {
  showTaggingIcon: {
    title: 'userTaggerShowTaggingIconTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerShowTaggingIconDesc'
  },
  storeSourceLink: {
    title: 'userTaggerStoreSourceLinkTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerStoreSourceLinkDesc',
    advanced: true
  },
  useCommentsLinkAsSource: {
    title: 'userTaggerUseCommentsLinkAsSourceTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerUseCommentsLinkAsSourceDesc',
    advanced: true
  },
  trackVoteWeight: {
    title: 'userTaggerTrackVoteWeightTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTrackVoteWeightDesc',
    advanced: true
  },
  vwNumber: {
    title: 'userTaggerVwNumberTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerVWNumberDesc',
    advanced: true,
    dependsOn: options => options.trackVoteWeight.value
  },
  truncateTag: {
    title: 'userTaggerTruncateTagTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTruncateTagDesc',
    advanced: true
  },
  presetTags: {
    title: 'userTaggerPresetTagsTitle',
    type: 'table',
    addRowText: '+add preset',
    fields: [{
      key: 'text',
      name: 'text',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'select',
      value: 'none',
      values: Object.entries(bgToTextColorMap).map(([k, v]) => ({
        name: k,
        value: k,
        style: `color: ${v}; background-color: ${k};`
      }))
    }],
    value: [],
    description: 'userTaggerPresetTagsDesc',
    advanced: true
  }
};
const tagStorage = storage_namespaceObject.wrapPrefix('tag.', () => null, user => user.toLowerCase(), true);

userTagger_module.beforeLoad = () => {
  watchForThings(null, thing => {
    const user = thing.getAuthor();
    if (user) userTagger_Tag.get(user);
  }, {
    immediate: true
  });
  watchForElements(['page', 'selfText'], usernameSelector, applyFromElement);
  watchForRedditEvents('postAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;

    for (const tag of element.getElementsByClassName('RESUserTag')) tag.remove();

    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('commentAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('userHovercard', (element, {
    user: {
      username
    },
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username,
      renderTaggingIcon: false
    });
  });
};

userTagger_module.contentStart = () => {
  if (userTagger_module.options.trackVoteWeight.value && loggedInUser()) {
    attachVoteHandler();
  }

  userTagger_registerCommandLine();
  addDashboardTab('userTaggerContents', i18n('userTaggerMyUserTags'), userTagger_module.moduleID, userTagger_addDashboardFunctionality);
};

function applyFromElement(element) {
  const username = getUsernameFromLink(element);
  if (username) return applyToUser(element, {
    username
  });
}

function applyToUser(element, {
  username,
  renderTaggingIcon = userTagger_module.options.showTaggingIcon.value && username !== loggedInUser(),
  renderVoteWeight = userTagger_module.options.trackVoteWeight.value && username !== loggedInUser()
} = {}) {
  const tag = userTagger_Tag.getUnfilled(username);
  tag.add(element, {
    renderVoteWeight,
    renderTaggingIcon
  });
  tag.fill();
}
const tags = new Map();
class userTagger_Tag {
  static buildTagElement({
    text,
    color
  } = {}) {
    return string_namespaceObject.html`
			<span class="RESUserTag">
				<a
					class="userTagLink ${text || color ? 'hasTag' : 'RESUserTagImage'} ${userTagger_module.options.truncateTag.value ? 'truncateTag' : ''}"
					${(text || color) && string_namespaceObject._html`style="background-color: ${color || 'none'}; color: ${bgToTextColorMap[color || 'none']} !important;"`}
					title="${text || 'set a tag'}"
					href="javascript:void 0"
				>${text || '\u00A0'}</a>
			</span>
		`;
  }

  static async getStored() {
    return Object.entries((await tagStorage.getAll())).map(([k, v]) => {
      const tag = userTagger_Tag.getUnfilled(k);
      tag.load(v);
      return tag;
    });
  }

  static getUnfilled(id) {
    let tag = tags.get(id);

    if (!tag) {
      tag = new userTagger_Tag(id);
      tags.set(id, tag);
    }

    return tag;
  }

  static async get(id) {
    const tag = userTagger_Tag.getUnfilled(id);
    await tag.fill();
    return tag;
  }

  get ignored() {
    return listFilters.users.includesString(this.id);
  }

  constructor(id = '~dummy') {
    this.id = void 0;
    this.text = null;
    this.link = null;
    this.color = null;
    this.votesUp = 0;
    this.votesDown = 0;
    this.instances = [];
    this.fill = lodash_once_default()(async () => {
      const data = await tagStorage.get(this.id);

      if (data) {
        if (Object.keys(this.getBaseDifference(data)).length) {
          this.load(data);
        } else {
          this.delete();
        }
      }
    });
    this.id = id;
  }

  load(data) {
    if (data.color !== undefined) this.color = data.color;else if (data.color === 'none') this.color = null;
    if (data.link !== undefined) this.link = data.link;
    if (data.text !== undefined) this.text = data.text;
    if (data.votesDown !== undefined) this.votesDown = data.votesDown;
    if (data.votesUp !== undefined) this.votesUp = data.votesUp;

    for (const instance of this.instances) this.render(instance);
  }

  extract() {
    return {
      color: this.color,
      link: this.link,
      text: this.text,
      votesDown: this.votesDown,
      votesUp: this.votesUp
    };
  }

  save() {
    tagStorage.set(this.id, this.getBaseDifference());
  }

  getBaseDifference(data = this.extract()) {
    const base = new userTagger_Tag().extract();
    return pickBy_default()(data, (v, k) => base[k] !== v);
  }

  delete() {
    tagStorage.delete(this.id);
  }

  add(element, {
    renderTaggingIcon,
    renderVoteWeight,
    append = isAppType('d2x')
  } = {}) {
    const instance = this.instances.find(v => v.element === element) || {
      element
    };
    instance.append = append;
    if (!this.instances.includes(instance)) this.instances.push(instance);
    if (renderTaggingIcon) instance.renderTaggingIcon = true;
    if (renderVoteWeight) instance.renderVoteWeight = true;
    this.render(instance);
  }

  get votes() {
    return this.votesUp - this.votesDown;
  }

  ignore({
    showNotice = true
  } = {}) {
    if (showNotice) {
      notifications_showNotification({
        moduleID: userTagger_module.moduleID,
        notificationID: 'addedToIgnoreList',
        message: `
					<p>Now ignoring content posted by ${this.id}.</p>
					${isPageType('inbox') ? `
						<p>If you wish to block ${this.id} from sending you messages, go to <a href="/message/messages/">your messages</a> and click 'block user' underneath their last message.</p>
						<p><a href="https://www.reddit.com/r/changelog/comments/ijfps/reddit_change_users_may_block_other_users_that/">About blocking users</a>.</p>
					` : ''}
				`,
        closeDelay: 5000
      });
    }

    listFilters.users.toggleString(this.id, true);
    if (!this.text) this.load({
      text: 'ignored'
    });
    this.save();
  }

  unignore() {
    listFilters.users.toggleString(this.id, false);
    if (this.text === 'ignored') this.load({
      text: null
    });
    this.save();
  }

  openPrompt(instance) {
    if (this.link === null && userTagger_module.options.storeSourceLink.value) {
      this.link = getLinkBasedOnTagLocation(instance.element);
    }

    infocard('userTagger').target(instance.tagger || instance.element).options({
      openDelay: 0,
      width: 350,
      closeOnMouseOut: false
    }).populateWith(card => populateDialog(this, card)).begin();
  }

  render(instance) {
    if (instance.vw) instance.vw.remove();

    if (instance.renderVoteWeight && (this.votesUp || this.votesDown)) {
      instance.vw = preventCloning(string_namespaceObject.html`
				<a
					class="voteWeight"
					href="javascript:void 0"
					title="${i18n('userTaggerYourVotesFor', this.id, `+${this.votesUp} -${this.votesDown}`)}"
					style="${getVoteWeightStyle(this)}"
				>${userTagger_module.options.vwNumber.value ? `[${this.votes > 0 ? '+' : ''}${this.votes}]` : '[vw]'}</a>
			`);
      instance.vw.addEventListener('click', () => this.openPrompt(instance));

      if (instance.append) {
        (instance.tagger || instance.element).appendChild(instance.vw);
      } else {
        (instance.tagger || instance.element).after(instance.vw);
      }
    }

    if (instance.tagger) instance.tagger.remove();

    if (this.text || this.color || instance.renderTaggingIcon) {
      instance.tagger = preventCloning(this.text || this.color ? userTagger_Tag.buildTagElement(this) : userTagger_Tag.defaultTagElement());
      instance.tagger.addEventListener('click', () => this.openPrompt(instance));

      if (instance.append) {
        instance.element.appendChild(instance.tagger);
      } else {
        instance.element.after(instance.tagger);
      }
    }
  }

}

userTagger_Tag.defaultTagElement = (e => () => e().cloneNode(true))(lodash_once_default()(() => userTagger_Tag.buildTagElement()));

function populateDialog(tag, card) {
  const head = string_namespaceObject.html`<div class="userTagger-dialog-head">
		<span class="res-icon">&#xF0AC;</span>
		<span>${tag.id}</span>
		<span class="res-usertag-ignore"></span>
		</div>
	</div>`;
  const colors = Object.entries(bgToTextColorMap).map(([color, textColor]) => ({
    textColor,
    color
  }));
  const presetTags = userTagger_module.options.presetTags.value;
  const body = string_namespaceObject.html`
		<form id="userTaggerToolTip">
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerText">Text</label>
				<input class="fieldPair-text" type="text" id="userTaggerText" value="${tag.text}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerColor">Color</label>
				<select id="userTaggerColor">
					${colors.map(({
    textColor,
    color
  }) => string_namespaceObject._html`
						<option style="color: ${textColor}; background-color: ${color}" value="${color}" ${tag.color === color && string_namespaceObject._html`selected`}>${color}</option>
					`)}
				</select>
			</div>
			<div class="fieldPair" style="flex-wrap: wrap">
				<label class="fieldPair-label" for="userTaggerPreview">Preview</label>
				<span id="userTaggerPreview"></span>
				<a id="userTaggerPresetSaveAs" title="save as preset" href="javascript:void 0">save as preset</a>
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerLink">
					<span class="userTaggerOpenLink">
						<a title="open link" href="javascript:void 0">Source URL</a>
					</span>
				</label>
				<input class="fieldPair-text" type="text" id="userTaggerLink" value="${tag.link}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesUp" title="Upvotes you have given this redditor">Upvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesUp" value="${tag.votesUp}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesDown" title="Downvotes you have given this redditor">Downvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesDown" value="${tag.votesDown}">
			</div>
			<div class="fieldPair" ${!presetTags.length && 'hidden'}>
				<label class="fieldPair-label" for="userTaggerPresetTags">Presets</label>
				<span id="userTaggerPresetTags"></span>
			</div>
			<div class="res-usertagger-footer">
				<a href="/r/dashboard#userTaggerContents" target="_blank" rel="noopener noreferer">View tagged users</a>
				<input type="submit" id="userTaggerSave" value=" save tag">
			</div>
		</form>
	`;
  const elements = {
    color: downcast(body.querySelector('#userTaggerColor'), HTMLSelectElement),
    presetSaveAs: downcast(body.querySelector('#userTaggerPresetSaveAs'), HTMLAnchorElement),
    presetTag: downcast(body.querySelector('#userTaggerPresetTags'), HTMLElement),
    presetFieldPair: downcast(body.querySelector('#userTaggerPresetTags').parentElement, HTMLElement),
    link: downcast(body.querySelector('#userTaggerLink'), HTMLInputElement),
    openLink: downcast(body.querySelector('.userTaggerOpenLink a'), HTMLAnchorElement),
    preview: downcast(body.querySelector('#userTaggerPreview'), HTMLElement),
    save: downcast(body.querySelector('#userTaggerSave'), HTMLElement),
    text: downcast(body.querySelector('#userTaggerText'), HTMLInputElement),
    votesDown: downcast(body.querySelector('#userTaggerVotesDown'), HTMLInputElement),
    votesUp: downcast(body.querySelector('#userTaggerVotesUp'), HTMLInputElement)
  };
  head.querySelector('.res-usertag-ignore').append(createElement_namespaceObject.toggleButton(ignore => {
    const textShouldBeUpdated = extract().text === tag.text;
    if (ignore) tag.ignore();else tag.unignore();
    if (textShouldBeUpdated) elements.text.value = tag.text || '';
    updateTagPreview();
  }, 'userTaggerIgnore', tag.ignored, '\uF038', '\uF03B', false, true));

  function extract() {
    return {
      color: elements.color.value !== 'none' ? elements.color.value : null,
      link: elements.link.value || null,
      text: elements.text.value || null,
      votesDown: parseInt(elements.votesDown.value, 10) || 0,
      votesUp: parseInt(elements.votesUp.value, 10) || 0
    };
  }

  function updateTagPreview() {
    empty(elements.preview);
    elements.preview.appendChild(userTagger_Tag.buildTagElement(extract()));
  }

  function buildPresetTagElement(text, color) {
    const element = userTagger_Tag.buildTagElement({
      text,
      color
    });
    element.addEventListener('click', () => {
      tag.load({
        text,
        color
      });
      tag.save();
      card.close();
    });
    return element;
  }

  function saveAsPreset() {
    const {
      text,
      color
    } = extract();

    if (text || color) {
      elements.presetFieldPair.hidden = false;
      elements.presetTag.append(buildPresetTagElement(text, color));
      userTagger_module.options.presetTags.value.push([String(text), String(color)]);
      options_save(userTagger_module.options.presetTags);
    } else {
      window.alert('Tag text must be specified in order to save as preset.');
    }
  }

  elements.openLink.addEventListener('click', () => openNewTabs('none', ...elements.link.value.split(/\s/)));
  elements.presetTag.append(...presetTags.map(([text, color]) => buildPresetTagElement(text, color)));
  elements.presetSaveAs.addEventListener('click', () => saveAsPreset());
  jquery_default()(body).on('change input click', updateTagPreview);
  body.addEventListener('submit', e => {
    e.preventDefault();
    tag.load(extract());
    tag.save();
    card.close();
  });
  updateTagPreview();
  setTimeout(() => {
    elements.text.setSelectionRange(elements.text.value.length, elements.text.value.length);
    elements.text.focus();
  });
  return [head, body];
}

function userTagger_registerCommandLine() {
  let tag;
  registerCommand('tag', `tag [text] - ${i18n('userTaggerCommandLineDescription')}`, async (command, val) => {
    const username = selectedThing_namespaceObject.current && selectedThing_namespaceObject.current.getAuthor();
    tag = username && (await userTagger_Tag.get(username));
    return tag ? i18n(val ? 'userTaggerTagUserAs' : 'userTaggerTagUser', tag.id, val) : i18n('userTaggerTagCanNotSetTag');
  }, (command, val) => {
    if (tag) {
      tag.load({
        text: val
      });
      tag.save();
    } else {
      return i18n('userTaggerTagCanNotSetTag');
    }
  });
}

function attachVoteHandler() {
  document.body.addEventListener('click', e => {
    if (e.button !== 0) return;

    if (e.target.classList.contains('arrow')) {
      handleVoteClick(e.target);
    }
  }, true);
}

async function handleVoteClick(arrow) {
  const $this = jquery_default()(arrow);
  const $otherArrow = $this.siblings('.arrow');

  if ($this.hasClass('archived')) {
    return;
  }

  let up = 0;
  let down = 0;

  if ($this.hasClass('up')) {
    up = 1;

    if ($otherArrow.hasClass('downmod')) {
      down = -1;
    }
  } else if ($this.hasClass('upmod')) {
    up = -1;
  } else if ($this.hasClass('down')) {
    down = 1;

    if ($otherArrow.hasClass('upmod')) {
      up = -1;
    }
  } else if ($this.hasClass('downmod')) {
    down = -1;
  }

  const thing = Thing_Thing.checkedFrom(arrow);
  const username = thing.getAuthor();
  if (username === loggedInUser()) return;
  const tag = username && (await userTagger_Tag.get(username));
  if (!tag) throw new Error('No tag');
  tag.load({
    votesUp: tag.votesUp + up,
    votesDown: tag.votesDown + down
  });
  tag.save();
}

function getLinkBasedOnTagLocation(obj) {
  const thing = Thing_Thing.from(obj);
  if (!thing) return '';
  const link = !userTagger_module.options.useCommentsLinkAsSource.value && thing.getTitleElement() || thing.getCommentPermalink();
  return link ? link.href : '';
}

function getVoteWeightStyle({
  votes,
  votesUp,
  votesDown
}) {
  let red = 255;
  let green = 255;
  let blue = 255;
  let alpha = 1;

  if (votesUp > votesDown) {
    red = Math.max(0, 255 - 8 * votes);
    green = 255;
    blue = Math.max(0, 255 - 8 * votes);
    alpha = Math.abs(votes) / (votesUp + votesDown);
  } else if (votesUp < votesDown) {
    red = 255;
    green = Math.max(0, 255 - Math.abs(8 * votes));
    blue = Math.max(0, 255 - Math.abs(8 * votes));
    alpha = Math.abs(votes) / (votesUp + votesDown);
  }

  const color = `rgba(${red}, ${green}, ${blue}, ${0.2 + alpha * 0.8})`;
  return isNightModeOn() ? `color: ${color};` : `background-color: ${color};`;
}

async function userTagger_addDashboardFunctionality(tabPage) {
  const headers = {
    username: i18n('userTaggerUsername'),
    tag: i18n('userTaggerTag'),
    color: i18n('userTaggerColor'),
    votesDown: i18n('userTaggerVotesDown'),
    votesUp: i18n('userTaggerVotesUp'),
    delete: ''
  };
  const data = await userTagger_Tag.getStored();
  const table = new table_namespaceObject.RESTable(headers, data, tag => {
    const tagSpan = document.createElement('span');
    tag.add(tagSpan, {
      renderTaggingIcon: true,
      append: true
    });
    const deleteSpan = string_namespaceObject.html`<span class="res-icon res-right deleteIcon" data-icon="&#xf056;"></span>`;
    deleteSpan.addEventListener('click', e => {
      alert_namespaceObject.open(i18n('userTaggerAreYouSureYouWantToDeleteTag', tag.id), {
        cancelable: true
      }).then(() => {
        tag.delete();
        e.currentTarget.closest('tr').remove();

        pull_default()(data, tag);
      });
    });
    return {
      username: string_namespaceObject.html`<a href="/user/${tag.id}">${tag.id}</a>`,
      tag: tagSpan,
      color: string_namespaceObject.html`<span style="color: ${tag.color || 'initial'}">${tag.color ? tag.color : ''}</span>`,
      votesDown: tag.votesDown,
      votesUp: tag.votesUp,
      delete: deleteSpan
    };
  }, {
    sortBy: 'username'
  });
  const element = document.createElement('div');
  element.append(table.createSearchElement(tag => tag.id, 'Username', true), table.createSelectFilters([{
    name: i18n('userTaggerAllUsers'),
    filter: () => true,
    initialSelected: false
  }, {
    name: i18n('userTaggerTaggedUsers'),
    filter: tag => tag.text,
    initialSelected: true
  }]), table.createPaginationElement(), table.element);
  tabPage.append(element);
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserTag.js


class UserTag_UserTag extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `user tag ${this.conditions.patt}`.trim();
    this.value = this.build(true, '/./');
  }

  static async thingToCriterion(thing) {
    const author = thing.getAuthor();
    return author && (await userTagger_Tag.get(author)).text || '';
  }

  async evaluate(thing) {
    const author = thing.getAuthor();
    if (!author) return null;
    const tag = (await userTagger_Tag.get(author)).text;
    return tag ? this.value.some(v => v.test(tag)) : false;
  }

}
UserTag_UserTag.text = 'User tag';
UserTag_UserTag.fields = ['author of this post has tag matching ', {
  type: 'text',
  id: 'patt'
}];
UserTag_UserTag.pattern = '[RegEx]';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserVoteWeight.js




class UserVoteWeight_UserVoteWeight extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `vote weight ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `vote weight ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    const username = thing.getAuthor();
    if (!username) throw new Error('No username');
    return String((await userTagger_Tag.get(username)).votes || 0);
  }

  static get disabled() {
    return !modules_isEnabled(userTagger_namespaceObject) || !userTagger_module.options.trackVoteWeight.value;
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  async evaluate(thing) {
    const username = thing.getAuthor();
    if (!username) return null;
    return numericalCompare(this.value.op, (await userTagger_Tag.get(username)).votes, this.value.val);
  }

}
UserVoteWeight_UserVoteWeight.text = 'User vote weight';
UserVoteWeight_UserVoteWeight.defaultConditions = {
  op: '>',
  val: 0
};
UserVoteWeight_UserVoteWeight.fields = ['user\'s vote weight is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' votes'];
UserVoteWeight_UserVoteWeight.slow = 1;
UserVoteWeight_UserVoteWeight.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Username.js

class Username_Username extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getAuthor();
  }

  evaluate(thing) {
    const user = thing.getAuthor();
    if (!user) return null;
    return this.value.some(v => v.test(user));
  }

}
Username_Username.text = 'Username';
Username_Username.fields = ['posted by /u/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/VoteType.js

const VoteType_options = [['upvoted', 'upvote'], ['downvoted', 'downvote'], ['not voted', 'unvoted']];
class VoteType_VoteType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = (VoteType_options.find(([, cls]) => cls === this.conditions.kind) || [])[0];
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return VoteType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'upvote':
        return thing.isUpvoted();

      case 'downvote':
        return thing.isDownvoted();

      case 'unvoted':
        return thing.isUnvoted();

      default:
        throw new Error('Invalid option');
    }
  }

}
VoteType_VoteType.text = 'Vote type';
VoteType_VoteType.defaultConditions = {
  kind: 'unvoted'
};
VoteType_VoteType.fields = ['post is ', {
  type: 'select',
  id: 'kind',
  options: VoteType_options
}, ' by me'];
VoteType_VoteType.pattern = `(${VoteType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/index.js























// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentContent.js

class CommentContent_CommentContent extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `comment contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  evaluate(thing) {
    const body = thing.getTextBody();
    if (!body) return null;
    return this.value.some(v => v.test(body.textContent));
  }

}
CommentContent_CommentContent.text = 'Comment content';
CommentContent_CommentContent.fields = ['comment contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentLength.js


const CommentLength_options = ['characters', 'words'];
class CommentLength_CommentLength extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `length ${prettyOperator(this.conditions.op)} ${this.conditions.val} ${this.conditions.kind}`;
    this.falseText = `length ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val} ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      kind: 'words',
      val: parseInt(input, 10)
    };
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const md = thing.entry.querySelector('.md');
    if (!md) return null;

    switch (this.value.kind) {
      case 'characters':
        return numericalCompare(this.value.op, md.textContent.length, this.value.val);

      case 'words':
        return numericalCompare(this.value.op, md.textContent.split(' ').length, this.value.val);

      default:
        throw new Error('Invalid option');
    }
  }

}
CommentLength_CommentLength.text = 'Comment length';
CommentLength_CommentLength.fields = ['comment length is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' ', {
  type: 'select',
  id: 'kind',
  options: CommentLength_options
}];
CommentLength_CommentLength.defaultConditions = {
  op: '>',
  kind: 'words',
  val: 0
};
CommentLength_CommentLength.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/Depth.js


class Depth_Depth extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `depth ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `depth ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '==',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getParents().length);
  }

  isValid() {
    return this.value.val >= 0;
  }

  evaluate(thing) {
    const depth = thing.getParents().length;
    return numericalCompare(this.value.op, depth, this.value.val);
  }

}
Depth_Depth.text = 'Comment depth';
Depth_Depth.defaultConditions = {
  op: '>',
  val: 0
};
Depth_Depth.fields = ['comment\'s depth ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}];
Depth_Depth.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsDeleted.js

class IsDeleted_IsDeleted extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'deleted';
  }

  evaluate(thing) {
    return thing.isDeleted();
  }

}
IsDeleted_IsDeleted.text = 'Deleted';
IsDeleted_IsDeleted.fields = ['comment is deleted'];
IsDeleted_IsDeleted.unique = true;
// CONCATENATED MODULE: ./lib/modules/readComments.js





const readComments_module = new Module('readComments');
readComments_module.moduleName = 'readCommentsName';
readComments_module.category = 'commentsCategory';
readComments_module.description = 'readCommentsDesc';
readComments_module.options = {
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'readCommentsCleanCommentsDesc',
    title: 'readCommentsCleanCommentsTitle',
    advanced: true
  },
  monitorSelected: {
    type: 'boolean',
    value: true,
    description: 'readCommentsMonitorSelectedDesc',
    title: 'readCommentsMonitorSelectedTitle'
  },
  monitorWhenIncognito: {
    type: 'boolean',
    value: false,
    dependsOn: () => readComments_module.options.monitorSelected.value,
    description: 'readCommentsMonitorWhenIncognitoDesc',
    title: 'readCommentsMonitorWhenIncognitoTitle',
    advanced: true
  }
};
readComments_module.include = ['comments', 'commentsLinklist'];
const currentId = (execRegexes.comments(location.pathname) || [])[2] || location.pathname;
const readComments_entryStorage = storage_namespaceObject.wrapPrefix('readComments.', () => ({
  updateTime: Date.now(),
  ids: {}
}));
const readComments_initial = readComments_entryStorage.get(currentId);
let readComments_ids;

readComments_module.beforeLoad = async () => {
  readComments_ids = await readComments_initial.then(({
    ids
  }) => new Set(Object.keys(ids)));
  maybeHidePrevious();

  if (readComments_module.options.monitorSelected.value) {
    if (!readComments_module.options.monitorWhenIncognito.value && isPrivateBrowsing()) return;
    selectedThing_namespaceObject.addListener(current => {
      if (current.isComment() && current.isContentVisible()) readComments_add(current);
    }, 'beforePaint');
  }

  maybePruneOldEntries('readComments', readComments_entryStorage, parseInt(readComments_module.options.cleanComments.value, 10));
};

async function maybeHidePrevious() {
  if (!readComments_ids.size) return;
  const filterline = await filterlinePromise;
  const filter = filterline.createFilter({
    type: 'isRead',
    id: 'isRead'
  });
  if (filter.state === false && filter.effects.hide) return;
  await new Promise(res => watchForThings(['comment'], thing => {
    if (isRead(thing)) res();
  }));
  const hideButton = document.createElement('button');
  hideButton.textContent = 'Hide read comments';
  hideButton.addEventListener('click', () => {
    filter.update(false, undefined, {
      hide: true
    });
    if (!filter.parent) filterline.addFilter(filter);
    if (ensureFilterlineVisible) ensureFilterlineVisible();
    notification.close();
  });
  const notification = notifications_showNotification({
    moduleID: readComments_module.moduleID,
    notificationID: 'hideRead',
    header: 'Previously read comments',
    message: hideButton,
    closeDelay: 8000
  });
}

const _add = batch(ids => readComments_entryStorage.patch(currentId, {
  ids: ids.reduce((acc, id) => {
    acc[id] = true;
    return acc;
  }, {}),
  updateTime: Date.now()
}), {
  size: Infinity,
  delay: 5000,
  flushBeforeUnload: true
});

const readComments_add = thing => {
  if (!readComments_ids) return;
  const id = thing.getFullname();

  _add(id);
};
const isRead = thing => {
  if (!readComments_ids) throw new Error();
  return readComments_ids.has(thing.getFullname());
};
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsRead.js



class IsRead_IsRead extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'read';
  }

  static get disabled() {
    return !modules_isEnabled(readComments_namespaceObject);
  }

  evaluate(thing) {
    return isRead(thing);
  }

}
IsRead_IsRead.text = 'Read';
IsRead_IsRead.fields = ['comment is read'];
IsRead_IsRead.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/index.js
















// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/BrowsingFrontPage.js


class BrowsingFrontPage_BrowsingFrontPage extends Case_Case {
  evaluate() {
    return isPageType('linklist') && !currentSubreddit() && !currentMultireddit() && !currentUserProfile();
  }

}
BrowsingFrontPage_BrowsingFrontPage.text = 'Browsing the front page';
BrowsingFrontPage_BrowsingFrontPage.fields = ['when browsing the front page'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentLocation.js


class CurrentLocation_CurrentLocation extends Case_Case {
  evaluate() {
    return fullLocation() === this.value.patt;
  }

}
CurrentLocation_CurrentLocation.text = 'When browsing in location';
CurrentLocation_CurrentLocation.defaultConditions = {
  patt: fullLocation()
};
CurrentLocation_CurrentLocation.fields = ['when browsing ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentMulti.js


class CurrentMulti_CurrentMulti extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      name: Case_Case.buildRegex(this.conditions.name),
      user: Case_Case.buildRegex(this.conditions.user)
    };
  }

  evaluate() {
    const rawMulti = currentMultireddit();
    if (!rawMulti) return false;
    const parts = /^(?:user\/)?([a-z0-9_-]+)\/m\/([a-z0-9_-]+)$/i.exec(rawMulti);
    if (!parts) return false;
    const [, user, multi] = parts;

    if (user === 'me' && this.conditions.name === 'me') {
      return this.value.name.test(multi);
    } else {
      return this.value.user.test(user) && this.value.name.test(multi);
    }
  }

}
CurrentMulti_CurrentMulti.text = 'When browsing a multireddit';
CurrentMulti_CurrentMulti.defaultConditions = {
  user: '',
  name: ''
};
CurrentMulti_CurrentMulti.fields = ['when browsing /u/', {
  type: 'text',
  id: 'user'
}, '/m/', {
  type: 'text',
  id: 'name'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentUserProfile.js


class CurrentUserProfile_CurrentUserProfile extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const user = currentUserProfile();
    return !!user && this.value.test(user);
  }

}
CurrentUserProfile_CurrentUserProfile.text = 'When browsing a user profile';
CurrentUserProfile_CurrentUserProfile.defaultConditions = {
  patt: ''
};
CurrentUserProfile_CurrentUserProfile.fields = ['when browsing /u/', {
  type: 'text',
  id: 'patt'
}, '\'s posts'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentSub.js


class CurrentSub_CurrentSub extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const sub = currentSubreddit();
    return !!sub && this.value.test(sub);
  }

}
CurrentSub_CurrentSub.text = 'When browsing a subreddit';
CurrentSub_CurrentSub.defaultConditions = {
  patt: ''
};
CurrentSub_CurrentSub.fields = ['when browsing /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Date.js


const Date_options = [['before', '<'], ['on or after', '>=']];
class Date_Date extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      op: this.conditions.op,
      date: localization_dayjs(this.conditions.date)
    };
  }

  isValid() {
    return this.value.date.isValid();
  }

  evaluate() {
    return this.value.op === '<' === localization_dayjs().isBefore(this.value.date);
  }

}
Date_Date.text = 'Date';
Date_Date.defaultConditions = {
  op: '<',
  date: '2020-12-30'
};
Date_Date.fields = ['today is ', {
  type: 'select',
  options: Date_options,
  id: 'op'
}, ' ', {
  type: 'text',
  id: 'date'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Dow.js

const Dow_days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
class Dow_Dow extends Case_Case {
  evaluate() {
    const currentDOW = Dow_days[new Date().getDay()];
    return this.value.days.includes(currentDOW);
  }

}
Dow_Dow.text = 'Day of week';
Dow_Dow.defaultConditions = {
  days: []
};
Dow_Dow.fields = ['current day of the week is ', {
  type: 'checkset',
  items: Dow_days,
  id: 'days'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/LoggedInAs.js


class LoggedInAs_LoggedInAs extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.loggedInAs);
  }

  async evaluate() {
    await pagePhases_namespaceObject.sitetableStarted;
    const myName = loggedInUser();
    return !!myName && this.value.test(myName);
  }

}
LoggedInAs_LoggedInAs.text = 'Logged in user';
LoggedInAs_LoggedInAs.defaultConditions = {
  loggedInAs: ''
};
LoggedInAs_LoggedInAs.fields = ['logged in as /u/', {
  type: 'text',
  id: 'loggedInAs'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Toggle.js



const getOptions = () => customToggles_getToggles().map(({
  key,
  text
}) => [text, key]);

class Toggle_Toggle extends Case_Case {
  evaluate() {
    const key = this.value.toggleName;
    return toggleActive(key);
  }

}
Toggle_Toggle.text = 'Custom toggle';
Toggle_Toggle.defaultConditions = {
  toggleName: getOptions()[0] || ''
};
Toggle_Toggle.fields = ['custom toggle ', {
  type: 'select',
  id: 'toggleName',

  get options() {
    return getOptions();
  }

}, ' is enabled'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/index.js









// CONCATENATED MODULE: ./lib/modules/filteReddit/cases.js






class cases_Inert extends Case_Case {
  isValid() {
    return false;
  }

  evaluate() {
    console.error('Evaluating inert case');
    return false;
  }

}

class cases_True extends Case_Case {
  evaluate() {
    return true;
  }

}

cases_True.text = 'True';
cases_True.fields = ['always true'];

class cases_False extends Case_Case {
  evaluate() {
    return false;
  }

}

cases_False.text = 'False';
cases_False.fields = ['always false'];
class cases_Group extends Case_Case {
  constructor(...args) {
    super(...args);
    this._cases = this.conditions.of.map(v => Case_Case.fromConditions(v));
    this.trueText = this._cases.length && this.toCriterion(this.conditions.op, this._cases) || 'empty group';

    this.value = (() => {
      const op = this.conditions.op;
      const [NONE, ANY, ONE, ALL] = [op === 'none', op === 'any', op === 'one', op === 'all'];

      const evaluators = this._cases.sort((a, b) => a.constructor.slow - b.constructor.slow).map(cased => cased.evaluate.bind(cased));

      return fastAsync(function* (thing) {
        let seenTrue = false;

        for (const evaluator of evaluators) {
          if (yield evaluator(thing)) {
            if (NONE) return false;else if (ANY) return true;else if (ONE && seenTrue) return false;
            seenTrue = true;
          } else {
            if (ALL) return false;
          }
        }

        if (NONE) return true;else if (ANY) return false;else if (ONE) return seenTrue;else return true;
      });
    })();
  }

  toCriterion(op, cases) {
    let str = cases.map(v => v.trueText).join(` ${(op === 'any' || op === 'none') && '' || op === 'one' && '' || ''} `);
    if (cases.length > 1) str = `(${str})`;
    return op === 'none' ? ` ${str}` : str;
  }

  isValid() {
    return this._cases.every(v => v.isValid());
  }

  hasType(type) {
    return super.hasType(type) || this._cases.some(v => v.hasType(type));
  }

  evaluate(thing) {
    return this.value(thing);
  }

  onObserve() {
    return this._cases.map(v => v.observe(this)).some(v => v);
  }

}
cases_Group.text = 'Group of conditions';
cases_Group.fields = [{
  type: 'select',
  options: ['none', 'any', 'one', 'all'],
  id: 'op'
}, ' of these are true:', {
  type: 'multi',
  include: 'all',
  id: 'of'
}];
cases_Group.defaultConditions = {
  op: 'all',
  of: []
};
cases_Group.slow = 1;
const falseConditions = {
  type: 'false'
};
const trueConditions = {
  type: 'true'
};
const inertConditions = {
  type: 'inert'
};
function resolveGroup(initial, precompute = true, keepGroup = false) {
  let seenTrue = false;
  let of = [];
  let op = initial.op;

  for (let v of initial.of) {
    if (!cases_has(v.type)) {
      console.error(`Type ${v.type} is not available`);
      return inertConditions;
    }

    if (v.type === 'group') v = resolveGroup(v, precompute);

    if (!keepGroup && precompute && !available[v.type].prototype.evaluate.length) {
      const match = Case_Case.fromConditions(v).evaluate();

      if (typeof match === 'boolean') {
        if (match) {
          if (op === 'none') return falseConditions;
          if (op === 'any') return trueConditions;
          if (op === 'one' && seenTrue) return falseConditions;
          seenTrue = true;
        } else {
          if (op === 'all') return falseConditions;
        }

        continue;
      }
    }

    of.push(v);
  }

  if (op === 'one' && seenTrue) {
    op = 'none';
  }

  if (!keepGroup) {
    if (of.length === 1) {
      const p = of[0];

      if (op !== 'none') {
        return p;
      } else if (p.type === 'group') {
        if (p.op === 'none') {
          p.op = 'any';
          return p;
        } else if (p.op === 'any' || p.op === 'all') {
          p.op = 'none';
          return p;
        }
      }
    }

    if (!of.length) {
      if (op === 'none') return trueConditions;
      if (op === 'any') return falseConditions;
      if (op === 'one') return falseConditions;
      if (op === 'all') return trueConditions;
    }
  }

  if (precompute && (op === 'any' || op === 'none')) {
    const l = of.length;
    const typeSorted = of.sort((a, b) => a.type === b.type ? 0 : a.type > b.type ? 1 : -1);
    of = [];

    for (let i = 0; i < l; i++) {
      const a = typeSorted[i];
      const cls = available[a.type];
      const reconcile = cls.reconcile;

      if (reconcile) {
        const values = [a];
        let b;

        while ((b = typeSorted[i + 1]) && a.type === b.type) {
          i++;
          values.push(b);
        }

        of.push(...reconcile(values));
      } else {
        of.push(a);
      }
    }
  }

  return {
    type: 'group',
    op,
    of
  };
}
function cases_getConditions(type, conditions) {
  return {
    type,
    ...(available[type] && available[type].defaultConditions),
    ...conditions
  };
}
function getGroup(op, of) {
  return cases_getConditions('group', {
    op,
    of
  });
}
function createAdHoc(type, getConditions, variant, context, customFilter) {
  const {
    opts: {
      name = type
    } = {}
  } = customFilter || {};

  class AdHoc extends Case_Case {
    static get defaultConditions() {
      return getConditions();
    }

  }

  AdHoc.text = name;
  AdHoc.unique = true;
  AdHoc.variant = variant;
  AdHoc._customFilter = customFilter;
  cases_add(type, AdHoc, context);
  return AdHoc;
}
const available = {};

function getUniqueTypeName(name) {
  if (typeof name !== 'string') name = '';

  while (!name || cases_has(name)) {
    name += randomHash();
  }

  return name;
}

function cases_add(type, c, ...contexts) {
  if (!type || available.hasOwnProperty(type) && c !== available[type]) {
    type = getUniqueTypeName(type);
  }

  c.type = type;
  if (!c.contexts) c.contexts = [];
  c.contexts.push(...contexts);
  available[type] = c;
}
const primitives = new Set();
function populatePrimitives(types = ['post', 'comment', 'browse']) {
  function fill(cases, ...contexts) {
    for (const [k, v] of Object.entries(cases)) {
      cases_add(k, v, ...contexts);
      primitives.add(v);
    }
  }

  fill({
    inert: cases_Inert,
    false: cases_False,
    true: cases_True
  });
  fill({
    group: cases_Group
  }, 'post', 'comment', 'browse');
  if (types.includes('post')) fill(postCases_namespaceObject, 'post');
  if (types.includes('comment')) fill(commentCases_namespaceObject, 'comment');
  if (types.includes('browse')) fill(browseCases_namespaceObject, 'browse');
}
function filterThings(things, conditions) {
  if (!conditions) return things;
  const cased = Case_Case.fromConditions(conditions);
  return asyncFilter(things, thing => cased.evaluate(thing));
}
const cases_remove = type => {
  delete available[type];
};
const cases_has = type => available.hasOwnProperty(type);
const cases_get = type => cases_has(type) ? available[type] : cases_Inert;
const getByContext = (context, primitivesOnly = true) => pickBy_default()(available, v => v.contexts.includes(context) && (!primitivesOnly || primitives.has(v)));
const isUseful = type => typeof type === 'string' && cases_has(type) && ![cases_Inert.type, cases_False.type, cases_True.type].includes(type);
// CONCATENATED MODULE: ./lib/modules/accountSwitcher.js









const accountSwitcher_module = new Module('accountSwitcher');
accountSwitcher_module.moduleName = 'accountSwitcherName';
accountSwitcher_module.category = 'myAccountCategory';
accountSwitcher_module.description = 'accountSwitcherDesc';
accountSwitcher_module.options = {
  keepLoggedIn: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherKeepLoggedInDesc',
    title: 'accountSwitcherKeepLoggedInTitle',
    keywords: ['remember']
  },
  accounts: {
    type: 'table',
    addRowText: 'accountSwitcherAddAccount',
    fields: [{
      key: 'username',
      name: 'accountSwitcherUsername',
      type: 'text'
    }, {
      key: 'password',
      name: 'accountSwitcherPassword',
      type: 'password'
    }, {
      key: '2fa',
      name: 'accountSwitcherRequiresOtp',
      type: 'boolean',
      value: false
    }],
    value: [],
    description: 'accountSwitcherAccountsDesc',
    title: 'accountSwitcherAccountsTitle'
  },
  updateOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherUpdateOtherTabsDesc',
    title: 'accountSwitcherUpdateOtherTabsTitle',
    value: true,
    advanced: true
  },
  reloadOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherReloadOtherTabsDesc',
    title: 'accountSwitcherReloadOtherTabsTitle',
    value: false,
    advanced: true
  },
  showCurrentUserName: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherShowCurrentUserNameDesc',
    title: 'accountSwitcherShowCurrentUserNameTitle',
    advanced: true
  },
  dropDownStyle: {
    type: 'enum',
    values: [{
      name: 'accountSwitcherSnoo',
      value: 'alien'
    }, {
      name: 'accountSwitcherSimpleArrow',
      value: 'arrow'
    }],
    value: 'alien',
    description: 'accountSwitcherDropDownStyleDesc',
    title: 'accountSwitcherDropDownStyleTitle',
    advanced: true,
    bodyClass: true
  },
  showUserDetails: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowUserDetailsDesc',
    title: 'accountSwitcherShowUserDetailsTitle',
    advanced: true
  },
  showKarma: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowKarmaDesc',
    title: 'accountSwitcherShowKarmaTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  },
  showGold: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowGoldDesc',
    title: 'accountSwitcherShowGoldTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  }
};
let hover;

const accounts = lodash_once_default()(() => accountSwitcher_module.options.accounts.value.reduce((acc, v) => {
  acc[v[0].toLowerCase()] = {
    text: v[0],
    storedPassword: v[1],
    requiresOtp: v[2]
  };
  return acc;
}, {}));

accountSwitcher_module.contentStart = () => {
  const downArrow = accountSwitcher_module.options.dropDownStyle.value === 'alien' ? string_namespaceObject.html`<span id="RESAccountSwitcherIcon"></span>` : string_namespaceObject.html`<span id="RESAccountSwitcherIcon"><span class="downArrow"></span></span>`;
  downArrow.addEventListener('click', () => hover.begin());
  downArrow.addEventListener('dblclick', manageAccounts);
  const userLink = document.querySelector('#header-bottom-right > span.user > a');

  if (userLink) {
    userLink.style.marginRight = '2px';
    userLink.after(downArrow);
  } else {
    addFloater(downArrow, {
      order: 3
    });
  }

  hover = dropdownList(accountSwitcher_module.moduleID).options({
    className: 'RESAccountSwitcherDropdown',
    openDelay: 0,
    offsetHeight: 5
  }).populateWith(createAccountMenu).target(downArrow);
  let username;
  registerCommand(/^sw$/, `sw [username] - ${i18n('accountSwitcherCliHelp')}`, (command, val) => {
    const usernames = Object.keys(accounts()).filter(username => username.startsWith(val.toLowerCase()));
    username = usernames.includes(val) ? val : usernames[0];
    return `${i18n('accountSwitcherCliSwitchToUsernamePrompt')} ${val}${without_default()(usernames, val).length ? `[${usernames.map(v => v.replace(val, '')).filter(Boolean).join('|')}]` : ''}`;
  }, () => {
    if (username) switchTo(username);else manageAccounts();
  });
};

async function createAccountMenu() {
  const accountMenu = document.createDocumentFragment();
  const users = await Promise.all(Object.entries(accounts()).map(async ([username, {
    text
  }]) => ({
    text,
    username,
    active: username.localeCompare(loggedInUser() || '', {
      sensitivity: 'base'
    }) === 0,
    data: accountSwitcher_module.options.showUserDetails.value && (await getUserInfo(username).catch(e => {
      console.error('Error loading userinfo for', username, e);
      return {};
    })).data || {}
  })));

  for (const {
    text,
    username,
    active,
    data
  } of users) {
    if (!accountSwitcher_module.options.showCurrentUserName.value && active) continue;
    const goldExpDate = data.gold_expiration && new Date(data.gold_expiration * 1000);
    const element = string_namespaceObject.html`
			<li class="accountName ${active && 'active'}">
				<span style="margin-right: auto;">${text}</span>
				${accountSwitcher_module.options.showKarma.value && data.link_karma && string_namespaceObject._html`
					<span style="margin-left: 4px">(${data.link_karma} &middot; ${data.comment_karma})</span>
				`}
				${accountSwitcher_module.options.showGold.value && data.is_gold && string_namespaceObject._html`
					<span style="all: initial; margin-left: 4px; line-height: 0;" class="gilded-icon" title="${goldExpDate && i18n('accountSwitcherGoldUntil', formatDate(goldExpDate), formatDateDiff(new Date(), goldExpDate))}"></span>
				`}
				<a style="margin-left: 4px" onclick="event.stopPropagation()" href="/user/${username}" class="res-icon linkIcon"></a>
			</li>
		`;
    element.addEventListener('click', async () => {
      bodyClasses_namespaceObject.add('res-accountSwitcher-in-progress');

      try {
        await switchTo(username);
      } catch (e) {
        bodyClasses_namespaceObject.remove('res-accountSwitcher-in-progress');
        console.error(e);
      }
    });
    accountMenu.append(element);
  }

  {
    const element = string_namespaceObject.html`<li class="addAccount">+ add account</li>`;
    element.addEventListener('click', manageAccounts);
    accountMenu.append(element);
  }
  return [accountMenu];
}

const switchTo = mutex(async username => {
  const {
    storedPassword,
    requiresOtp
  } = accounts()[username];
  const logoutPromise = isLoggedIn() && ajax({
    method: 'POST',
    url: '/logout'
  });
  const password = storedPassword ? storedPassword : window.prompt(i18n('accountSwitcherPasswordPrompt', username));
  let otp;

  if (requiresOtp) {
    otp = {
      otp: window.prompt(i18n('accountSwitcherOptPrompt', username))
    };
  }

  await logoutPromise;
  const {
    success,
    jquery
  } = await ajax({
    method: 'POST',
    url: '/api/login',
    data: {
      user: username,
      passwd: password,
      ...otp,
      rem: accountSwitcher_module.options.keepLoggedIn.value ? 'on' : 'off'
    },
    type: 'json'
  }).catch(e => {
    notifications_showNotification({
      moduleID: 'accountSwitcher',
      message: i18n('accountSwitcherAccountSwitchError')
    });
    throw e;
  });

  if (accountSwitcher_module.options.updateOtherTabs.value) {
    switchedAccountElsewhere(success ? username : null);
  }

  if (success) {
    reloadPage();
  } else {
    const jqueryRpc = JSON.stringify(jquery);
    const message = jqueryRpc.includes('PASSWORD') && i18n('accountSwitcherLoginError', username) || jqueryRpc.includes('RATELIMIT') && i18n('accountSwitcherRateLimitError') || i18n('accountSwitcherUnknownError', username, jqueryRpc);
    alert_namespaceObject.open(message, {
      cancelable: true
    }).then(manageAccounts);
  }
});
const switchedAccountElsewhere = multicast(username => {
  const hasDraft = Array.from(document.getElementsByTagName('textarea')).some(textarea => textarea.value);

  if (!hasDraft && accountSwitcher_module.options.reloadOtherTabs.value) {
    reloadPage();
    return;
  }

  let message = username ? i18n('accountSwitcherUserSwitched', username) : i18n('accountSwitcherLoggedOut');

  if (hasDraft) {
    message += ` ${i18n('accountSwitcherDraft', loggedInUser() || '')}`;
  }

  message += ` <p><a class="RESNotificationButtonBlue" href="${location.pathname}">${i18n('accountSwitcherReload')}</a></p>`;
  notifications_showNotification({
    moduleID: 'accountSwitcher',
    optionKey: 'updateOtherTabs',
    message
  });
}, {
  name: 'switchedAccountElsewhere',
  local: false,
  crossContext: false
});

function manageAccounts() {
  hover.close();
  settingsNavigation_open(accountSwitcher_module.moduleID, 'accounts');
}

function reloadPage() {
  history.pushState({}, '');
  location.reload();
}
// CONCATENATED MODULE: ./lib/modules/submitIssue.js









const submitIssue_module = new Module('submitIssue');
submitIssue_module.moduleName = 'submitIssueName';
submitIssue_module.category = 'aboutCategory';
submitIssue_module.alwaysEnabled = true;
submitIssue_module.sort = -7;
submitIssue_module.description = 'submitIssueDesc';
submitIssue_module.include = ['submit'];
const submitIssue_subreddits = ['enhancement', 'resissues'];
const subredditsForDiagnostics = ['beta', 'help', 'resbetatesting'];

submitIssue_module.go = () => {
  checkIfSubmitting();
};

const submitWizardTemplate = ({
  foolin,
  settings,
  bugs,
  requests
}) => string_namespaceObject.html`
	<div>
		${foolin && string_namespaceObject._html`
			<h2>Enjoy April Fool's</h2>
			<p>RES can't turn off any of Reddit's shenanigans. However, <a href="/r/Enhancement/wiki/faq/srstyle" target="_blank" rel="noopener noreferer">you can turn off subreddit styles</a>.</p>
		`}

		<h2>Something is broken in RES. How do I fix it?</h2>

		<p>Take a minute to read through other posts. Someone might have already posted a solution.</p>

		<ol id="RESKnownBugs">
			${bugs.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>

		<p><a href="/r/RESissues/submit/" class="blueButton">Ask how to fix RES</a></p>

		<p>Please write some text about:</p>
		<dl>

			<dt>What makes this happen?</dt>
			<dd>
				clicking a button, opening an image preview, ...
			</dd>


			<dt>Where does this happen?</dt>
			<dd>
				in a particular subreddit, on comments pages, on frontpage (reddit.com), on /r/all, ...
			</dd>

			<dt>Screenshot/video of problem</dt>
			<dd>
				<a href="https://www.take-a-screenshot.org/" target="_blank" rel="noreferer noopener">Take a screenshot</a>, <a href="https://imgur.com/upload">upload it</a>, and copy-paste the link here.
			</dd>
		</dl>


		<h2>How do I customize or use RES features?</h2>
		<p>If you want to disable certain features of RES, try searching in <a href="${settings}">RES settings</a>, your account's <a href="/prefs">reddit preferences</a>, or <a href="/r/Enhancement/search?q=restrict_sr=on">posts in r/Enhancement</a>.</p>

		<p><a href="/r/Enhancement/submit/" class="blueButton">Get guidance on using RES</a></p>


		<h2>I have a suggestion.</h2>

		<p>Look for similar ideas before posting:</p>
		<ol id="RESKnownFeatureRequests">
			${requests.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>
		<p><a href="/r/Enhancement/submit/" class="blueButton">Post a request</a></p>


		<h2>I found a security issue.</h2>
		<p>Please report security issues privately using modmail.</p>
		<p><a href="/message/compose/?to=/r/Enhancement" class="blueButton">Report a security issue</a></p>
	</div>
`;

const submitIssueDefaultBody = `
*What's up?*
???


*Where does it happen?*
???


*Screenshots or mock-ups*
???


*What browser extensions are installed?*
???
`.trim();
const diagnostics = lodash_once_default()(() => `

- Night mode: ${String(isNightModeOn())}
- RES Version: ${metadata_version}
- Browser: ${browserDetect_namespaceObject.browser}
- Browser Version: ${browserDetect_namespaceObject.version}
- Cookies Enabled: ${String(navigator.cookieEnabled)}
- Reddit beta: ${String(jquery_default()('.beta-hint').length > 0)}

`);

function checkIfSubmitting() {
  const subredditInput = document.getElementById('sr-autocomplete');
  const selfText = document.querySelector('.usertext-edit textarea');

  if (subredditInput) {
    function check() {
      const subreddit = subredditInput.value;

      if (submitIssue_subreddits.includes(subreddit.toLowerCase())) {
        showWizard();
        injectTemplate(selfText);
      } else {
        hideWizard();
      }
    }

    check();
    subredditInput.addEventListener('change', e => {
      if (e.res) return;
      check();
    });
    jquery_default()('#suggested-reddits .sr-suggestion').on('click', () => setTimeout(check, 500));
  }

  if (selfText && subredditInput) {
    jquery_default()(selfText).add(subredditInput).on('blur', () => {
      const subreddit = subredditInput.value;

      if ([...submitIssue_subreddits, ...subredditsForDiagnostics].includes(subreddit.toLowerCase())) {
        const diagnosticsStripped = diagnostics().replace(/\s/g, '');
        const selfTextStripped = selfText.value.replace(/\s/g, '');

        if (!selfTextStripped.includes(diagnosticsStripped)) {
          selfText.value += diagnostics();
          jquery_default()(selfText).trigger('input');
        }
      } else {
        selfText.value = selfText.value.replace(diagnostics(), '');
        jquery_default()(selfText).trigger('input');
      }
    });
  }
}

function updateSubreddit(subreddit) {
  const input = document.querySelector('#sr-autocomplete');
  input.value = subreddit;
  const e = new Event('change');
  e.res = true;
  input.dispatchEvent(e);
}

function injectTemplate(selfText) {
  if (selfText && !selfText.value) {
    selfText.value = submitIssueDefaultBody;
  }
}

async function wizard() {
  const [bugs, requests] = await Promise.all([fetchLinks('/r/Enhancement/wiki/knownbugs.json'), fetchLinks('/r/Enhancement/wiki/knownrequests.json')]);
  return submitWizardTemplate({
    foolin: submitIssue_foolin(),
    bugs,
    requests,
    settings: makeUrlHash()
  });
}

const guiderId = 'RESSubmitWizard';

async function showWizard() {
  const guider = guiders.get(guiderId);

  if (guider) {
    guiders.show(guider.id);
    return;
  }

  const description = await wizard();
  guiders.createGuider({
    attachTo: '.submit .usertext',
    description,
    buttonCustomHTML: `
		<footer>
			<small>
				<a href="/r/RESissues/wiki/knownissues">known issues</a>
				|  <a href="/r/RESissues/wiki/postanissue">troubleshooting</a>
			</small>
		</footer>
	`,
    id: guiderId,
    position: 3,
    title: 'What are you posting about?'
  }).show();
  jquery_default()(document.body).on('click', '#RESSubmitWizard a[href$="/submit/"]', e => {
    const match = e.currentTarget.pathname.match(regexes.submit);
    if (!match) return;
    updateSubreddit(match[1]);
    e.preventDefault();
  });
}

function hideWizard() {
  if (guiders.get(guiderId)) {
    guiders.hideAll();
  }
}

async function fetchLinks(url) {
  try {
    const {
      data
    } = await ajax({
      url,
      type: 'json'
    });
    return parseObjectList(data && data.content_md);
  } catch (e) {
    return [];
  }
}

function parseObjectList(text) {
  if (!text) {
    return [];
  }

  const items = text.split(/\s*-{3,}\s*/).filter(x => x.match(/[^\s\n]/));
  return items.map(dictText => {
    const item = {};
    const dictMapping = dictText.replace(/\r/g, '').split('\n');

    for (const rawLine of dictMapping) {
      const line = jquery_default.a.trim(rawLine).split(':');

      if (line.length > 0) {
        const key = line.shift();

        if (key) {
          item[key] = line.join(':');
        }
      }
    }

    return item;
  });
}

function submitIssue_foolin() {
  const now = new Date();
  return now.getMonth() === 2 && now.getDate() > 30 || now.getMonth() === 3 && now.getDate() <= 2;
}
// CONCATENATED MODULE: ./lib/modules/commentTools.js













const commentTools_module = new Module('commentTools');
commentTools_module.moduleName = 'commentToolsName';
commentTools_module.category = 'commentsCategory';
commentTools_module.description = 'commentToolsDesc';
commentTools_module.options = {
  userAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsUserAutoCompleteDesc',
    title: 'commentToolsUserAutoCompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  subredditAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsSubredditAutocompleteDesc',
    title: 'commentToolsSubredditAutocompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  wikiAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsWikiAutocompleteDesc',
    title: 'commentToolsWikiAutocompleteTitle',
    advanced: true
  },
  formattingToolButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsFormattingToolButtonsDesc',
    title: 'commentToolsFormattingToolButtonsTitle'
  },
  keyboardShortcuts: {
    dependsOn: options => options.formattingToolButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsKeyboardShortcutsDesc',
    title: 'commentToolsKeyboardShortcutsTitle'
  },
  boldKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [66, false, true, false, false],
    description: 'commentToolsBoldKeyDesc',
    title: 'commentToolsBoldKeyTitle'
  },
  italicKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [73, false, true, false, false],
    description: 'commentToolsItalicKeyDesc',
    title: 'commentToolsItalicKeyTitle'
  },
  strikeKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [83, false, true, false, false],
    description: 'commentToolsStrikeKeyDesc',
    title: 'commentToolsStrikeKeyTitle'
  },
  superKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [187, false, true, true, false],
    description: 'commentToolsSuperKeyDesc',
    title: 'commentToolsSuperKeyTitle'
  },
  linkKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [75, false, true, false, false],
    description: 'commentToolsLinkKeyDesc',
    title: 'commentToolsLinkKeyTitle'
  },
  quoteKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [190, false, true, true, false],
    description: 'commentToolsQuoteKeyDesc',
    title: 'commentToolsQuoteKeyTitle'
  },
  ctrlEnterSubmitsComments: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSubmitsCommentsDesc',
    title: 'commentToolsCtrlEnterSubmitsCommentsTitle'
  },
  ctrlEnterSavesLiveThreads: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSavesLiveThreadsDesc',
    title: 'commentToolsCtrlEnterSavesLiveThreadsTitle'
  },
  ctrlEnterSubmitsPosts: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrolEnterSubmitsPostsDesc',
    title: 'commentToolsCtrolEnterSubmitsPostsTitle'
  },
  commentingAs: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCommentingAsDesc',
    title: 'commentToolsCommentingAsTitle'
  },
  highlightIfAltAccount: {
    dependsOn: options => options.commentingAs.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsHighlightIfAltAccountDesc',
    title: 'commentToolsHighlightIfAltAccountTitle'
  },
  showInputLength: {
    type: 'boolean',
    value: true,
    description: 'commentToolsShowInputLengthDesc',
    title: 'commentToolsShowInputLengthTitle',
    advanced: true,
    bodyClass: true
  },
  macroButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroButtonsDesc',
    title: 'commentToolsMacroButtonsTitle',
    bodyClass: true
  },
  macros: {
    dependsOn: options => options.macroButtons.value,
    type: 'table',
    addRowText: 'commentToolsAddShortcut',
    fields: [{
      key: 'label',
      name: 'commentToolsLabel',
      type: 'text'
    }, {
      key: 'text',
      name: 'commentToolsText',
      type: 'textarea'
    }, {
      key: 'category',
      name: 'commentToolsCategory',
      type: 'text'
    }, {
      key: 'key',
      name: 'commentToolsKey',
      type: 'keycode'
    }],
    value: [['reddiquette', '[reddiquette](/wiki/reddiquette) ', undefined, undefined], ['Promote RES', '[Reddit Enhancement Suite](https://redditenhancementsuite.com "also /r/Enhancement") ', undefined, undefined], ['Current timestamp', '{{now}} ', undefined, undefined]],
    description: 'commentToolsMacrosDesc',
    title: 'commentToolsMacrosTitle'
  },
  keepMacroListOpen: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: false,
    description: 'commentToolsKeepMacroListOpenDesc',
    title: 'commentToolsKeepMacroListOpenTitle',
    advanced: true
  },
  macroPlaceholders: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroPlaceholdersDesc',
    title: 'commentToolsMacroPlaceholdersTitle'
  },
  enabledOnBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentToolsEnableOnBanMessagesDesc',
    title: 'commentToolsEnableOnBanMessagesTitle',
    advanced: true
  }
};
commentTools_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'liveThread', /^\/r\/[\-\w\.]+\/wiki\/(?:create|edit)(\/\w+)?/i];
const SUBMIT_LIMITS = {
  STYLESHEET: 128 * 1024,
  SIDEBAR: 10240,
  DESCRIPTION: 500,
  WIKI: 512 * 1024,
  COMMENT: 10000,
  LIVE_COMMENT: 4096,
  POST: 40000,
  POST_TITLE: 300,
  BAN_MESSAGE: 1000
};
const macroCallbackTable = [];
const macroKeyTable = [];

commentTools_module.contentStart = () => {
  jquery_default()(document.body).on('focus', commentTextareaSelector, attachEditorToUsertext);
  initializeCtrlEnterToSubmit();
  initializeLengthCounters();
  initializeAutocomplete();
};

function initializeCtrlEnterToSubmit() {
  if (commentTools_module.options.ctrlEnterSubmitsComments.value) {
    onCtrlEnter('.usertext-edit textarea, #BigEditor textarea, #wiki_page_content', e => {
      const currentForm = jquery_default()(e.currentTarget).closest('form');
      const saveButton = currentForm.find('.save')[0] || currentForm.find('#wiki_save_button')[0] || jquery_default()('.BEFoot button')[0];
      if (saveButton) click(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSavesLiveThreads.value) {
    onCtrlEnter('.usertext-edit textarea', () => {
      const saveButton = jquery_default()('#new-update-form .save-button button')[0];
      if (saveButton) click(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSubmitsPosts.value) {
    onCtrlEnter('#title-field textarea, #text-field textarea, #url, #sr-autocomplete, input.captcha', () => {
      const $captcha = jquery_default()('input.captcha:not(.cap-text)');

      if ($captcha.length && $captcha.val() === '') {
        $captcha.focus();
      } else {
        click(jquery_default()('.spacer .btn')[0]);
      }
    });
  }
}

function initializeLengthCounters() {
  if (commentTools_module.options.showInputLength.value) {
    jquery_default()(document.body).on('input', '.usertext-edit textarea, #title-field textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function () {
      updateCounter(this);
    });
    jquery_default()('.submit-page #title-field span.title').prepend('<span class="RESCharCounter" title="character limit: 0/300">0/300</span>');
  }
}

const initializeEditorTools = lodash_once_default()(() => {
  jquery_default()(document.body).on('click', 'div.markdownEditor-wrapper a:not(.userTagLink)', function (e) {
    e.preventDefault();
    const index = parseInt(jquery_default()(this).attr('data-macro-index'), 10);
    const box = findTextareaForElement(this);

    if (!box) {
      console.error('Failed to locate textarea.');
      return;
    }

    const handler = macroCallbackTable[index];

    if (!handler) {
      throw new Error(`No macro callback at index: ${index}.`);
    }

    handler(box);
    box.focus();
    box.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  }).on('click', '.RESMacroDropdownTitle', function (e) {
    const thisCat = e.currentTarget;

    if (thisCat.classList.contains('openMacro')) {
      thisCat.classList.remove('openMacro');
    } else {
      jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
      thisCat.classList.add('openMacro');
    }

    jquery_default()(this).next().css({
      top: `${thisCat.offsetTop + thisCat.offsetHeight}px`,
      left: `${thisCat.offsetLeft + thisCat.offsetWidth - thisCat.nextSibling.offsetWidth}px`
    });
  });

  if (commentTools_module.options.keyboardShortcuts.value) {
    jquery_default()(document.body).on('keydown', '.usertext-edit textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function (e) {
      if (e.key === NAMED_KEYS.Escape) {
        this.blur();
        e.preventDefault();
        return;
      }

      for (const [testedKeyArray, macroIndex] of macroKeyTable) {
        if (checkKeysForEvent(e, testedKeyArray)) {
          const handler = macroCallbackTable[macroIndex];
          handler(this);
          this.dispatchEvent(new Event('input', {
            bubbles: true,
            cancelable: true
          }));
          e.preventDefault();
          return;
        }
      }
    });
  }
});

const commentTextareaSelector = ['textarea[name=text]', 'textarea[name=description]', 'textarea[name=public_description]', 'textarea[name=body]', 'textarea[name=ban_message]', 'textarea[name=content]', 'textarea[name=title]'].join(':not([readonly]),');

function getFieldLimit(elem) {
  switch (elem.name) {
    case 'title':
      return SUBMIT_LIMITS.POST_TITLE;

    case 'text':
      if (isPageType('submit') || jquery_default()(elem).closest('.thing').hasClass('self')) {
        return SUBMIT_LIMITS.POST;
      }

      return SUBMIT_LIMITS.COMMENT;

    case 'description':
      return SUBMIT_LIMITS.SIDEBAR;

    case 'body':
      return SUBMIT_LIMITS.LIVE_COMMENT;

    case 'public_description':
      return SUBMIT_LIMITS.DESCRIPTION;

    case 'content':
      return SUBMIT_LIMITS.WIKI;

    case 'ban_message':
      return SUBMIT_LIMITS.BAN_MESSAGE;

    default:
      return 1337;
  }
}

function attachEditorToUsertext() {
  if (this.hasAttribute('commentTools-initialized')) return;
  this.setAttribute('commentTools-initialized', true);

  if (this.hasAttribute('data-max-length')) {
    return;
  }

  const limit = getFieldLimit(this);
  this.setAttribute('data-limit', limit);

  if (this.name === 'title') {
    return;
  }

  if (this.id === 'ban_message' && !commentTools_module.options.enabledOnBanMessages.value) {
    return;
  }

  if (this.id === 'ban_message') {
    this.style.width = '500px';
    this.style.height = '100px';
  }

  const bar = makeEditBar();

  if (this.id === 'wiki_page_content' || this.id === 'ban_message') {
    jquery_default()(this).parent().prepend(bar);
  } else {
    jquery_default()(this).parent().before(bar);
  }

  updateCounter(this);
}

function updateCounter(textarea) {
  const length = jquery_default()(textarea).val().length;
  const limit = textarea.getAttribute('data-limit');
  const counter = jquery_default()(textarea).parent().parent().find('.RESCharCounter');
  counter.attr('title', `character limit: ${length}/${limit}`);
  counter.text(`${length}/${limit}`);

  if (length > limit) {
    counter.addClass('tooLong');
  } else {
    counter.removeClass('tooLong');
  }
}
let cachedEditBar;
function makeEditBar() {
  initializeEditorTools();

  if (cachedEditBar) {
    return jquery_default()(cachedEditBar).clone();
  }

  const $editBar = jquery_default()('<div class="markdownEditor">');
  const wrappedEditBar = jquery_default()('<div class="markdownEditor-wrapper">').append($editBar);

  if (commentTools_module.options.commentingAs.value) {
    const commentingAsMessage = location.href.match(/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned\/?/i) ? 'Moderating as' : 'Speaking as';
    const commentingAs = jquery_default()('<div class="commentingAs">').html(`${commentingAsMessage}: `).append(jquery_default()('#header-bottom-right .user a:first').clone().wrap('<span class="commentingAsUser"></span>').parent());
    const loggedIn = loggedInUser();

    if (loggedIn && isRunning(userTagger_namespaceObject)) {
      applyToUser(commentingAs.find('a')[0], {
        username: loggedIn,
        renderVoteWeight: false
      });
    }

    if (commentTools_module.options.highlightIfAltAccount.value && accountSwitcher_module.options.accounts.value.length && loggedIn && loggedIn.toLowerCase() !== accountSwitcher_module.options.accounts.value[0][0].toLowerCase()) {
      commentingAs.addClass('highlightedAltAccount');
    }

    wrappedEditBar.append(commentingAs);
  }

  if (commentTools_module.options.formattingToolButtons.value) {
    const shortcuts = commentTools_module.options.keyboardShortcuts.value;
    $editBar.append(makeEditButton('<b>Bold</b>', `bold${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.boldKey.value)})` : ''}`, commentTools_module.options.boldKey.value, 'btn-bold', box => {
      wrapSelection(box, '**', '**');
    }));
    $editBar.append(makeEditButton('<i>Italic</i>', `italic${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.italicKey.value)})` : ''}`, commentTools_module.options.italicKey.value, 'btn-italic', box => {
      wrapSelection(box, '*', '*');
    }));
    $editBar.append(makeEditButton('<del>strike</del>', `strike${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.strikeKey.value)})` : ''}`, commentTools_module.options.strikeKey.value, 'btn-strike', box => {
      wrapSelection(box, '~~', '~~');
    }));
    $editBar.append(makeEditButton('<sup>sup</sup>', `super${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.superKey.value)})` : ''}`, commentTools_module.options.superKey.value, 'btn-superscript', box => {
      wrapSelectedWords(box, '^');
    }));
    $editBar.append(makeEditButton('Link', `link${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.linkKey.value)})` : ''}`, commentTools_module.options.linkKey.value, 'btn-link', box => {
      linkSelection(box);
    }));
    $editBar.append(makeEditButton('>Quote', `quote${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.quoteKey.value)})` : ''}`, commentTools_module.options.quoteKey.value, 'btn-quote', box => {
      wrapSelectedLines(box, '> ', '');
    }));
    $editBar.append(makeEditButton('<span style="font-family: monospace">Code</span>', 'code', null, 'btn-code', box => {
      wrapSelectedLines(box, '    ', '');
    }));
    $editBar.append(makeEditButton('&bull;Bullets', 'bullet list', null, 'btn-list-unordered', box => {
      wrapSelectedLines(box, '* ', '');
    }));
    $editBar.append(makeEditButton('1.Numbers', 'number list', null, 'btn-list-ordered', box => {
      wrapSelectedLines(box, '1. ', '');
    }));
    $editBar.append(makeEditButton('<span style="border: 1px black solid;">Table</span>', 'table', null, 'btn-table', box => {
      const selectedText = box.value.substring(box.selectionStart, box.selectionEnd).replace(/^[\s]+/, '').replace(/[\s]+$/, '').split('\n');
      let isTable;

      if (selectedText.length >= 2) {
        if (selectedText[0].includes('|')) {
          selectedText[0] = selectedText[0].replace(/^\|/, '').replace(/\|\s+$/, '');
          const numSeparator = selectedText[0].split('|').length;
          isTable = true;
          selectedText[1] = selectedText[1].replace(/\|[^|\-]+$/, '');
          selectedText[1] = selectedText[1].replace(/-/g, '--');

          if (!selectedText[1].includes('-|') && !selectedText[1].includes('|-')) {
            isTable = false;
          }

          selectedText[1] = selectedText[1].replace(/^\]+/, '').replace(/[\s|]+$/, '');

          if (selectedText[1].split('-|-').length < numSeparator) {
            isTable = false;
          }

          if (/[^|\-]/.test(selectedText[1])) {
            isTable = false;
          }

          if (isTable) {
            for (const i of range(2, selectedText.length)) {
              if (!selectedText[i].includes('|')) {
                isTable = false;
                break;
              }

              selectedText[i] = selectedText[i].replace(/^\|/, '').replace(/[\s|]+$/, '');

              if (selectedText[i].split('|').length !== numSeparator) {
                isTable = false;
                break;
              }
            }
          }
        }
      }

      let startTable;

      if (isTable) {
        startTable = selectedText.reduce((prevTable, currText, i) => {
          if (i === 1) {
            return prevTable;
          }

          return `${prevTable}<tr><td>${escapeHTML(currText).replace(/\|/g, '</td><td>')}</td></tr>`;
        }, '');
      } else {
        startTable = '<tr><td>Foo</td><td>Bar</td></tr><tr><td>Foo</td><td>Bar</td></tr>';
      }

      const element = string_namespaceObject.html`<div><div class="buttonContainer"></div><table class="commentPreview" contenteditable="true">${string_namespaceObject.safe(startTable)}</table></div>`;
      alert_namespaceObject.open(element, {
        cancelable: true
      }).then(() => {
        let generatedTable = '\n\n';
        let generatedTableSeparation = '';
        jquery_default()('tr:first td', element).each(function () {
          const text = jquery_default()(this).text().replace(/[\n|]/g, '');
          generatedTable += `${text} | `;
          generatedTableSeparation += '-'.repeat(text.length);
          generatedTableSeparation += '|';
        });
        generatedTableSeparation = generatedTableSeparation.substr(0, generatedTableSeparation.length - 1);
        generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n${generatedTableSeparation}\n`;
        jquery_default()('tr:gt(0)', element).each(function () {
          jquery_default()(this).find('td').each(function () {
            generatedTable += `${jquery_default()(this).text().replace(/[\n|]/g, '')} | `;
          });
          generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n`;
        });

        if (isTable) {
          replaceSelection(box, generatedTable);
        } else {
          wrapSelection(box, generatedTable, '');
        }

        jquery_default()(box).trigger('input');
      });
      const addRow = alert_namespaceObject.makeButton('+ Row');
      const remRow = alert_namespaceObject.makeButton('- Row');
      const addCol = alert_namespaceObject.makeButton('+ Col');
      const remCol = alert_namespaceObject.makeButton('- Col');
      addRow.addEventListener('click', () => {
        const nbCol = jquery_default()('tr:first td', element).length;
        const newRow = '<td>text</td>'.repeat(nbCol);
        jquery_default()('table', element).append(`<tr>${newRow}</tr>`);
      });
      remRow.addEventListener('click', () => {
        if (jquery_default()('tr', element).length > 1) {
          jquery_default()('table tr:last', element).remove();
        }
      });
      addCol.addEventListener('click', () => {
        jquery_default()('table tr', element).append('<td>text</td>');
      });
      remCol.addEventListener('click', () => {
        if (jquery_default()('tr:first td', element).length > 1) {
          jquery_default()('table tr td:last-of-type', element).remove();
        }
      });
      const $buttonContainer = jquery_default()('.buttonContainer', element);
      $buttonContainer.append(addRow);
      $buttonContainer.append(remRow);
      $buttonContainer.append(addCol);
      $buttonContainer.append(remCol);
    }));
  }

  if (commentTools_module.options.showInputLength.value) {
    const $counter = jquery_default()('<span class="RESCharCounter" title="character limit: 0/?????">0/?????</span>');
    $editBar.prepend($counter);
  }

  if (commentTools_module.options.macroButtons.value) {
    buildMacroDropdowns(wrappedEditBar);
    const addMacroButton = makeEditButton(i18n(commentTools_module.options.macros.addRowText), null, null, 'btn-macro btn-macro-add', () => {
      settingsNavigation_open(commentTools_module.moduleID, 'macros');
      jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
    });
    addButtonToMacroGroup('', addMacroButton);
  }

  cachedEditBar = wrappedEditBar;
  return cachedEditBar;
}
const macroDropDownTable = new Map();

function getMacroGroup(groupName) {
  groupName = (groupName || '').toString().trim() || 'macros';
  let macroGroup = macroDropDownTable.get(groupName);

  if (macroGroup === undefined) {
    macroGroup = {};
    macroGroup.titleButton = jquery_default()(`<span class="RESMacroDropdownTitle">${groupName}</span>`);
    macroGroup.container = jquery_default()('<span class="RESMacroDropdown"></span>');
    macroGroup.dropdown = jquery_default()('<ul class="RESMacroDropdownList"></ul>');
    macroGroup.container.append(macroGroup.dropdown);
    macroDropDownTable.set(groupName, macroGroup);
  }

  return macroGroup;
}

function addButtonToMacroGroup(groupName, button) {
  const group = getMacroGroup(groupName);
  group.dropdown.append(jquery_default()('<li>').append(button));
}

function getDebugMacros() {
  if (!isCurrentSubreddit('Enhancement', 'RESissues')) return [];
  return [['RES modified settings', '\n\n{{resmodifiedsettings}}\n', null, null], ['RES diagnostics', '{{resdiagnostics}}', null, null]];
}

function buildMacroDropdowns(editBar) {
  const macros = [...commentTools_module.options.macros.value, ...getDebugMacros()];

  for (const [title, text, category, key] of macros) {
    const button = makeEditButton(title, null, key, 'btn-macro', box => {
      macroSelection(box, text);
    });
    addButtonToMacroGroup(category, button);
  }

  const $macroWrapper = jquery_default()('<span class="RESMacroWrappingSpan">');
  const defaultGroup = getMacroGroup('');
  $macroWrapper.append(defaultGroup.titleButton);
  $macroWrapper.append(defaultGroup.container);

  for (const [category, macroGroup] of macroDropDownTable) {
    if (category === 'macros') {
      continue;
    }

    $macroWrapper.append(macroGroup.titleButton);
    $macroWrapper.append(macroGroup.container);
  }

  editBar.append($macroWrapper);
}

function makeEditButton(label, title, key, cls, handler) {
  if (label === null) {
    label = 'unlabeled';
  }

  if (title === null) {
    title = '';
  }

  const macroButtonIndex = macroCallbackTable.length;
  const button = string_namespaceObject.html`<a class="edit-btn ${cls}" title="${title}" href="#" tabindex="1" data-macro-index="${macroButtonIndex}">${label}</a>`;

  if (key && key[0] !== null) {
    macroKeyTable.push([key, macroButtonIndex]);
  }

  macroCallbackTable[macroButtonIndex] = handler;
  return button;
}

function linkSelection(box) {
  let url = prompt('Enter the URL:', '');

  if (url) {
    url = url.replace(/[\(\)]/g, '\\$&');
    wrapSelection(box, '[', `](${url})`, text => text.replace(/[\[\]\(\)]/g, '\\$&'));
  }
}

function macroSelection(box, macroText) {
  if (!commentTools_module.options.keepMacroListOpen.value) {
    jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
  }

  if (commentTools_module.options.macroPlaceholders.value) {
    wrapSelection(box, '', '', selectedText => fillPlaceholders(box, macroText, selectedText));
  } else {
    wrapSelection(box, macroText, '');
  }
}

function fillPlaceholders(box, macroText, selectedText) {
  const placeholders = macroText.match(/\{\{\w+\}\}/g);

  if (placeholders) {
    const completedPlaceholders = new Set();

    for (const placeholder of placeholders) {
      if (completedPlaceholders.has(placeholder)) {
        continue;
      }

      completedPlaceholders.add(placeholder);
      const placeholderInnerText = placeholder.substring(2, placeholder.length - 2).toLowerCase();
      let value;

      try {
        value = getMagicPlaceholderValue(placeholderInnerText, macroText, selectedText, box);
      } catch (e) {
        console.error('Error getting magic placeholder value', placeholderInnerText);
        console.error(e);
      }

      if (value === undefined) {
        value = promptForPlaceholderValue(placeholder, macroText);
      }

      if (value === null) {
        break;
      }

      macroText = macroText.replace(new RegExp(placeholder, 'g'), value);
    }
  }

  return macroText;
}

function getMagicPlaceholderValue(placeholder, macroText, selectedText, box) {
  const handler = magicPlaceholders.find(current => current.matches.includes(placeholder));

  if (handler) {
    return handler.handle(macroText, selectedText, box);
  }
}

const magicPlaceholders = [{
  matches: ['subreddit'],

  handle(macroText, selectedText, box) {
    const thing = Thing_Thing.from(box);
    const subreddit = thing && thing.getSubreddit();

    if (subreddit) {
      return `/r/${subreddit}`;
    }
  }

}, {
  matches: ['me', 'my_username'],

  handle() {
    const username = loggedInUser();

    if (username) {
      return `/u/${username}`;
    }
  }

}, {
  matches: ['op', 'op_username'],

  handle(macroText, selectedText, box) {
    let profile;

    if (isPageType('comments')) {
      profile = document.querySelector('.sitetable .author');
    } else {
      let $next = jquery_default()(box);
      let furthest = $next;

      do {
        if ($next && $next.length) furthest = $next;
        $next = $next.parent().closest('.sitetable');
      } while ($next.length);

      profile = furthest.find('.author')[0];
    }

    if (profile) {
      const match = profile.pathname.match(regexes.profile);
      if (!match) throw new Error(`Invalid profile link: ${profile.href}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['url'],

  handle() {
    return location.href;
  }

}, {
  matches: ['reply_to', 'reply_to_username'],

  handle(macroText, selectedText, box) {
    let $base = jquery_default()(box);
    const isEditing = $base.closest('.thing, .entry').hasClass('entry');

    if (isEditing) {
      $base = $base.closest('.thing').parent();
    }

    const profile = $base.closest('.thing').find('.entry .author')[0];

    if (!profile) {
      return getMagicPlaceholderValue('op', macroText, selectedText, box);
    } else {
      const match = profile.pathname.match(regexes.profile);
      if (!match) throw new Error(`Invalid profile link: ${String(profile)}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['selected', 'selection'],

  handle(macroText, selectedText) {
    return selectedText;
  }

}, {
  matches: ['now'],

  handle() {
    const date = new Date();
    return date.toTimeString();
  }

}, {
  matches: ['today'],

  handle() {
    const date = new Date();
    return date.toDateString();
  }

}, {
  matches: ['linkflair'],

  handle() {
    if (isPageType('comments')) {
      return document.querySelector('.linkflairlabel').textContent;
    }
  }

}, {
  matches: ['escaped'],

  handle(macroText, selectedText) {
    return selectedText.replace(/[\[\]()\\\*\^~\-_.]/g, '\\$&').replace(/^([ ]{0,3})>/gm, '$1\\>');
  }

}, {
  matches: ['resmodifiedsettings'],

  handle() {
    return getModifiedText();
  }

}, {
  matches: ['resdiagnostics'],

  handle() {
    return diagnostics();
  }

}];

function promptForPlaceholderValue(placeholder, macroText) {
  return prompt(`${macroText}\n\n\nEnter replacement for ${placeholder}:`, placeholder);
}

function wrapSelection(box, prefix, suffix, escapeFunction) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  let selectedText = text.substring(selectionStart, selectionEnd);
  const afterSelection = text.substring(selectionEnd);
  let trailingSpace = '';
  let cursor = selectedText.length - 1;

  while (cursor > 0 && selectedText[cursor] === ' ') {
    trailingSpace += ' ';
    cursor--;
  }

  selectedText = selectedText.substring(0, cursor + 1);

  if (typeof escapeFunction === 'function') {
    selectedText = escapeFunction(selectedText);
  }

  box.value = beforeSelection + prefix + selectedText + suffix + trailingSpace + afterSelection;
  box.selectionEnd = beforeSelection.length + prefix.length + selectedText.length;

  if (selectionStart === selectionEnd) {
    box.selectionStart = box.selectionEnd;
  } else {
    box.selectionStart = beforeSelection.length + prefix.length;
  }

  box.scrollTop = scrollTop;
}

function replaceSelection(box, replacement) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const afterSelection = text.substring(selectionEnd);
  box.value = beforeSelection + replacement + afterSelection;
  box.selectionEnd = beforeSelection.length + replacement.length;
  box.scrollTop = scrollTop;
}

function wrapSelectedLines(box, prefix, suffix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  let selectionEnd = box.selectionEnd;
  const text = box.value;
  let startPosition = 0;
  const lines = text.split('\n');

  for (const i of range(0, lines.length)) {
    let lineStart = startPosition;
    let lineEnd = lineStart + lines[i].length;

    if (selectionStart <= lineStart && lineStart <= selectionEnd || selectionStart <= lineEnd && lineEnd <= selectionEnd || lineStart <= selectionStart && selectionStart <= lineEnd || lineStart <= selectionEnd && selectionEnd <= lineEnd) {
      lines[i] = prefix + lines[i] + suffix;
      let startMovement = 0;
      let endMovement = 0;

      if (lineStart < selectionStart) {
        startMovement += prefix.length;
      }

      if (lineEnd < selectionStart) {
        startMovement += suffix.length;
      }

      if (lineStart < selectionEnd) {
        endMovement += prefix.length;
      }

      if (lineEnd < selectionEnd) {
        endMovement += suffix.length;
      }

      selectionStart += startMovement;
      selectionEnd += endMovement;
      lineStart += prefix.length;
      lineEnd += prefix.length + suffix.length;
    }

    startPosition = lineEnd + 1;
  }

  box.value = lines.join('\n');
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd;
  box.scrollTop = scrollTop;
}

function wrapSelectedWords(box, prefix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const selectedWords = text.substring(selectionStart, selectionEnd).split(' ');
  const afterSelection = text.substring(selectionEnd);
  let selectionModify = 0;

  for (const i of range(0, selectedWords.length)) {
    if (selectedWords[i] !== '') {
      if (selectedWords[i].includes('\n')) {
        const newLinePosition = selectedWords[i].lastIndexOf('\n') + 1;
        selectedWords[i] = selectedWords[i].substring(0, newLinePosition) + prefix + selectedWords[i].substring(newLinePosition);
        selectionModify += prefix.length;
      }

      if (selectedWords[i].charAt(0) !== '\n') {
        selectedWords[i] = prefix + selectedWords[i];
      }

      selectionModify += prefix.length;
    } else if (selectedWords[i] === '' && selectedWords.length === 1) {
      selectedWords[i] = prefix + selectedWords[i];
      selectionModify += prefix.length;
      selectionStart += prefix.length;
    }
  }

  box.value = beforeSelection + selectedWords.join(' ') + afterSelection;
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd + selectionModify;
  box.scrollTop = scrollTop;
}

const autoCompleteMatchRegExp = /(^|\W)\/?(?:r\/([\w]+)\/)?(wiki|w|r|u)\/([-\w]+)$/;

function initializeAutocomplete() {
  if (!commentTools_module.options.subredditAutocomplete.value && !commentTools_module.options.userAutocomplete.value && !commentTools_module.options.wikiAutocomplete.value) return;
  jquery_default()(document.body).on('input', '.usertext .usertext-edit textarea, #BigText, #wiki_page_content', debounce_default()(async e => {
    const textarea = e.currentTarget;
    const prefixText = textarea.value.slice(0, textarea.selectionStart);
    const [,, subreddit, [type] = [], query] = autoCompleteMatchRegExp.exec(prefixText) || [];
    const completions = query && (type === 'u' && commentTools_module.options.userAutocomplete.value && (await getUserCompletions(query)) || type === 'r' && commentTools_module.options.subredditAutocomplete.value && (await getSubredditCompletions(query)) || type === 'w' && commentTools_module.options.wikiAutocomplete.value && (await getWikiCompletions(query, subreddit || currentSubreddit() || ''))) || [];
    autoComplete(textarea)(completions);
  }, 100));
}

const autoComplete = memoize_default()(textarea => {
  const element = string_namespaceObject.html`<div id="autocomplete_dropdown" class="drop-choices srdrop"></div>`;
  let entries = [];
  let index = 0;
  element.addEventListener('click', e => {
    const text = (e.target.closest('.choice') || e.target).textContent;
    const caretPos = textarea.selectionStart;
    let left = textarea.value.substr(0, caretPos);
    const right = textarea.value.substr(caretPos);
    left = left.replace(autoCompleteMatchRegExp, `$1${text} `);
    textarea.value = left + right;
    textarea.selectionStart = textarea.selectionEnd = left.length;
    textarea.focus();
    textarea.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  });

  const updateSelection = () => {
    for (const entry of entries) entry.classList.remove('selectedItem');

    entries[index % entries.length].classList.add('selectedItem');
  };

  const remove = () => {
    element.remove();
    textarea.removeEventListener('keydown', navigate);
    textarea.removeEventListener('blur', remove);
  };

  const navigate = e => {
    if (e.metaKey || e.shiftKey || e.ctrlKey || e.altKey) return;
    if (!document.contains(element)) return;

    switch (e.key) {
      case NAMED_KEYS.Down:
      case NAMED_KEYS.Right:
        e.preventDefault();
        index++;
        updateSelection();
        return;

      case NAMED_KEYS.Up:
      case NAMED_KEYS.Left:
        e.preventDefault();
        index--;
        updateSelection();
        return;

      case NAMED_KEYS.Tab:
      case NAMED_KEYS.Enter:
        e.preventDefault();
        entries[index % entries.length].click();
        return;

      case NAMED_KEYS.Escape:
        e.preventDefault();
        e.stopImmediatePropagation();
        remove();
        break;

      default:
        break;
    }
  };

  return matches => {
    if (!matches.length || document.activeElement !== textarea) {
      remove();
      return;
    }

    empty(element);
    entries = matches.slice(0, 20).map(text => string_namespaceObject.html`<a class="choice">${text}</a>`);
    element.append(...entries);
    index = 0;
    updateSelection();

    if (!document.contains(element)) {
      const textareaOffset = jquery_default()(textarea).offset();
      textareaOffset.left += jquery_default()(textarea).width();
      jquery_default()(element).css(textareaOffset);
      document.body.append(element);
      textarea.addEventListener('keydown', navigate);
      textarea.addEventListener('blur', () => {
        setTimeout(() => {
          if (document.activeElement !== textarea) remove();
        }, 200);
      });
    }
  };
});

async function getSubredditCompletions(query) {
  const {
    names
  } = await ajax({
    method: 'POST',
    url: '/api/search_reddit_names.json',
    query: {
      query
    },
    data: {
      query
    },
    type: 'json',
    cacheFor: DAY
  });
  return names.map(name => `/r/${name}`);
}

const loadAllTags = lodash_once_default()(() => userTagger_Tag.getStored());

async function getUserCompletions(query) {
  await loadAllTags();
  return Array.from(tags.values()).filter(({
    id
  }) => id.toLowerCase().startsWith(query.toLowerCase())).filter(({
    text,
    votesUp,
    instances
  }) => text || votesUp || instances.length).sort((a, b) => Number(b.instances.length > a.instances.length) || a.id.localeCompare(b.id)).map(({
    id
  }) => `/u/${id}`);
}

async function getWikiCompletions(query, subreddit) {
  const {
    data: wikiPages
  } = await ajax({
    method: 'GET',
    url: `/r/${subreddit}/wiki/pages.json`,
    type: 'json',
    cacheFor: DAY
  });
  return wikiPages.filter(wikiPage => wikiPage.toLowerCase().startsWith(query.toLowerCase())).map(wikiPage => `/r/${subreddit}/wiki/${wikiPage}`);
}

function findTextareaForElement(elem) {
  const textarea = jquery_default()(elem).closest('.usertext-edit, #BigEditor, .wiki-page-content, #banned').find('textarea').filter('#BigText, [name=text], [name=description], [name=public_description], [name=body], #wiki_page_content, #ban_message').get(0);
  return textarea;
}

function onCtrlEnter(selector, callback) {
  jquery_default()(document.body).on('keydown', selector, e => {
    if (e.key === NAMED_KEYS.Enter && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      callback(e);
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/usernameHider.js





const usernameHider_module = new Module('usernameHider');
usernameHider_module.moduleName = 'usernameHiderName';
usernameHider_module.category = 'myAccountCategory';
usernameHider_module.disabledByDefault = true;
usernameHider_module.description = 'usernameHiderDesc';
usernameHider_module.options = {
  displayText: {
    title: 'usernameHiderDisplayTextTitle',
    type: 'text',
    value: '~anonymous~',
    description: 'usernameHiderDisplayTextDesc'
  },
  perAccountDisplayText: {
    title: 'usernameHiderPerAccountDisplayTextTitle',
    type: 'table',
    addRowText: '+add account',
    fields: [{
      key: 'username',
      name: 'username',
      type: 'text'
    }, {
      key: 'displayText',
      name: 'displayText',
      type: 'text'
    }],
    value: [],
    description: 'usernameHiderPerAccountDisplayTextDesc'
  },
  hideAllUsernames: {
    title: 'usernameHiderHideAllUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAllUsernamesDesc'
  },
  hideAccountSwitcherUsernames: {
    title: 'usernameHiderHideAccountSwitcherUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAccountSwitcherUsernamesDesc'
  },
  showUsernameOnHover: {
    title: 'usernameHiderShowUsernameOnHoverTitle',
    type: 'boolean',
    value: false,
    description: 'usernameHiderShowUsernameOnHoverDesc'
  }
};

const substitutes = lodash_once_default()(() => new Map([[(loggedInUser() || '').toLowerCase(), usernameHider_module.options.displayText.value], ...usernameHider_module.options.perAccountDisplayText.value.map(([username, substitute]) => [username.toLowerCase(), substitute])]));

const getDisplayText = (username, alt = username) => substitutes().get(username.toLowerCase()) || alt;

usernameHider_module.contentStart = () => {
  for (const username of new Set([loggedInUser(), ...(usernameHider_module.options.hideAllUsernames.value ? usernameHider_module.options.perAccountDisplayText.value.map(([username]) => username) : []), ...(usernameHider_module.options.hideAccountSwitcherUsernames.value ? accountSwitcher_module.options.accounts.value.map(([username]) => username) : [])].filter(Boolean)).values()) {
    hideUsername(username, getDisplayText(username, usernameHider_module.options.displayText.value));
  }
};

function hideUsername(user, displayText) {
  if (!displayText || user === displayText) return;
  const userHref = `[href*="/user/${user}"]`;
  addCSS(`
		p.tagline > a${userHref},
		#header .user > a${userHref},
		.titlebox .tagline a.author${userHref},
		.commentingAsUser a${userHref},
		a.author${userHref},
		.bottom a${userHref} {
			line-height: 0;
			font-size: 0;
		}

		p.tagline > a${userHref}::after,
		#header .user > a${userHref}::after,
		.titlebox .tagline a.author${userHref}::after,
		.commentingAsUser a${userHref}::after,
		a.author${userHref}::after,
		.bottom a${userHref}::after {
			content: "${displayText}";
			letter-spacing: normal;
			font-size: 10px;
			background-color: inherit;
			border-radius: inherit;
			padding: inherit;
		}

		a.author${userHref}::after {
			margin-right: 0.5em;
		}

		.commentingAsUser a${userHref}::after {
			font-size: small;
		}
	`);

  if (usernameHider_module.options.showUsernameOnHover.value) {
    addCSS(`
			p.tagline > a${userHref}:hover,
			#header .user > a${userHref}:hover,
			.titlebox .tagline a.author${userHref}:hover,
			.commentingAsUser a${userHref}:hover,
			a.author${userHref}:hover,
			.bottom a${userHref}:hover {
				line-height: inherit;
				font-size: inherit;
			}

			p.tagline > a${userHref}:hover::after,
			#header .user > a${userHref}:hover::after,
			.titlebox .tagline a.author${userHref}:hover::after,
			.commentingAsUser a${userHref}:hover::after,
			a.author${userHref}:hover::after,
			.bottom a${userHref}:hover::after {
				content: none;
			}
		`);
  }

  const curatedBy = document.querySelector('.multi-details > h2 a');

  if (curatedBy) {
    const curatedByUsername = curatedBy.pathname.match(regexes.profile);

    if (curatedByUsername && curatedByUsername[1].toLowerCase() === user.toLowerCase()) {
      curatedBy.textContent = curatedBy.textContent.replace(user, displayText);

      if (usernameHider_module.options.showUsernameOnHover.value) {
        jquery_default()(curatedBy).on('mouseenter', function () {
          this.textContent = this.textContent.replace(displayText, user);
        }).on('mouseleave', function () {
          this.textContent = this.textContent.replace(user, displayText);
        });
      }
    }
  }
}
// CONCATENATED MODULE: ./lib/modules/quickMessage.js











const quickMessage_module = new Module('quickMessage');
quickMessage_module.moduleName = 'quickMessageName';
quickMessage_module.category = 'usersCategory';
quickMessage_module.description = 'quickMessageDesc';
quickMessage_module.options = {
  openQuickMessage: {
    title: 'quickMessageOpenQuickMessageTitle',
    type: 'keycode',
    value: [77, false, true, false, false],
    description: 'quickMessageOpenQuickMessageDesc'
  },
  defaultSubject: {
    title: 'quickMessageDefaultSubjectTitle',
    type: 'text',
    value: '',
    description: 'quickMessageDefaultSubjectDesc'
  },
  sendAs: {
    title: 'quickMessageSendAsTitle',
    type: 'enum',
    values: [{
      name: 'Current user',
      value: 'user'
    }, {
      name: 'Current subreddit',
      value: 'sub'
    }, {
      name: 'Last selected',
      value: 'last'
    }, {
      name: 'Last selected (this page load)',
      value: 'temporary'
    }],
    value: 'user',
    description: 'quickMessageSendAsDesc'
  },
  handleContentLinks: {
    title: 'quickMessageHandleContentLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleContentLinksDesc'
  },
  handleSideLinks: {
    title: 'quickMessageHandleSideLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleSideLinksDesc'
  },
  linkToCurrentPage: {
    title: 'quickMessageLinkToCurrentPageTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageLinkToCurrentPageDesc'
  }
};
const lastSentAsStorage = storage_namespaceObject.wrapPrefix('RESmodules.quickMessage.lastSentAs.', () => null);

quickMessage_module.contentStart = () => {
  registerCommand((cmd, val) => cmd === 'qm' && /^(?:([^\s]+)(?:\s(.*))?)?$/.exec(val), 'qm [recipient [message]] - open quick message dialog', (command, val, [, to, body]) => {
    if (body) {
      return `quick message to ${to}: ${body}`;
    } else if (to) {
      return `quick message to ${to}`;
    }

    return 'quick message';
  }, (command, val, [, to, body]) => {
    openQuickMessageDialog({
      to,
      body
    });
  });
  window.addEventListener('keydown', e => {
    if (checkKeysForEvent(e, quickMessage_module.options.openQuickMessage.value)) {
      e.preventDefault();
      openQuickMessageDialog();
    }
  }, true);

  if (quickMessage_module.options.handleContentLinks.value) {
    jquery_default()('div.content[role="main"]').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }

  if (quickMessage_module.options.handleSideLinks.value) {
    jquery_default()('div.side').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }
};

const quickMessageDialog = lodash_once_default()(() => {
  const $dialog = jquery_default()(string_namespaceObject.html`
		<div id="quickMessage">
			<div id="quickMessageDialog" class="RESDialogSmall">
				<h3>Send Message<a class="gearIcon" href="${makeUrlHash(quickMessage_module.moduleID)}"></a></h3>
				<div id="quickMessageDialogClose" class="RESCloseButton RESCloseButtonTopRight"></div>
				<div id="quickMessageDialogContents" class="RESDialogContents clear">
					<form name="quickMessageDialogForm" action="">
						<label for="quickMessageDialogFrom">From</label>
						<select id="quickMessageDialogFrom"></select>
						<label for="quickMessageDialogTo">To</label>
						<input type="text" id="quickMessageDialogTo" value=""/>
						<label for="quickMessageDialogSubject">Subject</label>
						<input type="text" id="quickMessageDialogSubject" value=""/>
						<label for="quickMessageDialogBody">Body</label>
						<textarea id="quickMessageDialogBody"></textarea>
						<div class="clear"></div>
						<input type="button" id="quickMessageDialogSend" value=" send message"/>
						<a href="/message/compose" class="fullMessageForm blueButton">open full message form</a>
					</form>
				</div>
			</div>
		</div>
	`);
  const from = downcast($dialog.find('#quickMessageDialogFrom').get(0), HTMLSelectElement);
  const to = downcast($dialog.find('#quickMessageDialogTo').get(0), HTMLInputElement);
  const subject = downcast($dialog.find('#quickMessageDialogSubject').get(0), HTMLInputElement);
  const body = downcast($dialog.find('#quickMessageDialogBody').get(0), HTMLTextAreaElement);
  $dialog.find('#quickMessageDialogClose').on('click', e => {
    e.preventDefault();
    closeQuickMessageDialog();
  });
  $dialog.get(0).addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      e.preventDefault();
      closeQuickMessageDialog();
    }
  }, true);
  $dialog.find('#quickMessageDialogSend').get(0).addEventListener('click', e => {
    e.preventDefault();
    quickMessage_sendMessage();
  }, true);
  onCtrlEnter('#quickMessageDialog', quickMessage_sendMessage);
  $dialog.find('a.fullMessageForm').on('mousedown focus', e => {
    jquery_default()(e.currentTarget).attr('href', getFullMessageFormUrl());
  }).on('click', closeQuickMessageDialog);
  $dialog.find('a').on('keypress', e => {
    if (e.key === NAMED_KEYS.Enter) {
      e.currentTarget.click();
    }
  });
  from.addEventListener('change', () => {
    const val = from.value;
    updateModeratorIcon(val.startsWith('/r/'));
    const loggedIn = loggedInUser();
    if (loggedIn) lastSentAsStorage.set(loggedIn, val);
  });
  $dialog.appendTo(document.body);
  return {
    $dialog,
    from,
    to,
    subject,
    body
  };
});

function updateModeratorIcon(state) {
  quickMessageDialog().$dialog.find('label[for=quickMessageDialogFrom]').toggleClass('moderator', state);
}

function messageLinkEventHandler(e) {
  const {
    searchParams,
    pathname
  } = new URL(downcast(e.target, HTMLAnchorElement).href, location.href);
  const hasModifier = e.ctrlKey || e.altKey || e.metaKey || e.shiftKey;

  if (e.button === 0 && !hasModifier && regexes.composeMessage.test(pathname)) {
    e.preventDefault();
    const srMatch = regexes.subreddit.exec(pathname);
    openQuickMessageDialog({
      from: srMatch ? `/r/${srMatch[1]}` : undefined,
      to: searchParams.get('to') || '',
      subject: searchParams.get('subject') || '',
      body: searchParams.get('message') || ''
    });
    return true;
  }
}

async function getValidSendFrom() {
  const username = loggedInUser();

  if (!username) {
    return [];
  }

  const users = [{
    name: `/u/${username}`,
    displayText: `/u/${isRunning(usernameHider_namespaceObject) ? getDisplayText(username) : username}`
  }];

  if (isModeratorAnywhere()) {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine/moderator.json',
      query: {
        limit: 1000,
        show: 'all',
        user: loggedInUser() || ''
      },
      type: 'json',
      cacheFor: HOUR
    });
    const modSubs = data.children.map(({
      data
    }) => {
      const name = data.url.slice(0, -1);
      return {
        name,
        displayText: name
      };
    });
    users.push(...modSubs);
  }

  return users;
}

const setUpSendFromDropdown = lodash_once_default()(async () => {
  const senders = await getValidSendFrom();

  for (const {
    name,
    displayText
  } of senders) {
    const currentOption = document.createElement('option');
    currentOption.value = name;
    currentOption.text = displayText;
    quickMessageDialog().from.add(currentOption);
  }

  quickMessageDialog().from.disabled = senders.length < 2;
});

function focusFirstEmpty() {
  Array.from(quickMessageDialog().$dialog.find('input, textarea')).find((ele, i, {
    length
  }) => !ele.value || i === length - 1).focus();
}

async function updateSelectedSender(desiredUser, loggedIn) {
  const sendAsOptions = Array.from(quickMessageDialog().from.options).map(ele => jquery_default()(ele).text().toLowerCase());
  let indexToSelect = sendAsOptions.indexOf(desiredUser.toLowerCase());

  if (indexToSelect === -1) {
    switch (quickMessage_module.options.sendAs.value) {
      case 'sub':
        const sub = currentSubreddit();
        if (sub) indexToSelect = sendAsOptions.indexOf(`/r/${sub.toLowerCase()}`);
        break;

      case 'last':
        const lastSelected = await lastSentAsStorage.get(loggedIn);

        if (lastSelected) {
          indexToSelect = sendAsOptions.indexOf(lastSelected.toLowerCase());
        }

        break;

      case 'temporary':
        indexToSelect = quickMessageDialog().from.selectedIndex;
        break;

      default:
        indexToSelect = 0;
        break;
    }
  }

  quickMessageDialog().from.selectedIndex = indexToSelect !== -1 ? indexToSelect : 0;
  updateModeratorIcon(quickMessageDialog().from.value.startsWith('/r/'));
}

async function openQuickMessageDialog({
  from = '',
  to = '',
  subject = quickMessage_module.options.defaultSubject.value,
  body = quickMessage_module.options.linkToCurrentPage.value ? location.href : ''
} = {}) {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'quickMessageNoUser',
      header: 'Not Logged In.',
      closeDelay: 3000,
      message: 'You must log in to use the quick message dialog.'
    });
    return;
  }

  await setUpSendFromDropdown();
  await updateSelectedSender(from, loggedIn);
  quickMessageDialog().to.value = to;
  quickMessageDialog().subject.value = subject;
  quickMessageDialog().body.value = body;
  quickMessageDialog().$dialog.fadeIn(300);
  focusFirstEmpty();
}

function closeQuickMessageDialog() {
  quickMessageDialog().$dialog.fadeOut(300);

  for (const ele of quickMessageDialog().$dialog.find('input, textarea, button')) {
    ele.blur();
  }
}

function getFullMessageFormUrl() {
  const subreddit = quickMessageDialog().from.value.startsWith('/r/') ? quickMessageDialog().from.value : '';
  return subreddit + string_namespaceObject.encode`/message/compose?to=${quickMessageDialog().to.value}&subject=${quickMessageDialog().subject.value}&message=${quickMessageDialog().body.value}`;
}

const presetSendErrors = {
  NO_USER: 'No recipient specified.',
  NO_SUBJECT: 'No subject specified.',
  NO_TEXT: 'Message body is empty.',
  BAD_CAPTCHA: '<p>Sorry, reddit requires you to enter a captcha to send messages. This is usually because your account is brand new or has low karma.</p><b>Click on "open full message form" and try again (your message will be preserved).</b>',
  TOO_LONG: 'Either your subject (max 100 characters) or body (max 10,000 characters) is too long.'
};

async function quickMessage_sendMessage() {
  const from = quickMessageDialog().from.value;

  try {
    const {
      json: {
        errors
      }
    } = await ajax({
      method: 'POST',
      url: '/api/compose',
      data: {
        api_type: 'json',
        from_sr: from.includes('/r/') ? from.slice(3) : '',
        subject: quickMessageDialog().subject.value,
        text: quickMessageDialog().body.value,
        to: quickMessageDialog().to.value
      },
      type: 'json'
    });

    if (errors[0]) {
      notifications_showNotification({
        moduleID: 'quickMessage',
        notificationID: 'quickMessageSendError',
        header: 'Message not sent.',
        closeDelay: 15000,
        message: presetSendErrors[errors[0][0]] || `${errors[0][0]} : ${errors[0][1]}`
      });
    } else {
      closeQuickMessageDialog();
    }
  } catch (e) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'failedToSendQuickMessage',
      header: 'Sending Failed!',
      closeDelay: 15000,
      message: 'Reddit is likely under heavy load. Either wait a minute or click on "open full message form" and try again (your message will be preserved).'
    });
    throw e;
  }
}
// CONCATENATED MODULE: ./lib/modules/userHighlight.js





const userHighlight_module = new Module('userHighlight');
userHighlight_module.moduleName = 'userHighlightName';
userHighlight_module.category = 'usersCategory';
userHighlight_module.description = 'userHighlightDesc';
userHighlight_module.bodyClass = true;
userHighlight_module.options = {
  highlightSelf: {
    title: 'userHighlightHighlightSelfTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightSelfDesc'
  },
  selfColor: {
    title: 'userHighlightSelfColorTitle',
    type: 'color',
    value: '#B8860B',
    description: 'userHighlightSelfColorDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  selfColorHover: {
    title: 'userHighlightSelfColorHoverTitle',
    type: 'color',
    value: '#8A6508',
    description: 'userHighlightSelfColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  highlightOP: {
    title: 'userHighlightHighlightOPTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightOPDesc'
  },
  OPColor: {
    title: 'userHighlightOPColorTitle',
    type: 'color',
    value: '#0055DF',
    description: 'userHighlightOPColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  OPColorHover: {
    title: 'userHighlightOPColorHoverTitle',
    type: 'color',
    value: '#4E7EAB',
    description: 'userHighlightOPColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  highlightAdmin: {
    title: 'userHighlightHighlightAdminTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAdminDesc'
  },
  adminColor: {
    title: 'userHighlightAdminColorTitle',
    type: 'color',
    value: '#FF0011',
    description: 'userHighlightAdminColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  adminColorHover: {
    title: 'userHighlightAdminColorHoverTitle',
    type: 'color',
    value: '#B3000C',
    description: 'userHighlightAdminColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  highlightAlum: {
    title: 'userHighlightHighlightAlumTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAlumDesc'
  },
  alumColor: {
    title: 'userHighlightAlumColorTitle',
    type: 'color',
    value: '#BE1337',
    description: 'userHighlightAlumColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  alumColorHover: {
    title: 'userHighlightAlumColorHoverTitle',
    type: 'color',
    value: '#8F0E29',
    description: 'userHighlightAlumColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  highlightFriend: {
    title: 'userHighlightHighlightFriendTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightFriendDesc'
  },
  friendColor: {
    title: 'userHighlightFriendColorTitle',
    type: 'color',
    value: '#FF4500',
    description: 'userHighlightFriendColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  friendColorHover: {
    title: 'userHighlightFriendColorHoverTitle',
    type: 'color',
    value: '#B33000',
    description: 'userHighlightFriendColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  highlightMod: {
    title: 'userHighlightHighlightModTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightModDesc'
  },
  modColor: {
    title: 'userHighlightModColorTitle',
    type: 'color',
    value: '#228822',
    description: 'userHighlightModColorDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  modColorHover: {
    title: 'userHighlightModColorHoverTitle',
    type: 'color',
    value: '#134913',
    description: 'userHighlightModColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  highlightOpMentions: {
    title: 'userHighlightOpMentionsTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightOpMentionsDesc'
  },
  opMentionsColor: {
    title: 'userHighlightOpMentionsColorTitle',
    type: 'color',
    value: '#6D4731',
    description: 'userHighlightOpMentionsColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  opMentionsHover: {
    title: 'userHighlightOpMentionsHoverTitle',
    type: 'color',
    value: '#C4946E',
    description: 'userHighlightOpMentionsHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  highlightFirstCommenter: {
    title: 'userHighlightHighlightFirstCommenterTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightFirstCommenterDesc'
  },
  dontHighlightFirstComment: {
    title: 'userHighlightDontHighlightFirstCommentTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightDontHighlightFirstCommentDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColor: {
    title: 'userHighlightFirstCommentColorTitle',
    type: 'color',
    value: '#46B6CC',
    description: 'userHighlightFirstCommentColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColorHover: {
    title: 'userHighlightFirstCommentColorHoverTitle',
    type: 'color',
    value: '#72D2E5',
    description: 'userHighlightFirstCommentColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  fontColor: {
    title: 'userHighlightFontColorTitle',
    type: 'color',
    value: '#FFFFFF',
    description: 'userHighlightFontColorDesc',
    advanced: true
  },
  autoColorUsernames: {
    title: 'userHighlightAutoColorUsernamesTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightAutoColorUsernamesDesc'
  },
  autoColorUsing: {
    title: 'userHighlightAutoColorUsingTitle',
    description: 'userHighlightAutoColorUsingDesc',
    type: 'enum',
    value: 'hash-userid-notbright',
    values: [{
      name: 'Random color, not too bright, consistent for each user; night mode-friendly',
      value: 'hash-userid-notbright'
    }, {
      name: 'Simple random color, consistent for each user. (original)',
      value: 'hash-userid'
    }, {
      name: 'All black or, in night mode, all light gray.',
      value: 'monochrome'
    }],
    advanced: true,
    dependsOn: options => options.autoColorUsernames.value
  },
  generateHoverColors: {
    title: 'userHighlightGenerateHoverColorsTitle',
    type: 'button',
    text: 'Generate',
    callback: generateHoverColors,
    description: 'userHighlightGenerateHoverColorsDesc',
    advanced: true
  }
};

userHighlight_module.beforeLoad = () => {
  if (userHighlight_module.options.autoColorUsernames.value) {
    watchForThings(['post', 'comment', 'message'], updateNewUsernames, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFirstCommenter.value) {
    watchForThings(['comment'], updateFirstComments, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFriend.value) {
    highlight('friend', userHighlight_module.options.friendColor.value, userHighlight_module.options.friendColorHover.value);
  }

  if (userHighlight_module.options.highlightOP.value) {
    highlight('submitter', userHighlight_module.options.OPColor.value, userHighlight_module.options.OPColorHover.value);
  }

  if (userHighlight_module.options.highlightMod.value) {
    highlight('moderator', userHighlight_module.options.modColor.value, userHighlight_module.options.modColorHover.value);
  }

  if (userHighlight_module.options.highlightAdmin.value) {
    highlight('admin', userHighlight_module.options.adminColor.value, userHighlight_module.options.adminColorHover.value);
  }

  if (userHighlight_module.options.highlightAlum.value) {
    highlight('alum', userHighlight_module.options.alumColor.value, userHighlight_module.options.alumColorHover.value);
  }

  if (userHighlight_module.options.highlightOpMentions.value && isPageType('comments')) {
    watchForElements(['selfText'], null, selftext => {
      const thing = Thing_Thing.from(selftext);
      const author = thing && thing.getAuthor();
      highlightMentionedUsers(selftext, userHighlight_module.options.opMentionsColor.value, userHighlight_module.options.opMentionsHover.value, author);
    }, {
      immediate: true
    });
  }
};

userHighlight_module.contentStart = () => {
  const username = loggedInUser();

  if (userHighlight_module.options.highlightSelf.value && username) {
    highlight(`author[href$="/${username}"]`, userHighlight_module.options.selfColor.value, userHighlight_module.options.selfColorHover.value);
  }
};

function highlightMentionedUsers(element, color, hoverColor, ...exclude) {
  Array.from(element.querySelectorAll('a')).map(getUsernameFromLink).filter(Boolean).filter(user => !exclude.includes(user)).forEach(user => highlight(`author[href$="/${user}" i]`, color, hoverColor));
}

function updateFirstComments(thing) {
  if (!thing.isTopLevelComment()) return;
  const idClass = Array.from(thing.element.classList).find(cls => cls.startsWith('id-t1_'));
  if (!idClass) return;
  const author = thing.getAuthorElement();
  if (!author) return;
  const authorClass = Array.from(author.classList).find(cls => cls.startsWith('id-t2_'));

  if (authorClass) {
    const container = `.${idClass}${userHighlight_module.options.dontHighlightFirstComment.value ? ' .child' : ''}`;
    highlight(authorClass, userHighlight_module.options.firstCommentColor.value, userHighlight_module.options.firstCommentColorHover.value, container);
  }
}

function updateNewUsernames(thing) {
  const element = thing.getAuthorElement();
  if (!element) return;
  const idClass = Array.from(element.classList).find(cls => cls.startsWith('id-t2_'));
  if (!idClass) return;
  const colorGetter = autoColorUsing[userHighlight_module.options.autoColorUsing.value];
  const color = colorGetter(idClass);
  doTextColor(idClass, color);
}

const autoColorUsing = {
  'hash-userid-notbright'(idClass) {
    const hash = hashCode(idClass);
    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const lum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    const minLum = 0x66;
    const maxLum = 0xAA;
    let color = [r, g, b];
    let nightmodeColor = [r, g, b];

    if (lum < minLum) {
      const scale = minLum / lum;
      nightmodeColor = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    } else if (lum > maxLum) {
      const scale = maxLum / lum;
      color = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    }

    color = `rgb(${color.join(',')})`;
    nightmodeColor = `rgb(${nightmodeColor.join(',')})`;
    return {
      color,
      nightmodeColor
    };
  },

  'hash-userid'(idClass) {
    let hash = 5381;

    for (const char of idClass) {
      hash = (hash << 5) + hash + char.charCodeAt(0);
    }

    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const color = `rgb(${[r, g, b].join(',')})`;
    return {
      color
    };
  },

  monochrome() {
    return {
      color: 'black',
      nightmodeColor: '#ccc'
    };
  }

};
function highlightUser(userid) {
  return highlight(`author.id-t2_${userid}`, userInfo_module.options.highlightColor.value, userInfo_module.options.highlightColorHover.value);
}
const userHighlight_css = [];
const throttled = async_throttle(() => {
  addCSS(userHighlight_css.splice(0, userHighlight_css.length).join('\n'));
});

const userHighlight_batch = v => {
  userHighlight_css.push(v);
  throttled();
};

function highlight(selector, color, hoverColor, container = '') {
  userHighlight_batch(`
${container} .tagline .author.${selector},
${container} .crosspost-preview-tagline .author.${selector} {
	color: ${userHighlight_module.options.fontColor.value} !important;
	font-weight: bold;
	padding: 0 2px 0 2px;
	border-radius: 3px;
	background-color: ${color} !important;
}
${container} .collapsed .tagline .author.${selector},
${container} .collapsed .crosspost-preview-tagline .author.${selector} {
	color: white !important;
	background-color: #AAA !important;
}
${container} .tagline .author.${selector}:hover,
${container} .crosspost-preview-tagline .author.${selector}:hover {
	background-color: ${hoverColor} !important;
	text-decoration: none !important;
}
	`);
}

function doTextColor(selector, colorData) {
  const color = colorData.color;
  const nightmodeColor = colorData.nightmodeColor || colorData.color;
  userHighlight_batch(`
.tagline .author.${selector} {
	color: ${color} !important;
}
.res-nightmode .tagline .author.${selector} {
	color: ${nightmodeColor} !important;
}
	`);
}

function generateHoverColor(color) {
  if (!/^#[0-9A-F]{6}$/i.test(color)) throw new Error('Input color must be a six digit hex value');
  let R = parseInt(color.substr(1, 2), 16);
  let G = parseInt(color.substr(3, 2), 16);
  let B = parseInt(color.substr(5, 2), 16);
  R = Math.round(0.75 * R) + 256;
  G = Math.round(0.75 * G) + 256;
  B = Math.round(0.75 * B) + 256;
  return `#${R.toString(16).substr(1)}${G.toString(16).substr(1)}${B.toString(16).substr(1)}`;
}

function generateHoverColors() {
  try {
    for (const option of ['selfColor', 'OPColor', 'adminColor', 'friendColor', 'modColor', 'firstCommentColor', 'alumColor']) {
      const current = (stage_namespaceObject.get(userHighlight_module.moduleID) || userHighlight_module.options)[option].value;
      options_storage_set(userHighlight_module.moduleID, option, generateHoverColor(current));
    }

    alert_namespaceObject.open('Saved, but not yet updated in settings console. Reload page without saving to see new values.');
  } catch (e) {
    alert_namespaceObject.open(i18n('userHighlightColorCouldNotBeGenerated'));
  }
}
// CONCATENATED MODULE: ./lib/modules/userInfo.js










const userInfo_module = new Module('userInfo');
userInfo_module.moduleName = 'userInfoName';
userInfo_module.category = 'usersCategory';
userInfo_module.description = 'userInfoDesc';
userInfo_module.options = {
  hoverInfo: {
    title: 'userInfoHoverInfoTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHoverInfoDesc'
  },
  useQuickMessage: {
    title: 'userInfoUseQuickMessageTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoUseQuickMessageDesc',
    dependsOn: options => options.hoverInfo.value
  },
  hoverDelay: {
    title: 'userInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'userInfoHoverDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeDelay: {
    title: 'userInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'userInfoFadeDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeSpeed: {
    title: 'userInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'userInfoFadeSpeedDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  gildComments: {
    title: 'userInfoGildCommentsTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoGildCommentsDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightButton: {
    title: 'userInfoHighlightButtonTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHighlightButtonDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightColor: {
    title: 'userInfoHighlightColorTitle',
    type: 'color',
    value: '#5544CC',
    description: 'userInfoHighlightColorDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  },
  highlightColorHover: {
    title: 'userInfoHighlightColorHoverTitle',
    type: 'color',
    value: '#6677AA',
    description: 'userInfoHighlightColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  }
};
const highlightedUsers = {};

userInfo_module.contentStart = () => {
  if (userInfo_module.options.hoverInfo.value) {
    infocard(userInfo_module.moduleID).options({
      width: 475,
      openDelay: parseFloat(userInfo_module.options.hoverDelay.value),
      fadeDelay: parseFloat(userInfo_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(userInfo_module.options.fadeSpeed.value)
    }).populateWith(showUserInfo).watch(usernameSelector);
  }
};

async function showUserInfo(card) {
  const username = getUsernameFromLink(card.getCheckedTarget());

  if (!username) {
    console.error(i18n('userInfoInvalidUsernameLink'));
    return;
  }

  const thing = Thing_Thing.from(card.getCheckedTarget());
  let data;

  try {
    ({
      data
    } = await getUserInfo(username));
  } catch (e) {
    return [null, i18n('userInfoUserNotFound')];
  }

  if (data.is_suspended) {
    return [null, i18n('userInfoUserSuspended')];
  }

  const d = new Date(data.created_utc * 1000);
  const header = string_namespaceObject.html`
		<div>
			<a href="/user/${data.name}">/u/${data.name}</a>
		 	(<a href="/user/${data.name}/submitted/">${i18n('userInfoLinks')}</a>)
		 	(<a href="/user/${data.name}/comments/">${i18n('userInfoComments')}</a>)
		</div>
	`;

  if (loggedInUser()) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('userInfoAddRemoveFriends'), '', () => data.is_friend, async state => {
      ajax({
        method: 'POST',
        url: `/api/${state ? 'friend' : 'unfriend'}`,
        data: {
          type: 'friend',
          name: data.name,
          container: `t2_${(await getUserInfo()).data.id}`
        }
      });
      ajax.invalidate({
        url: `/user/${data.name}/about.json`
      });
    });
    button.style.marginLeft = '12px';
    header.appendChild(button);
  }

  card.populate([header]);
  const $body = jquery_default()('<div id="authorInfoToolTip" />');
  let userHTML = string_namespaceObject.escape`
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoRedditorSince')}</div> <div class="fieldPair-text">${formatDate(d)} (${formatDateDiff(d)})</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoPostKarma')}</div> <div class="fieldPair-text">${formatNumber(data.link_karma)}</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoCommentKarma')}</div> <div class="fieldPair-text">${formatNumber(data.comment_karma)}</div></div>
	`;
  const userTaggerEnabled = isRunning(userTagger_namespaceObject);
  const userTag = userTaggerEnabled && (await userTagger_Tag.get(data.name));

  if (userTaggerEnabled) {
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoUserTag')}</div> <div class="fieldPair-text" style="display:flex"><a class="author" style="display: none;" href="/u/${data.name}"/></div></div>`;
  }

  if (userTag && userTag.link) {
    const links = userTag.link.split(/\s/).reduce((acc, url) => acc + string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" href="${url}">${url.replace(/^https?:\/\/(www\.)?/, '')}</a>`, '');
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoLink')}</div> <div class="fieldPair-text">${links}</div></div>`;
  }

  userHTML += string_namespaceObject.escape`
		<div class="clear"></div>
		<div class="bottomButtons">
			<a target="_blank" rel="noopener noreferer" class="blueButton composeButton" href="/message/compose/?to=${data.name}"><img src="https://redditstatic.s3.amazonaws.com/mailgray.png"> ${i18n('userInfoSendMessage')}</a>
	`;

  if (data.is_gold) {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" class="blueButton" href="/gold/about">${i18n('userInfoUserHasRedditGold')}</a>`;
  } else {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" id="gildUser" class="blueButton" href="/gold?goldtype=gift&recipient=${data.name}">${i18n('userInfoGiftRedditGold')}</a>`;
  }

  if (userInfo_module.options.highlightButton.value) {
    const isHighlight = !highlightedUsers[data.id];
    userHTML += string_namespaceObject.escape`<div class="${isHighlight ? 'blueButton' : 'redButton'}" id="highlightUser" data-userid="${data.id}">${isHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight')}</div>`;
  }

  if (userTag) {
    const getButton = () => string_namespaceObject.html`<div class="${userTag.ignored ? 'redButton' : 'blueButton'}" id="ignoreUser">&empty; ${userTag.ignored ? i18n('userInfoUnignore') : i18n('userInfoIgnore')}</div>`;

    $body.on('click', '#ignoreUser', e => {
      if (e.currentTarget.classList.contains('blueButton')) userTag.ignore();else userTag.unignore();
      e.currentTarget.replaceWith(getButton());
    });
    userHTML += getButton().outerHTML;
  }

  userHTML += '<div class="clear"></div></div>';
  $body.append(userHTML);

  if (userTag) {
    userTag.add(downcast($body.find('.author').get(0), HTMLAnchorElement), {
      renderTaggingIcon: true
    });
  }

  if (userInfo_module.options.highlightButton.value) {
    $body.find('#highlightUser').on('click', ({
      currentTarget
    }) => {
      const userid = currentTarget.getAttribute('data-userid');
      toggleUserHighlight(currentTarget, userid, thing);
    });
  }

  if (userInfo_module.options.gildComments.value && thing && thing.isComment()) {
    $body.find('#gildUser').on('click', e => {
      if (!thing || e.ctrlKey || e.metaKey || e.shiftKey) return;
      card.close();
      const giveGold = thing.entry.querySelector('.give-gold');
      click(giveGold);
      e.preventDefault();
    });
  }

  if (userInfo_module.options.useQuickMessage.value && isRunning(quickMessage_namespaceObject)) {
    $body.find('a.composeButton').on('click', e => {
      if (e.which === 1) {
        e.preventDefault();
        let entryUrl;

        if (quickMessage_module.options.linkToCurrentPage.value && thing) {
          const permalink = thing.getCommentPermalink();

          if (permalink) {
            entryUrl = permalink.href;
            if (!entryUrl.includes('?context=')) entryUrl += '?context=10';
          }
        }

        openQuickMessageDialog({
          to: data.name,
          body: entryUrl
        });
        card.close();
      }
    });
  }

  return [null, $body];
}

function toggleUserHighlight(authorInfoToolTipHighlight, userid, thing) {
  if (highlightedUsers[userid]) {
    highlightedUsers[userid].remove();
    delete highlightedUsers[userid];
    toggleUserHighlightButton(authorInfoToolTipHighlight, true);
  } else {
    highlightedUsers[userid] = highlightUser(userid);
    toggleUserHighlightButton(authorInfoToolTipHighlight, false);
  }

  if (isRunning(commentNavigator_namespaceObject) && commentNavigator_module.options.openOnHighlightUser.value) {
    setCategory('highlighted', true);
    if (thing) updateFromSelected(thing);
    commentNavigator_toggle(false, true);
  }
}

function toggleUserHighlightButton(authorInfoToolTipHighlight, canHighlight) {
  jquery_default()(authorInfoToolTipHighlight).toggleClass('blueButton', canHighlight).toggleClass('redButton', !canHighlight).text(canHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight'));
}
// CONCATENATED MODULE: ./lib/modules/wheelBrowse.js




const wheelBrowse_module = new Module('wheelBrowse');
wheelBrowse_module.moduleName = 'wheelBrowseName';
wheelBrowse_module.category = 'browsingCategory';
wheelBrowse_module.description = 'wheelBrowseDesc';
let behavior;

wheelBrowse_module.contentStart = () => {
  if (!behavior && isPageType('linklist')) useLinklistBehavior();
  if (!behavior) return;
  const wheelBrowseWidget = string_namespaceObject.html`<div hidden class="res-wheel-browse"></div>`;
  const onWheel = behavior(wheelBrowseWidget);
  selectedThing_namespaceObject.addListener(current => {
    wheelBrowseWidget.hidden = !current;
  }, 'instantly');
  wheelBrowseWidget.addEventListener('wheel', e => {
    e.stopImmediatePropagation();
    e.preventDefault();
    onWheel(e.deltaY > 0 ? 'down' : 'up', e);
  });
  addFloater(wheelBrowseWidget, {
    order: -1
  });
};

function setCallback(v) {
  behavior = v;
}

function useLinklistBehavior() {
  const galleryPart = string_namespaceObject.html`<div hidden class="res-wheel-browse-gallery"></div>`;
  let media;

  function updateGalleryPart(direction) {
    const expando = expando_Expando.getEntryExpandoFrom(selectedThing_namespaceObject.current);
    media = expando && expando.media;
    galleryPart.hidden = !(media && media.element.classList.contains('res-gallery-slideshow') && !(direction === 'down' && media.element.querySelector('[last-piece=true]')) && !(direction === 'up' && media.element.querySelector('[first-piece=true]')));
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => settingsNavigation_open(wheelBrowse_module.moduleID));
    wheelBrowseWidget.addEventListener('mouseenter', () => {
      updateGalleryPart();
    });
    wheelBrowseWidget.append(galleryPart);
    return (direction, {
      target
    }) => {
      if (target === wheelBrowseWidget) {
        selectedThing_namespaceObject.move(direction, {
          allowMediaBrowse: true,
          scrollStyle: 'top'
        });
      } else if (target === galleryPart) {
        const clicker = media && media.element.querySelector(direction === 'down' ? '.res-gallery-next' : '.res-gallery-previous');
        if (clicker) clicker.click();
        updateGalleryPart(direction);
      }
    };
  });
}
// CONCATENATED MODULE: ./lib/modules/commentNavigator.js












const commentNavigator_module = new Module('commentNavigator');
commentNavigator_module.moduleName = 'commentNavName';
commentNavigator_module.category = 'commentsCategory';
commentNavigator_module.description = 'commentNavDesc';
commentNavigator_module.options = {
  showByDefault: {
    type: 'boolean',
    value: false,
    description: 'commentNavigatorShowByDefaultDesc',
    title: 'commentNavigatorShowByDefaultTitle'
  },
  openOnHighlightUser: {
    type: 'boolean',
    value: true,
    description: 'commentNavigatorOpenOnHighlightUserDesc',
    title: 'commentNavigatorOpenOnHighlightUserTitle',
    advanced: true
  },
  popularConditions: {
    type: 'text',
    value: JSON.stringify({
      type: 'commentLength',
      op: '>',
      kind: 'words',
      val: 0
    }),
    description: 'commentNavigatorPopularConditionsDesc',
    title: 'commentNavigatorPopularConditionsTitle',
    advanced: true
  }
};
commentNavigator_module.include = ['comments'];

commentNavigator_module.contentStart = () => {
  installEntryElement();

  if (commentNavigator_module.options.showByDefault.value) {
    commentNav();
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => {
      commentNavigator_toggle();
    });
    return direction => {
      if (direction === 'up') commentNavigator_move('up');else commentNavigator_move('down');
    };
  });

  const getMatchingCategory = async val => val && (await getCategories()).find(({
    category
  }) => category.startsWith(val));

  registerCommand('nav', 'nav [sortType] - open the comment navigator', async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    return `navigate comments by [(${(await getCategories()).map(({
      category
    }) => matchingCategory === category ? `<b>${category}</b>` : category).join('|')})]`;
  }, async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    if (matchingCategory) setCategory(matchingCategory);
    commentNavigator_toggle(false, true);
  });
};

const commentNavigator_initialize = lodash_once_default()(() => {
  watchForThings(['comment'], () => {
    _memoized.cache.clear();
  });
  selectedThing_namespaceObject.addListener(updateFromSelected, 'instantly');
  if (selectedThing_namespaceObject.current) updateFromSelected(selectedThing_namespaceObject.current);
});

const commentNavigator_sortTypes = {
  custom: {
    title: 'Navigate custom category',
    conditions: {
      type: 'false'
    }
  },
  comment: {
    title: 'Navigate comments',
    conditions: {
      type: 'true'
    }
  },
  submitter: {
    title: 'Navigate comments made by the post submitter',
    conditions: {
      type: 'userAttr',
      attr: 'submitter'
    }
  },
  moderator: {
    title: 'Navigate comments made by moderators',
    conditions: {
      type: 'userAttr',
      attr: 'moderator'
    }
  },
  friend: {
    title: 'Navigate comments made by users on your friends list',
    conditions: {
      type: 'userAttr',
      attr: 'friend'
    }
  },
  me: {
    title: 'Navigate comments made by you',
    conditions: {
      type: 'userAttr',
      attr: 'me'
    }
  },
  admin: {
    title: 'Navigate comments made by reddit admins',
    conditions: {
      type: 'userAttr',
      attr: 'admin'
    }
  },
  highlighted: {
    title: 'Navigate comments made by highlighted user',

    getElements() {
      const highlightedUserSelector = Object.keys(highlightedUsers).map(key => `.author.id-t2_${key}`).join(', ');
      return highlightedUserSelector ? document.querySelectorAll(highlightedUserSelector) : [];
    }

  },
  tagged: {
    title: 'Navigate comments made by tagged users',
    getElements: () => document.querySelectorAll('.tagline .userTagLink.hasTag')
  },
  gilded: {
    title: 'Navigate through gilded comments',
    getElements: () => document.querySelectorAll('.gilded-icon')
  },
  IAmA: {
    title: 'Navigate through questions that have been answered by the submitter (most useful in /r/IAmA)',
    getThings: async () => filterMap((await getPosts('submitter')), thing => thing.parent ? [thing.parent] : undefined)
  },
  images: {
    title: 'Navigate through comments with images',
    conditions: {
      type: 'hasExpando',
      types: ['image']
    }
  },
  videos: {
    title: 'Navigate through comments with videos',
    conditions: {
      type: 'hasExpando',
      types: ['video']
    }
  },
  popular: {
    title: 'Navigate through comments in order of highest vote total',

    async getThings() {
      return flow_default()(filterMap(thing => {
        const score = thing.getScore();

        if (typeof score === 'number') {
          return [[score, thing]];
        }
      }), arr => arr.sort((a, b) => b[0] - a[0]), map_default()(([, thing]) => thing))((await getPosts('comment')));
    },

    get conditions() {
      return JSON.parse(commentNavigator_module.options.popularConditions.value);
    },

    nonlinear: true
  },
  new: {
    title: 'Navigate through new comments (Reddit Gold users only)',
    getElements: () => document.querySelectorAll('.new-comment'),
    disabled: () => !document.body.querySelector('.gold-accent.comment-visits-box')
  },
  upvoted: {
    title: 'Navigate through comments you upvoted',
    conditions: {
      type: 'voteType',
      kind: 'upvote'
    }
  }
};
function updateCustomConditions(conditions) {
  commentNavigator_sortTypes.custom.conditions = conditions;
}

function getCategories() {
  return Promise.all(Object.entries(commentNavigator_sortTypes).filter(([, {
    disabled
  }]) => !disabled || !disabled()).map(async ([category, {
    title
  }]) => ({
    category,
    selected: category === currentCategory,
    size: (await getVisiblePosts(category)).length,
    title
  }))).then(v => v.filter(({
    size,
    selected
  }) => selected || size));
}

const _memoized = memoize_default()(async category => {
  const {
    getElements,
    getThings,
    conditions
  } = commentNavigator_sortTypes[category];
  let things;

  if (getThings) {
    things = uniq_default()((await getThings()));
  } else if (getElements) {
    things = uniq_default()(Array.from(getElements()).map(e => Thing_Thing.from(e)).filter(Boolean));
  } else {
    things = Thing_Thing.things().filter(thing => thing.isComment());
  }

  return filterThings(things, conditions);
});

const getPosts = (category = currentCategory) => _memoized(category);

const getVisiblePosts = category => getPosts(category).then(v => v.filter(thing => thing.isContentVisible()));

let lastNavigatedTo = null;
let currentCategory = isCurrentSubreddit('IAmA', 'casualiama') ? 'IAmA' : 'popular';
let isOpen = false;

const commentNav = lodash_once_default()(() => {
  const box = string_namespaceObject.html`
		<div id="REScommentNavBox">
			<select id="commentNavBy">
				<option selected value="${currentCategory}">${currentCategory}</option>
			</select>
			<details id="commentNavByConditions" hidden>
				<summary>Conditions</summary>
		<div class="builderItem"></div>
			</details>
			<hr style="margin-bottom: 0">
			<div id="commentNavButtons">
				<button id="commentNavUp">&#x25B2;</button>
				<div id="commentNavPostCount"></div>
				<button id="commentNavDown">&#x25BC;</button>
			</div>
		</div>
	`;
  const select = downcast(box.querySelector('#commentNavBy'), HTMLSelectElement);
  select.addEventListener('focus', async () => {
    empty(select);
    const categories = await getCategories();
    select.append(...categories.map(({
      category,
      selected,
      size
    }) => string_namespaceObject.html`
				<option ${selected && 'selected'} value="${category}">${category}<span> (${size})</span></option>
			`));
  }, true);
  select.addEventListener('keyup', ({
    which
  }) => {
    if (which === 27) select.blur();
  });
  select.addEventListener('change', () => {
    const selectedItem = select.options.item(select.selectedIndex);

    if (selectedItem !== null) {
      setCategory(selectedItem.value);
    }

    updateBuilder();
  });
  const postCount = box.querySelector('#commentNavPostCount');
  postCount.addEventListener('click', () => moveTo(lastNavigatedTo));
  const up = downcast(box.querySelector('#commentNavUp'), HTMLButtonElement);
  up.addEventListener('click', () => commentNavigator_move('up'));
  const down = downcast(box.querySelector('#commentNavDown'), HTMLButtonElement);
  down.addEventListener('click', () => commentNavigator_move('down'));
  addFloater(box, {
    separate: true
  });
  const ele = box.querySelector('#commentNavByConditions');
  ele.addEventListener('click', lodash_once_default()(() => {
    const builderCases = getByContext('comment');
    const group = resolveGroup(getGroup('any', [commentNavigator_sortTypes[currentCategory].conditions]), true, true);
    const $builderBlock = caseBuilder_namespaceObject.drawBuilderBlock(group, builderCases, false);
    $builderBlock.on('change input', frameThrottle(() => {
      commentNavigator_module.options.popularConditions.value = JSON.stringify(caseBuilder_namespaceObject.readBuilderBlock($builderBlock, builderCases));
      options_save(commentNavigator_module.options.popularConditions);
      setCategory(currentCategory, true);
    }));
    const wrapper = ele.querySelector('.builderItem');
    wrapper.append($builderBlock.get(0));
  }));

  const updateBuilder = () => {
    ele.hidden = currentCategory !== 'popular';
  };

  commentNavigator_initialize();
  updateBuilder();
  isOpen = true;
  return {
    select,
    refresh: function (index, length, lastNavigatedToIndex) {
      up.disabled = lastNavigatedToIndex <= 0;
      down.disabled = lastNavigatedToIndex >= length - 1;
      postCount.textContent = length ? `${lastNavigatedToIndex === index ? '' : '~'}${lastNavigatedToIndex + 1}/${length}` : 'none';
    },
    open: function () {
      isOpen = true;
      box.hidden = false;
    },
    close: function () {
      isOpen = false;
      box.hidden = true;
    }
  };
});

function installEntryElement() {
  const location = document.body.querySelector('.commentarea .panestack-title');
  if (!location) return;
  const commentNavToggle = string_namespaceObject.html`<div class="res-commentNavToggle">navigate by</div>`;
  const choices = string_namespaceObject.html`<div class="res-commentNavToggle-choices"><div>`;
  commentNavToggle.append(choices);
  location.append(commentNavToggle);
  commentNavToggle.addEventListener('mouseenter', async () => {
    empty(choices);
    const categories = await getCategories();
    choices.append(...categories.map(({
      category,
      title,
      size
    }) => {
      const element = string_namespaceObject.html`
				<div class="res-commentNavToggle-type" title="${title}" category="${category}">${category} (${size})</div>
			`;
      element.addEventListener('click', () => {
        setCategory(category);
      });
      return element;
    }));
  });
}

async function updateFromSelected(selected) {
  const posts = await getVisiblePosts();

  if (posts.includes(selected) && (!commentNavigator_sortTypes[currentCategory].nonlinear || Math.abs(posts.indexOf(lastNavigatedTo) - posts.indexOf(selected)) <= 1)) {
    lastNavigatedTo = selected;
  }

  commentNav().refresh(posts.indexOf(selected), posts.length, posts.indexOf(lastNavigatedTo));
}
function setCategory(category, keepSelected = false) {
  currentCategory = category;
  lastNavigatedTo = null;
  commentNav().select.value = category;

  _memoized.cache.delete(currentCategory);

  if (keepSelected) {
    commentNavigator_move('refresh');
  } else {
    commentNavigator_move('top');
  }
}
function commentNavigator_toggle(focus = false, open = !isOpen) {
  if (!open) {
    commentNav().close();
  } else {
    commentNav().open();
    if (focus) commentNav().select.focus();
  }
}
async function commentNavigator_move(change) {
  commentNavigator_initialize();

  if (!commentNavigator_sortTypes[currentCategory].nonlinear) {
    const all = Thing_Thing.things();
    const lastNavigatedToIndex = all.indexOf(lastNavigatedTo);
    const selectedIndex = all.indexOf(selectedThing_namespaceObject.current);

    if (change === 'down' && selectedIndex < lastNavigatedToIndex || change === 'up' && selectedIndex > lastNavigatedToIndex) {
      moveTo(lastNavigatedTo);
      return;
    }
  }

  const visible = await getVisiblePosts();

  if (change === 'top') {
    moveTo(visible[0]);
  } else {
    const all = [...(await getPosts())];
    if (change === 'up') all.reverse();
    const comment = all.slice(all.indexOf(lastNavigatedTo) + (change === 'refresh' ? 0 : 1)).find(v => visible.includes(v));
    moveTo(comment);
  }
}

function moveTo(thing) {
  if (!thing) return;
  lastNavigatedTo = thing;
  selectedThing_namespaceObject.set(thing, {
    scrollStyle: 'top'
  }, true);
}
// CONCATENATED MODULE: ./lib/modules/easterEgg.js



const easterEgg_module = new Module('easterEgg');
easterEgg_module.moduleName = 'easterEggName';
easterEgg_module.category = 'coreCategory';
easterEgg_module.description = 'easterEggDesc';
easterEgg_module.hidden = true;
let konami;

easterEgg_module.contentStart = () => {
  konami = createKonami(() => {
    const $baconBit = jquery_default()('<div>', {
      id: 'baconBit'
    }).appendTo(document.body);
    notifications_showNotification({
      header: 'RES Easter Eggies!',
      message: 'Mmm, bacon!',
      moduleID: easterEgg_module.moduleID,
      notificationID: 'konami'
    });
    setTimeout(() => $baconBit.addClass('makeitrain'), 500);
  });
};

function konamiActive() {
  return !!konami && konami.almostThere;
}

function createKonami(callback) {
  const konami = {
    input: '',
    pattern: '38384040373937396665',
    almostThere: false,
    prepattern: '383840403739373966',
    load: () => {
      document.addEventListener('keydown', event => {
        konami.input += event.keyCode;

        if (konami.input.length > konami.pattern.length) {
          konami.input = konami.input.substr(konami.input.length - konami.pattern.length);
        }

        if (konami.input === konami.pattern) {
          konami.code();
          konami.input = '';
          event.preventDefault();
        } else if (konami.input === konami.prepattern || konami.input.substr(2, konami.input.length) === konami.prepattern) {
          konami.almostThere = true;
          setTimeout(() => {
            konami.almostThere = false;
            konami.input = '';
          }, 2000);
        }
      }, false);
    },
    code: () => {}
  };

  if (typeof callback === 'function') {
    konami.code = callback;
    konami.load();
  }

  return konami;
}
// CONCATENATED MODULE: ./lib/modules/hideChildComments.js




const hideChildComments_module = new Module('hideChildComments');
hideChildComments_module.moduleName = 'hideChildCommentsName';
hideChildComments_module.category = 'commentsCategory';
hideChildComments_module.description = 'hideChildCommentsDesc';
hideChildComments_module.options = {
  automatic: {
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsAutomaticDesc',
    title: 'hideChildCommentsAutomaticTitle'
  },
  nested: {
    type: 'boolean',
    value: true,
    description: 'hideChildCommentsNestedDesc',
    title: 'hideChildCommentsNestedTitle'
  },
  hideNested: {
    dependsOn: options => options.nested.value,
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsHideNestedDesc',
    title: 'hideChildCommentsHideNestedTitle'
  }
};
hideChildComments_module.include = ['comments'];
let initialHide, toggleAllButton;

hideChildComments_module.beforeLoad = () => {
  initialHide = hideChildComments_module.options.automatic.value && !/\/comments\/(?:\w+)\/(?:\w+)\/(\w+)/.test(location.pathname);
  watchForThings(['comment'], addToggleChildrenButton);
  watchForThings(['post'], addToggleAllButton);
};

const addToggleAllButton = lodash_once_default()(thing => {
  const menu = thing.element.querySelector('ul.buttons');
  if (!menu) return;

  function toggle(action) {
    const includeChildren = hideChildComments_module.options.nested.value && hideChildComments_module.options.hideNested.value;
    const selector = includeChildren ? '.thing.comment' : '.nestedlisting > .thing.comment';
    forEachChunked(document.querySelectorAll(`${selector} > .entry .toggleChildren[action=${action}]`), toggle => {
      toggle.click();
    });

    if (action === 'hide') {
      initialHide = true;
      a.setAttribute('action', 'show');
      a.setAttribute('title', 'Show all comments.');
      a.dataset.text = i18n('hideChildCommentsShowAllLinkLabel');
    } else {
      initialHide = false;
      a.setAttribute('action', 'hide');
      a.setAttribute('title', 'Show only replies to original poster.');
      a.dataset.text = i18n('hideChildCommentsHideAllLinkLabel');
    }
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'noCtrlF res-toggleAllChildren');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  toggleAllButton = a;
  toggle(initialHide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
});

function addToggleChildrenButton(comment) {
  if (!hideChildComments_module.options.nested.value && !comment.isTopLevelComment()) return;
  if (!comment.getNumberOfChildren()) return;
  const children = comment.element.querySelector('div.child > .sitetable');
  const menu = comment.element.querySelector('ul.buttons');
  if (!children || !menu) return;

  function toggle(action) {
    if (action === 'hide') {
      children.style.display = 'none';
      a.dataset.text = i18n('hideChildCommentsShowLinkLabel', comment.getNumberOfChildren());
      a.setAttribute('action', 'show');
    } else {
      children.style.display = '';
      a.dataset.text = i18n('hideChildCommentsHideLinkLabel');
      a.setAttribute('action', 'hide');
    }

    comment.element.classList.toggle('res-children-hidden', action === 'hide');
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'toggleChildren noCtrlF');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  const hide = initialHide && (hideChildComments_module.options.hideNested.value || comment.isTopLevelComment());
  toggle(hide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
}

function toggleAll() {
  const button = toggleAllButton;
  if (!button) throw new Error('Toggle all button not found');
  button.click();
}
function hideChildComments_toggle(thing) {
  const button = thing.entry.querySelector('a.toggleChildren');
  if (!button) throw new Error('Toggle button not found');
  button.click();
}
// CONCATENATED MODULE: ./lib/modules/neverEndingReddit.js









const neverEndingReddit_module = new Module('neverEndingReddit');
neverEndingReddit_module.moduleName = 'nerName';
neverEndingReddit_module.category = 'browsingCategory';
neverEndingReddit_module.description = 'nerDesc';
neverEndingReddit_module.options = {
  returnToPrevPage: {
    type: 'boolean',
    value: true,
    description: 'nerReturnToPrevPageDesc',
    title: 'nerReturnToPrevPageTitle'
  },
  autoLoad: {
    type: 'boolean',
    value: true,
    description: 'nerAutoLoadDesc',
    title: 'nerAutoLoadTitle'
  },
  pauseAfterEvery: {
    dependsOn: options => options.autoLoad.value,
    type: 'text',
    value: '0',
    description: 'nerPauseAfterEveryDesc',
    title: 'nerPauseAfterEveryTitle'
  },
  showPauseButton: {
    dependsOn: options => options.autoLoad.value,
    type: 'boolean',
    value: true,
    description: 'nerShowPauseButtonDesc',
    title: 'nerShowPauseButtonTitle'
  },
  reversePauseIcon: {
    dependsOn: options => options.autoLoad.value && options.showPauseButton.value,
    type: 'boolean',
    value: false,
    description: 'nerReversePauseIconDesc',
    title: 'nerReversePauseIconTitle',
    advanced: true
  },
  showServerInfo: {
    type: 'boolean',
    value: false,
    description: 'nerShowServerInfoDesc',
    title: 'nerShowServerInfoTitle',
    advanced: true,
    bodyClass: true
  }
};
neverEndingReddit_module.exclude = ['wiki', 'comments', 'd2x'];

neverEndingReddit_module.shouldRun = () => !isCurrentSubreddit('dashboard');

const dupeSet = new Set();
const pauseReasonStorage = storage_namespaceObject.wrap('RESmodules.neverEndingReddit.pauseReason', undefined);
let neverEndingReddit_pauseReason;

neverEndingReddit_module.beforeLoad = () => {
  watchForThings(['post'], thing => {
    if (document.contains(thing.element) && !thing.element.closest('#siteTable')) return;
    const id = thing.getFullname();
    if (dupeSet.has(id)) thing.element.remove();
    dupeSet.add(id);
  }, {
    immediate: true
  });
};

neverEndingReddit_module.go = async () => {
  pages[0] = {
    url: location.pathname,
    container: neverEndingReddit_container(),
    nextPageUrl: retrieveNextPageUrl(neverEndingReddit_container())
  };
  const loadReturnToPrevPage = initiateReturnToPrevPage();
  if (loadReturnToPrevPage) await loadReturnToPrevPage();

  if (neverEndingReddit_module.options.autoLoad.value) {
    setPause((await pauseReasonStorage.get()));
    selectedThing_namespaceObject.addListener(current => {
      if (neverEndingReddit_pauseReason) return;
      const things = Thing_Thing.visibleThingElements();
      const distanceFromBottom = things.length - (things.indexOf(current.element) + 1);
      if (distanceFromBottom === 1) prefetchNextPage();else if (distanceFromBottom < 1) loadNextPage();
    });
  }

  prepareNextPageLoad(false);
};

const neverEndingReddit_container = lodash_once_default()(() => getLastSiteTable() || document.createElement('div'));

const pages = [];

function retrieveNextPageUrl(container) {
  const {
    buttons,
    next
  } = getNextPrevLinks(container);
  if (buttons) buttons.hidden = true;
  return next;
}

const getNextPageUrl = (page = pages.slice(-1)[0]) => page.nextPageUrl;

let loadNextPage = () => {};
let refreshAutoLoad;

function prepareNextPageLoad(displayEndBanner = true) {
  const nextPageUrl = getNextPageUrl();

  if (!nextPageUrl) {
    if (displayEndBanner) endNER('No more pages');
    return;
  }

  const pauseAfterPages = parseInt(neverEndingReddit_module.options.pauseAfterEvery.value, 10);

  if (neverEndingReddit_module.options.autoLoad.value && pauseAfterPages) {
    if (pages.length % pauseAfterPages === 0) setPause('pauseAfterEvery');else if (neverEndingReddit_pauseReason === 'pauseAfterEvery') setPause(null);
  }

  const startPromise = new Promise(res => {
    loadNextPage = res;
  });
  const donePromise = startPromise.then(() => loadPage(nextPageUrl, pages.length)).then(prepareNextPageLoad).catch(e => {
    endNER(`Could not load the next page: ${e.message}`);
    console.error(e);
  });
  createLoaderWidget(startPromise, donePromise);
  if (refreshAutoLoad) refreshAutoLoad(false);
}

const pauseButton = lodash_once_default()(() => {
  const element = jquery_default()('<span>', {
    id: 'NREPause',
    title: 'Pause / Restart Never Ending Reddit',
    click: () => setPause(neverEndingReddit_pauseReason ? null : 'manual')
  }).get(0);
  addFloater(element, {
    container: 'visibleAfterScroll'
  });
  return element;
});

function setPause(source) {
  if (neverEndingReddit_module.options.showPauseButton.value) {
    pauseButton().classList.toggle('paused', neverEndingReddit_module.options.reversePauseIcon.value === !source);
  }

  neverEndingReddit_pauseReason = source;
  if (neverEndingReddit_pauseReason) pauseReasonStorage.set(source);else pauseReasonStorage.delete();
  if (refreshAutoLoad) refreshAutoLoad();
}

const isNerUrl = () => location.hash.startsWith(RES_NER_PAGE_HASH);

function setReturnToPage(selected) {
  let number = 0;
  const $earlierMarkers = jquery_default()(selected.element).parent().prevAll('.NERPageMarker');
  const marker = $earlierMarkers.get(0);
  if (marker) number = parseInt(marker.dataset.number, 10);
  const {
    ner: saved
  } = history.state || {};
  if (saved && saved.number === number) return;
  if ($earlierMarkers.length > 1) history.scrollRestoration = 'manual';
  const page = pages[number];
  history.replaceState({ ...history.state,
    ner: {
      number,
      url: page.url,
      nextPageUrl: page.nextPageUrl
    }
  }, `${document.title}${number ? `- page ${number + 1}` : ''}`, number ? `${RES_NER_PAGE_HASH}=${number + 1}` : `${location.pathname}${location.search}${isNerUrl() ? '' : location.hash}`);
}

const initiateReturnToPrevPage = lodash_once_default()(() => {
  if (!neverEndingReddit_module.options.returnToPrevPage.value) return;
  const {
    ner: {
      number,
      url
    } = {}
  } = history.state || {};
  let append;

  if (number && url && isNerUrl()) {
    const loadPromise = loadPage(url, number, new Promise(res => {
      append = () => {
        res();
        return loadPromise;
      };
    }));
  }

  return async () => {
    if (append) await append();
    selectedThing_namespaceObject.addListener(setReturnToPage, 'instantly');
  };
});

function getLastSiteTable(body = document.body) {
  const selector = '.sitetable, .search-result-group';
  const elements = Array.from(body.querySelectorAll(selector)).reverse();

  for (const element of elements) {
    if (!element.parentElement || !element.parentElement.closest(selector)) return element;
  }
}

function getNextPrevLinks(ele = document.body) {
  const buttons = ele.matches('.modactionlisting') ? ele.nextElementSibling : ele.querySelector('.nav-buttons');
  return buttons ? {
    buttons,
    next: (buttons.querySelector('a[rel~=next]') || {}).href,
    prev: (buttons.querySelector('a[rel~=prev]') || {}).href
  } : {};
}

function setLoaderWidgetActionText(widget) {
  empty(widget);
  widget.append(...string_namespaceObject.html`<span>
		<h2>
			Never Ending Reddit
			${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
		</h2>
		<p>
			Click here load to just load the next page;
			${neverEndingReddit_pauseReason ? string_namespaceObject.safe(`or click ${pauseButton().outerHTML} in the top right corner;`) : null}
		</p>
		<p>
			<a id="NERStaticLink" href="${getNextPageUrl() || ''}">or open next page</a> (and clear Never-Ending stream)
		</p>
	</span>`.children);
}

function createLoaderWidget(startPromise, donePromise) {
  const widget = document.createElement('div');
  widget.id = 'progressIndicator';
  widget.className = 'neverEndingReddit';
  widget.addEventListener('click', e => {
    if (e.target.tagName === 'A') return;
    loadNextPage();
  });
  startPromise.then(({
    scrollToLoadWidget = false
  } = {}) => {
    empty(widget);
    widget.append(string_namespaceObject.html`<span class="RESLoadingSpinner"></span>`);
    if (scrollToLoadWidget) scrollToElement(widget, null, {
      scrollStyle: 'middle',
      direction: 'down'
    });
  });
  donePromise.finally(() => widget.remove());
  const prefetchIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    prefetchNextPage();
  }, {
    rootMargin: '100%'
  });
  prefetchIo.observe(widget);

  const displayPauseReason = lodash_once_default()(pauseReason => notifications_showNotification({
    moduleID: neverEndingReddit_module.moduleID,
    notificationID: pauseReason,
    message: pauseReason === 'pauseAfterEvery' ? `
				<p>Time for a break!</p>
				<p>Never-Ending Reddit has been paused because you've passed ${neverEndingReddit_module.options.pauseAfterEvery.value} pages.</p>
			` : `<p>Never-Ending Reddit is paused. Click ${pauseButton().outerHTML} button in the top right corner to unpause it.</p>`
  }));

  const pauseReasonIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (isIntersecting && neverEndingReddit_pauseReason) displayPauseReason(neverEndingReddit_pauseReason);
  }, {
    threshold: [1]
  });
  const loadNextPageIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    loadNextPage();
  }, {
    threshold: [1]
  });

  refreshAutoLoad = (updateWidget = true) => {
    const enabled = neverEndingReddit_module.options.autoLoad.value && !neverEndingReddit_pauseReason;
    if (enabled) loadNextPageIo.observe(widget);else loadNextPageIo.disconnect();
    if (updateWidget) setLoaderWidgetActionText(widget);
    pauseReasonIo.observe(widget);
  };

  setLoaderWidgetActionText(widget);
  startPromise.then(() => {
    prefetchIo.disconnect();
    loadNextPageIo.disconnect();
    pauseReasonIo.disconnect();
    refreshAutoLoad = null;
  });
  pages.slice(-1)[0].container.append(widget);
}

const fetchPage = memoize_default()(url => ajax({
  url,
  cacheFor: HOUR
}));

const prefetchNextPage = () => {
  const url = getNextPageUrl();
  if (url) fetchPage(url);
};

async function loadPage(url, number, attachPromise) {
  const html = (await fetchPage(url)).replace(/<style(.|\s)*?>|<link(.|\s)*?>|<script(.|\s)*?\/script>/g, '');
  const document = new DOMParser().parseFromString(html, 'text/html');

  if (context_data.username && context_data.username !== documentLoggedInUser(document.body)) {
    throw new Error('Page loaded was not for current user');
  }

  const newSiteTable = getLastSiteTable(document.body);
  if (!newSiteTable) throw Error('Could not find any siteTable');
  const noresults = newSiteTable.querySelector('#noresults');
  if (noresults) throw new Error(noresults.textContent);

  for (const {
    name
  } of newSiteTable.attributes) newSiteTable.removeAttribute(name);

  pages[number] = {
    url,
    container: newSiteTable,
    nextPageUrl: retrieveNextPageUrl(newSiteTable)
  };
  registerPage(newSiteTable);
  const pageMarker = string_namespaceObject.html`<div class="NERPageMarker" data-number="${number}">
		<a href="${pages[number].url}">Page ${number + 1}</a>
		${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
	</div>`;
  await attachPromise;
  const firstLen = jquery_default()(neverEndingReddit_container()).find('.link:last .rank').text().length;
  const lastLen = jquery_default()(newSiteTable).find('.link:last .rank').text().length;

  if (lastLen > firstLen) {
    addCSS(`body.res > .content .link .rank { width: ${(lastLen * 1.1).toFixed(1)}ex; }`);
  }

  neverEndingReddit_container().append(pageMarker, newSiteTable);
  window.dispatchEvent(new Event('neverEndingLoad', {
    bubbles: true,
    cancelable: true
  }));
}

function endNER(text) {
  jquery_default()('<div>', {
    class: 'NERPageMarker NERPageMarkerLast',
    text
  }).append(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon')).append(`
			<p class="nextprev">
				<a href="${location.href.split('#')[0]}">start over</a>
				<a href="${getNextPageUrl() || ''}">try again</a>
				<a target="_blank" rel="noopener noreferer" href="/r/Enhancement/wiki/faq/never_ending_reddit">learn more</a>
				<a href="/r/random">random subreddit</a>
			</p>
		`).appendTo(neverEndingReddit_container());
}
// CONCATENATED MODULE: ./lib/modules/noParticipation.js






const noParticipation_module = new Module('noParticipation');
const noParticipation_urls = {
  moreinfo: 'https://www.reddit.com/r/NoParticipation/wiki/intro'
};
noParticipation_module.moduleName = 'noPartName';
noParticipation_module.description = 'noPartDesc';
noParticipation_module.category = 'subredditsCategory';
noParticipation_module.options = {
  disableVoteButtons: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableVoteButtonsDesc',
    title: 'noPartDisableVoteButtonsTitle',
    bodyClass: true
  },
  disableCommentTextarea: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableCommentTextareaDesc',
    title: 'noPartDisableCommentTextareaTitle',
    bodyClass: true
  },
  evenIfSubscriber: {
    type: 'boolean',
    value: false,
    description: 'noPartEvenIfSubscriberDesc',
    title: 'noPartEvenIfSubscriberTitle'
  },
  escapeNP: {
    type: 'boolean',
    value: true,
    description: 'noPartEscapeNPDesc',
    title: 'noPartEscapeNPTitle'
  }
};

noParticipation_module.shouldRun = () => isNpHostname(location.hostname);

const boilerplateNotificationText = `
	<p>
		<div class="RES-spoiler">
			<label class="RES-spoiler-title">Hover here for more details</label>
			<div class="RES-spoiler-contents">
				You came to this page by following a <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">NP</a> link, so you may be interfering with normal conversation.
				Please respect reddit's <a href="https://reddit.com/rules" target="_blank" rel="noopener noreferer">rules</a> by not commenting or voting. Violating these rules may get you banned.
				<a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a>
			</div>
		</div>
	</p>
`;
let noParticipationActive;

noParticipation_module.contentStart = () => {
  if (noParticipation_module.options.escapeNP.value) {
    jquery_default()(document.body).on('mousedown', 'a', removeNpFromLink);
  }

  if (isNPIrrelevant()) {
    notifyNpIrrelevant();
  } else if (loggedInUser()) {
    if (isPageType('comments', 'linklist') && !(document.body.classList.contains('front-page') || document.body.classList.contains('profile-page'))) {
      applyNoParticipationMode();
    } else {
      notifyNpIrrelevant();
    }
  }
};

function isNpHostname(hostname) {
  return /^(?:\w+-)?np(?:-\w+)?\./i.test(hostname);
}

function removeNpFromLink(e) {
  const target = e.currentTarget;
  if (!target.getAttribute('href').startsWith('/') && target.matches('.md a')) return;

  if (target.hostname.endsWith('np.reddit.com')) {
    target.hostname = 'www.reddit.com';
  }
}

function isNPIrrelevant() {
  return !isPageType('comments') || isSubscriber() && !noParticipation_module.options.evenIfSubscriber.value;
}

function isVotingBlocked() {
  return noParticipationActive && noParticipation_module.options.disableVoteButtons.value;
}

function isSubscriber() {
  return document.body.classList.contains('subscriber');
}

function nonNpLocation(href = location.href) {
  const nonNpUrl = new URL(href, location.href);
  if (isNpHostname(nonNpUrl.hostname)) nonNpUrl.hostname = 'www.reddit.com';
  return nonNpUrl.href;
}

function notifyNpIrrelevant() {
  const message = isSubscriber() ? `You're browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but you're a subscriber here.` : `You're still browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but it's no longer necessary.`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'ok-participation',
    closeDelay: 3000,
    header: 'Okay to Participate',
    message: `${message} <p><a href="${nonNpLocation()}">Click here to return to normal reddit</a></p>`
  });
}

function notifyNpActive() {
  const message = isSubscriber() ? `
			<span class="res-icon">&#xF15A;</span>
			Please think before you comment or vote, and remember the subreddit's rules.
			Although you subscribe to this subreddit, you can still derail a particular thread.
			<p><a href="${nonNpLocation()}">Click here to return to normal reddit.</a></p>
		` : `
			<strong>
				<span class="res-icon">&#xF15A;</span>
				Do not vote or comment.
			</strong>
		`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'no-participation',
    closeDelay: 10000,
    header: 'No Participation',
    message: `${message}${boilerplateNotificationText}`
  });
}

const votedOnButtons = [];
async function notifyNoVote(voteButton) {
  const canUndoVote = voteButton && !voteButton.matches('.upmod, .downmod');
  if (voteButton) votedOnButtons.push(voteButton);
  const notification = await notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    cooldown: 5000,
    header: 'No Participation',
    message: `
			<strong><span class="res-icon">&#xF15A;</span> Do not vote.</strong>
			${boilerplateNotificationText}
			${canUndoVote ? '<p><button type="button" class="redButton" data-action="revertvote">Undo vote</button></p>' : ''}
		`
  });

  if (notification) {
    jquery_default()(notification.element).find('[data-action=revertvote]').on('click', () => {
      revertVote(votedOnButtons);
      notification.close();
    });
  }
}

const notifyNoComment = lodash_once_default()(() => {
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableCommentTextarea',
    header: 'No Participation',
    message: `<strong><span class="res-icon">&#xF15A;</span> Do not comment.</strong>${boilerplateNotificationText}`
  });
});

function applyNoParticipationMode() {
  noParticipationActive = true;
  notifyNpActive();
  bodyClasses_namespaceObject.add('res-noParticipation');
  watchForVote();
  jquery_default()(document.body).on('keydown', commentTextareaSelector, e => {
    notifyNoComment();

    if (noParticipation_module.options.disableCommentTextarea.value) {
      downcast(e.currentTarget, HTMLTextAreaElement).disabled = true;
    }
  });
}

function watchForVote() {
  jquery_default()(document.body).on('click', '.arrow', e => {
    if (e.currentTarget.classList.contains('up') || e.currentTarget.classList.contains('down')) {
      notifyNoVote(e.currentTarget);
    }
  });
}

function revertVote(voteButtons) {
  voteButtons.forEach((voteButton, index) => {
    setTimeout(() => {
      if (voteButton.classList.contains('upmod') || voteButton.classList.contains('downmod')) {
        click(voteButton);
      }
    }, index * 2000);
  });
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    header: 'No Participation',
    message: `
			${voteButtons.length > 1 ? 'Your votes are being reverted.' : 'Your vote has been reverted.'}
			Please remember not to vote!
			<p><a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a></p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/saveComments.js










const saveComments_module = new Module('saveComments');
saveComments_module.moduleName = 'saveCommentsName';
saveComments_module.description = 'saveCommentsDesc';
saveComments_module.category = 'commentsCategory';
saveComments_module.exclude = ['submit'];
const savedCommentStorage = storage_namespaceObject.wrapBlob('RESmodules.saveComments.savedComments', () => {
  throw new Error('Saved comment not found');
});

saveComments_module.beforeLoad = () => {
  watchForThings(['comment'], thing => {
    const sibling = thing.element.querySelector('ul.buttons .comment-save-button');
    if (!sibling) return;
    sibling.after(saveElement());
  });
};

saveComments_module.contentStart = () => {
  if (isPageType('profile')) {
    createElement_namespaceObject.tabMenuItem({
      text: 'saved - RES',
      onChange: () => {
        location.href = '/r/dashboard/#savedComments';
      }
    });
  }

  addDashboardTab('savedComments', 'Saved Comments', saveComments_module.moduleID, async tabPage => jquery_default()(tabPage).append((await drawSavedComments())));
};

const saveElement = (e => () => preventCloning(e().cloneNode(true)))(lodash_once_default()(() => {
  jquery_default()(document.body).on('click', 'li.saveComments', ({
    currentTarget
  }) => {
    if (currentTarget.classList.contains('saved-RES')) return;
    const thing = Thing_Thing.checkedFrom(currentTarget);
    saveComment(thing);
    const a = currentTarget.firstElementChild;
    requestAnimationFrame(() => {
      a.dataset.text = 'saved-RES';
      a.href = '/r/dashboard#savedComments';
    });
  });
  return string_namespaceObject.html`
		<li class="saveComments">
			<a class="RES-save noCtrlF" href="javascript:void 0" title="Save using RES - which is local only, but preserves the full text in case someone edits/deletes it" data-text="save-RES"></a>
		</li>
	`;
}));

function getCommentContent(thing) {
  const content = jquery_default()(thing.entry.querySelector('div.usertext-body > div.md')).clone();
  content.find('.keyNavAnnotation, .expando-button, .res-expando-box, script, .userTagLink').remove();
  return content.html();
}

async function saveComment(thing) {
  const permaLink = thing.getCommentPermalink();
  if (!permaLink) throw new Error('Comment lacks permalink');
  const id = thing.getFullname().split('_').slice(-1)[0];
  if ((await savedCommentStorage.getAll()).hasOwnProperty(id)) return;
  savedCommentStorage.set(id, {
    href: permaLink.href,
    username: thing.getAuthor() || '[deleted]',
    comment: getCommentContent(thing),
    timeSaved: new Date().toString()
  });
}

const savedCommentsTemplate = ({
  comments,
  keyNavTip,
  moduleDescription
}) => string_namespaceObject.html`
	<div id="res-saveComments" class="sitetable linklisting">
		${!comments.length && string_namespaceObject._html`
			<div class="res-module-description md">
				<h1>Saving comments with RES</h1>
				${string_namespaceObject.safe(snudown_es_markdown(moduleDescription))}
			</div>
		`}
		${keyNavTip && keyNavTip.map(({
  keyNavHash,
  savePostKey,
  saveCommentKey,
  saveRESKey
}) => string_namespaceObject._html`
			<div class="res-module-tip infobar">
				<p><i>Keyboard Shortcuts</i> <a class="gearIcon" href="${keyNavHash}" title="RES settings"></a></p>
				<ul>
					<li><b>${savePostKey}</b>: save a submission.</li>
					<li><b>${saveCommentKey}</b>: save a comment (to your reddit account).</li>
					<li><b>${saveRESKey}</b>: save a comment with RES.</li>
				</ul>
			</div>
		`)}
		<div class="res-saveComments-list">
			${comments.map(({
  id,
  link,
  username,
  dateTime,
  date,
  timeAgo,
  body
}) => string_namespaceObject._html`
				<div class="entry res-savedComment">
					<div class="savedCommentHeader">
						<a href="${link}">
							<b>${username}</b>
							- saved <date title="${dateTime}" datetime="${date}">${timeAgo}</date> ago
						</a>
					</div>
					<div class="savedCommentBody md">${string_namespaceObject.safe(body)}</div>
					<div class="savedCommentFooter">
						<ul class="flat-list buttons">
							<li><a href="${link}">permalink</a></li>
							<li><a class="unsaveComment" href="#" data-unsaveID="${id}">unsave-RES</a></li>
						</ul>
					</div>
				</div>
			`)}
		</div>
	</div>
`;

const drawSavedComments = lodash_once_default()(async () => {
  const savedComments = await savedCommentStorage.getAll();
  const comments = Object.entries(savedComments).map(([id, {
    comment,
    href,
    username,
    timeSaved
  }]) => {
    const date = new Date(timeSaved);
    return {
      id,
      link: href,
      username,
      date: formatDate(date),
      dateTime: formatDateTime(date),
      timeAgo: formatDateDiff(date),
      body: comment.replace(/<(script|iframe|video)(.|\s)*?\/(script|iframe|video)>/g, '')
    };
  });
  return jquery_default()(savedCommentsTemplate({
    moduleDescription: i18n(saveComments_module.description),
    keyNavTip: modules_isEnabled(keyboardNav_namespaceObject) && [{
      keyNavHash: makeUrlHash(keyboardNav_module.moduleID, 'savePost'),
      savePostKey: keycode_niceKeyCode(keyboardNav_module.options.savePost.value),
      saveCommentKey: keycode_niceKeyCode(keyboardNav_module.options.saveComment.value),
      saveRESKey: keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)
    }],
    comments
  })).on('click', '.unsaveComment', e => {
    e.preventDefault();
    savedCommentStorage.delete(e.currentTarget.dataset.unsaveid);
    e.currentTarget.textContent = 'removed';
  });
});

function showEducationalNotification() {
  notifications_showNotification({
    moduleID: saveComments_module.moduleID,
    optionKey: 'savePost',
    notificationID: 'saveRES-educational',
    closeDelay: 10000,
    cooldown: 3 * WEEK,
    header: 'Saving Posts and Comments',
    message: `
			<p>
				The keyboard shortcuts <b>"${keycode_niceKeyCode(keyboardNav_module.options.savePost.value)}"</b> (posts) and <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveComment.value)}"</b> (comments) will save a post/comment to your reddit account (same as the "save" button).
				It will be accessible from anywhere that you're logged in, but the original text will not be preserved if it is edited or deleted.
			</p>
			<p>
				The keyboard shortcut <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)}"</b> will save a comment to RES (same as the "save-RES" button).
				It will only be available locally, but the original text will be preserved if the comment is edited or deleted.
			</p>
			<p>These shortcuts can be changed in the ${makeUrlHashLink(keyboardNav_module.moduleID, 'savePost', 'settings console')}.<p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/showParent.js




const showParent_module = new Module('showParent');
showParent_module.moduleName = 'showParentName';
showParent_module.category = 'myAccountCategory';
showParent_module.description = 'showParentDesc';
showParent_module.options = {
  hoverDelay: {
    title: 'showParentHoverDelayTitle',
    type: 'text',
    value: '500',
    description: 'showParentHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'showParentFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'showParentFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'showParentFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'showParentFadeSpeedDesc',
    advanced: true
  },
  direction: {
    title: 'showParentDirectionTitle',
    type: 'enum',
    value: 'down',
    values: [{
      name: 'Above',
      value: 'up'
    }, {
      name: 'Below',
      value: 'down'
    }],
    description: 'showParentDirectionDesc',
    bodyClass: true
  }
};
showParent_module.include = ['comments'];
let showParent_hover;

showParent_module.contentStart = () => {
  showParent_hover = infocard(showParent_module.moduleID).options({
    openDelay: parseFloat(showParent_module.options.hoverDelay.value),
    fadeDelay: parseFloat(showParent_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(showParent_module.options.fadeSpeed.value)
  }).populateWith(card => showCommentHover(Thing_Thing.checkedFrom(card.getCheckedTarget()))).watch('.comment .buttons :not(:first-child) .bylink');
};

function startHover(button) {
  if (showParent_hover) showParent_hover.target(button).begin();
}

function showParent_handleVoteClick() {
  const $this = jquery_default()(this);
  const voteClasses = {
    up: 'likes',
    none: 'unvoted',
    down: 'dislikes'
  };
  const id = $this.parent().parent().attr('data-fullname');
  let direction = /(up|down)(?:mod)?/.exec(this.className);
  if (!direction) return;
  direction = direction[1];
  const $targetButton = jquery_default()(`.content .thing.id-${id}`).children('.midcol').find(`.arrow.${direction}, .arrow.${direction}mod`);

  if ($targetButton.length !== 1) {
    console.error('When attempting to find %s arrow for comment %s %d elements were returned', direction, id, $targetButton.length);
    return;
  }

  function removeClickHandlers(event) {
    event.stopPropagation();
  }

  $targetButton.on('click', removeClickHandlers);
  $targetButton.click();
  $targetButton.off('click', removeClickHandlers);
  const $midcol = $this.parent();
  let startDir = 'none';

  for (const [key, value] of Object.entries(voteClasses)) {
    if ($midcol.hasClass(value)) {
      startDir = key;
      break;
    }
  }

  const newDir = direction === startDir ? 'none' : direction;
  $midcol.parent().children(`.${voteClasses[startDir]}`).removeClass(voteClasses[startDir]).addClass(voteClasses[newDir]);
  $midcol.find('.up, .upmod').toggleClass('upmod', newDir === 'up').toggleClass('up', newDir !== 'up');
  $midcol.find('.down, .downmod').toggleClass('downmod', newDir === 'down').toggleClass('down', newDir !== 'down');
}

function showCommentHover(thing) {
  const direction = showParent_module.options.direction.value;
  let $parents = jquery_default()(thing.element).parents('.thing').clone();
  let topParentURL = '';

  if ($parents.length === 0) {
    topParentURL = jquery_default()(thing.element).find('[data-event-action="parent"]').first().attr('data-href-url');
  } else {
    const topParentId = $parents.last().attr('data-fullname');
    topParentURL = jquery_default()(`[data-fullname="${topParentId}"] > .entry [data-event-action="parent"]`).first().attr('data-href-url');
  }

  if (direction === 'up') {
    $parents = jquery_default()($parents.get().reverse());
  }

  $parents.addClass('comment parentComment').removeClass('thing even odd');
  $parents.children('.child').remove();
  $parents.each(function () {
    const $this = jquery_default()(this);
    $this.off('click');
    let id = $this.attr('data-fullname');

    if (id) {
      id = id.slice(3);
      $this.find('> .entry .tagline').append(`<a class="bylink parentlink" href="#${id}">goto comment</a>`);
    }
  });
  $parents.find('.parent').remove();
  $parents.find('.usertext-body').show();
  $parents.find('.flat-list.buttons').remove();
  $parents.find('.usertext-edit').remove();
  $parents.find('.RESUserTag').remove();
  $parents.find('.voteWeight').remove();
  $parents.find('.collapsed').remove();
  $parents.find('.expand').remove();
  $parents.find('form').attr('id', '');
  $parents.find('.arrow').on('click', showParent_handleVoteClick);
  $parents.find('.res-expando-box, .expando-button').remove();
  $parents.find('.keyNavAnnotation').remove();
  const $container = jquery_default()('<div class="parentCommentWrapper">');
  $container.append($parents);

  if (topParentURL) {
    $container.append(`<a class="bylink" href="${topParentURL}">View parent comment</a>`);
  }

  $parents.slice(0, -1).after('<div class="parentArrow">reply to</div>');
  return ['Parents', $container];
}
// CONCATENATED MODULE: ./lib/modules/singleClick.js



const singleClick_module = new Module('singleClick');
singleClick_module.moduleName = 'singleClickName';
singleClick_module.category = 'browsingCategory';
singleClick_module.description = 'singleClickDesc';
singleClick_module.options = {
  openOrder: {
    title: 'singleClickOpenOrderTitle',
    type: 'enum',
    values: [{
      name: 'open comments then link',
      value: 'commentsfirst'
    }, {
      name: 'open link then comments',
      value: 'linkfirst'
    }],
    value: 'commentsfirst',
    description: 'singleClickOpenOrderDesc'
  },
  hideLEC: {
    title: 'singleClickHideLECTitle',
    type: 'boolean',
    value: true,
    description: 'singleClickHideLECDesc',
    advanced: true
  },
  openFrontpage: {
    title: 'singleClickOpenFrontpageTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenFrontpageDesc',
    dependsOn: options => !options.hideLEC.value
  },
  openBackground: {
    title: 'singleClickOpenBackgroundTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenBackgroundDesc'
  }
};
singleClick_module.exclude = ['comments'];
const invokeOnPostMap = new WeakMap();

singleClick_module.beforeLoad = () => {
  watchForThings(['post'], thing => {
    const urls = new Set([thing.getPostUrl()]);

    if (thing.isLinkPost()) {
      urls.add(thing.getCommentsLink().href);
    } else if (singleClick_module.options.openFrontpage.value) {
      const frontpageLink = thing.getSubredditLink();
      if (frontpageLink) urls.add(frontpageLink.href);
    }

    const ordered = (singleClick_module.options.openOrder.value === 'commentsfirst' ? [...urls].reverse() : [...urls]).filter(Boolean);

    const open = focused => {
      openNewTabs(focused, ...ordered);
    };

    invokeOnPostMap.set(thing, open);
    if (!ordered.length || singleClick_module.options.hideLEC.value && ordered.length === 1) return;
    const text = ordered.length === 1 ? '[l=c]' : '[l+c]';
    const ele = string_namespaceObject.html`<li><a href="javascript:void(0)" class="noCtrlF" data-text="${text}"></a></li>`;
    ele.firstElementChild.addEventListener('auxclick', e => {
      e.preventDefault();
    });
    ele.firstElementChild.addEventListener('mouseup', e => {
      if (e.button !== 0 && e.button !== 1) return;
      const focused = !e.button && !e.ctrlKey && !singleClick_module.options.openBackground.value;
      open(focused);
    });
    thing.getButtons().append(ele);
  });
};
// CONCATENATED MODULE: ./lib/modules/keyboardNav.js
























const keyboardNav_module = new Module('keyboardNav');
keyboardNav_module.moduleName = 'keyboardNavName';
keyboardNav_module.category = 'browsingCategory';
keyboardNav_module.description = 'keyboardNavDesc';
keyboardNav_module.options = {
  linearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'directional',
    description: 'keyboardNavLinearScrollStyleDesc',
    title: 'keyboardNavLinearScrollStyleTitle',
    advanced: true
  },
  nonLinearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'legacy',
    description: 'keyboardNavNonLinearScrollStyleDesc',
    title: 'keyboardNavNonLinearScrollStyleTitle',
    advanced: true
  },
  linkNumbers: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNumbersDesc',
    title: 'keyboardNavLinkNumbersTitle'
  },
  linkNumberPosition: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'Place on right',
      value: 'right'
    }, {
      name: 'Place on left',
      value: 'left'
    }],
    value: 'right',
    description: 'keyboardNavLinkNumberPositionDesc',
    title: 'keyboardNavLinkNumberPositionTitle',
    advanced: true
  },
  linkToggleExpando: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkToggleExpandoDesc',
    title: 'keyboardNavLinkToggleExpandoTitle'
  },
  linkNumberAltModeModifier: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'Shift',
      value: 'shift'
    }, {
      name: 'Alt',
      value: 'alt'
    }],
    value: 'alt',
    description: 'keyboardNavLinkNumberAltModeModifierDesc',
    title: 'keyboardNavLinkNumberAltModeModifierTitle',
    advanced: true
  },
  linkNewTab: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNewTabDesc',
    title: 'keyboardNavLinkNewTabTitle',
    advanced: true
  },
  onHideMoveDown: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavOnHideMoveDownDesc',
    title: 'keyboardNavOnHideMoveDownTitle',
    advanced: true
  },
  onVoteMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteMoveDownDesc',
    title: 'keyboardNavOnVoteMoveDownTitle',
    advanced: true
  },
  onVoteCommentMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteCommentMoveDownDesc',
    title: 'keyboardNavOnVoteCommentMoveDownTitle',
    advanced: true
  },
  followLinkNewTabFocus: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavFollowLinkNewTabFocusDesc',
    title: 'keyboardNavFollowLinkNewTabFocusTitle'
  },
  toggleHelp: {
    type: 'keycode',
    value: [191, false, false, true, false],
    description: 'keyboardNavToggleHelpDesc',
    title: 'keyboardNavToggleHelpTitle',

    callback() {
      toggleKeyNavHelp();
    }

  },
  toggleCmdLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject],
    value: [190, false, false, false, false],
    description: 'keyboardNavToggleCmdLineDesc',
    title: 'keyboardNavToggleCmdLineTitle',

    callback() {
      commandLine_toggle();
    }

  },
  enterFilterCommandLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject, filteReddit_namespaceObject],
    value: [70, false, false, false, false],
    description: 'keyboardNavEnterFilterCommandLineDesc',
    title: 'keyboardNavEnterFilterCommandLineTitle',

    callback() {
      commandLine_open('fl ');
    }

  },
  hide: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile'],
    value: [72, false, false, false, false],
    description: 'keyboardNavHideDesc',
    title: 'keyboardNavHideTitle',
    callback: hideLink
  },
  moveUp: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpDesc',
    title: 'keyboardNavMoveUpTitle',

    callback() {
      selectedThing_namespaceObject.move('up', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDown: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownDesc',
    title: 'keyboardNavMoveDownTitle',

    callback() {
      selectedThing_namespaceObject.move('down', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      }, moveDownFallback);
    }

  },
  moveUpComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpCommentDesc',
    title: 'keyboardNavMoveUpCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('up', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDownComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownCommentDesc',
    title: 'keyboardNavMoveDownCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('down', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveTop: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveTopDesc',
    title: 'keyboardNavMoveTopTitle',

    callback() {
      selectedThing_namespaceObject.move('top', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveBottom: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveBottomDesc',
    title: 'keyboardNavMoveBottomTitle',

    callback() {
      selectedThing_namespaceObject.move('bottom', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveUpSiblingDesc',
    title: 'keyboardNavMoveUpSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('upSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveDownSiblingDesc',
    title: 'keyboardNavMoveDownSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('downSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownParentSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, false, false],
    description: 'keyboardNavMoveDownParentSiblingDesc',
    title: 'keyboardNavMoveDownParentSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('downParentSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpThread: {
    type: 'keycode',
    include: ['comments'],
    value: [75, true, false, true, false],
    description: 'keyboardNavMoveUpThreadDesc',
    title: 'keyboardNavMoveUpThreadTitle',

    callback() {
      selectedThing_namespaceObject.move('upThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownThread: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, true, false],
    description: 'keyboardNavMoveDownThreadDesc',
    title: 'keyboardNavMoveDownThreadTitle',

    callback() {
      selectedThing_namespaceObject.move('downThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToTopComment: {
    type: 'keycode',
    include: ['comments'],
    value: [84, false, false, false, false],
    description: 'keyboardNavMoveToTopCommentDesc',
    title: 'keyboardNavMoveToTopCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('toTopComment', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToParent: {
    type: 'keycode',
    include: ['comments'],
    value: [80, false, false, false, false],
    description: 'keyboardNavMoveToParentDesc',
    title: 'keyboardNavMoveToParentTitle',

    callback() {
      selectedThing_namespaceObject.move('toParent', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  undoMove: {
    type: 'keycode',
    value: [90, false, true, false, false],
    description: 'keyboardNavUndoMoveDesc',
    title: 'keyboardNavUndoMoveTitle',

    callback() {
      selectedThing_namespaceObject.move('previous', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  showParents: {
    type: 'keycode',
    requiresModules: [showParent_namespaceObject],
    value: [80, false, false, true, false],
    description: 'keyboardNavShowParentsDesc',
    title: 'keyboardNavShowParentsTitle',

    callback(selected = getSelected()) {
      startHover(assertElement(selected.element.querySelector('.buttons .bylink[href^="#"]')));
    }

  },
  followLink: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, false, false],
    description: 'keyboardNavFollowLinkDesc',
    title: 'keyboardNavFollowLinkTitle',

    callback() {
      followLink();
    }

  },
  followLinkNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, true, false],
    description: 'keyboardNavFollowLinkNewTabDesc',
    title: 'keyboardNavFollowLinkNewTabTitle',

    callback() {
      followLink(true);
    }

  },
  toggleExpando: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, false, false],
    description: 'keyboardNavToggleExpandoDesc',
    title: 'keyboardNavToggleExpandoTitle',

    callback(selected = getSelected()) {
      toggleThingExpandos(selected, {
        scrollOnToggle: keyboardNav_module.options.scrollOnExpando.value
      });
    }

  },
  scrollOnExpando: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnExpandoDesc',
    title: 'keyboardNavScrollOnExpandoTitle',
    advanced: true
  },
  imageSizeUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, false, false],
    description: 'keyboardNavImageSizeUpDesc',
    title: 'keyboardNavImageSizeUpTitle',

    callback() {
      imageResize({
        factor: 1.3
      });
    }

  },
  imageSizeDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, false, false],
    description: 'keyboardNavImageSizeDownDesc',
    title: 'keyboardNavImageSizeDownTitle',

    callback() {
      imageResize({
        factor: 1 / 1.3
      });
    }

  },
  imageSizeUpFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, true, false],
    description: 'keyboardNavImageSizeUpFineDesc',
    title: 'keyboardNavImageSizeUpFineTitle',

    callback() {
      imageResize({
        factor: 1.1
      });
    }

  },
  imageSizeDownFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, true, false],
    description: 'keyboardNavImageSizeDownFineDesc',
    title: 'keyboardNavImageSizeDownFineTitle',

    callback() {
      imageResize({
        factor: 1 / 1.1
      });
    }

  },
  imageSizeAnyHeight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, false, true, false],
    description: 'keyboardNavImageSizeAnyHeightDesc',
    title: 'keyboardNavImageSizeAnyHeightTitle',

    callback() {
      imageResize({
        removeHeightRestriction: true
      });
    }

  },
  imageMoveUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [38, false, true, false, false],
    description: 'keyboardNavImageMoveUpDesc',
    title: 'keyboardNavImageMoveUpTitle',

    callback() {
      imageMove(0, -50);
    }

  },
  imageMoveDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [40, false, true, false, false],
    description: 'keyboardNavImageMoveDownDesc',
    title: 'keyboardNavImageMoveDownTitle',

    callback() {
      imageMove(0, 50);
    }

  },
  imageMoveLeft: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [37, false, true, false, false],
    description: 'keyboardNavImageMoveLeftDesc',
    title: 'keyboardNavImageMoveLeftTitle',

    callback() {
      imageMove(-50, 0);
    }

  },
  imageMoveRight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, true, false, false],
    description: 'keyboardNavImageMoveRightDesc',
    title: 'keyboardNavImageMoveRightTitle',

    callback() {
      imageMove(50, 0);
    }

  },
  previousGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [219, false, false, false, false],
    description: 'keyboardNavPreviousGalleryImageDesc',
    title: 'keyboardNavPreviousGalleryImageTitle',

    callback() {
      navigateGallery('previous');
    }

  },
  nextGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [221, false, false, false, false],
    description: 'keyboardNavNextGalleryImageDesc',
    title: 'keyboardNavNextGalleryImageTitle',

    callback() {
      navigateGallery('next');
    }

  },
  scrollOnGalleryNavigate: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnGalleryNavigateDesc',
    title: 'keyboardNavScrollOnGalleryNavigateTitle',
    advanced: true
  },
  toggleViewImages: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, true, false],
    description: 'keyboardNavToggleViewImagesDesc',
    title: 'keyboardNavToggleViewImagesTitle',

    callback() {
      viewImagesButton().click();
    }

  },
  toggleChildren: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [13, false, false, false, false],
    description: 'keyboardNavToggleChildrenDesc',
    title: 'keyboardNavToggleChildrenTitle',
    callback: toggleChildren
  },
  followComments: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, false, false],
    description: 'keyboardNavFollowCommentsDesc',
    title: 'keyboardNavFollowCommentsTitle',

    callback() {
      followComments();
    }

  },
  followCommentsNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, true, false],
    description: 'keyboardNavFollowCommentsNewTabDesc',
    title: 'keyboardNavFollowCommentsNewTabTitle',

    callback() {
      followComments(true);
    }

  },
  followLinkAndCommentsNewTab: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, false, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabTitle',

    callback() {
      invokeOnPostMap.get(getSelected())(true);
    }

  },
  followLinkAndCommentsNewTabBG: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, true, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabBGDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabBGTitle',

    callback() {
      invokeOnPostMap.get(getSelected())(false);
    }

  },
  upVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, false, false],
    description: 'keyboardNavUpVoteDesc',
    title: 'keyboardNavUpVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod');
    }

  },
  downVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, false, false],
    description: 'keyboardNavDownVoteDesc',
    title: 'keyboardNavDownVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod');
    }

  },
  upVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, true, false],
    description: 'keyboardNavUpVoteWithoutTogglingDesc',
    title: 'keyboardNavUpVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod', true);
    }

  },
  downVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, true, false],
    description: 'keyboardNavDownVoteWithoutTogglingDesc',
    title: 'keyboardNavDownVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod', true);
    }

  },
  savePost: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments'],
    value: [83, false, false, false, false],
    description: 'keyboardNavSavePostDesc',
    title: 'keyboardNavSavePostTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.link-save-button a, .link-unsave-button a', ASSERT));
    }

  },
  saveComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist'],
    value: [83, false, false, true, false],
    description: 'keyboardNavSaveCommentDesc',
    title: 'keyboardNavSaveCommentTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.comment-save-button > a', ASSERT));
    }

  },
  saveRES: {
    type: 'keycode',
    requiresModules: [saveComments_namespaceObject],
    value: [83, false, false, false, false],
    description: 'keyboardNavSaveRESDesc',
    title: 'keyboardNavSaveRESTitle',

    callback() {
      click(getFirstElementInThingByQuery('.saveComments, .unsaveComments', ASSERT));
      showEducationalNotification();
    }

  },
  reply: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [82, false, false, false, false],
    description: 'keyboardNavReplyDesc',
    title: 'keyboardNavReplyTitle',
    mustBeLoggedIn: true,
    callback: reply
  },
  edit: {
    type: 'keycode',
    include: ['comments', 'profile'],
    value: [69, false, false, false, false],
    description: 'keyboardNavEditDesc',
    title: 'keyboardNavEditTitle',
    mustBeLoggedIn: true,

    callback() {
      click(getFirstElementInThingByQuery('.entry .edit-usertext', ASSERT, getSelected()));
    }

  },
  showChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, false, false],
    description: 'keyboardNavShowChildCommentsDesc',
    title: 'keyboardNavShowChildCommentsTitle',

    callback(selected = getSelected()) {
      hideChildComments_toggle(selected);
    }

  },
  showAllChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, true, false],
    description: 'keyboardNavShowAllChildCommentsDesc',
    title: 'keyboardNavShowAllChildCommentsTitle',

    callback() {
      toggleAll();
    }

  },
  followPermalink: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, false, false],
    description: 'keyboardNavFollowPermalinkDesc',
    title: 'keyboardNavFollowPermalinkTitle',

    callback() {
      followPermalink();
    }

  },
  followPermalinkNewTab: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, true, false],
    description: 'keyboardNavFollowPermalinkNewTabDesc',
    title: 'keyboardNavFollowPermalinkNewTabTitle',

    callback() {
      followPermalink(true);
    }

  },
  followSubreddit: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, false, false],
    description: 'keyboardNavFollowSubredditDesc',
    title: 'keyboardNavFollowSubredditTitle',

    callback() {
      followSubreddit();
    }

  },
  followSubredditNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, true, false],
    description: 'keyboardNavFollowSubredditNewTabDesc',
    title: 'keyboardNavFollowSubredditNewTabTitle',

    callback() {
      followSubreddit(true);
    }

  },
  followProfile: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, false, false],
    description: 'keyboardNavFollowProfileDesc',
    title: 'keyboardNavFollowProfileTitle',

    callback() {
      followProfile();
    }

  },
  followProfileNewTab: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, true, false],
    description: 'keyboardNavFollowProfileNewTabDesc',
    title: 'keyboardNavFollowProfileNewTabTitle',

    callback() {
      followProfile(true);
    }

  },
  toggleCommentNavigator: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [78, false, false, false, false],
    description: 'keyboardNavToggleCommentNavigatorDesc',
    title: 'keyboardNavToggleCommentNavigatorTitle',

    callback() {
      commentNavigator_toggle(true);
    }

  },
  commentNavigatorMoveUp: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [38, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveUpDesc',
    title: 'keyboardNavCommentNavigatorMoveUpTitle',

    callback() {
      commentNavigator_move('up');
    }

  },
  commentNavigatorMoveDown: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [40, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveDownDesc',
    title: 'keyboardNavCommentNavigatorMoveDownTitle',

    callback() {
      commentNavigator_move('down');
    }

  },
  focusOnSearchBox: {
    type: 'keycode',
    value: [191, true, false, false, false],
    description: 'keyboardNavFocusOnSearchBoxDesc',
    title: 'keyboardNavFocusOnSearchBoxTitle',

    callback() {
      document.querySelector('#search input[name="q"]').focus();
    }

  },
  useGoMode: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavUseGoModeDesc',
    title: 'keyboardNavUseGoModeTitle'
  },
  goMode: {
    type: 'keycode',
    value: [71, false, false, false, false],
    description: 'keyboardNavGoModeDesc',
    title: 'keyboardNavGoModeTitle',
    dependsOn: options => options.useGoMode.value,

    callback() {
      if (keyboardNav_module.options.useGoMode.value) toggleGoMode();
    }

  },
  inbox: {
    type: 'keycode',
    value: [73, false, false, false, false],
    description: 'keyboardNavInboxDesc',
    title: 'keyboardNavInboxTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  inboxNewTab: {
    type: 'keycode',
    value: [73, false, false, true, false],
    description: 'keyboardNavInboxNewTabDesc',
    title: 'keyboardNavInboxNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  modmail: {
    type: 'keycode',
    value: [77, false, false, false, false],
    description: 'keyboardNavModmailDesc',
    title: 'keyboardNavModmailTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  modmailNewTab: {
    type: 'keycode',
    value: [77, false, false, true, false],
    description: 'keyboardNavModmailNewTabDesc',
    title: 'keyboardNavModmailNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  profile: {
    type: 'keycode',
    value: [85, false, false, false, false],
    description: 'keyboardNavProfileDesc',
    title: 'keyboardNavProfileTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileNewTab: {
    type: 'keycode',
    value: [85, false, false, true, false],
    description: 'keyboardNavProfileNewTabDesc',
    title: 'keyboardNavProfileNewTabTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  frontPage: {
    type: 'keycode',
    value: [70, false, false, false, false],
    description: 'keyboardNavFrontPageDesc',
    title: 'keyboardNavFrontPageTitle',

    callback() {
      keyboardNav_navigateTo('/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  slashAll: {
    type: 'keycode',
    value: [65, true, false, false, false],
    description: 'keyboardNavSlashAllDesc',
    title: 'keyboardNavSlashAllTitle',

    callback() {
      keyboardNav_navigateTo('/r/all', {
        leaveNP: true
      });
    },

    goMode: true
  },
  subredditFrontPage: {
    type: 'keycode',
    value: [70, false, false, true, false],
    description: 'keyboardNavsSubredditFrontPageDesc',
    title: 'keyboardNavsSubredditFrontPageTitle',

    callback() {
      const sub = currentSubreddit();
      if (sub) keyboardNav_navigateTo(`/r/${sub}`, {
        leaveNP: false
      });
    },

    goMode: true
  },
  random: {
    type: 'keycode',
    value: [89, true, false, false, false],
    description: 'keyboardNavRandomDesc',
    title: 'keyboardNavRandomTitle',

    callback() {
      keyboardNav_navigateTo('/r/random', {
        leaveNP: true
      });
    },

    goMode: true
  },
  nextPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [78, false, false, false, false],
    description: 'keyboardNavNextPageDesc',
    title: 'keyboardNavNextPageTitle',

    callback() {
      if (isRunning(neverEndingReddit_namespaceObject)) {
        loadNextPage({
          scrollToLoadWidget: true
        });
      } else {
        const next = getNextPrevLinks().next;
        if (next) location.href = next;
      }
    },

    goMode: true
  },
  prevPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [80, false, false, false, false],
    description: 'keyboardNavPrevPageDesc',
    title: 'keyboardNavPrevPageTitle',

    callback() {
      if (!isRunning(neverEndingReddit_namespaceObject)) {
        const prev = getNextPrevLinks().prev;
        if (prev) location.href = prev;
      }
    },

    goMode: true
  },
  overviewLegacy: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [79, false, false, true, false],
    description: 'keyboardNavOverviewLegacyDesc',
    title: 'keyboardNavOverviewLegacyTitle',

    callback() {
      const currentUser = currentUserProfile();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}/overview`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileView: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [80, false, false, true, false],
    description: 'keyboardNavProfileViewDesc',
    title: 'keyboardNavProfileViewTitle',

    callback() {
      const currentUser = currentUserProfile();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}`, {
        leaveNP: true
      });
    },

    goMode: true
  }
};

keyboardNav_module.beforeLoad = () => {
  keyboardNav_registerCommandLine();

  if (keyboardNav_module.options.linkNumbers.value) {
    selectedThing_namespaceObject.addListener(updateLinkAnnotations, 'instantly');
    watchForElements(['selfText'], null, element => {
      const thing = Thing_Thing.from(element);
      if (selectedThing_namespaceObject.current === thing) updateLinkAnnotations(thing);
    });
  }
};

keyboardNav_module.contentStart = () => {
  window.addEventListener('keydown', handleKeyPress, true);
};

function keyboardNav_registerCommandLine() {
  registerCommand(/\d+/, '[number] - navigates to the link with that number (if annotation exists) or rank (link pages)', () => {}, command => {
    const number = parseInt(command, 10);
    const annotation = linkAnnotations[number - 1];

    if (annotation) {
      if (!document.contains(annotation.link)) {
        console.log('Annotation refers to removed link; ignoring');
        return;
      }

      openLink(number - 1);
    } else {
      followLinkByRank(number);
    }
  });
}

let linkAnnotations = [];

function updateLinkAnnotations(selected) {
  for (const {
    annotation
  } of linkAnnotations) annotation.remove();

  linkAnnotations = Array.from(selected && selected.entry.querySelectorAll('div.md a:not(.noKeyNav)') || []).filter(link => !isCommentCode(link) && !isEmptyLink(link)).map((link, i) => {
    const number = i + 1;
    const title = number < 10 ? `press ${number} to open link` : number === 10 ? 'press 0 to open link' : `press ${keycode_niceKeyCode(keyboardNav_module.options.toggleCmdLine.value)} then ${number} and Enter to open link`;
    const annotation = string_namespaceObject.html`<span class="noCtrlF keyNavAnnotation" data-text="[${number}]" title="${title}"></span>`;
    if (keyboardNav_module.options.linkNumberPosition.value === 'right') link.after(annotation);else link.before(annotation);
    return {
      annotation,
      link
    };
  });
}

function toggleKeyNavHelp() {
  const slideSpeed = 400;

  if (!drawHelp().attr('shown')) {
    drawHelp().attr('shown', 'false');
    drawHelp().css({
      right: '-350px'
    });
    drawHelp().show();
  }

  if (drawHelp().attr('shown') === 'true') {
    drawHelp().animate({
      right: '-350px'
    }, slideSpeed);
    drawHelp().attr('shown', 'false');
  } else {
    drawHelp().animate({
      right: '20px'
    }, slideSpeed);
    drawHelp().attr('shown', 'true');
  }
}

const drawHelp = lodash_once_default()(() => {
  const keys = filterMap(getActiveCommandOptions(), opt => {
    let keyCode = keycode_niceKeyCode(opt.value);

    if (opt.goMode && keyboardNav_module.options.useGoMode.value) {
      keyCode = `${keycode_niceKeyCode(keyboardNav_module.options.goMode.value)}  ${keyCode}`;
    }

    return [{
      keyCode,
      description: i18n(opt.description)
    }];
  });
  return jquery_default()(string_namespaceObject.html`
		<div id="keyHelp">
			<table>
				<thead>
					<tr><th>Key</th><th>Function</th></tr>
				</thead>
				<tbody>
					${keys.map(({
    keyCode,
    description
  }) => string_namespaceObject._html`
						<tr><td>${keyCode}</td><td>${description}</td></tr>
					`)}
				</tbody>
			</table>
		</div>
	`).appendTo(document.body);
});

function getLinkKeys() {
  const altModeModifier = keyboardNav_module.options.linkNumberAltModeModifier.value;
  const keys = [];

  function addKey(key, index) {
    keys.push({
      value: [key, false, false, false, false],

      callback() {
        openLink(index);
      }

    });

    if (altModeModifier !== 'none') {
      keys.push({
        value: [key, altModeModifier === 'alt', false, altModeModifier === 'shift', false],

        callback() {
          openLink(index, true);
        }

      });
    }
  }

  if (keyboardNav_module.options.linkNumbers.value) {
    [49, 50, 51, 52, 53, 54, 55, 56, 57, 48].forEach(addKey);
    [97, 98, 99, 100, 101, 102, 103, 104, 105, 96].forEach(addKey);
  }

  return keys;
}

const getActiveCommandOptions = lodash_once_default()(() => filterMap(Object.values(keyboardNav_module.options), option => {
  if (option.type === 'keycode' && option.callback && (!option.dependsOn || option.dependsOn(keyboardNav_module.options)) && (!option.include || matchesPageLocation(option.include)) && (!option.mustBeLoggedIn || loggedInUser()) && (!option.requiresModules || option.requiresModules.every(isRunning))) {
    return [option];
  }
}));

const _commandLookup = lodash_once_default()(() => {
  const lookup = {};

  for (const option of [...getActiveCommandOptions(), ...getLinkKeys()]) {
    const hash = hashKeyArray(option.value);

    if (!lookup[hash]) {
      lookup[hash] = [];
    }

    lookup[hash].push(option);
  }

  return lookup;
});

function handleKeyPress(e) {
  if (konamiActive()) return;

  if (document.activeElement && ['A', 'BUTTON'].includes(document.activeElement.tagName)) {
    const hasDefaultBehavior = [NAMED_KEYS.Tab, NAMED_KEYS.Enter, NAMED_KEYS.Space].includes(e.key);
    if (hasDefaultBehavior) return;
  } else if (document.activeElement && document.activeElement.tagName !== 'BODY') {
    return;
  }

  const hash = hashKeyEvent(e);
  const options = (_commandLookup()[hash] || []).filter(v => {
    if (v.goMode) return keyboardNav_module.options.useGoMode.value === goModeActive;else return !goModeActive;
  });

  if (options.length) {
    handleCallbacks(options);
    e.preventDefault();
    e.target.blur();
  }
}

async function handleCallbacks(options) {
  if (options.some(v => v.goMode)) {
    if (goModeActive) toggleGoMode();

    if (options.length > 1) {
      const shortcut = keycode_niceKeyCode(options[0].value);
      options = await promptUniqueShortcut(shortcut, options);
    }
  }

  for (const option of options) {
    try {
      option.callback();
    } catch (e) {
      console.error('Could not execute callback', i18n(option.title), e);
    }
  }
}

const promptUniqueShortcut = memoize_default()(async (shortcut, options) => {
  const question = i18n('keyboardNavAmbiguousShortcutPrompt', i18n(keyboardNav_module.moduleName), `<i>${shortcut}</i>`, '<br><br>', `<i>${shortcut}</i>`);
  const optionButtons = options.map(option => [option, jquery_default()(`<button style="width: 100%; margin-top: 2px;">${i18n(option.description)}</button>`).get(0)]);
  const followUp = i18n('keyboardNavAmbiguousShortcutPromptFollowUp', makeUrlHashLink(keyboardNav_module.moduleID, undefined, i18n(keyboardNav_module.moduleName)));
  const message = jquery_default()(`<div>${question}</div>`).append(optionButtons.map(([, button]) => button)).append(`<br><br><small>(${followUp})</small>`).get(0);
  const notification = notifications_showNotification({
    moduleID: keyboardNav_module.moduleID,
    header: 'Ambiguous shortcut',
    message,
    noDisable: true,
    closeDelay: Infinity
  });
  const preservedOption = await Promise.race(optionButtons.map(([option, button]) => waitForEvent(button, 'click').then(() => option)));

  for (const option of without_default()(options, preservedOption)) {
    option.value = [-1, false, false, false, false];
    options_save(option);
  }

  notification.close();
  return [preservedOption];
});

function getSelected() {
  const selected = selectedThing_namespaceObject.current;
  if (!selected) throw new Error('A entry must be selected');
  if (!selected.isVisible()) throw new Error('Entry must be visible');
  return selected;
}

const ASSERT = true;
const NOASSERT = false;

function assertElement(element) {
  if (!element) throw new Error('Element not available');
  return element;
}

function getFirstElementInThingByQuery(query, assertExistance, thing = getSelected()) {
  const element = thing.entry.querySelector(query);
  return assertExistance ? assertElement(element) : element;
}

function getElementsInThingByQuery(query, assertLength, thing = getSelected()) {
  const elements = Array.from(thing.entry.querySelectorAll(query));
  if (assertLength) assertElement(elements[0]);
  return elements;
}

function getMostVisibleElementInThingByQuery(query, assertLength, thing) {
  return maxBy_default()(getElementsInThingByQuery(query, assertLength, thing), getPercentageVisibleYAxis);
}

function hideLink(selected = getSelected()) {
  const hide = assertElement(selected.getHideElement());

  if (keyboardNav_module.options.onHideMoveDown.value) {
    selectedThing_namespaceObject.move('down', {
      allowMediaBrowse: true,
      scrollStyle: 'none'
    }, moveDownFallback);
  }

  click(hide);
}

function followSubreddit(newWindow = false, selected = getSelected()) {
  const a = downcast(assertElement(selected.getSubredditLink()), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow,
    leaveNP: true
  });
}

function followProfile(newWindow = false, selected = getSelected()) {
  keyboardNav_navigateTo(selected.getAuthorUrl(), {
    newWindow,
    leaveNP: true
  });
}

function toggleChildren(selected = getSelected()) {
  if (selected.element.classList.contains('link')) return;
  click(assertElement(getFirstElementInThingByQuery('span.deepthread > a', NOASSERT, selected) || getFirstElementInThingByQuery('span.morecomments > a', NOASSERT, selected) || getFirstElementInThingByQuery('a.expand', NOASSERT, selected)));
}

function imageResize({
  factor = 1,
  removeHeightRestriction = false
}) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-zoomable', ASSERT);
  if (removeHeightRestriction) mostVisible.style.maxHeight = 'none';
  resize(mostVisible, mostVisible.clientWidth * factor);
}

function imageMove(deltaX, deltaY) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-movable', ASSERT);
  showImages_move(mostVisible, deltaX, deltaY);
}

function navigateGallery(direction) {
  const gallery = getMostVisibleElementInThingByQuery('.res-gallery', ASSERT);
  assertElement(gallery.querySelector(`.res-step-${direction}`)).click();

  if (keyboardNav_module.options.scrollOnGalleryNavigate.value) {
    scrollToElement(assertElement(gallery.querySelector('.res-gallery-pieces')), null, {
      scrollStyle: 'directional',
      restrictDirectionTo: 'up'
    });
  }
}

function followLink(newWindow = false, selected = getSelected()) {
  if (isPageType('comments') && !selected.element.classList.contains('link')) return;
  const a = selected.getPostLink();
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followLinkByRank(num) {
  const target = Thing_Thing.visibleThings().find(v => v.getRank() === num);
  if (!target) throw new Error(`Could not find visible entry at rank ${num}`);
  selectedThing_namespaceObject.set(target);
  followLink();
}

function followPermalink(newWindow = false) {
  const a = downcast(getFirstElementInThingByQuery('a.bylink', ASSERT), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followComments(newWindow = false, selected = getSelected()) {
  const a = selected.getCommentsLink();
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function vote(way, preventToggle = false, selected = getSelected()) {
  const button = assertElement(way === 'upmod' ? selected.getUpvoteButton() : selected.getDownvoteButton());

  if (button.classList.contains('archived')) {} else if (isVotingBlocked()) {
    notifyNoVote();
  } else if (!preventToggle || !button.classList.contains(way)) {
    click(button);
  }

  if (selected.isComment()) {
    if (keyboardNav_module.options.onVoteCommentMoveDown.value) keyboardNav_module.options.moveDownComment.callback();
  } else {
    if (keyboardNav_module.options.onVoteMoveDown.value) keyboardNav_module.options.moveDown.callback();
  }
}

function reply(selected = getSelected()) {
  if (selected.element.classList.contains('link') && isPageType('comments')) {
    const $target = jquery_default()('.usertext-edit textarea[name=text]:first');

    if ($target.filter(':visible').length) {
      $target.focus();
      return;
    }
  }

  click(assertElement(getFirstElementInThingByQuery('.buttons a[onclick*=reply]', NOASSERT, selected) || getFirstElementInThingByQuery('.buttons a.comments, .buttons a.bylink', NOASSERT, selected)));
}

function keyboardNav_navigateTo(href, options) {
  if (options.leaveNP && modules_isEnabled(noParticipation_namespaceObject) && noParticipation_module.options.escapeNP.value) {
    href = nonNpLocation(href);
  }

  if (options.newWindow) {
    openNewTab(href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = href;
  }
}

const goModePanel = lodash_once_default()(() => {
  const goModes = getActiveCommandOptions().filter(opt => opt.goMode).map(opt => ({
    key: i18n(opt.title),
    niceKeyCode: keycode_niceKeyCode(opt.value)
  }));
  return jquery_default()(string_namespaceObject.html`
		<div id="goModePanel" class="RESDialogSmall">
			<h3>Press a key to go:</h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESDialogContents">
				<table>
					${goModes.map(({
    niceKeyCode,
    key
  }) => string_namespaceObject._html`
						<tr>
							<td>${niceKeyCode}</td>
							<td class="arrow">&rarr;</td>
							<td>${key}</td>
						</tr>
					`)}
				</table>
			</div>
		</div>
	`).find('.RESCloseButton').click(toggleGoMode).end();
});

let goModeActive = false;

function toggleGoMode() {
  goModeActive = !goModeActive;

  if (goModeActive) {
    jquery_default()(document.body).on('keyup', handleGoModeEscapeKey);
    goModePanel().appendTo(document.body).fadeIn();
  } else {
    goModePanel().fadeOut();
    jquery_default()(document.body).off('keyup', handleGoModeEscapeKey);
  }
}

function handleGoModeEscapeKey(event) {
  if (event.key === NAMED_KEYS.Escape) {
    toggleGoMode();
  }
}

function moveDownFallback() {
  const bump = isRunning(neverEndingReddit_namespaceObject) && (!selectedThing_namespaceObject.current || [selectedThing_namespaceObject.current, undefined].includes(last_default()(Thing_Thing.visibleThings())));
  if (bump) loadNextPage({
    scrollToLoadWidget: true
  });
}

function openLink(index, altMode = false) {
  const link = linkAnnotations[index] && linkAnnotations[index].link;
  if (!link) throw Error(`Link annotation ${index} is not available`);
  const expando = getLinkExpando(link);

  if (expando && keyboardNav_module.options.linkToggleExpando.value !== altMode) {
    click(expando.button);
  } else if (isSettingsUrl(link.href)) {
    settingsNavigation_update(link);
  } else if (keyboardNav_module.options.linkNewTab.value) {
    openNewTab(link.href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = link.href;
  }
}
// CONCATENATED MODULE: ./lib/modules/RESTips.js
















const RESTips_module = new Module('RESTips');
RESTips_module.moduleName = 'resTipsName';
RESTips_module.category = 'aboutCategory';
RESTips_module.description = 'resTipsDesc';
RESTips_module.options = {
  menuItem: {
    title: 'RESTipsMenuItemTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsMenuItemDesc'
  },
  dailyTip: {
    title: 'RESTipsDailyTipTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsDailyTipDesc'
  },
  newFeatureTips: {
    title: 'RESTipsNewFeatureTipsTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsNewFeatureTipsDesc'
  }
};
RESTips_module.include = ['r2'];
const featureTipsStorage = storage_namespaceObject.wrapPrefix('RESTips.featureTips.', () => ({
  enabled: true
}));
const lastTooltipStorage = storage_namespaceObject.wrap('RESLastToolTip', 0);

RESTips_module.contentStart = () => {
  if (RESTips_module.options.menuItem.value) {
    menu_addMenuItem(() => string_namespaceObject.html`<span>${i18n('tipsAndTricks')}</span>`, () => {
      showOrdinaryTip('random');
    });
  }
};

let allowFeatureTips;
const RESTips_featureTips = new Map();
const featureTipReadyPromise = new Promise(resolve => {
  allowFeatureTips = () => resolve(true);
});

RESTips_module.afterLoad = async () => {
  const showsDailyTip = RESTips_module.options.dailyTip.value && (await dailyTip());
  if (RESTips_module.options.newFeatureTips.value && !showsDailyTip) allowFeatureTips();
};

const newFeatureTipsCheckbox = lodash_once_default()(() => jquery_default()('<label><input type="checkbox" name="disableNewFeatureTipsCheckbox" checked />Show these tips when new features appear</label>').click(e => {
  RESTips_module.options.newFeatureTips.value = e.currentTarget.querySelector('input').checked;
  options_save(RESTips_module.options.newFeatureTips);
}));

const addFeatureTip = memoize_default()(async (id, tip) => {
  tip.onHide = () => {
    featureTipsStorage.set(id, {
      enabled: false
    });
  };

  RESTips_featureTips.set(id, tip);
  tips.push(tip);
  if (!tip.quiet && (await featureTipReadyPromise) && (await featureTipsStorage.get(id).then(({
    enabled
  }) => enabled))) showFeatureTip(id);
});
const showFeatureTip = mutex(id => {
  const tip = RESTips_featureTips.get(id);

  if (!tip) {
    console.error('Feature tip is not added', id);
    return;
  }

  if (tip.attachTo instanceof Element && !elementInViewport(tip.attachTo)) {
    console.log('Ignoring feature tip whose attachment element is not visible:', tip);
    return;
  }

  return showTip(tip, {
    title: 'New feature',
    classString: 'res-featureTip',
    buttonCustomHTML: newFeatureTipsCheckbox(),
    buttons: []
  });
});

async function dailyTip() {
  const lastCheck = await lastTooltipStorage.get();
  const now = Date.now();
  const delay = penalizedDelay(RESTips_module.moduleID, 'dailyTip', {
    value: DAY,
    default: DAY
  });

  if (now - lastCheck > delay) {
    lastTooltipStorage.set(now);

    if (lastCheck === 0) {
      await showOrdinaryTip();
    } else {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', clamp_default()(MAX_PENALTY / tips.length, 3, 8));
      await showOrdinaryTip('random');
    }

    return true;
  }

  return false;
}

function generateContent({
  message,
  keyboard,
  options
}) {
  const description = [];
  if (typeof message === 'function') description.push(message());else if (typeof message === 'string') description.push(message);

  if (keyboard) {
    const disabled = !modules_isEnabled(keyboardNav_namespaceObject);
    description.push(`<h2 class="keyboardNav${disabled ? 'keyboardNavDisabled' : ''}">`);
    description.push(`Keyboard Navigation${disabled ? ' (disabled)' : ''}`);
    description.push('</h2>');
    const keyboardTable = createElement_namespaceObject.table(keyboard, generateContentKeyboard);
    if (keyboardTable) description.push(keyboardTable);
  }

  if (options) {
    for (const option of options) {
      description.push('<h2 class="settingsPointer">');
      description.push('<span class="gearIcon"></span> RES Settings');
      description.push('</h2>');
      const optionTable = createElement_namespaceObject.table(option, generateContentOption);
      if (optionTable) description.push(optionTable);
    }
  }

  return jquery_default()('<div />').html(description.join('\n'));
}

function generateContentKeyboard(keyboardNavOption) {
  const keyCode = keycode_niceKeyCode(keyboardNav_module.options[keyboardNavOption].value);
  if (!keyCode) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td><code>${keyCode.toLowerCase()}</code></td>`);
  description.push(`<td>${keyboardNavOption}</td>`);
  description.push('</tr><tr>');
  description.push('<td>&nbsp;</td>');
  description.push(`<td>${i18n(keyboardNav_module.options[keyboardNavOption].description)}</td>`);
  description.push('</tr>');
  return description;
}

function generateContentOption(option) {
  const mod = getUnchecked(option.moduleID);
  if (!mod) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td>${i18n(mod.category)}</td>`);
  description.push('<td>');
  description.push(makeUrlHashLink(option.moduleID, undefined, i18n(mod.moduleName)));
  description.push('</td>');
  description.push('<td>');
  description.push(option.key ? makeUrlHashLink(option.moduleID, option.key) : '&nbsp;');
  description.push('</td>');

  if (option.key && mod.options[option.key]) {
    description.push('</tr><tr>');
    description.push(`<td colspan="3">${i18n(mod.options[option.key].description)}</td>`);
  }

  description.push('</tr>');
  return description;
}

const tips = [{
  message: `
		Welcome to RES, a community-driven unofficial browser extension for Reddit. You can turn on, turn off, or change options for RES features using the gear icon link at the top right.
		<p>For feature requests, or just help getting a question answered, be sure to subscribe to <a href="/r/Enhancement">/r/Enhancement</a>.</p>
		<p>If RES has enhanced your reddit experience, please show your appreciation by <a href="${RES_SETTINGS_HASH}/contribute">donating or contributing!</a></p>
		`,
  attachTo: '#RESSettingsButton',
  position: 5
}, {
  message: 'Click the tag icon next to a user to tag that user with any name you like - you can also color code the tag.',
  attachTo: '.RESUserTagImage',
  position: 3,
  options: [{
    moduleID: 'userTagger'
  }]
}, {
  message: 'If your RES data gets deleted or you move to a new computer, you can restore it from backup. <br><br><b>Firefox</b> especially sometimes loses your RES settings and data. <br><br><a href="/r/Enhancement/wiki/backing_up_res_settings" target="_blank" rel="noopener noreferer">Learn where RES stores your data and settings</a></p>',
  title: 'Back up your RES data!'
}, {
  message: 'Don\'t forget to subscribe to <a href="/r/Enhancement">/r/Enhancement</a> to keep up to date on the latest versions of RES or suggest features! For bug reports, submit to <a href="/r/RESIssues">/r/RESIssues</a>'
}, {
  message: 'Don\'t want to see posts containing certain keywords? Want to filter out certain subreddits from /r/all? Try the filteReddit module!',
  options: [{
    moduleID: 'filteReddit'
  }]
}, {
  message: 'Keyboard Navigation is one of the most underutilized features in RES. You should try it!',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Did you know you can configure the appearance of a number of things in RES? For example: Selected Entry lets you configure the look of the "selected" box, and commentBoxes lets you configure the borders / shadows.',
  options: [{
    moduleID: 'selectedEntry',
    key: 'setColors'
  }, {
    moduleID: 'commentStyle',
    key: 'commentBoxes'
  }]
}, {
  message: 'Do you subscribe to a ton of subreddits? Give the subreddit tagger a try; it can make your homepage a bit more readable.',
  options: [{
    moduleID: 'subRedditTagger'
  }]
}, {
  message: 'If you haven\'t tried it yet, Keyboard Navigation is great. Just hit ? while browsing for instructions.',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Roll over a user\'s name to get information about them such as their karma, and how long they\'ve been a reddit user.',
  options: [{
    moduleID: 'userInfo',
    key: 'hoverInfo'
  }]
}, {
  message: 'Hover over the "parent" link in comments pages to see the text of the parent being referred to.',
  options: [{
    moduleID: 'showParent'
  }]
}, {
  message: 'You can configure the color and style of the User Highlighter module if you want to change how the highlights look.',
  options: [{
    moduleID: 'userHighlight'
  }]
}, {
  message: 'Not a fan of how comments pages look? You can change the appearance in the Style Tweaks module',
  options: [{
    moduleID: 'styleTweaks'
  }]
}, {
  message: 'Don\'t like the style in a certain subreddit? RES gives you a checkbox to disable styles individually - check the right sidebar!'
}, {
  message: 'Looking for posts by submitter, post with photos, or posts in IAmA form? Try out the comment navigator.'
}, {
  message: 'Have you seen the <a href="/r/Dashboard">RES Dashboard</a>? It allows you to do all sorts of great stuff, like keep track of lower traffic subreddits, and manage your <a href="/r/Dashboard#userTaggerContents">user tags</a> and <a href="/r/Dashboard#newCommentsContents">thread subscriptions</a>!',
  options: [{
    moduleID: 'dashboard'
  }]
}, {
  message: 'Sick of seeing these tips?  They only show up once every 24 hours, but you can disable that in the RES Tips and Tricks preferences.',
  options: [{
    moduleID: 'RESTips'
  }]
}, {
  message: 'Did you know that there is now a "keep me logged in" option in the Account Switcher? Turn it on if you want to stay logged in to Reddit when using the switcher!',
  options: [{
    moduleID: 'accountSwitcher',
    key: 'keepLoggedIn'
  }]
}, {
  message: 'See that little [vw] next to users you\'ve voted on?  That\'s their vote weight - it moves up and down as you vote the same user up / down.',
  options: [{
    moduleID: 'userTagger',
    key: 'vwNumber'
  }]
}];

const dailyTipsCheckbox = lodash_once_default()(() => jquery_default()(`<label><input type="checkbox" name="disableDailyTipsCheckbox" ${RESTips_module.options.dailyTip.value ? 'checked' : ''} />Show these tips once every 24 hours</label>`).click(e => {
  RESTips_module.options.dailyTip.value = e.currentTarget.querySelector('input').checked;
  options_save(RESTips_module.options.dailyTip);
}));

let lastTip;

function showOrdinaryTip(change) {
  alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 1);
  let currTipIndex = Math.max(tips.indexOf(lastTip), 0);
  let tip;

  while (!tip || tip.attachTo && !jquery_default()(tip.attachTo).is(':visible')) {
    if (change === 'random') currTipIndex = random_default()(tips.length);else if (change === 'prev') currTipIndex -= 1;else if (change === 'next') currTipIndex += 1;else change = 'next';
    currTipIndex = positiveModulo(currTipIndex, tips.length);
    tip = tips[currTipIndex];
  }

  return showTip(tip, {
    buttons: [{
      name: 'Prev',
      onclick: () => showOrdinaryTip('prev')
    }, {
      name: 'Next',
      onclick: () => showOrdinaryTip('next')
    }],

    onClose() {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 4);
    },

    classString: 'res-ordinaryTip',
    buttonCustomHTML: dailyTipsCheckbox(),
    title: 'RES Tips and Tricks'
  });
}

function showTip(tip, guiderObj) {
  const {
    continuation
  } = lastTip = tip;

  if (continuation) {
    const origGuiderObj = { ...guiderObj
    };
    guiderObj.buttons = [...guiderObj.buttons, {
      name: 'More',
      onclick: async () => {
        const upcomingId = continuation();
        let nextTip;

        while (!(nextTip = RESTips_featureTips.get(upcomingId))) {
          await new Promise(r => setTimeout(r, 100));
        }

        showTip(nextTip, origGuiderObj);
      }
    }];
  }

  const attachTo = tip.attachTo && jquery_default()(tip.attachTo).get(0) || null;

  const toggleIncreasedZIndex = state => {
    if (attachTo) attachTo.classList.toggle('restips-increased-z-index', state);
  };

  return new Promise(resolve => {
    guiders.hideAll();
    guiders.createGuider({
      id: `res-guider-${performance.now()}`,
      closeOnEscape: true,
      xButton: true,
      description: generateContent(tip),
      ...guiderObj,
      ...tip,

      onHide() {
        if (tip.onHide) tip.onHide();
        toggleIncreasedZIndex(false);
        resolve();
      },

      attachTo
    });
    toggleIncreasedZIndex(true);
    guiders.show();
  });
}
// CONCATENATED MODULE: ./lib/modules/about.js


const about_module = new Module('about');
about_module.moduleName = 'aboutName';
about_module.category = 'aboutCategory';
about_module.sort = -10;
about_module.alwaysEnabled = true;
about_module.description = 'aboutDesc';
about_module.options = {
  presets: {
    type: 'button',
    description: 'aboutOptionsPresets',
    title: 'aboutOptionsPresetsTitle',
    text: createElement_namespaceObject.icon(0xF142),
    callback: {
      moduleID: 'presets'
    }
  },
  backup: {
    type: 'button',
    description: 'aboutOptionsBackup',
    title: 'aboutOptionsBackupTitle',
    text: createElement_namespaceObject.icon(0xF059),
    callback: {
      moduleID: 'backupAndRestore'
    }
  },
  searchSettings: {
    type: 'button',
    description: 'aboutOptionsSearchSettings',
    title: 'aboutOptionsSearchSettingsTitle',
    text: createElement_namespaceObject.icon(0xF097),
    callback: {
      moduleID: 'search'
    }
  },
  announcements: {
    type: 'button',
    description: 'aboutOptionsAnnouncements',
    title: 'aboutOptionsAnnouncementsTitle',
    text: createElement_namespaceObject.icon(0xF108),
    callback: '/r/RESAnnouncements/new'
  },
  donate: {
    type: 'button',
    description: 'aboutOptionsDonate',
    title: 'aboutOptionsDonateTitle',
    text: createElement_namespaceObject.icon(0xF104),
    callback: 'https://redditenhancementsuite.com/contribute/'
  },
  bugs: {
    type: 'button',
    description: 'aboutOptionsBugs',
    title: 'aboutOptionsBugsTitle',
    text: createElement_namespaceObject.icon(0xF003),
    callback: '/r/RESIssues/wiki/postanissue'
  },
  suggestions: {
    type: 'button',
    description: 'aboutOptionsSuggestions',
    title: 'aboutOptionsSuggestionsTitle',
    text: createElement_namespaceObject.icon(0xF076),
    callback: '/r/Enhancement'
  },
  faq: {
    type: 'button',
    description: 'aboutOptionsFAQ',
    title: 'aboutOptionsFAQTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: '/r/Enhancement/wiki/index'
  },
  code: {
    type: 'button',
    description: 'aboutOptionsCode',
    title: 'aboutOptionsCodeTitle',
    text: createElement_namespaceObject.icon(0xF063),
    callback: 'https://github.com/honestbleeps/Reddit-Enhancement-Suite'
  },
  contributors: {
    type: 'button',
    description: 'aboutOptionsContributors',
    title: 'aboutOptionsContributorsTitle',
    text: createElement_namespaceObject.icon(0xF048),
    callback: 'https://redditenhancementsuite.com/about'
  },
  privacy: {
    type: 'button',
    description: 'aboutOptionsPrivacy',
    title: 'aboutOptionsPrivacyTitle',
    text: createElement_namespaceObject.icon(0xF0C2),
    callback: '/r/Enhancement/wiki/about/privacy'
  },
  license: {
    type: 'button',
    description: 'aboutOptionsLicense',
    title: 'aboutOptionsLicenseTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: 'https://www.gnu.org/licenses/gpl-3.0.html'
  }
};
// CONCATENATED MODULE: ./lib/modules/announcements.js






const announcements_module = new Module('announcements');
announcements_module.moduleName = 'announcementsName';
announcements_module.category = 'coreCategory';
announcements_module.description = 'announcementsDesc';
announcements_module.hidden = true;
const announcements_subreddit = announcementsSubreddit;
const sourceUrl = `/r/${announcements_subreddit}/new.json?limit=1`;
const viewUrl = `/r/${announcements_subreddit}/new`;
const markedReadDate = storage_namespaceObject.wrap('RESmodules.announcement.markedReadDate', 0);
const lastUnreadDate = storage_namespaceObject.wrap('RESmodules.announcement.lastUnreadDate', 0);
const lastID = storage_namespaceObject.wrap('RESModules.announcement.lastAnnouncementID', null);
const archiveAfter = 31 * DAY;
const pizzazzAfter = 29 * DAY;
const recheckPostAfter = HOUR;
const announcements_now = Date.now();
let biff;

announcements_module.go = async () => {
  if (isCurrentSubreddit(announcements_subreddit)) {
    setMarkedRead();
  } else {
    const post = await postForNotification();

    if (post) {
      notify(post);
    }
  }
};

async function postForNotification() {
  const post = await getLatestPost();

  if (!post) {
    return false;
  }

  cacheLatestPost(post);
  const result = await shouldNotify(post);
  return result ? post : false;
}

async function shouldNotify(post) {
  const createdDate = post.created_utc * 1000;

  if (createdDate + archiveAfter <= announcements_now) {
    return false;
  }

  if (createdDate <= (await markedReadDate.get())) {
    return false;
  }

  if (!isPostRelevant(post)) {
    return false;
  }

  return true;
}

const notify = lodash_once_default()(async post => {
  const url = post.id ? `/comments/${post.id}` : viewUrl;
  const withPizzazz = (await lastUnreadDate.get()) + pizzazzAfter < announcements_now;
  const title = post.author ? i18n('announcementsNewPostByUser', announcements_subreddit, post.author) : i18n('announcementsNewPost', announcements_subreddit);
  addAnnouncementBiff(post, url, title, withPizzazz);
  const hasSeenNotification = await lastUnreadDate.has();

  if (hasSeenNotification) {
    menu_addMenuItem(() => string_namespaceObject.html`<span title="${title}">
				new announcement!
				<span data-action="preventOpenNewTab" class="RESMenuItemButton res-icon"></span> // TODO Restore title="i18n('announcementsMarkAsRead')"
			</span>`, e => {
      setMarkedRead();
      if (e.target.closest('[data-action="preventOpenNewTab"]')) return;
      openNewTab(url);
    }, -8);
  }
});

async function cacheLatestPost(post) {
  if (post.id !== (await lastID.get())) {
    lastID.set(post.id);
    lastUnreadDate.set(announcements_now);
  }
}

function addAnnouncementBiff(post, url, title, withPizzazz) {
  biff = string_namespaceObject.html`<a id="RESAnnouncementAlert" class="${withPizzazz ? 'important' : ''} href="${url}" target="_blank">`;
  biff.append(createElement_namespaceObject.icon(0xF076, 'span', '', title));
  biff.addEventListener('click', setMarkedRead);
  addFloater(biff, {
    container: 'inNavbar'
  });
}

async function getLatestPost() {
  const {
    data: {
      children: [{
        data
      }]
    }
  } = await ajax({
    url: sourceUrl,
    type: 'json',
    cacheFor: recheckPostAfter
  });
  return data;
}

function setMarkedRead() {
  markedReadDate.set(announcements_now);
  if (biff) biff.remove();
}

function isPostRelevant(post) {
  if (!/chrome|safari|firefox|opera|edge/i.test(post.title)) {
    return true;
  }

  if (post.title.toLowerCase().includes("chrome".toLowerCase())) {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./lib/modules/autoHide.js






const autoHide_module = new Module('autoHide');
autoHide_module.moduleName = 'autoHideName';
autoHide_module.category = 'browsingCategory';
autoHide_module.description = 'autoHideDesc';
autoHide_module.options = {
  mustBeVisibleDuration: {
    type: 'text',
    value: '2000',
    description: 'autoHideMustBeVisibleDurationDesc',
    title: 'autoHideMustBeVisibleDurationTitle'
  },
  types: {
    type: 'enum',
    values: [{
      name: 'All',
      value: ''
    }, {
      name: 'Only comments',
      value: 'comment'
    }, {
      name: 'Only link posts',
      value: 'post'
    }],
    value: 'comment',
    description: 'autoHideTypesDesc',
    title: 'autoHideTypesTitle'
  }
};
const autoHide_thingType = isPageType('comments', 'commentsLinklist') ? 'comment' : 'post';
const hidePost = batch(posts => send(HIDE, posts), {
  size: 50,
  delay: 5000,
  flushBeforeUnload: true
});

autoHide_module.shouldRun = () => !isPrivateBrowsing();

autoHide_module.beforeLoad = () => {
  if (autoHide_module.options.types.value && autoHide_thingType !== autoHide_module.options.types.value) return;

  if (autoHide_thingType === 'comment' && !isRunning(readComments_namespaceObject)) {
    console.warn('Auto-hiding comments requires readComments');
    return;
  }

  const mustBeVisibleDuration = parseFloat(autoHide_module.options.mustBeVisibleDuration.value) || 0;
  const pending = new Map();
  const io = new IntersectionObserver(entries => {
    for (const {
      target,
      isIntersecting
    } of entries) {
      const thing = Thing_Thing.checkedFrom(target);
      const id = pending.get(thing);

      if (isIntersecting) {
        pending.set(thing, setTimeout(() => {
          if (autoHide_thingType === 'post') hidePost(thing);else readComments_add(thing);
          io.unobserve(target);
          pending.delete(thing);
        }, mustBeVisibleDuration));
      } else if (id) {
        pending.delete(thing);
        clearTimeout(id);
      }
    }
  }, {
    threshold: [0],
    rootMargin: '0px 0px -30px 0px'
  });
  watchForThings([autoHide_thingType], thing => {
    io.observe(thing.entry);
  });
};
// EXTERNAL MODULE: ./node_modules/lodash/mapValues.js
var lodash_mapValues = __webpack_require__(75);
var lodash_mapValues_default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues);

// CONCATENATED MODULE: ./lib/modules/backupAndRestore/serialization.js

function serialize(settings) {
  return JSON.stringify({
    SCHEMA_VERSION: 2,
    data: settings
  });
}
function deserialize(string) {
  const object = JSON.parse(string);

  switch (object.SCHEMA_VERSION) {
    default:
      {
        const {
          SCHEMA_VERSION,
          ...encoded
        } = object;
        return lodash_mapValues_default()(encoded, (v, k) => {
          try {
            return JSON.parse(v);
          } catch (e) {
            console.warn('Could not parse:', k, 'falling back to raw string.');
            return v;
          }
        });
      }

    case 1:
      {
        const {
          SCHEMA_VERSION,
          ...settings
        } = object;
        return settings;
      }

    case 2:
      {
        const {
          data: settings
        } = object;
        return settings;
      }
  }
}
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Provider.js
class Provider {
  init({}) {
    return Promise.resolve(this);
  }

  read() {
    throw new Error('unimplemented');
  }

  write(data) {
    throw new Error('unimplemented');
  }

}
Provider.key = 'abstract';
Provider.text = 'Abstract';
Provider.notifyBackupDone = true;
Provider.supportsAutomaticBackups = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/File.js



class File_File extends Provider {
  read() {
    return new Promise((resolve, reject) => {
      const link = document.createElement('input');
      link.type = 'file';
      link.accept = '.resbackup';
      link.addEventListener('change', () => {
        const file = link.files[0];
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };

        reader.readAsText(file);
      });
      waitForEvent(window, 'mousemove').then(() => setTimeout(() => {
        if (!link.files.length) reject(new Error('No file selected.'));
      }));
      link.click();
    });
  }

  write(data) {
    const blob = new Blob([data], {
      type: 'application/json'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const date = new Date();
    link.download = `RES-${date.getUTCFullYear()}-${date.getMonth() + 1}-${date.getDate()}-${Math.round(date.getTime() / 1000)}-${metadata_version.replace(/\./g, '_')}.resbackup`;
    click(link);
    return Promise.resolve();
  }

}
File_File.key = 'file';
File_File.text = 'backupAndRestoreProvidersFile';
File_File.notifyBackupDone = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/GoogleDrive.js



const FILE = 'res-storage.json';
const FOLDER = 'appDataFolder';
class GoogleDrive_GoogleDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({
    googleLoginHint
  }) {
    this.accessToken = await launchAuthFlow({
      domain: `https://accounts.google.com/o/oauth2/v2/auth?login_hint=${googleLoginHint}`,
      clientId: '568759524377-nv0o2u4afuuulkfcjd7f6guf27qkevpt.apps.googleusercontent.com',
      scope: 'https://www.googleapis.com/auth/drive.appdata',
      permissions: ['https://content.googleapis.com/drive/v3/*', 'https://accounts.google.com/o/oauth2/v2/auth']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Google Drive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getExistingFile() {
    const {
      files: [file]
    } = await ajax({
      method: 'GET',
      url: 'https://content.googleapis.com/drive/v3/files',
      query: {
        fields: 'files(id)',
        q: `name="${FILE}"`,
        spaces: FOLDER
      },
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
    return file;
  }

  async getOrCreateFile() {
    const existingFile = await this.getExistingFile();
    if (existingFile) return existingFile;
    return ajax({
      method: 'POST',
      url: 'https://content.googleapis.com/drive/v3/files',
      query: {
        fields: 'id'
      },
      data: JSON.stringify({
        name: FILE,
        parents: [FOLDER]
      }),
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

  async read() {
    const file = await this.getExistingFile();
    if (!file) throw new Error('Could not find backup.');
    return ajax({
      method: 'GET',
      url: `https://content.googleapis.com/drive/v3/files/${file.id}`,
      query: {
        alt: 'media'
      },
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      }
    });
  }

  async write(data) {
    const {
      id
    } = await this.getOrCreateFile();
    await ajax({
      method: 'PATCH',
      url: `https://content.googleapis.com/upload/drive/v3/files/${id}`,
      query: {
        uploadType: 'media'
      },
      data,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
GoogleDrive_GoogleDrive.key = 'googledrive';
GoogleDrive_GoogleDrive.text = 'Google Drive';
GoogleDrive_GoogleDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/OneDrive.js



const OneDrive_FILE = 'res-storage.json';
class OneDrive_OneDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://login.live.com/oauth20_authorize.srf',
      clientId: 'a1f95f80-0129-475b-9894-dfbb94f5ff1c',
      scope: 'onedrive.appfolder',
      permissions: ['https://login.live.com/oauth20_authorize.srf']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to OneDrive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getMetadata() {
    try {
      return await ajax({
        method: 'GET',
        url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}`,
        query: {
          select: 'id,@content.downloadUrl'
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        },
        type: 'json'
      });
    } catch (e) {
      if (e.status === 404) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async read() {
    const file = await this.getMetadata();
    return ajax({
      method: 'GET',
      url: file['@content.downloadUrl']
    });
  }

  async write(data) {
    await ajax({
      method: 'PUT',
      url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}:/content`,
      data,
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
OneDrive_OneDrive.key = 'onedrive';
OneDrive_OneDrive.text = 'OneDrive';
OneDrive_OneDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Dropbox.js



const Dropbox_FILE = '/res-storage.json';
class Dropbox_Dropbox extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://www.dropbox.com/oauth2/authorize',
      clientId: 'tdevom9o5xn0hnt',
      permissions: ['https://www.dropbox.com/oauth2/authorize']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Dropbox.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async read() {
    try {
      return await ajax({
        method: 'POST',
        url: 'https://content.dropboxapi.com/2/files/download',
        query: {
          arg: JSON.stringify({
            path: Dropbox_FILE
          })
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      });
    } catch (e) {
      if (e.status === 409) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async write(data) {
    await ajax({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/upload',
      query: {
        arg: JSON.stringify({
          path: Dropbox_FILE,
          mode: 'overwrite',
          mute: true
        })
      },
      data,
      headers: {
        'Content-Type': 'application/octet-stream',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
Dropbox_Dropbox.key = 'dropbox';
Dropbox_Dropbox.text = 'Dropbox';
Dropbox_Dropbox.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/index.js




// CONCATENATED MODULE: ./lib/modules/backupAndRestore.js








const backupAndRestore_module = new Module('backupAndRestore');
backupAndRestore_module.moduleName = 'backupName';
backupAndRestore_module.category = 'aboutCategory';
backupAndRestore_module.sort = -8;
backupAndRestore_module.alwaysEnabled = true;
backupAndRestore_module.description = 'backupDesc';
backupAndRestore_module.options = {
  backup: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(backup)
    })),
    description: 'backupAndRestoreBackupDesc',
    title: 'backupAndRestoreBackupTitle'
  },
  restore: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(restore)
    })),
    description: 'backupAndRestoreRestoreDesc',
    title: 'backupAndRestoreRestoreTitle'
  },
  reloadWarning: {
    type: 'enum',
    value: 'warn',
    values: [{
      name: 'backupAndRestoreReloadWarningNone',
      value: 'none'
    }, {
      name: 'backupAndRestoreReloadWarningWarn',
      value: 'warn'
    }, {
      name: 'backupAndRestoreReloadWarningAuto',
      value: 'auto'
    }],
    description: 'backupAndRestoreReloadWarningDesc',
    title: 'backupAndRestoreReloadWarningTitle'
  },
  automaticBackups: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'backupAndRestoreAutomaticBackupsNone',
      value: 'none'
    }, ...Object.values(providers_namespaceObject).filter(p => p.supportsAutomaticBackups).map(p => ({
      name: p.text,
      value: p.key
    }))],
    description: 'backupAndRestoreAutomaticBackupsDesc',
    title: 'backupAndRestoreAutomaticBackupsTitle',

    onChange() {
      lastCheckStorage.set(0);
      handleAutomaticSync();
    }

  },
  warnBeforeAutomaticRestore: {
    type: 'boolean',
    value: true,
    description: 'backupAndRestoreWarnBeforeAutomaticRestoreDesc',
    title: 'backupAndRestoreWarnBeforeAutomaticRestoreTitle',
    dependsOn: options => options.automaticBackups.value !== 'none'
  },
  googleAccount: {
    type: 'text',
    value: '',
    description: 'backupAndRestoreGoogleAccountDesc',
    title: 'backupAndRestoreGoogleAccountTitle',
    advanced: true
  }
};

backupAndRestore_module.afterLoad = async () => {
  await handleAutomaticSync();
};

function getProvider(providerClass) {
  return new providerClass().init({
    googleLoginHint: backupAndRestore_module.options.googleAccount.value
  });
}

const lastModifiedStorage = storage_namespaceObject.wrapPrefix('backup.lastModified.', () => 0);
const lastCheckStorage = storage_namespaceObject.wrap('backup.lastCheck', 0);

async function handleAutomaticSync() {
  const automaticProviderKey = backupAndRestore_module.options.automaticBackups.value;
  if (automaticProviderKey === 'none') return;
  const providerClass = Object.values(providers_namespaceObject).find(p => p.key === automaticProviderKey);
  if (!providerClass) throw new Error(`Can't find provider with key ${automaticProviderKey}`);
  const now = Date.now();
  const lastCheck = await lastCheckStorage.get();
  if (now - lastCheck < 15 * MINUTE) return;
  if (!(await lastCheckStorage.compareAndSet(lastCheck, now))) return;
  const provider = await getProvider(providerClass);
  let remoteBackup;

  const lastModifiedKey = lastModifiedStorage._keyGen(providerClass.key);

  try {
    remoteBackup = deserialize((await provider.read()));
  } catch (e) {
    console.warn('Failed to read automatic backup:', e);
    remoteBackup = {
      [lastModifiedKey]: 0
    };
  }

  if (remoteBackup[lastModifiedKey] > (await lastModifiedStorage.get(providerClass.key))) {
    await restore(provider, backupAndRestore_module.options.warnBeforeAutomaticRestore.value ? 'automatic' : 'none');
  } else {
    await backup(provider);
  }
}

async function backup(provider) {
  const {
    key,
    text,
    notifyBackupDone
  } = provider.constructor;
  await lastModifiedStorage.set(key, Date.now());
  const storage = await storage_namespaceObject.getAll();
  await provider.write(serialize(storage));

  if (notifyBackupDone) {
    notifications_showNotification({
      message: i18n('backupAndRestoreSavedNotification', text),
      notificationID: 'backupAndRestoreSaved',
      moduleID: backupAndRestore_module.moduleID,
      closeDelay: 1000
    });
  }
}

async function restore(provider, alertType = 'normal') {
  const {
    key,
    name
  } = provider.constructor;
  const data = await provider.read();
  const storage = deserialize(data);
  const isAutomatic = alertType === 'automatic';

  if (alertType !== 'none') {
    const lastModifiedKey = lastModifiedStorage._keyGen(key);

    const backupDate = storage[lastModifiedKey];
    let size;

    try {
      size = new Intl.NumberFormat(i18n_locale, {
        style: 'unit',
        unit: 'byte',
        notation: 'compact',
        unitDisplay: 'narrow'
      }).format(data.length);
    } catch (e) {
      size = `${data.length / 1e6} MB`;
    }

    try {
      await alert_namespaceObject.open(`
			${isAutomatic ? `
				<p><b>${i18n('backupAndRestoreFoundBackup', name)}</b></p>
				<br>
			` : ''}
			<p>${i18n('backupAndRestoreBackupOverwriteWarning')}</p>
			<br>
			${isAutomatic ? `
				<p>${i18n('backupAndRestoreAfterCancel')}</p>
				<br>
			` : ''}
			${backupDate ? `
				<p>${i18n('backupAndRestoreBackupDate', formatDateTime(new Date(backupDate)))}</p>
			` : ''}
			<p>${i18n('backupAndRestoreBackupSize', size)}</p>
		`, {
        cancelable: true
      });
    } catch (e) {
      if (isAutomatic) {
        settingsNavigation_open(backupAndRestore_module.moduleID, 'automaticBackups');
      }

      return;
    }
  }

  await storage_namespaceObject.setMultiple(storage);
  await lastCheckStorage.set(Date.now());
  await sendMessage('runMigrations');
  postRestore(backupAndRestore_module.options.reloadWarning.value);
  await alert_namespaceObject.open(i18n('backupAndRestoreImported'));
  postRestore.local('auto');
}

const postRestore = multicast(operation => {
  switch (operation) {
    case 'warn':
      alert_namespaceObject.open(i18n('backupAndRestoreImportedOtherTabs'), {
        cancelable: true
      }).then(() => location.reload(), () => {});
      break;

    case 'auto':
      location.reload();
      break;

    case 'none':
    default:
      break;
  }
}, {
  name: 'restore-settings-warning',
  local: false
});
// CONCATENATED MODULE: ./lib/modules/subredditManager.js









const subredditManager_module = new Module('subredditManager');
subredditManager_module.moduleName = 'subredditManName';
subredditManager_module.category = 'subredditsCategory';
subredditManager_module.description = 'subredditManDesc';
subredditManager_module.include = ['r2'];
subredditManager_module.bodyClass = true;
subredditManager_module.options = {
  subredditShortcut: {
    title: 'subredditManagerSubredditShortcutTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerSubredditShortcutDesc'
  },
  shortcutsPerAccount: {
    title: 'subredditManagerShortcutsPerAccountTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerShortcutsPerAccountDesc'
  },
  alwaysApplySuffixToMulti: {
    title: 'subredditManagerAlwaysApplySuffixToMultiTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAlwaysApplySuffixToMultiDesc'
  },
  dropdownEditButton: {
    title: 'subredditManagerDropdownEditButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDropdownEditButtonDesc'
  },
  shortcutDropdownDelay: {
    title: 'subredditManagerShortcutDropdownDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditManagerShortcutDropdownDelayDesc'
  },
  shortcutEditDropdownDelay: {
    title: 'subredditManagerShortcutEditDropdownDelayTitle',
    dependsOn: options => options.dropdownEditButton.value,
    type: 'text',
    value: '3000',
    description: 'subredditManagerShortcutEditDropdownDelayDesc'
  },
  allowLowercase: {
    title: 'subredditManagerAllowLowercaseTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAllowLowercaseDesc',
    bodyClass: true
  },
  linkDashboard: {
    title: 'subredditManagerLinkDashboardTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkDashboardDesc'
  },
  linkAll: {
    title: 'subredditManagerLinkAllTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkAllDesc'
  },
  linkFront: {
    title: 'subredditManagerLinkFrontTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFrontDesc'
  },
  linkPopular: {
    title: 'subredditManagerLinkPopularTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkPopularDesc'
  },
  linkProfilePosts: {
    title: 'subredditManagerLinkProfilePostsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkProfilePostsDesc'
  },
  linkRandom: {
    title: 'subredditManagerLinkRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkRandomDesc'
  },
  linkMyRandom: {
    title: 'subredditManagerLinkMyRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkMyRandomDesc'
  },
  linkRandNSFW: {
    title: 'subredditManagerLinkRandNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerLinkRandNSFWDesc'
  },
  linkUsers: {
    title: 'subredditManagerLinkUsersTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkUsersDesc'
  },
  linkFriends: {
    title: 'subredditManagerLinkFriendsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFriendsDesc'
  },
  linkMod: {
    title: 'subredditManagerLinkModTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModDesc'
  },
  linkModqueue: {
    title: 'subredditManagerLinkModqueueTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModqueueDesc'
  },
  linkSaved: {
    title: 'subredditManagerLinkSavedTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkSavedDesc'
  },
  buttonEdit: {
    title: 'subredditManagerButtonEditTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerButtonEditDesc'
  },
  lastUpdate: {
    title: 'subredditManagerLastUpdateTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLastUpdateDesc'
  },
  storeSubredditVisit: {
    title: 'subredditManagerStoreSubredditVisitTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerStoreSubredditVisitDesc',
    advanced: true
  },
  storeSubredditVisitIncognito: {
    title: 'subredditManagerStoreSubredditVisitIncognitoTitle',
    dependsOn: options => options.storeSubredditVisit.value,
    type: 'boolean',
    value: false,
    description: 'subredditManagerStoreSubredditVisitIncognitoDesc',
    advanced: true
  },
  dragDropDelete: {
    title: 'subredditManagerDragDropDeleteTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDragDropDeleteDesc',
    advanced: true
  },
  displayMultiCounts: {
    title: 'subredditManagerDisplayMultiCountsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDisplayMultiCountsDesc'
  }
};
let shortcutsContainer, $subredditGroupDropdown, subredditGroupDropdownUL, subredditGroupDropdownRefItem, $editShortcutDialog, deleteButton;
let mySubredditShortcuts = [];
const subredditsLastViewedStorage = storage_namespaceObject.wrap(() => `RESmodules.subredditManager.subredditsLastViewed.${loggedInUser() || 'null'}`, {});
const subredditShortcutsStorage = storage_namespaceObject.wrap(() => {
  const username = subredditManager_module.options.shortcutsPerAccount.value ? loggedInUser() : null;
  return `RESmodules.subredditManager.subredditShortcuts.${username || 'null'}`;
}, []);

const loadShortcuts = async () => {
  mySubredditShortcuts = await subredditShortcutsStorage.get();
};

const initialShortcutsLoad = lodash_once_default()(() => pagePhases_namespaceObject.sitetableStarted.then(loadShortcuts));

subredditManager_module.beforeLoad = () => {
  waitForDescendant(document.documentElement, '#sr-header-area').then(createSubredditBar);
};

subredditManager_module.contentStart = async () => {
  createSidebarShortcutToggle();
  await initialShortcutsLoad();
  watchForThings(['subreddit'], thing => {
    const titleElement = thing.getTitleElement();
    const container = thing.element.querySelector('.midcol');
    if (!titleElement || !container) return;
    const [, subreddit] = regexes.subreddit.exec(titleElement.pathname) || [];
    if (!subreddit) return;
    container.append(createShortcutToggleButton(subreddit));
  });
};

subredditManager_module.afterLoad = () => {
  if (subredditManager_module.options.lastUpdate.value && document.getElementsByClassName('listing-chooser').length) {
    subredditManager_lastUpdate();
  }

  const subreddit = currentSubreddit();

  if (subreddit) {
    requestAnimationFrame(() => {
      setLastViewtime(subreddit);
    });
  }
};

function createSidebarShortcutToggle() {
  const subreddit = currentSubreddit();

  if (subreddit && subredditManager_module.options.subredditShortcut.value) {
    const subButtons = document.querySelectorAll('.side .fancy-toggle-button');

    for (const subButton of subButtons) {
      let thisSubredditFragment, isMulti;

      if (!subreddit.includes('+') && !isCurrentSubreddit('mod')) {
        thisSubredditFragment = subreddit;
        isMulti = false;
      } else if (jquery_default()(subButton).parent().hasClass('subButtons')) {
        thisSubredditFragment = jquery_default()(subButton).parent().parent().find('a.title').text();
        isMulti = true;
      } else {
        thisSubredditFragment = jquery_default()(subButton).next().text();
        isMulti = true;
      }

      if (jquery_default()(`#subButtons-${thisSubredditFragment}`).length === 0) {
        const $subButtonsWrapper = jquery_default()(`<div id="subButtons-${thisSubredditFragment}" class="subButtons"></div>`);
        jquery_default()(subButton).wrap($subButtonsWrapper);
        getMultiCounts(thisSubredditFragment).then(multiCount => {
          jquery_default()(subButton).append(multiCount);
        });

        if (isMulti) {
          const theWrap = jquery_default()(subButton).parent();
          jquery_default()(theWrap).appendTo(jquery_default()(theWrap).parent());
        }
      }

      subButton.addEventListener('click', () => {
        ajax.invalidate({
          url: '/subreddits/mine.json',
          query: {
            after: '',
            limit: 100,
            user: loggedInUser()
          }
        });
      });
      const $subButtons = jquery_default()(`#subButtons-${thisSubredditFragment}`);
      const button = createShortcutToggleButton(subreddit);
      initialShortcutsLoad().then(() => button.dispatchEvent(new CustomEvent('refresh')));
      button.classList.add('RESshortcutside');
      $subButtons.append(button);
      const $next = $subButtons.next();

      if ($next.hasClass('title') && !$subButtons.hasClass('swapped')) {
        $subButtons.before($next);
        $subButtons.addClass('swapped');
      }
    }
  }
}

function createShortcutToggleButton(subreddit) {
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveShortcut'), i18n('subredditInfoAddThisSubredditToShortcuts'), () => mySubredditShortcuts.some(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase()), state => {
    if (state) addSubredditShortcut(subreddit);else removeSubredditShortcut(subreddit);
    redrawShortcuts();
  });
}
let hideSubredditGroupDropdownTimer, showSubredditGroupDropdownTimer;

function redrawShortcuts() {
  shortcutsContainer.textContent = '';
  const currentSub = (currentSubreddit() || '').toLowerCase().split('+').sort().join('+');

  const isCurrent = sub => {
    const sortedSubs = sub.replace(/\?\+/g, '+').split('+').sort();
    return sortedSubs.some(v => isCurrentSubreddit(v)) || currentSub === sortedSubs.join('+');
  };

  let i = 0;

  for (const shortcut of mySubredditShortcuts) {
    const thisShortCut = document.createElement('a');
    thisShortCut.setAttribute('orderIndex', String(i++));
    thisShortCut.setAttribute('data-subreddit', shortcut.subreddit);
    thisShortCut.classList.add('subbarlink');
    if (isCurrent(shortcut.subreddit)) thisShortCut.classList.add('RESShortcutsCurrentSub');
    thisShortCut.setAttribute('href', `/r/${shortcut.subreddit.replace(/(?:\?\+.*|\?$)/, '')}`);
    thisShortCut.textContent = shortcut.displayName;
    thisShortCut.addEventListener('click', e => {
      if (e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        return true;
      } else {
        e.preventDefault();
        followSubredditShortcut(e.currentTarget.href);
      }
    });
    thisShortCut.addEventListener('dblclick', e => {
      e.preventDefault();
      followSubredditShortcut.cancel();
      hideSubredditGroupDropdown();
      editSubredditShortcut(e.currentTarget, e);
    });
    thisShortCut.addEventListener('mouseover', e => {
      clearTimeout(hideSubredditGroupDropdownTimer);
      showSubredditGroupDropdown(e.currentTarget);
    });
    thisShortCut.addEventListener('mouseout', () => {
      clearTimeout(showSubredditGroupDropdownTimer);
      hideSubredditGroupDropdownTimer = setTimeout(() => hideSubredditGroupDropdown(), 500);
    });
    thisShortCut.addEventListener('dragstart', subredditDragStart);
    thisShortCut.addEventListener('dragenter', subredditDragEnter);
    thisShortCut.addEventListener('dragover', subredditDragOver);
    thisShortCut.addEventListener('dragleave', subredditDragLeave);
    thisShortCut.addEventListener('drop', subredditDrop);
    thisShortCut.addEventListener('dragend', subredditDragEnd);
    const sep = document.createElement('span');
    sep.setAttribute('class', 'separator');
    sep.textContent = '-';
    shortcutsContainer.append(sep);
    shortcutsContainer.append(thisShortCut, sep);
  }

  if (mySubredditShortcuts.length) {
    shortcutsContainer.style.textTransform = '';
  } else {
    shortcutsContainer.style.textTransform = 'none';
    shortcutsContainer.textContent = 'add shortcuts from the my subreddits menu at left or click the button by the subreddit name, drag and drop to sort';
  }
}

function showSubredditGroupDropdown(obj) {
  let subreddits = [];
  let suffix = '';

  if (obj.getAttribute && obj.getAttribute('data-subreddit').includes('+')) {
    let cleanSubreddits = obj.getAttribute('data-subreddit');

    if (cleanSubreddits.indexOf('/') > cleanSubreddits.lastIndexOf('+') || subredditManager_module.options.alwaysApplySuffixToMulti.value) {
      let pos;

      if ((pos = cleanSubreddits.lastIndexOf('?')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos);
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }

      if ((pos = cleanSubreddits.lastIndexOf('/')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos) + suffix;
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }
    }

    subreddits = cleanSubreddits.replace(/\?\+/g, '+').split('+');
  }

  if (!(subreddits.length || subredditManager_module.options.dropdownEditButton.value)) {
    return;
  }

  let delay;

  if (subreddits.length) {
    delay = parseInt(subredditManager_module.options.shortcutDropdownDelay.value, 10);
  } else {
    delay = parseInt(subredditManager_module.options.shortcutEditDropdownDelay.value, 10);
  }

  clearTimeout(showSubredditGroupDropdownTimer);
  showSubredditGroupDropdownTimer = setTimeout(() => _showSubredditGroupDropdown(obj, subreddits, suffix), delay);
}

function _showSubredditGroupDropdown(obj, subreddits, suffix) {
  subredditGroupDropdownRefItem = obj;

  if (!$subredditGroupDropdown) {
    $subredditGroupDropdown = jquery_default()('<div>', {
      id: 'RESSubredditGroupDropdown'
    });
    subredditGroupDropdownUL = document.createElement('ul');
    $subredditGroupDropdown.append(subredditGroupDropdownUL);

    if (subredditManager_module.options.dropdownEditButton.value) {
      $subredditGroupDropdown.append(`
				<div class="RESShortcutsEditButtons">
					<a href="#" class="delete res-icon" title="delete">&#xF155;</a>
					<a href="#" class="edit res-icon" title="edit">&#xF139;</a>
				</div>
			`);
    }

    $subredditGroupDropdown.appendTo(document.body);
    $subredditGroupDropdown.on('mouseout', () => {
      hideSubredditGroupDropdownTimer = setTimeout(() => {
        hideSubredditGroupDropdown();
      }, 500);
    });
    $subredditGroupDropdown.on('mouseover', () => {
      clearTimeout(hideSubredditGroupDropdownTimer);
    });
    $subredditGroupDropdown.on('click', '.edit', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
    });
    $subredditGroupDropdown.on('click', '.delete', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
      deleteButton.click();
    });
  }

  jquery_default()(subredditGroupDropdownUL).find('li:not(.RESShortcutsEditButtons)').remove();

  if (subreddits) {
    const $rows = subreddits.reduce(($collection, subreddit) => {
      const $thisLI = jquery_default()(`<li><a href="/r/${subreddit}${suffix}">${subreddit}<span class="shortcutSuffix">${suffix}</span></a></li>`);

      if (isCurrentSubreddit(subreddit)) {
        $thisLI.addClass('RESShortcutsCurrentSub');
      }

      return $collection.add($thisLI);
    }, jquery_default()());
    jquery_default()(subredditGroupDropdownUL).prepend($rows);
  }

  const {
    left
  } = jquery_default()(obj).offset();
  const {
    bottom
  } = document.querySelector('#sr-header-area').getBoundingClientRect();
  $subredditGroupDropdown.css({
    top: `${bottom}px`,
    left: `${left}px`
  }).show();
}

function hideSubredditGroupDropdown() {
  hideSubredditGroupDropdownTimer = undefined;

  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }
}

function editSubredditShortcut(ele, event) {
  const subreddit = ele.getAttribute('data-subreddit');
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit === subreddit);

  if (!$editShortcutDialog) {
    $editShortcutDialog = jquery_default()('<div>', {
      id: 'editShortcutDialog'
    }).appendTo(document.body);
  }

  const unsortable = !subreddit.includes('+');
  const thisForm = `
		<form name="editSubredditShortcut">
			<h3>Edit Shortcut</h3>
			<div id="editShortcutClose" class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESFormItem">
				<label for="subreddit">Subreddit:</label>
				<div class="RESFieldItem">
					<input type="text" name="subreddit" value="${subreddit}" id="shortcut-subreddit" class="${unsortable ? 'unsortable' : ''}"><!-- no whitespace
					--><button type="submit" id="sortButton" title="Sort subreddits">A-Z</button>

					<div class="RESDescription">Put a + between subreddits to make a drop-down menu.<br/>Put ?+ to make subreddits after it only show in dropdown.</div>
				</div>
			</div>
			<div class="RESFormItem">
				<label for="displayName">Display Name:</label>
				<div class="RESFieldItem">
					<input type="text" name="displayName" value="${ele.textContent}" id="shortcut-displayname">
				</div>
			</div>
			<input type="hidden" name="idx" value="${idx}">
			<button type="button" name="shortcut-save" id="shortcut-save">save</button>
			<button type="button" name="shortcut-delete" id="shortcut-delete">delete</button>
		</form>
	`;
  $editShortcutDialog.html(thisForm);
  $editShortcutDialog.find('#shortcut-subreddit').on('keyup', throttle_default()(({
    currentTarget: shortcut
  }) => {
    if (!shortcut.value.includes('+')) {
      shortcut.classList.add('unsortable');
    } else {
      shortcut.classList.remove('unsortable');
    }
  }, 500));
  const subredditInput = $editShortcutDialog.find('input[name=subreddit]').get(0);
  const displayNameInput = $editShortcutDialog.find('input[name=displayName]').get(0);
  $editShortcutDialog.find('FORM').on('submit', e => e.preventDefault());
  const saveButton = $editShortcutDialog.find('button[name=shortcut-save]').click(() => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();
    const subreddit = $editShortcutDialog.find('input[name=subreddit]').val();
    const displayName = $editShortcutDialog.find('input[name=displayName]').val();
    saveSubredditShortcut(subreddit, displayName, idx);
    $editShortcutDialog.hide();
  }).get(0);
  deleteButton = $editShortcutDialog.find('button[name=shortcut-delete]').get(0);
  deleteButton.addEventListener('click', () => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();

    if (confirm('Are you sure you want to delete this shortcut?')) {
      saveSubredditShortcut('', '', idx);
      $editShortcutDialog.hide();
    }
  });

  function sortSubmenu(e) {
    const inputEl = $editShortcutDialog.find('input[name=subreddit]').get(0);
    const currStr = inputEl.value;
    const ascArr = currStr.split('+');
    ascArr.sort();
    const ascStr = ascArr.join('+');
    const descArr = ascArr;
    descArr.reverse();
    const descStr = descArr.join('+');
    let btnTxt;

    if (e.target instanceof HTMLButtonElement && e.target.type === 'submit') {
      inputEl.value = currStr === ascStr ? descStr : ascStr;
      btnTxt = currStr === ascStr ? 'A-Z' : 'Z-A';
    } else {
      btnTxt = currStr === ascStr ? 'Z-A' : 'A-Z';
    }

    jquery_default()('#sortButton').text(btnTxt);
  }

  $editShortcutDialog.find('#sortButton').click(sortSubmenu);
  $editShortcutDialog.find('input[name=subreddit]').on('change', sortSubmenu);
  subredditInput.addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Enter) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  subredditInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      click(saveButton);
    }
  });
  displayNameInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      click(saveButton);
    }
  });
  $editShortcutDialog.find('#editShortcutClose').click(() => {
    $editShortcutDialog.hide();
  });
  $editShortcutDialog.show();
  const thisLeft = Math.min(event.clientX, window.innerWidth - ($editShortcutDialog.get(0).offsetWidth + 20));
  $editShortcutDialog.css('left', `${thisLeft}px`);
  setTimeout(() => subredditInput.focus(), 200);
}

async function saveSubredditShortcut(subreddit, displayName, idx) {
  if (subreddit === '' || displayName === '') {
    subreddit = mySubredditShortcuts[idx].subreddit;
    await removeSubredditShortcut(subreddit);
  } else {
    mySubredditShortcuts[idx] = {
      subreddit,
      displayName,
      addedDate: Date.now()
    };
    saveLatestShortcuts();
  }

  redrawShortcuts();
}

const followSubredditShortcut = debounce_default()(url => {
  location.href = url;
}, 300);

let dragSrcEl, srDataTransfer;

function subredditDragStart(e) {
  followSubredditShortcut.cancel();
  this.style.opacity = '0.4';
  dragSrcEl = this;

  if (subredditManager_module.options.dragDropDelete.value) {
    addTrashBin(dragSrcEl);
  }

  e.dataTransfer.effectAllowed = 'move';
  srDataTransfer = `${this.getAttribute('orderIndex')},${jquery_default()(this).data('subreddit')}`;
}

function subredditDragEnter() {
  this.classList.add('srOver');
  return false;
}

function subredditDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault();
  }

  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }

  e.dataTransfer.dropEffect = 'move';
  return false;
}

function subredditDragLeave() {
  this.classList.remove('srOver');
  return false;
}

function subredditDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }

  e.preventDefault();

  if (dragSrcEl !== this) {
    if (e.target.getAttribute('id') !== 'res-shortcut-trash') {
      const theData = srDataTransfer.split(',');
      const srcOrderIndex = parseInt(theData[0], 10);
      const srcSubreddit = mySubredditShortcuts[srcOrderIndex];
      const destOrderIndex = parseInt(this.getAttribute('orderIndex'), 10);
      const destSubreddit = mySubredditShortcuts[destOrderIndex];
      const rearranged = [];
      let rearrangedI = 0;
      mySubredditShortcuts.forEach((shortcut, i) => {
        if (i !== srcOrderIndex && i !== destOrderIndex) {
          rearranged[rearrangedI] = shortcut;
          rearrangedI++;
        } else if (i === destOrderIndex) {
          if (destOrderIndex > srcOrderIndex) {
            rearranged[rearrangedI] = destSubreddit;
            rearrangedI++;
            rearranged[rearrangedI] = srcSubreddit;
            rearrangedI++;
          } else {
            rearranged[rearrangedI] = srcSubreddit;
            rearrangedI++;
            rearranged[rearrangedI] = destSubreddit;
            rearrangedI++;
          }
        }
      });
      mySubredditShortcuts = rearranged;
      saveLatestShortcuts();
      redrawShortcuts();
    } else {
      const theData = srDataTransfer.split(',');
      const srcSubreddit = theData[1];
      removeSubredditShortcut(srcSubreddit);
    }
  }

  return false;
}

function subredditDragEnd() {
  this.style.opacity = '1';
  this.classList.remove('srOver');

  if (subredditManager_module.options.dragDropDelete.value) {
    removeTrashBin();
  }

  return false;
}

async function createSubredditBar(headerContents) {
  const originalShortcuts = Array.from(document.querySelectorAll('.sr-list a.choice'));
  const myRandom = subredditManager_module.options.linkMyRandom.value && originalShortcuts.find(({
    pathname
  }) => pathname === '/r/myrandom/');
  const myRandomGold = myRandom && myRandom.classList.contains('gold');
  const users = subredditManager_module.options.linkUsers.value && originalShortcuts.find(({
    pathname
  }) => pathname === '/users/');
  const originalFrontpage = originalShortcuts.find(({
    pathname
  }) => pathname === '/');
  const originalPopular = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/popular/');
  const originalProfilePosts = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/profileposts/');
  empty(headerContents);
  await initialShortcutsLoad();
  const user = loggedInUser();
  const staticShortcutsHTML = [subredditManager_module.options.linkDashboard.value && '<a class="subbarlink" href="/r/Dashboard/">Dashboard</a>', subredditManager_module.options.linkFront.value && originalFrontpage && `<a class="subbarlink" href="/">${originalFrontpage.textContent}</a>`, subredditManager_module.options.linkPopular.value && originalPopular && `<a class="subbarlink" href="/r/popular/">${originalPopular.textContent}</a>`, subredditManager_module.options.linkProfilePosts.value && originalProfilePosts && `<a class="subbarlink" href="/r/profileposts/">${originalProfilePosts.textContent}</a>`, subredditManager_module.options.linkAll.value && '<a class="subbarlink" href="/r/all/">All</a>', subredditManager_module.options.linkRandom.value && '<a class="subbarlink" href="/r/random/">Random</a>', subredditManager_module.options.linkMyRandom.value && myRandom && `<a class="subbarlink ${myRandomGold ? 'gold' : ''}" href="/r/myrandom/">MyRandom</a>`, subredditManager_module.options.linkUsers.value && users && '<a class="subbarlink" href="/users/">Users</a>', subredditManager_module.options.linkRandNSFW.value && '<a class="over18 subbarlink" href="/r/randnsfw/">RandNSFW</a>', user && [subredditManager_module.options.linkFriends.value && '<a class="subbarlink" href="/r/friends/">Friends</a>', isModeratorAnywhere() && [subredditManager_module.options.linkMod.value && '<a class="subbarlink" href="/r/mod/">Mod</a>', subredditManager_module.options.linkModqueue.value && '<a class="subbarlink" href="/r/mod/about/modqueue">Modqueue</a>'], subredditManager_module.options.linkSaved.value && `<a class="subbarlink" href="/user/${user}/saved">Saved</a>`], subredditManager_module.options.buttonEdit.value && `${makeUrlHashLink(subredditManager_module.moduleID, '', 'edit', 'subbarlink res-sr-options-link')}`].flat(3).filter(Boolean).join('<span class="separator">-</span>');
  headerContents.append(...string_namespaceObject.html`<span>
		<div id="srLeftContainer" class="sr-bar">
			<div id="srDropdown">
					<div id="srDropdownContainer"><a href="javascript:void 0">My Subreddits</a></div>
			</div>
			<div id="RESStaticShortcuts"><span class="separator">-</span>${string_namespaceObject.safe(staticShortcutsHTML)}</div>
			<span class="srSep">|</span>
		</div>
		<div id="RESShortcutsViewport">
			<div id="RESShortcuts" class="sr-bar"></div>
		</div>
		<div id="RESShortcutsEditContainer">
			<div id="RESShortcutsSort" title="sort subreddit shortcuts"></div>
			<div id="RESShortcutsRight">&gt;</div>
			<div id="RESShortcutsAdd" class="res-icon" title="add shortcut"></div>
			<div id="RESShortcutsLeft">&lt;</div>
		</div>
	</span>`.children);
  headerContents.querySelector('#srDropdownContainer').addEventListener('click', e => {
    e.stopImmediatePropagation();
    toggleSubredditDropdown();
  });
  shortcutsContainer = headerContents.querySelector('#RESShortcuts');
  const choice = [...headerContents.querySelectorAll('.subbarlink:not(.res-sr-options-link)')].find(link => link instanceof HTMLAnchorElement && fullLocation(link.pathname) === fullLocation());
  if (choice) choice.classList.add('RESShortcutsCurrentSub');
  const shortcutsEditContainer = document.createElement('div');
  shortcutsEditContainer.classList.add('res-sr-edit');
  headerContents.querySelector('#RESShortcutsSort').addEventListener('click', async ({
    currentTarget
  }) => {
    const menu = sortMenu();
    document.body.append(menu);
    const {
      bottom,
      left
    } = currentTarget.getBoundingClientRect();
    menu.style.top = `${bottom}px`;
    menu.style.left = `${Math.min(document.body.getBoundingClientRect().width - menu.getBoundingClientRect().width, left)}px`;
    await waitForEvent(menu, 'mouseleave');
    menu.remove();
  });
  const addButton = headerContents.querySelector('#RESShortcutsAdd');
  addButton.addEventListener('click', () => {
    toggleShortCutsAddForm();
  });
  const leftButton = headerContents.querySelector('#RESShortcutsLeft');
  leftButton.addEventListener('click', () => {
    const firstChild = shortcutsContainer.firstChild;
    const containerMargin = parseInt(firstChild.style.marginLeft, 10) || 0;
    const shiftWidth = Math.floor(jquery_default()('#RESShortcutsViewport').width()) - 80;
    const marginLeft = containerMargin + shiftWidth;

    if (marginLeft <= 0) {
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
  const rightButton = headerContents.querySelector('#RESShortcutsRight');
  rightButton.addEventListener('click', () => {
    const firstChild = shortcutsContainer.firstChild;
    let marginLeft = firstChild.style.marginLeft;
    marginLeft = parseInt(marginLeft.replace('px', ''), 10);
    if (isNaN(marginLeft)) marginLeft = 0;
    const shiftWidth = jquery_default()('#RESShortcutsViewport').width() - 80;

    if (shortcutsContainer.offsetWidth > shiftWidth) {
      marginLeft -= shiftWidth;
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
  redrawShortcuts();
}

const trashBin = lodash_once_default()(() => {
  const $title = jquery_default()('<div>', {
    class: 'res-shortcut-trash-title'
  });
  const $trashZone = jquery_default()('<div>', {
    id: 'res-shortcut-trash-zone',
    class: 'res-icon'
  });
  const shortCutsTrash = $trashZone.get(0);
  shortCutsTrash.addEventListener('dragenter', subredditDragEnter);
  shortCutsTrash.addEventListener('dragleave', subredditDragLeave);
  shortCutsTrash.addEventListener('dragover', subredditDragOver);
  shortCutsTrash.addEventListener('drop', subredditDrop);
  const $wrapper = jquery_default()('<div>', {
    id: 'res-shortcut-trash'
  }).append($title, $trashZone, jquery_default()('<div>', {
    id: 'res-dragDrop-tip',
    text: 'Did you know? You can arrange shortcuts by dragging them left & right along the top bar.'
  }));
  return {
    $wrapper,
    $trashZone,
    $title
  };
});

function toggleShortCutsAddForm() {
  let shortCutsAddFormContainer = document.querySelector('RESShortcutsAddFormContainer');

  const close = () => shortCutsAddFormContainer.remove();

  if (shortCutsAddFormContainer) {
    close();
    return;
  }

  shortCutsAddFormContainer = document.createElement('div');
  shortCutsAddFormContainer.setAttribute('id', 'RESShortcutsAddFormContainer');
  shortCutsAddFormContainer.append(string_namespaceObject.html`
		<form id="shortCutsAddForm">
			<div><strong>Add Shortcut</strong></div>
			<div class="res-shortcuts-add-tip">Put a &plus; between subreddits to make a multireddit.</div>
			<div><label for="newShortcut">Subreddit:</label><input type="text" id="newShortcut"></div>
			<div><label for="displayName">Display Name:</label><input type="text" id="displayName"></div>
			<input type="submit" name="submit" value="add" id="addSubreddit">
			<div class="res-shortcuts-add-footer"><a href="/subreddits/">manage subscribed</a></div>
		</form>
	`);
  const shortCutsAddFormField = shortCutsAddFormContainer.querySelector('#newShortcut');
  const shortCutsAddFormFieldDisplayName = shortCutsAddFormContainer.querySelector('#displayName');
  shortCutsAddFormField.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) close();
  });
  shortCutsAddFormFieldDisplayName.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) close();
  });
  const shortCutsAddForm = shortCutsAddFormContainer.querySelector('#shortCutsAddForm');
  shortCutsAddForm.addEventListener('submit', e => {
    e.preventDefault();
    let subreddit = shortCutsAddFormField.value;
    let displayname = shortCutsAddFormFieldDisplayName.value;
    if (displayname === '') displayname = subreddit;
    subreddit = subreddit.replace(/^\/?r\//i, '');

    if (subreddit) {
      addSubredditShortcut(subreddit, displayname);
    }

    close();
  });
  document.body.append(shortCutsAddFormContainer);
  shortCutsAddFormField.focus();

  if (subredditManager_module.options.dragDropDelete.value) {
    const trashOpenLink = string_namespaceObject.html`<a class="res-trash-open" href="javascript: void 0" title="Choose which shortcuts to remove"><span class="res-icon">&#xF155;</span> remove shortcuts...</a>`;
    jquery_default()('#RESShortcutsAddFormContainer .res-shortcuts-add-footer').prepend(trashOpenLink, ' | ');
    trashOpenLink.addEventListener('click', () => {
      addTrashBin();
    });
  }
}

const $pageOverlay = lodash_once_default()(() => {
  const srHeaderArea = document.querySelector('#sr-header-area');
  return jquery_default()('<div>', {
    id: 'res-trash-overlay'
  }).css({
    top: `${srHeaderArea.offsetHeight}px`
  }).click(() => removeTrashBin());
});

function addTrashBin(shortcut) {
  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }

  if (shortcut) {
    trashBin().$title.html(string_namespaceObject.escape`Drop here to delete shortcut <strong>${jquery_default()(shortcut).text()}</strong>`);
  } else {
    trashBin().$title.text('Drag and drop shortcuts to delete them');
  }

  trashBin().$wrapper.appendTo(document.body).show();
  $pageOverlay().appendTo(document.body).show();
}

function removeTrashBin() {
  $pageOverlay().hide();
  trashBin().$wrapper.hide();
  trashBin().$trashZone.removeClass('srOver');
}

const sortMenu = lodash_once_default()(() => {
  const element = string_namespaceObject.html`
	<div id="sort-menu" style="display: block" class="drop-choices">
		<p>&nbsp;sort by:</p>
		<a class="choice" data-field="displayName" href="javascript:void 0">display name</a>
		<a class="choice" data-field="addedDate" href="javascript:void 0">added date</a>
	</div>`;
  let lastField;
  jquery_default()(element).find('a').click(({
    currentTarget
  }) => {
    const field = currentTarget.dataset.field;
    const sameField = lastField === field;
    lastField = field;
    sortShortcuts(sameField ? null : field, sameField);
  });
  return element;
});

function sortShortcuts(field, reverse) {
  if (field) mySubredditShortcuts.sort((a, b) => String(a[field]).localeCompare(String(b[field]), undefined, {
    numeric: true,
    sensitivity: 'base'
  }));
  if (reverse) mySubredditShortcuts.reverse();
  redrawShortcuts();
  saveLatestShortcuts();
}

const srList = lodash_once_default()(async () => {
  const element = document.createElement('div');
  element.id = 'srList';
  const user = loggedInUser();

  if (!user) {
    element.append(string_namespaceObject.html`<div>You must be logged in to load your own list of subreddits. <a style="display: inline; float: left;" href="/subreddits/">browse them all</a></div>`);
    return element;
  }

  element.append(string_namespaceObject.html`<div>Loading subreddits (may take a moment)...</div>`);

  try {
    const table = await getMySubredditsTable(user);
    empty(element);
    element.append(string_namespaceObject.html`<a style="float: right;" href="/subreddits/">View all &raquo;</a>`, table);
  } catch (e) {
    console.error(e);
    element.append(string_namespaceObject.html`<span>There was an error getting your subreddits. You may have third party cookies disabled by your browser. For this function to work, you\'ll need to add an exception for cookies from reddit.com'</span>`);
  }

  return element;
});

async function toggleSubredditDropdown(e) {
  const ele = await srList();
  if (ele && e && (ele.contains(e.target) || !document.contains(e.target))) return;

  if (document.body.contains(ele)) {
    ele.remove();
    document.body.removeEventListener('click', toggleSubredditDropdown);
  } else {
    document.body.append(ele);
    document.body.addEventListener('click', toggleSubredditDropdown);
  }
}

async function getMySubredditsTable(user) {
  const headers = {
    subreddit: 'subreddit',
    ...(subredditManager_module.options.storeSubredditVisit.value ? {
      lastVisited: 'Last Visited'
    } : {}),
    shortcutToggle: ''
  };
  const mySubreddits = new Map();
  let after = '';

  do {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine.json',
      query: {
        after,
        limit: 100,
        user
      },
      type: 'json',
      cacheFor: DAY
    });

    if (data && data.children) {
      for (const {
        data: sub
      } of data.children) mySubreddits.set(sub.display_name, sub);

      after = data.after;
    } else if (!after) {
      throw new Error('No subreddits feched?');
    }
  } while (after);

  const subredditsLastViewed = await subredditsLastViewedStorage.get();
  const data = [...mySubreddits.values()];
  const table = new table_namespaceObject.RESTable(headers, data, ({
    display_name: displayName,
    url
  }) => {
    const lv = subredditsLastViewed[displayName.toLowerCase()];
    const ts = lv && parseInt(lv.last_visited, 10);
    const theLV = document.createElement('span');

    if (ts) {
      const dateVisited = new Date(ts);
      theLV.textContent = formatRelativeTime(dateVisited);
      theLV.setAttribute('title', formatDate(dateVisited));
    } else {
      theLV.textContent = 'N/A';
    }

    const shortcutToggle = createShortcutToggleButton(displayName);
    shortcutToggle.className = '';
    return {
      subreddit: string_namespaceObject.html`<a href="${url}">${displayName}</a>`,
      lastVisited: theLV,
      shortcutToggle
    };
  }, {
    pageSize: Infinity,
    sortBy: 'subreddit'
  });
  const ele = document.createElement('div');
  ele.append(table.createSearchElement(({
    display_name: displayName
  }) => displayName, i18n('subredditManagerFilterPlaceholder'), true), table.element);
  return ele;
}

async function getMultiCounts(displayName) {
  if (!subredditManager_module.options.displayMultiCounts.value) return '';
  const user = loggedInUser();
  if (!user) return '';
  const multis = await ajax({
    url: `/api/multi/user/${user}`,
    type: 'json',
    cacheFor: DAY
  });
  const count = multis.filter(multi => multi.data.subreddits.some(sr => sr.name === displayName)).length;
  if (count) return string_namespaceObject.escape`<span class="multi-count" title="${i18n('subredditManagerMultiCountTitle', displayName, count)}">${count}</span>`;else return '';
}

function saveLatestShortcuts() {
  subredditShortcutsStorage.set(mySubredditShortcuts || []);
}

async function addSubredditShortcut(subreddit, displayname) {
  await loadShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    alert_namespaceObject.open('Whoops, you already have a shortcut for that subreddit');
  } else {
    displayname = displayname || subreddit;
    const subredditObj = {
      subreddit,
      displayName: displayname.toLowerCase(),
      addedDate: Date.now()
    };
    mySubredditShortcuts.push(subredditObj);
    saveLatestShortcuts();
    redrawShortcuts();
    notifications_showNotification({
      moduleID: 'subredditManager',
      message: 'Subreddit shortcut added. You can edit by double clicking the shortcut.'
    });
  }
}

async function removeSubredditShortcut(subreddit) {
  await loadShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    mySubredditShortcuts.splice(idx, 1);
    saveLatestShortcuts();
    redrawShortcuts();
  }
}

function setLastViewtime(subreddit) {
  if (!subredditManager_module.options.storeSubredditVisit.value) return;
  if (!subredditManager_module.options.storeSubredditVisitIncognito.value && isPrivateBrowsing()) return;
  subredditsLastViewedStorage.patch({
    [subreddit.toLowerCase()]: {
      last_visited: Date.now()
    }
  });
}

function subscribeToSubreddit(subredditName, subscribe = true) {
  return ajax({
    method: 'POST',
    url: '/api/subscribe',
    data: {
      sr: subredditName,
      action: subscribe ? 'sub' : 'unsub'
    }
  });
}

async function subredditManager_lastUpdate() {
  const mySubredditList = jquery_default()('.drop-choices.srdrop a').map(function () {
    return this.textContent;
  }).toArray().join();
  const mySubredditListCachedObject = (await session_namespaceObject.get('RESmodules.subredditManager.mySubredditList')) || {};
  const mySubredditListCached = mySubredditListCachedObject[loggedInUser() || 'null'];

  let _lastUpdate;

  if (mySubredditListCached && mySubredditListCached.list === mySubredditList) {
    _lastUpdate = parseInt((new Date().getTime() - mySubredditListCached.time) / 60000, 10);

    if (_lastUpdate > 31) {
      _lastUpdate = false;
      mySubredditListCached.time = new Date().getTime() - 32 * 60000;
    } else {
      _lastUpdate += _lastUpdate > 1 ? ' minutes ago' : ' minute ago';
    }
  } else {
    mySubredditListCachedObject[loggedInUser() || 'null'] = {
      list: mySubredditList,
      time: new Date().getTime()
    };
    _lastUpdate = 'just now';
  }

  if (_lastUpdate !== false && mySubredditListCached) {
    jquery_default()('.listing-chooser a:first .description').after(`<br /><span class="description"><b>last update:</b><br />${_lastUpdate}</span>`);
  }

  const inactiveThreshold = new Date().getTime() - 2592000000;

  for (const [user, cachedObject] of Object.entries(mySubredditListCachedObject)) {
    if (cachedObject.time < inactiveThreshold) {
      delete mySubredditListCachedObject[user];
    }
  }

  session_namespaceObject.set('RESmodules.subredditManager.mySubredditList', mySubredditListCachedObject);
}
// CONCATENATED MODULE: ./lib/modules/betteReddit.js











const betteReddit_module = new Module('betteReddit');
betteReddit_module.moduleName = 'betteRedditName';
betteReddit_module.category = 'appearanceCategory';
betteReddit_module.description = 'betteRedditDesc';
betteReddit_module.options = {
  commentsLinksNewTabs: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentsLinksNewTabDesc',
    title: 'betteRedditCommentsLinksNewTabTitle'
  },
  fixHideLinks: {
    type: 'boolean',
    value: true,
    description: 'betteRedditFixHideLinksDesc',
    title: 'betteRedditFixHideLinksTitle'
  },
  hideLinkInstant: {
    type: 'boolean',
    value: false,
    description: 'betteRedditHideLinkInstantDesc',
    title: 'betteRedditHideLinkInstantTitle',
    dependsOn: options => options.fixHideLinks.value
  },
  hideLinkFadeDelay: {
    type: 'text',
    value: '5000',
    description: 'betteRedditHideLinkFadeDelayDesc',
    title: 'betteRedditHideLinkFadeDelayTitle',
    advanced: true,
    dependsOn: options => options.fixHideLinks.value && !options.hideLinkInstant.value
  },
  videoTimes: {
    type: 'boolean',
    value: true,
    description: 'betteRedditVideoTimesDesc',
    title: 'betteRedditVideoTimesTitle',
    advanced: true
  },
  videoUploaded: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoUploadedDesc',
    title: 'betteRedditVideoUploadedTitle',
    advanced: true
  },
  videoViewed: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoViewedDesc',
    title: 'betteRedditVideoViewedTitle',
    advanced: true
  },
  pinHeader: {
    type: 'enum',
    values: [{
      name: 'None',
      value: 'none'
    }, {
      name: 'Subreddit Bar only',
      value: 'sub'
    }, {
      name: 'User Bar',
      value: 'userbar'
    }, {
      name: 'Subreddit Bar and User bar',
      value: 'subanduser'
    }, {
      name: 'Full Header',
      value: 'header'
    }],
    value: 'none',
    description: 'betteRedditPinHeaderDesc',
    title: 'betteRedditPinHeaderTitle',
    bodyClass: 'pinHeader'
  },
  showLastEditedTimestamp: {
    type: 'boolean',
    value: true,
    description: 'betteRedditShowLastEditedTimestampDesc',
    title: 'betteRedditShowLastEditedTimestampTitle',
    bodyClass: true
  },
  scoreHiddenTimeLeft: {
    type: 'boolean',
    value: true,
    description: 'betteRedditScoreHiddenTimeLeftDesc',
    title: 'betteRedditScoreHiddenTimeLeftTitle'
  },
  showTimestampPosts: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampPostsDesc',
    title: 'betteRedditShowTimestampPostsTitle',
    bodyClass: true
  },
  showTimestampComments: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampCommentsDesc',
    title: 'betteRedditShowTimestampCommentsTitle',
    bodyClass: true
  },
  showTimestampSidebar: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampSidebarDesc',
    title: 'betteRedditShowTimestampSidebarTitle',
    bodyClass: true
  },
  showTimestampWiki: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampWikiDesc',
    title: 'betteRedditShowTimestampWikiTitle',
    bodyClass: true
  },
  showTimestampModerationLog: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampModerationLogDesc',
    title: 'betteRedditShowTimestampModerationLogTitle',
    bodyClass: true
  },
  restoreSavedTab: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestoreSavedTabDesc',
    title: 'betteRedditRestoreSavedTabTitle'
  },
  doNoCtrlF: {
    type: 'boolean',
    value: false,
    description: 'betteRedditDoNoCtrlFDesc',
    title: 'betteRedditDoNoCtrlFTitle'
  },
  showHiddenSortOptions: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowHiddenSortOptionsDesc',
    title: 'betteRedditShowHiddenSortOptionsTitle',
    bodyClass: true
  },
  truncateLongLinks: {
    type: 'boolean',
    value: false,
    description: 'betteRedditTruncateLongLinksDesc',
    title: 'betteRedditTruncateLongLinksTitle',
    bodyClass: true
  },
  commentCollapseInInbox: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentCollapseInInboxDesc',
    title: 'betteRedditCommentCollapseInInboxTitle',
    bodyClass: true
  },
  restrictScrollEvents: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestrictScrollEventsDesc',
    title: 'betteRedditRestrictScrollEventsTitle',
    advanced: true
  }
};
betteReddit_module.exclude = ['d2x'];

betteReddit_module.beforeLoad = () => {
  if (betteReddit_module.options.commentsLinksNewTabs.value) {
    watchForThings(['comment'], comment => {
      const body = comment.getTextBody();
      if (body) for (const link of body.querySelectorAll('a')) commentsLinksNewTabs(link);
    });
  }

  if (betteReddit_module.options.fixHideLinks.value) {
    watchForThings(['post'], fixHideLinks);
  }

  if (betteReddit_module.options.doNoCtrlF.value) {
    watchForElements(['page'], '.side a.reddit-comment-link', applyNoCtrlF);
    watchForThings(null, thing => {
      for (const link of thing.entry.querySelectorAll('ul.flat-list.buttons li a')) applyNoCtrlF(link);
    });
  }

  if (betteReddit_module.options.videoTimes.value || betteReddit_module.options.videoUploaded.value || betteReddit_module.options.videoViewed.value) {
    watchForThings(['post'], thing => {
      if (thing.isVisible()) fetchVideoData(thing);
    }, {
      immediate: true
    });
    watchForThings(['post'], showVideoData);
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'userbar':
      _addHeaderId('header-bottom-right', true);

      break;

    case 'sub':
      _addHeaderId('sr-header-area');

      break;

    case 'subanduser':
      _addHeaderId('sr-header-area');

      _addHeaderId('header-bottom-right', true);

      break;

    case 'header':
      _addHeaderId('header');

      break;

    case 'none':
    default:
      break;
  }

  if (betteReddit_module.options.restrictScrollEvents.value) {
    const scr = document.createElement('script');
    scr.innerHTML = `{
			// Prevents overzealous Reddit scroll listeners from constantly mutating the DOM while scrolling
			let debounce, lastEvent;
			window.addEventListener('scroll', e => {
				if (!debounce)  debounce = _.debounce(e => window.dispatchEvent(e), 300);
				if (e === lastEvent) return;
				lastEvent = e;
				debounce(e);
				e.stopImmediatePropagation();
			}, true);
		}`;
    document.documentElement.append(scr);
  }
};

betteReddit_module.contentStart = () => {
  if (betteReddit_module.options.scoreHiddenTimeLeft.value && isPageType('comments', 'commentsLinklist')) {
    jquery_default()('.sitetable').on('mouseenter', '.score-hidden', function () {
      const timeNode = jquery_default()(this).siblings('time').get(0);

      if (timeNode) {
        if (!this.getAttribute('title').includes('revealed')) {
          const scoreHiddenDuration = parseInt(this.getAttribute('title').match(/[0-9]+/)[0], 10);
          const postTime = new Date(timeNode.getAttribute('datetime')).getTime();
          const minutesLeft = Math.ceil((postTime + scoreHiddenDuration * 60000 - new Date().getTime()) / 60000);

          if (minutesLeft >= 1) {
            this.setAttribute('title', `score will be revealed in ${minutesLeft} minute${minutesLeft > 1 ? 's' : ''}`);
          } else {
            this.setAttribute('title', 'reload page to reveal score');
          }
        }
      }
    });
  }

  const user = loggedInUser();

  if (betteReddit_module.options.restoreSavedTab.value && user && document.querySelector('.with-listing-chooser:not(.profile-page)')) {
    restoreSavedTab(user);
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'header':
      betteReddit_pinHeader();
      break;

    case 'sub':
      pinSubredditBar();
      break;

    case 'subanduser':
      pinSubredditBar();
      pinUserBar();
      break;

    case 'userbar':
      pinUserBar();
      break;

    default:
      break;
  }
};

function commentsLinksNewTabs(link) {
  link.target = '_blank';
  link.rel = 'noopener noreferer';
}

function fixHideLinks(thing) {
  const orig = thing.getHideElement();
  if (!orig) return;
  const a = document.createElement('a');
  a.className = 'noCtrlF';
  a.href = 'javascript:void 0';
  a.dataset.eventAction = orig.dataset.eventAction;
  a.dataset.text = i18n(orig.dataset.eventAction === 'hide' ? 'betteRedditHideLinkLabel' : 'betteRedditUnhideLinkLabel');
  a.addEventListener('click', () => betteReddit_hideLink(a));
  orig.replaceWith(a);
}

const betteReddit_hideTimer = new Map();

async function betteReddit_hideLink(clickedLink, action = clickedLink.dataset.eventAction) {
  const timeout = betteReddit_module.options.hideLinkInstant.value ? null : parseInt(betteReddit_module.options.hideLinkFadeDelay.value, 10);
  const thing = Thing_Thing.checkedFrom(clickedLink);

  if (action === 'hide') {
    const expando = expando_Expando.getEntryExpandoFrom(thing);
    if (expando && expando.types.includes('native')) expando.collapse();

    if (timeout === null) {
      if (!isPageType('comments')) jquery_default()(thing.element).hide();
    } else {
      betteReddit_hideTimer.set(clickedLink, setTimeout(() => {
        if (clickedLink.dataset.eventAction === action) return;
        jquery_default()(thing.element).fadeOut(300);
      }, timeout));
    }
  }

  try {
    if (action === 'hide') await thingHide_hide(thing);else await unhide(thing);
  } catch (e) {
    alert_namespaceObject.open(i18n(action === 'hide' ? 'betteRedditHideSubmissionError' : 'betteRedditUnhideSubmissionError'));
    jquery_default()(thing.element).show();
    throw e;
  }
}

const fetchVideoData = memoize_default()(thing => {
  const url = new URL(thing.getPostUrl(), location.origin);
  if (!youtube.domains.some(domain => url.hostname.endsWith(domain))) return;
  const [id] = youtube.detect(url) || [];
  if (id) return youtube.getVideoData && youtube.getVideoData(id);
});

async function showVideoData(thing) {
  const data = await fetchVideoData(thing);
  if (!data) return;
  const {
    title,
    duration,
    publishedAt,
    viewCount
  } = data;
  const link = thing.getPostLink();
  const info = [];

  if (betteReddit_module.options.videoUploaded.value) {
    const uploaded = new Date(publishedAt);
    const dt = `${uploaded.toDateString()} ${uploaded.toTimeString()}`;
    const timeAgo = i18n('submitHelperTimeAgo', formatDateDiff(uploaded));
    info.push(`[<time title="${dt}" datetime="${publishedAt}" class="live-timestamp">${timeAgo}</time>]`);
  }

  if (betteReddit_module.options.videoViewed.value && viewCount) {
    info.push(i18n('betteRedditVideoViewed', viewCount));
  }

  const titleHasTimeRegex = /[\[|\(][0-9]*:[0-9]*[\]|\)]/;
  const getYoutubeStartTimeRegex = /\/?[&|\?]?(?:t|time_continue)=([\w\-][a-z0-9]*)/i;
  const timeMatch = getYoutubeStartTimeRegex.exec(link.href);
  const titleMatch = titleHasTimeRegex.test(link.textContent);
  let startTime;

  if (timeMatch && !titleMatch) {
    const seconds = fromYoutubeTimecodeToSeconds(timeMatch[1]);
    startTime = fromSecondsToTime(seconds);
  }

  if (info.length) {
    link.appendChild(string_namespaceObject.html`<span class="gray pay-link">${string_namespaceObject.safe(info.join(' '))}</span>`);
  }

  link.setAttribute('title', i18n('betteRedditVideoYouTubeTitle', title));

  if (betteReddit_module.options.videoTimes.value) {
    const thumbnail = thing.element.querySelector('a.thumbnail');

    if (thumbnail) {
      thumbnail.appendChild(string_namespaceObject.html`<div class="duration-overlay">${duration}${startTime ? ` (@${startTime})` : ''}</div>`);
    }
  }
}

function fromYoutubeTimecodeToSeconds(tc) {
  let timeSeconds = Number(tc);

  if (Number.isNaN(timeSeconds)) {
    const tcobj = tc.split(/(\d+[hms])/).filter(Boolean).reduce((acc, match) => {
      acc[match.slice(-1)] = Number(match.slice(0, -1));
      return acc;
    }, {});
    timeSeconds = (tcobj.h || 0) * 3600 + (tcobj.m || 0) * 60 + (tcobj.s || 0);
  }

  return timeSeconds;
}

function pinSubredditBar() {
  const sm = isRunning(subredditManager_namespaceObject);
  const sb = document.getElementById('sr-header-area');

  if (!sb) {
    return;
  }

  const header = document.getElementById('header');
  const spacer = document.createElement('div');
  spacer.style.paddingTop = window.getComputedStyle(sb, null).paddingTop;
  spacer.style.paddingBottom = window.getComputedStyle(sb, null).paddingBottom;

  if (sm) {
    spacer.style.height = `${parseInt(window.getComputedStyle(sb, null).height, 10) / 3 - 3}px`;
  } else {
    spacer.style.height = window.getComputedStyle(sb, null).height;
  }

  header.insertBefore(spacer, sb);
  document.body.insertBefore(sb, header);
  addCSS(`
		#header-bottom-left {
			margin-top: 19px;
		}

		div#sr-header-area {
			position: fixed;
			z-index: 10000 !important;
			left: 0;
			right: 0;
		}
	`);
  pinCommonElements(sm);
}

function pinUserBar() {
  const header = document.getElementById('header-bottom-left');
  const userbar = document.getElementById('header-bottom-right');
  window.addEventListener('scroll', debounce_default()(() => {
    if (header.getBoundingClientRect().top > 0) {
      userbar.classList.remove('res-floating-userbar');
    } else {
      userbar.classList.add('res-floating-userbar');
    }
  }, 300));
  pinCommonElements();
}

function betteReddit_pinHeader() {
  const sm = isRunning(subredditManager_namespaceObject);
  const header = document.getElementById('header');

  if (!header) {
    console.error('No element found with ID "header".');
    return;
  }

  const headerHeight = jquery_default()('#header').outerHeight(true);
  addCSS(`
		#header,
		#RESAccountSwitcherDropdown {
			position: fixed;
		}
	`);
  pinCommonElements(sm);
  addCSS(`
		#header {
			top: 0;
			left: 0;
			right: 0;
			bottom: auto;
		}
	`);
  jquery_default()('<div>', {
    id: 'RESPinnedHeaderSpacer',
    height: headerHeight
  }).insertBefore(header);
}

function pinCommonElements(sm) {
  if (sm) {
    addCSS(`
			#RESSubredditGroupDropdown,
			#srList,
			#RESShortcutsAddFormContainer,
			#editShortcutDialog {
				position: fixed !important;
			}
		`);
  } else {
    addCSS(`
			#sr-more-link {
				position: fixed;
			}
		`);
  }
}

function restoreSavedTab(user) {
  createElement_namespaceObject.tabMenuItem({
    text: 'saved',
    onChange: () => {
      location.href = `/user/${user}/saved/`;
    }
  });
}

function applyNoCtrlF(element) {
  if (element.classList.contains('noCtrlF')) return;
  element.classList.add('noCtrlF');
  element.dataset.text = element.textContent;
  element.textContent = '';
}
// CONCATENATED MODULE: ./lib/modules/commentDepth.js



const commentDepth_module = new Module('commentDepth');
commentDepth_module.moduleName = 'commentDepthName';
commentDepth_module.category = 'commentsCategory';
commentDepth_module.disabledByDefault = true;
commentDepth_module.description = 'commentDepthDesc';
commentDepth_module.options = {
  defaultCommentDepth: {
    type: 'text',
    value: '4',
    description: 'commentDepthDefaultCommentDepthDesc',
    title: 'commentDepthDefaultCommentDepthTitle'
  },
  defaultMinimumComments: {
    type: 'text',
    value: '50',
    description: 'commentDepthDefaultMinimumCommentsDesc',
    title: 'commentDepthDefaultMinimumCommentsTitle'
  },
  commentPermalinks: {
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermaLinksDesc',
    title: 'commentDepthCommentPermaLinksTitle'
  },
  commentPermalinksContext: {
    dependsOn: options => options.commentPermalinks.value,
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermalinksContextDesc',
    title: 'commentDepthCommentPermalinksContextTitle'
  },
  subredditCommentDepths: {
    type: 'table',
    addRowText: 'commentDepthAddSubreddit',
    fields: [{
      key: 'subreddits',
      name: 'commentDepthSubreddit',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'commentDepth',
      name: 'commentDepthCommentDepth',
      type: 'text',
      value: '4'
    }, {
      key: 'minimumComments',
      name: 'commentDepthMinimumComments',
      type: 'text',
      value: '50'
    }],
    value: [],
    description: 'commentDepthSubredditCommentDepthsDesc',
    title: 'commentDepthSubredditCommentDepthsTitle'
  }
};

commentDepth_module.contentStart = () => {
  jquery_default()(document.body).on('mousedown', 'a[href*="/comments"]', e => {
    const target = e.currentTarget;
    const url = new URL(target.href, location.href);
    if (url.searchParams.has('depth')) return;

    if (regexes.commentPermalink.test(url.pathname)) {
      if (!commentDepth_module.options.commentPermalinks.value) return;
      if (!commentDepth_module.options.commentPermalinksContext.value && url.searchParams.has('context')) return;
    }

    const matches = execRegexes.comments(url.pathname);
    if (!matches) return;
    const subreddit = matches[1].toLowerCase();
    const [, commentDepth, minimumComments] = commentDepth_module.options.subredditCommentDepths.value.find(([subreddits]) => subreddits.toLowerCase().split(',').includes(subreddit)) || [null, commentDepth_module.options.defaultCommentDepth.value, commentDepth_module.options.defaultMinimumComments.value];
    if (!parseInt(commentDepth, 10)) return;
    const minimumCount = parseInt(minimumComments, 10);

    if (minimumCount) {
      const thing = Thing_Thing.from(e.currentTarget);
      if (thing && thing.isPost() && (thing.getCommentCount() || 0) < minimumCount) return;
    }

    url.searchParams.set('depth', commentDepth);
    target.removeAttribute('data-inbound-url');
    target.href = url.href;
  });
};
// CONCATENATED MODULE: ./lib/modules/commentHidePersistor.js




const commentHidePersistor_module = new Module('commentHidePersistor');
commentHidePersistor_module.moduleName = 'commentHidePerName';
commentHidePersistor_module.category = 'commentsCategory';
commentHidePersistor_module.description = 'commentHidePerDesc';
commentHidePersistor_module.include = ['comments', 'inbox'];
const COLLAPSE_REASON = 'commentHidePersistor';
const commentHidePersistor_currentId = (execRegexes.comments(location.pathname) || [])[2];
const commentHidePersistor_entryStorage = storage_namespaceObject.wrapPrefix('commentHidePersistor.', () => ({
  updateTime: Date.now()
}));
const commentHidePersistor_initial = commentHidePersistor_currentId && commentHidePersistor_entryStorage.get(commentHidePersistor_currentId);

commentHidePersistor_module.beforeLoad = async () => {
  const {
    collapsedThings
  } = (await commentHidePersistor_initial) || {};
  if (!collapsedThings) return;
  watchForThings(['comment'], thing => {
    if (collapsedThings.hasOwnProperty(thing.getFullname())) thing.setCommentCollapse(true, COLLAPSE_REASON);
  }, {
    immediate: true
  });
};

commentHidePersistor_module.contentStart = () => {
  listenToCommentCollapse();
  maybePruneOldEntries('commentHidePersistor', commentHidePersistor_entryStorage);
};

function listenToCommentCollapse() {
  jquery_default()(document.body).on('click', 'a.expand', e => {
    const thing = Thing_Thing.checkedFrom(e.currentTarget);
    const collapsed = thing.isCollapsed();

    if (collapsed) {
      const currentCollapseReason = e.currentTarget.getAttribute('collapse-reason');
      if (currentCollapseReason && currentCollapseReason !== COLLAPSE_REASON) return;
      commentHidePersistor_entryStorage.patch(commentHidePersistor_currentId, {
        collapsedThings: {
          [thing.getFullname()]: true
        },
        updateTime: Date.now()
      });
    } else {
      e.currentTarget.removeAttribute('collapse-reason');
      commentHidePersistor_entryStorage.deletePath(commentHidePersistor_currentId, 'collapsedThings', thing.getFullname());
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/commentPreview.js












const commentPreview_module = new Module('commentPreview');
commentPreview_module.moduleName = 'commentPrevName';
commentPreview_module.category = 'commentsCategory';
commentPreview_module.description = 'commentPrevDesc';
commentPreview_module.options = {
  enableBigEditor: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableBigEditorDesc',
    title: 'commentPreviewEnableBigEditorTitle'
  },
  swapBigEditorLayout: {
    type: 'boolean',
    value: false,
    description: 'commentPreviewSwapBigEditorLayoutDesc',
    title: 'commentPreviewSwapBigEditorLayoutTitle',
    bodyClass: true
  },
  openBigEditor: {
    type: 'keycode',
    value: [69, false, true, false, false],
    description: 'commentPreviewOpenBigEditorDesc',
    title: 'commentPreviewOpenBigEditorTitle'
  },
  draftStyle: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewDraftStyleDesc',
    title: 'commentPreviewDraftStyleTitle',
    advanced: true,
    bodyClass: true
  },
  enableForComments: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForCommentsDesc',
    title: 'commentPreviewEnableForCommentsTitle',
    advanced: true
  },
  enableForPosts: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForPostsDesc',
    title: 'commentPreviewEnableForPostsTitle',
    advanced: true
  },
  enableForWiki: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForWikiDesc',
    title: 'commentPreviewEnableForWikiTitle',
    advanced: true
  },
  enableForSubredditConfig: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForSubredditConfigDesc',
    title: 'commentPreviewEnableForSubredditConfigTitle',
    advanced: true
  },
  enableForBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForBanMessagesDesc',
    title: 'commentPreviewEnableForBanMessagesTitle',
    advanced: true
  },
  sidebarPreview: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewSidebarPreviewDesc',
    title: 'commentPreviewSidebarPreviewTitle',
    advanced: true
  }
};
commentPreview_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'wiki'];
commentPreview_module.exclude = ['d2x', /^\/(?:r\/[\-\w\.]+\/)?wiki\/edit\/config\/automoderator\b/i];
const subredditImages = new Map();
let isWiki, isBan;

commentPreview_module.beforeLoad = () => {
  isWiki = isPageType('wiki');
  isBan = /^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned/i.test(location.href);
  const subreddit = currentSubreddit();
  if (isWiki && subreddit) initWikiImages(subreddit);
};

commentPreview_module.contentStart = () => {
  if (commentPreview_module.options.enableBigEditor.value) {
    jquery_default()(document.body).on('click', '.RESBigEditorPop', showBigEditor);

    if (isRunning(keyboardNav_namespaceObject)) {
      jquery_default()(document.body).on('keydown', '.usertext-edit textarea, #wiki_page_content', e => {
        if (checkKeysForEvent(e, commentPreview_module.options.openBigEditor.value)) {
          showBigEditor(e);
        }
      });
    }
  }

  if (isWiki) {
    attachWikiPreview();
    addBigEditorButton(document.querySelector('.markhelp'));
  } else {
    jquery_default()(document.body).on('focus', commentTextareaSelector, e => {
      addBigEditorButton(e.currentTarget);
      attachPreview(e.currentTarget);
    });
  }
};

async function initWikiImages(subreddit) {
  const {
    data
  } = await ajax({
    url: `/r/${subreddit}/about/stylesheet.json`,
    type: 'json'
  });

  if (data && data.images) {
    for (const {
      name,
      url
    } of data.images) {
      subredditImages.set(name, url);
    }
  }
}

function markdownToHTML(md) {
  if (isBan && md.length) {
    md = generateBanMessage(md, currentSubreddit() || '');
  }

  if (!isWiki) {
    return snudown_es_markdown(md);
  } else {
    const $doc = jquery_default()('<body>').html(markdownWiki(md));

    for (const img of $doc.find('img')) {
      const src = img.getAttribute('src');
      const imgKey = src && src.startsWith('%%') && src.endsWith('%%') && src.slice('%%'.length, -'%%'.length);
      const resolvedSrc = imgKey && subredditImages.get(imgKey);

      if (resolvedSrc) {
        img.src = resolvedSrc;
      } else {
        img.remove();
      }
    }

    const headerIds = new Map();
    const headers = $doc.find('h1, h2, h3, h4, h5, h6');
    const tocDiv = jquery_default()('<div>').addClass('toc');
    let $parent = jquery_default()('<ul>');
    $parent.data('level', 1);
    tocDiv.append($parent);
    let level = 1;
    let previous = 1;
    headers.each(function () {
      const contents = jquery_default()(this).text();
      let aid = jquery_default()('<div>').html(contents).text();
      aid = `${'wiki'}_${aid.replace(/ /g, '_').toLowerCase()}`;
      aid = aid.replace(/[^\w\.\-]/g, s => `.${s.charCodeAt(0).toString(16).toUpperCase()}`);
      const idNum = (headerIds.get(aid) || 0) + 1;
      headerIds.set(aid, idNum);

      if (idNum > 1) {
        aid += idNum;
      }

      jquery_default()(this).attr('id', aid);
      const li = jquery_default()('<li>').addClass(aid);
      const a = jquery_default()('<a>').attr('href', `#${aid}`).text(contents);
      li.append(a);
      const thisLevel = +this.tagName.slice(-1);

      if (thisLevel > previous) {
        const $newUL = jquery_default()('<ul>');
        $newUL.data('level', thisLevel);
        $parent.append($newUL);
        $parent = $newUL;
        level++;
      } else if (thisLevel < previous) {
        while (level > 1 && $parent.data('level') > thisLevel) {
          $parent = $parent.parent();
          level--;
        }
      }

      previous = thisLevel;
      $parent.append(li);
    });
    $doc.prepend(tocDiv);
    return $doc.html();
  }
}

const addBigEditorButton = memoize_default()(ele => {
  if (!commentPreview_module.options.enableBigEditor.value) return;
  const bigEditorButton = preventCloning(string_namespaceObject.html`
		<button type="button" class="RESBigEditorPop" tabIndex="3">
			<span class="res-icon res-icon-12">&#xF0A4;</span> big editor
		</button>
	`);

  if (isBan || isWiki) {
    ele.after(bigEditorButton);
  } else {
    const container = ele.closest('.usertext-edit');
    if (!container) return;
    const bottom = container.querySelector('.bottom-area');
    bottom.prepend(bigEditorButton);
  }
});

const attachPreview = memoize_default()(textarea => {
  if (!commentPreview_module.options.enableForComments.value && textarea.closest('.commentarea, .message') || !commentPreview_module.options.enableForPosts.value && (isPageType('submit') || textarea.closest('.link')) || !commentPreview_module.options.enableForSubredditConfig.value && /^\/r\/[\-\w.]+\/about\/edit/i.test(location.pathname) || !commentPreview_module.options.enableForBanMessages.value && isBan) {
    return;
  }

  const container = textarea.closest('.usertext-edit, #banned');
  if (!container) return;
  const preview = preventCloning(makePreviewBox());
  const elements = [preview.querySelector('.RESDialogContents')];

  if (commentPreview_module.options.sidebarPreview.value && textarea.getAttribute('name') === 'description') {
    elements.push(document.querySelector('.side .usertext-body .md'));
  }

  jquery_default()(textarea).on('input', debounce_default()(() => onTextareaInput(textarea, preview, elements), 100));
  onTextareaInput(textarea, preview, elements);
  jquery_default()(textarea.closest('form')).on('submit', () => {
    preview.remove();
  });
  container.append(preview);
});

function attachWikiPreview() {
  if (!commentPreview_module.options.enableForWiki.value) return;
  const preview = makePreviewBox();
  preview.querySelector('.md').classList.add('wiki');
  document.querySelector('#editform > br').after(preview);
  const contents = preview.querySelector('.RESDialogContents');
  jquery_default()('#wiki_page_content').on('input focus', debounce_default()(e => onTextareaInput(e.currentTarget, preview, [contents]), 100));
}

function onTextareaInput(textarea, preview, elements) {
  const markdownText = downcast(textarea, HTMLTextAreaElement).value;

  if (markdownText.length) {
    if (preview) preview.hidden = false;

    for (const ele of elements) ele.innerHTML = markdownToHTML(markdownText);
  } else {
    if (preview) preview.hidden = true;

    for (const ele of elements) empty(ele);
  }
}

function makePreviewBox() {
  return string_namespaceObject.html`
		<div class="RESDialogSmall livePreview">
			<h3>Live Preview</h3>
			${string_namespaceObject.safe(makeUrlHashLink(commentPreview_module.moduleID, undefined, ' ', 'gearIcon'))}
			<div class="md RESDialogContents"></div>
		</div>
	`;
}

const createBigEditor = lodash_once_default()(() => {
  const $editor = jquery_default()('<div id="BigEditor">');
  const $left = jquery_default()('<div class="BELeft RESDialogSmall"><h3>Editor</h3></div>');
  const $contents = jquery_default()('<div class="RESDialogContents"><textarea id="BigText" name="text" class=""></textarea></div>');
  const $textarea = $contents.find('textarea');
  const $foot = jquery_default()('<div class="BEFoot">');

  if (!isBan) {
    $foot.append(jquery_default()('<button type="button">save</button>').on('click', () => {
      const len = $textarea.val().length;
      const max = $textarea.data('max-length');

      if (len > max) {
        jquery_default()('#BigEditor .errorList .error').hide().filter('.TOO_LONG').text(`this is too long (max: ${max})`).show();
      } else if (len === 0) {
        jquery_default()('#BigEditor .errorList .error').hide().filter('.NO_TEXT').show();
      } else {
        hideBigEditor(true);
      }
    }));
  }

  $foot.append(jquery_default()('<button type="button">close</button>').on('click', () => hideBigEditor()));
  $foot.append(jquery_default()(`
		<span class="errorList">
			<span style="display: none;" class="error NO_TEXT">we need something here</span>
			<span style="display: none;" class="error TOO_LONG">this is too long (max: 10000)</span>
		</span>
	`));
  $contents.append($foot);
  $left.append($contents);
  const $right = jquery_default()(`
		<div class="BERight RESDialogSmall"><h3>Preview</h3><div class="RESCloseButton RESCloseButtonTopRight"></div>
		<div class="RESDialogContents"><div id="BigPreview" class=" md"></div></div></div>
	`);
  $editor.append($left).append($right);
  $right.find('.RESCloseButton').on('click', () => hideBigEditor());
  const $preview = $right.find('#BigPreview');
  $textarea.on('input', debounce_default()(() => onTextareaInput($textarea.get(0), null, [$preview.get(0)]), 100));
  $editor.on('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      hideBigEditor();
      e.preventDefault();
      return false;
    }
  });
  return $editor;
});

let $bigTextTarget;

function showBigEditor(e) {
  e.preventDefault();
  const $editor = createBigEditor();
  jquery_default()(document.body).append($editor).addClass('RESScrollLock');
  const $textarea = $editor.find('textarea');
  let $baseText;

  if (!isWiki && !isBan) {
    $baseText = jquery_default()(e.currentTarget).parents('.usertext-edit:first').find('textarea');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    jquery_default()('#BigPreview').removeClass('wiki');
    jquery_default()('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else if (isBan) {
    $baseText = jquery_default()('#ban_message');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    jquery_default()('#BigPreview').removeClass('wiki');
    jquery_default()('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else {
    $baseText = jquery_default()('#wiki_page_content');
    jquery_default()('#BigPreview').addClass('wiki');
    jquery_default()('.BERight .RESDialogContents').addClass('wiki-page-content');
  }

  const markdown = $baseText.val();
  const maxLength = $baseText.data('max-length');
  $textarea.data('max-length', maxLength).val(markdown).focus();
  $bigTextTarget = $baseText;
  $textarea.get(0).dispatchEvent(new Event('input', {
    bubbles: true,
    cancelable: true
  }));
}

function hideBigEditor(save = false) {
  if (!$bigTextTarget) throw new Error();
  const $editor = createBigEditor();
  const $textarea = $editor.find('textarea');
  $bigTextTarget.val($textarea.val());
  $bigTextTarget.get(0).dispatchEvent(new Event('input', {
    bubbles: true,
    cancelable: true
  }));

  if (save) {
    $bigTextTarget.closest('form').find('input[type=submit], button[type=submit]').click();
  } else {
    $bigTextTarget.focus();
  }

  $editor.get(0).remove();
  jquery_default()(document.body).removeClass('RESScrollLock');
  $bigTextTarget = null;
}

function generateBanMessage(message, subreddit) {
  return [`you have been banned from posting to [/r/${subreddit}](/r/${subreddit}).`, '', 'note from the moderators:', '', message.replace(/^/gm, '> '), '', 'you can contact the moderators regarding your ban by replying to this message. **warning**: using other accounts to circumvent a subreddit ban is considered a violation of reddit\'s [site rules](/rules) and can result in being banned from reddit entirely.'].join('\r\n');
}
// CONCATENATED MODULE: ./lib/modules/commentQuickCollapse.js




const commentQuickCollapse_module = new Module('commentQuickCollapse');
commentQuickCollapse_module.moduleName = 'commentQuickCollapseName';
commentQuickCollapse_module.category = 'commentsCategory';
commentQuickCollapse_module.description = 'commentQuickCollapseDesc';
commentQuickCollapse_module.options = {
  hideCommentsOnHeaderDoubleClick: {
    type: 'boolean',
    value: true,
    description: 'hideCommentsOnHeaderDoubleClickDesc',
    title: 'hideCommentsOnHeaderDoubleClickTitle'
  },
  toggleCommentsOnClickLeftEdge: {
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsOnClickLeftEdgeDesc',
    title: 'toggleCommentsOnClickLeftEdgeTitle'
  },
  leftEdgeColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#D1D1D1',
    description: 'toggleCommentsLeftEdgeColorDesc',
    title: 'toggleCommentsLeftEdgeColorTitle'
  },
  leftEdgeHoverColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#B1B1B1',
    description: 'toggleCommentsLeftEdgeHoverColorDesc',
    title: 'toggleCommentsLeftEdgeHoverColorTitle'
  },
  leftEdgeCollapsedColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#B1B1B1',
    description: 'toggleCommentsLeftEdgeCollapsedColorDesc',
    title: 'toggleCommentsLeftEdgeCollapsedColorTitle'
  },
  leftEdgeWidth: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'text',
    value: '50',
    description: 'toggleCommentsLeftEdgeWidthDesc',
    title: 'toggleCommentsLeftEdgeWidthTitle'
  },
  hideCollapseButton: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsLeftEdgeHideButtonDesc',
    title: 'toggleCommentsLeftEdgeHideButtonTitle'
  },
  scrollOnCollapse: {
    type: 'boolean',
    value: false,
    description: 'scrollOnCollapseDesc',
    title: 'scrollOnCollapseTitle'
  }
};
commentQuickCollapse_module.include = ['comments'];

commentQuickCollapse_module.beforeLoad = () => {
  if (commentQuickCollapse_module.options.toggleCommentsOnClickLeftEdge.value) {
    toggleCommentsOnClickLeftEdge();
  }
};

commentQuickCollapse_module.contentStart = () => {
  if (commentQuickCollapse_module.options.hideCommentsOnHeaderDoubleClick.value) {
    hideCommentsOnHeaderDoubleClick();
  }

  if (commentQuickCollapse_module.options.scrollOnCollapse.value) {
    scrollOnCollapse();
  }
};

function hideCommentsOnHeaderDoubleClick() {
  jquery_default()('.commentarea').on('dblclick', '.tagline', e => {
    const thing = Thing_Thing.checkedFrom(e.currentTarget);
    thing.setCommentCollapse(!thing.isCollapsed(), 'commentQuickCollapse');

    if (window.getSelection()) {
      window.getSelection().removeAllRanges();
    }
  });
}

function toggleCommentsOnClickLeftEdge() {
  const leftEdgeWidth = clamp_default()(parseInt(commentQuickCollapse_module.options.leftEdgeWidth.value, 10), 0, parseInt(commentQuickCollapse_module.options.leftEdgeWidth.default, 10)) / 100;
  addCSS(`
		.commentarea .comment {
			padding-left: ${2.5 * leftEdgeWidth}em !important;
		}

		.commentarea .comment > .entry > .tagline > .expand:hover {
			background-color: ${commentQuickCollapse_module.options.leftEdgeHoverColor.value};
		}

		.commentarea .entry > .tagline > .expand {
			width: ${2 * leftEdgeWidth}em !important;
			background-color: ${commentQuickCollapse_module.options.leftEdgeColor.value};
		}

		.commentarea .collapsed > .entry > .tagline > .expand {
			background-color: ${commentQuickCollapse_module.options.leftEdgeCollapsedColor.value};
		}
	`);
}

function scrollOnCollapse() {
  jquery_default()(document.body).on('click', '.expand', event => {
    if (click.isProgrammaticEvent(event)) return;
    const thing = Thing_Thing.checkedFrom(event.target);
    if (thing.element.classList.contains('noncollapsed')) return;
    const target = thing.getClosest(Thing_Thing.prototype.getNextSibling, {
      direction: 'down'
    });
    if (!target) return;
    selectedThing_namespaceObject.set(target, {
      scrollStyle: 'adopt',
      from: thing.entry
    });
  });
}
// CONCATENATED MODULE: ./lib/modules/commentSortBy.js


const commentSortBy_module = new Module('commentSortBy');
commentSortBy_module.moduleName = 'commentSortByTitle';
commentSortBy_module.category = 'commentsCategory';
commentSortBy_module.description = 'commentSortByDesc';
commentSortBy_module.include = ['d2x'];

commentSortBy_module.beforeLoad = () => {
  watchForRedditEvents('postModTools', (element, {
    _: {
      update
    }
  }) => {
    if (update) return;

    const _base = document.querySelector('#CommentSort--SortPicker');

    const base = _base && _base.parentElement;
    if (!base || base.querySelector('.sortByPrefLink')) return;
    base.append(string_namespaceObject.html`
			<a
				class="sortByPrefLink gearIcon"
				style="opacity: 0.3;"
				title="Go to comment sort preferences"
				href="https://old.reddit.com/prefs/#default_comment_sort"
				target="_blank"
			>${'\u00A0'}</a>
		`);
  });
};
// CONCATENATED MODULE: ./lib/modules/commentStyle.js


const commentStyle_module = new Module('commentStyle');
commentStyle_module.moduleName = 'commentStyleName';
commentStyle_module.category = 'appearanceCategory';
commentStyle_module.description = 'commentStyleDesc';
commentStyle_module.options = {
  commentBoxes: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentBoxesDesc',
    title: 'commentStyleCommentBoxesTitle',
    bodyClass: 'res-commentBoxes'
  },
  commentRounded: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentRoundedDesc',
    title: 'commentStyleCommentRoundedTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentBoxes-rounded'
  },
  commentHoverBorder: {
    type: 'boolean',
    value: false,
    description: 'commentStyleCommentHoverBorderDesc',
    title: 'commentStyleCommentHoverBorderTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentHoverBorder'
  },
  commentIndent: {
    type: 'text',
    value: '10',
    description: 'commentStyleCommentIndentDesc',
    title: 'commentStyleCommentIndentTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value
  },
  continuity: {
    type: 'boolean',
    value: false,
    description: 'commentStyleContinuityDesc',
    title: 'commentStyleContinuityTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-continuity'
  }
};
commentStyle_module.include = ['comments', 'commentsLinklist'];
commentStyle_module.exclude = ['d2x'];

commentStyle_module.beforeLoad = () => {
  if (commentStyle_module.options.commentBoxes.value && commentStyle_module.options.commentIndent.value) {
    addCSS(`
			.res-commentBoxes .comment {
				margin-left: ${commentStyle_module.options.commentIndent.value}px !important;
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/context.js



const context_module = new Module('context');
context_module.moduleName = 'contextName';
context_module.category = 'commentsCategory';
context_module.description = 'contextDesc';
context_module.options = {
  viewFullContext: {
    type: 'boolean',
    value: true,
    description: 'contextViewFullContextDesc',
    title: 'contextViewFullContextTitle'
  },
  defaultContext: {
    type: 'text',
    value: '3',
    description: 'contextDefaultContextDesc',
    title: 'contextDefaultContextTitle'
  }
};
context_module.include = ['comments', 'commentsLinklist', 'inbox', 'profile', 'modqueue'];

context_module.go = () => {
  if (isPageType('comments') && context_module.options.viewFullContext.value) {
    addViewFullContext();
  }

  const defaultContext = parseInt(context_module.options.defaultContext.value, 10);

  if (isPageType('commentsLinklist', 'inbox', 'profile', 'modqueue') && defaultContext >= 0) {
    setDefaultContext(defaultContext);
  }
};

function addViewFullContext() {
  if (location.search !== '?context=10000') {
    const pInfobar = document.querySelector('.infobar:not(#searchexpando) p');

    if (pInfobar) {
      if (jquery_default()('.sitetable:eq(1) .buttons:first .bylink').length > 1) {
        pInfobar.append('\u00A0', string_namespaceObject.html`<a href="?context=10000">view the full context</a>`, '\u00A0');
      }
    }
  }
}

function setDefaultContext(contextDepth) {
  jquery_default()(document.body).on('mousedown', 'a.bylink', e => {
    const target = e.currentTarget;
    target.href = target.href.replace(/(\?|&|;)context=\d+\b/, `$1context=${contextDepth}`);
  });
}
// CONCATENATED MODULE: ./lib/modules/contribute.js




const contribute_module = new Module('contribute');
contribute_module.moduleName = 'contributeName';
contribute_module.category = 'aboutCategory';
contribute_module.sort = -9;
contribute_module.alwaysEnabled = true;
contribute_module.description = 'contributeDesc';

contribute_module.contentStart = () => {
  menu_addMenuItem(() => string_namespaceObject.html`<span>${i18n('donateToRES')} &#8679;</span>`, () => {
    openNewTab('https://redditenhancementsuite.com/contribute/');
  });
};
// CONCATENATED MODULE: ./lib/modules/dashboard.js








const dashboard_module = new Module('dashboard');
dashboard_module.moduleName = 'dashboardName';
dashboard_module.category = 'productivityCategory';
dashboard_module.description = 'dashboardDesc';
dashboard_module.options = {
  menuItem: {
    type: 'boolean',
    value: true,
    description: 'dashboardMenuItemDesc',
    title: 'dashboardMenuItemTitle'
  },
  defaultPosts: {
    type: 'text',
    value: '3',
    description: 'dashboardDefaultPostsDesc',
    title: 'dashboardDefaultPostsTitle',
    advanced: true
  },
  defaultSort: {
    type: 'enum',
    values: [{
      name: 'hot',
      value: 'hot'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'rising',
      value: 'rising'
    }, {
      name: 'controversial',
      value: 'controversial'
    }, {
      name: 'top',
      value: 'top'
    }],
    value: 'hot',
    description: 'dashboardDefaultSortDesc',
    title: 'dashboardDefaultSortTitle'
  },
  defaultSortSearch: {
    type: 'enum',
    values: [{
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    value: 'relevance',
    description: 'dashboardDefaultSortSearchDesc',
    title: 'dashboardDefaultSortSearchTitle'
  },
  dashboardShortcut: {
    type: 'boolean',
    value: true,
    description: 'dashboardDashboardShortcutDesc',
    title: 'dashboardDashboardShortcutTitle'
  }
};

const initialWidgetLoad = lodash_once_default()(getLatestWidgets);

dashboard_module.beforeLoad = () => {
  if (dashboard_module.options.menuItem.value) {
    const dashboardUrl = isAppType('d2x') ? 'https://old.reddit.com/r/Dashboard' : '/r/Dashboard';
    menu_addMenuItem(() => string_namespaceObject.html`<a href="${dashboardUrl}">${i18n('myDashboard')}</a>`, undefined, -7);
  }
};

dashboard_module.contentStart = () => {
  addDashboardTab('dashboardContents', 'My dashboard', dashboard_module.moduleID, dashboard_addDashboardFunctionality);
  const subreddit = currentSubreddit();

  if (dashboard_module.options.dashboardShortcut.value && subreddit) {
    addDashboardShortcuts(subreddit);
  }
};

const MAX_ROWS = 100;
const dashboardStorage = storage_namespaceObject.wrap(() => `RESmodules.dashboard.${loggedInUser() || 'null'}`, []);
let widgets = [];

async function getLatestWidgets() {
  widgets = (await dashboardStorage.get()).filter(Boolean);
}

async function dashboard_addDashboardFunctionality(tabPage) {
  await initialWidgetLoad();
  attachAddComponent(jquery_default()(tabPage));
  attachEditComponent();
  initUpdateQueue();
}

function initUpdateQueue() {
  for (const widget of widgets) {
    if (widget) addWidget(widget);
  }

  sortable_core_esm.create(document.querySelector('#RESDashboard'), {
    handle: 'div.RESDashboardComponentHeader',
    onChange: () => saveOrder()
  });
}

const updateQueue = [];
let updateQueueTimer;

function addToUpdateQueue(updateFunction) {
  updateQueue.push(updateFunction);

  if (!updateQueueTimer) {
    updateQueueTimer = setInterval(processUpdateQueue, 2000);
    setTimeout(processUpdateQueue, 100);
  }
}

function processUpdateQueue() {
  const thisUpdate = updateQueue.pop();
  thisUpdate();

  if (updateQueue.length < 1) {
    clearInterval(updateQueueTimer);
    updateQueueTimer = undefined;
  }
}

function saveOrder() {
  const data = jquery_default()('#siteTable li.RESDashboardComponent').toArray().map(e => jquery_default()(e).attr('id'));
  data.reverse();
  const newOrder = [];

  for (const widget of widgets) {
    const newIndex = data.indexOf(widget.basePath.replace(/(\/|\+)/g, '_'));
    newOrder[newIndex] = widget;
  }

  widgets = newOrder;
  dashboardStorage.set(widgets);
}

let widgetBeingEdited;

function attachEditComponent() {
  const $dashboardEditComponent = jquery_default()('<div id="RESDashboardEditComponent" class="RESDashboardComponent" />');
  $dashboardEditComponent.html(`
		<div class="editWidget">Edit widget</div>
		<div id="editRedditFormContainer" class="editRedditForm">
			<form id="editRedditForm">
				<input type="text" id="editReddit" placeholder="subreddit / multireddit">
				<input type="text" id="editRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
			<form id="editSearchForm">
				<input type="text" id="editSearch" placeholder="search terms">
				<input type="text" id="editSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
		</div>
	`);
  $dashboardEditComponent.find('#editRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = jquery_default()('#editReddit').val();

    if (thisBasePath !== '') {
      thisBasePath = thisBasePath.replace(/,|\s/g, '+');
      widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
      widgetBeingEdited.basePath = `/r/${thisBasePath}`;
      widgetBeingEdited.displayName = jquery_default()('#editRedditDisplayName').val();
      widgetBeingEdited.update();
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editReddit').blur());
      widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', `/r/${thisBasePath}`);
      dashboard_updateWidget();
    }
  });
  $dashboardEditComponent.find('#editSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = jquery_default()('#editSearch').val();
    widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
    widgetBeingEdited.basePath = string_namespaceObject.encode`/search?q=${thisBasePath}`;
    widgetBeingEdited.displayName = jquery_default()('#editSearchDisplayName').val();
    widgetBeingEdited.update();
    jquery_default()('#RESDashboardEditComponent').fadeOut(() => {
      jquery_default()('#editSearch').val('').blur();
      jquery_default()('#editSearchDisplayName').val('').blur();
    });
    widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', thisBasePath);
    dashboard_updateWidget();
  });
  $dashboardEditComponent.find('.cancelButton').click(() => {
    if (widgetBeingEdited.basePath.startsWith('/search?q=')) {
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editSearchDisplayName').val('').blur());
    } else {
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editReddit').blur());
    }
  });
  jquery_default()(document.body).append($dashboardEditComponent);
}

function showEditForm() {
  const basePath = widgetBeingEdited.basePath;
  const widgetEle = widgetBeingEdited.widgetEle;
  const eleTop = jquery_default()(widgetEle).position().top;
  const eleWidth = jquery_default()(widgetEle).width();
  jquery_default()('#RESDashboardEditComponent').css('top', `${eleTop}px`).css('left', '5px').css('width', `${eleWidth + 2}px`);

  if (basePath.startsWith('/search?q=')) {
    jquery_default()('#editSearchDisplayName').val(widgetBeingEdited.displayName);
    jquery_default()('#editSearch').val(decodeURIComponent(basePath.substr(10)));
    jquery_default()('#editSearchForm').show();
    jquery_default()('#editRedditForm').hide();
    jquery_default()('#RESDashboardEditComponent').fadeIn('fast');
  } else {
    jquery_default()('#editReddit').val(widgetBeingEdited.basePath.substr(3));
    jquery_default()('#editRedditDisplayName').val(widgetBeingEdited.displayName);
    jquery_default()('#editRedditForm').show();
    jquery_default()('#editSearchForm').hide();
    jquery_default()('#RESDashboardEditComponent').fadeIn('fast');
  }
}

let $dashboardUL;

function attachAddComponent($tabPage) {
  const $dashboardAddComponent = jquery_default()('<div id="RESDashboardAddComponent" class="RESDashboardComponent" />');
  $dashboardAddComponent.html(`
		<div class="addNewWidget">Add a new widget</div>
		<div id="addWidgetButtons">
			<div class="addButton" id="addSearchWidget">+search widget</div>
			<div class="addButton" id="addMailWidget">+mail widget</div>
			<div class="addButton" id="addUserWidget">+user widget</div>
			<div class="addButton" id="addRedditWidget">+subreddit widget</div>
		</div>
		<div id="addSearchFormContainer" class="addSearchForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addSearchForm">
				<input type="text" id="addSearch" placeholder="search terms">
				<input type="text" id="addSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addMailWidgetContainer">
			<div class="backToWidgetTypes">&laquo; back</div>
			<div class="addButton widgetShortcut" widgetPath="/message/inbox/">+inbox</div>
			<div class="addButton widgetShortcut" widgetPath="/message/unread/">+unread</div>
			<div class="addButton widgetShortcut" widgetPath="/message/messages/">+messages</div>
			<div class="addButton widgetShortcut" widgetPath="/message/comments/">+comment replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/selfreply/">+post replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/moderator/">+modmail</div>
		</div>
		<div id="addUserFormContainer" class="addUserForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addUserForm">
				<input type="text" id="addUser">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addRedditFormContainer" class="addRedditForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addRedditForm">
				<input type="text" id="addReddit" placeholder="subreddit / multireddit">
				<input type="text" id="addRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
	`);
  $dashboardAddComponent.find('.backToWidgetTypes').click(function () {
    jquery_default()(this).parent().fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('.widgetShortcut').click(function () {
    const thisBasePath = jquery_default()(this).attr('widgetPath');
    addWidget({
      basePath: thisBasePath
    }, true);
    jquery_default()('#addMailWidgetContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addRedditWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => {
      jquery_default()('#addRedditFormContainer').fadeIn(() => {
        jquery_default()('#token-input-addReddit').focus();
      });
    });
  });
  $dashboardAddComponent.find('#addMailWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addMailWidgetContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addUserWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addUserFormContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addSearchFormContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = jquery_default()('#addReddit').val();

    if (thisBasePath !== '') {
      thisBasePath = thisBasePath.replace(/,|\s/g, '+');
      const thisDisplayName = jquery_default()('#addRedditDisplayName').val() ? jquery_default()('#addRedditDisplayName').val() : thisBasePath;
      addWidget({
        basePath: thisBasePath,
        displayName: thisDisplayName
      }, true);
      jquery_default()('#addReddit').val('').blur();
      jquery_default()('#addRedditFormContainer').fadeOut(() => {
        jquery_default()('#addWidgetButtons').fadeIn();
      });
    }
  });
  $dashboardAddComponent.find('#addUserForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = `/user/${jquery_default()('#addUser').val()}`;
    addWidget({
      basePath: thisBasePath
    }, true);
    jquery_default()('#addUser').val('').blur();
    jquery_default()('#addUserFormContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = string_namespaceObject.encode`/search?q=${jquery_default()('#addSearch').val()}`;
    const thisDisplayName = jquery_default()('#addSearchDisplayName').val() ? jquery_default()('#addSearchDisplayName').val() : thisBasePath;
    addWidget({
      basePath: thisBasePath,
      displayName: thisDisplayName
    }, true);
    jquery_default()('#addSearch').val('').blur();
    jquery_default()('#addSearchFormContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardUL = jquery_default()('<ul id="RESDashboard"></ul>');
  $tabPage.append($dashboardAddComponent, $dashboardUL);
}

function addWidget(optionsObject, isNew) {
  if (!optionsObject.basePath.startsWith('/')) {
    optionsObject.basePath = `/r/${optionsObject.basePath}`;
  }

  const exists = widgets.some(widget => widget.basePath === optionsObject.basePath);
  setTimeout(() => {
    jquery_default()(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).hide();
  }, 1000);

  if (exists && isNew) {
    alert_namespaceObject.open(`A widget for ${optionsObject.basePath} already exists!`);
  } else {
    const thisWidget = new WidgetObject(optionsObject);
    if ($dashboardUL) thisWidget.init();
    saveWidget(thisWidget.optionsObject());
  }
}

async function removeWidget(optionsObject) {
  await getLatestWidgets();
  let exists;
  widgets = widgets.filter(widget => {
    if (widget.basePath === optionsObject.basePath) {
      exists = true;
      jquery_default()(document.getElementById(widget.basePath.replace(/\/|\+/g, '_'))).fadeOut('slow', function () {
        jquery_default()(this).detach();
      });
      setTimeout(() => {
        jquery_default()(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).show();
      }, 1000);
      return false;
    }

    return true;
  });

  if (!exists) {
    notifications_showNotification({
      moduleID: 'dashboard',
      message: 'The widget you just tried to remove does not seem to exist.'
    });
  }

  dashboardStorage.set(widgets);
}

async function saveWidget(optionsObject) {
  await getLatestWidgets();
  let index = widgets.findIndex(widget => widget.basePath === optionsObject.basePath);

  if (index === -1) {
    index = widgets.length;
  }

  widgets[index] = optionsObject;
  dashboardStorage.set(widgets);
}

async function dashboard_updateWidget() {
  await getLatestWidgets();
  widgets = widgets.map(widget => {
    if (widget.basePath === widgetBeingEdited.formerBasePath) {
      delete widgetBeingEdited.formerBasePath;
      widget = widgetBeingEdited.optionsObject();
    }

    return widget;
  });
  dashboardStorage.set(widgets);
}

function WidgetObject(widgetOptions) {
  this.basePath = widgetOptions.basePath;

  if (widgetOptions.displayName === undefined || widgetOptions.displayName === null) {
    widgetOptions.displayName = this.basePath;
  }

  this.displayName = widgetOptions.displayName;
  this.numPosts = widgetOptions.numPosts || parseInt(dashboard_module.options.defaultPosts.value, 10);
  this.sortBy = widgetOptions.sortBy || dashboard_module.options.defaultSort.value;
  this.sortSearchBy = widgetOptions.sortSearchBy || dashboard_module.options.defaultSortSearch.value;
  this.minimized = widgetOptions.minimized || false;
  this.widgetEle = jquery_default()(`
		<li class="RESDashboardComponent" id="${this.basePath.replace(/\/|\+/g, '_')}">
			<div class="RESDashboardComponentScrim">
				<div class="RESDashboardComponentLoader">
					<span class="dashboardLoader"/><span>querying the server. one moment please.</span>
				</div>
			</div>
		</li>
	`);
  this.header = jquery_default()(`<div class="RESDashboardComponentHeader"><a class="widgetPath" title="${this.basePath}" href="${this.basePath}"></a></div>`);
  this.header.find('.widgetPath').text(this.displayName);
  this.sortControls = jquery_default()('<ul class="widgetSortButtons"><li sort="hot">hot</li><li sort="new">new</li><li sort="rising">rising</li><li sort="controversial">controversial</li><li sort="top">top</li></ul>');
  this.sortSearchControls = jquery_default()('<ul class="widgetSortButtons"><li sort="relevance">relevance</li><li sort="top">top</li><li sort="new">new</li><li sort="comments">comments</li></ul>');

  this.optionsObject = () => ({
    basePath: this.basePath,
    displayName: this.displayName,
    numPosts: this.numPosts,
    sortBy: this.sortBy,
    sortSearchBy: this.sortSearchBy,
    minimized: this.minimized
  });

  jquery_default()(this.sortControls).find(`li[sort=${this.sortBy}]`).addClass('active');
  jquery_default()(this.sortControls).find('li').click(e => {
    this.sortChange(jquery_default()(e.currentTarget).attr('sort'));
  });
  jquery_default()(this.sortSearchControls).find(`li[sort=${this.sortSearchBy}]`).addClass('active');
  jquery_default()(this.sortSearchControls).find('li').click(e => {
    this.sortChange(jquery_default()(e.currentTarget).attr('sort'));
  });
  jquery_default()(this.header).append(this.sortControls);

  if (!this.basePath.startsWith('/r/') && !this.basePath.startsWith('/user/')) {
    setTimeout(() => jquery_default()(this.sortControls).hide(), 100);
  }

  jquery_default()(this.header).append(this.sortSearchControls);

  if (!this.basePath.startsWith('/search?q=')) {
    setTimeout(() => jquery_default()(this.sortSearchControls).hide(), 100);
  }

  this.stateControls = jquery_default()('<ul class="widgetStateButtons"><li class="updateTime"></li><li action="refresh" class="refresh"><span class="res-icon">&#xF0B0;</span></li><li action="refreshAll" class="refreshAll">Refresh All</li><li action="addRow">+row</li><li action="subRow">-row</li><li action="edit" class="editButton"><span class="res-icon">&#xF139;</span></li><li action="minimize" class="minimize">-</li><li action="delete" class="RESClose">&times;</li></ul>');
  jquery_default()(this.stateControls).find('li').click(e => {
    switch (jquery_default()(e.currentTarget).attr('action')) {
      case 'refresh':
        this.update();
        break;

      case 'refreshAll':
        jquery_default()('li[action="refresh"]').click();
        break;

      case 'addRow':
        if (this.numPosts === MAX_ROWS) break;
        this.numPosts++;
        if (this.numPosts === MAX_ROWS) jquery_default()(this.stateControls).find('li[action=addRow]').addClass('disabled');
        jquery_default()(this.stateControls).find('li[action=subRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'subRow':
        if (this.numPosts === 0) break;
        this.numPosts--;
        if (this.numPosts === 1) jquery_default()(this.stateControls).find('li[action=subRow]').addClass('disabled');
        jquery_default()(this.stateControls).find('li[action=addRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'minimize':
        jquery_default()(this.widgetEle).toggleClass('minimized');

        if (jquery_default()(this.widgetEle).hasClass('minimized')) {
          jquery_default()(e.currentTarget).text('+');
          this.minimized = true;
        } else {
          jquery_default()(e.currentTarget).text('-');
          this.minimized = false;
          this.update();
        }

        jquery_default()(this.contents).parent().slideToggle();
        saveWidget(this.optionsObject());
        break;

      case 'delete':
        removeWidget(this.optionsObject());
        break;

      default:
        break;
    }
  });
  jquery_default()(this.header).append(this.stateControls);

  this.sortChange = sortBy => {
    this.sortBy = sortBy;
    this.sortSearchBy = sortBy;
    jquery_default()(this.header).find('ul.widgetSortButtons li').removeClass('active');
    jquery_default()(this.header).find(`ul.widgetSortButtons li[sort=${sortBy}]`).addClass('active');
    this.update();
    saveWidget(this.optionsObject());
  };

  this.edit = () => {
    widgetBeingEdited = this;
    showEditForm();
  };

  jquery_default()(this.header).find('.editButton').click(this.edit);

  this.update = () => {
    if (this.basePath.includes('/user/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `?sort=${this.sortBy}`;
    } else if (this.basePath.includes('/r/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `/${this.sortBy}/`;
    } else if (this.basePath.includes('/search?q=')) {
      this.sortPath = `&sort=${this.sortSearchBy}`;
    } else {
      this.sortPath = '';
    }

    this.url = `${location.protocol}//${location.hostname}/${this.basePath}${this.sortPath}`;
    jquery_default()(this.contents).fadeTo('fast', 0.25);
    jquery_default()(this.scrim).fadeIn();
    ajax({
      method: 'GET',
      url: this.url,
      query: {
        limit: this.numPosts
      }
    }).then(this.populate).catch(this.error);
  };

  this.container = jquery_default()('<div class="RESDashboardComponentContainer"><div class="RESDashboardComponentContents"></div></div>');

  if (this.minimized) {
    jquery_default()(this.container).addClass('minimized');
    jquery_default()(this.stateControls).find('li.minimize').addClass('minimized').text('+');
  }

  this.scrim = jquery_default()(this.widgetEle).find('.RESDashboardComponentScrim');
  this.contents = jquery_default()(this.container).find('.RESDashboardComponentContents');

  this.init = () => {
    this.draw();
    if (!this.minimized) addToUpdateQueue(this.update);
  };

  this.draw = () => {
    jquery_default()(this.widgetEle).append(this.header);
    jquery_default()(this.widgetEle).append(this.container);
    if (this.minimized) jquery_default()(this.widgetEle).addClass('minimized');
    $dashboardUL.prepend(this.widgetEle);
  };

  this.populate = response => {
    let $widgetContent = jquery_default()(response).find('#siteTable, .search-result-group>.contents:last');
    const $thisWidgetContents = jquery_default()(this.contents);
    $widgetContent.attr('id', `siteTable_${this.basePath.replace(/\/|\+/g, '_')}`);
    if ($widgetContent.length === 2) $widgetContent = jquery_default()($widgetContent[1]);
    $widgetContent.attr('url', `${this.url}?limit=${this.numPosts}`);

    if ($widgetContent.length > 0 && $widgetContent.html() !== '') {
      $widgetContent.html($widgetContent.html().replace(/<script(.|\s)*?\/script>/g, ''));
      const $noResults = $widgetContent.find('#noresults.error');

      if ($noResults.length) {
        $widgetContent.html('<span class="error">No results found for this widget. Some sort methods, such as rising, may not always have results. Please try a different method.</span>');
      }

      try {
        $thisWidgetContents.empty().append($widgetContent);
      } catch (e) {}

      $thisWidgetContents.fadeTo('fast', 1);
      jquery_default()(this.scrim).fadeOut(function () {
        jquery_default()(this).hide();
      });
    } else {
      if (this.url.includes('/message/')) {
        $thisWidgetContents.html('<div class="widgetNoMail">No messages were found.</div>');
      } else {
        $thisWidgetContents.html('<div class="error">There were no results returned for this widget. If you made a typo, simply close the widget to delete it. If reddit is just under heavy load, try clicking refresh in a few moments.</div>');
      }

      $thisWidgetContents.fadeTo('fast', 1);
      jquery_default()(this.scrim).fadeOut();
    }

    jquery_default()(this.stateControls).find('.updateTime').text(`updated: ${formatDateTime()}`);

    if ($widgetContent[0]) {
      registerPage($widgetContent[0]);
    }
  };

  this.error = e => {
    if (e.status === 404) {
      jquery_default()(this.contents).html('<div class="error">This widget received a 404 not found error. You may have made a typo when adding it.</div>');
    } else {
      jquery_default()(this.contents).html('<div class="error">There was an error loading data for this widget. Reddit may be under heavy load, or you may have provided an invalid path.</div>');
    }

    jquery_default()(this.scrim).fadeOut();
    jquery_default()(this.contents).fadeTo('fast', 1);
  };
}

function addDashboardShortcuts(subreddit) {
  const subButtons = document.querySelectorAll('.side .fancy-toggle-button');

  for (const subButton of subButtons) {
    let isMulti, thisSubredditFragment;

    if (!subreddit.includes('+') && !isCurrentSubreddit('mod')) {
      isMulti = false;
      thisSubredditFragment = subreddit;
    } else if (jquery_default()(subButton).parent().hasClass('subButtons')) {
      isMulti = true;
      thisSubredditFragment = jquery_default()(subButton).parent().parent().find('a.title').text();
    } else {
      isMulti = true;
      thisSubredditFragment = jquery_default()(subButton).next().text();
    }

    if (jquery_default()(`#subButtons-${thisSubredditFragment}`).length === 0) {
      const $subButtonsWrapper = jquery_default()(`<div id="subButtons-${thisSubredditFragment}" class="subButtons" style="margin: 0 !important;"></div>`);
      jquery_default()(subButton).wrap($subButtonsWrapper);

      if (isMulti) {
        const theWrap = jquery_default()(subButton).parent();
        jquery_default()(theWrap).appendTo(jquery_default()(theWrap).parent());
      }
    }

    const $subButtons = jquery_default()(`#subButtons-${thisSubredditFragment}`);
    const button = createSubredditToggleButton(subreddit);
    initialWidgetLoad().then(() => button.dispatchEvent(new CustomEvent('refresh')));
    button.classList.add('RESDashboardToggle');
    $subButtons.append(button);
    const next = $subButtons.next();

    if (jquery_default()(next).hasClass('title') && !$subButtons.hasClass('swapped')) {
      $subButtons.before(jquery_default()(next));
      $subButtons.addClass('swapped');
    }
  }
}

function createSubredditToggleButton(subreddit) {
  const basePath = `/r/${subreddit.toLowerCase()}`;
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveDashboard'), i18n('subredditInfoAddThisSubredditToDashboard'), () => widgets.some(widget => widget && widget.basePath.toLowerCase() === basePath), state => {
    if (state) {
      addWidget({
        basePath
      });
      notifications_showNotification({
        header: 'Dashboard Notification',
        moduleID: 'dashboard',
        message: `
						Dashboard widget added for ${basePath}
						<p><a class="RESNotificationButtonBlue" href="/r/Dashboard">view the dashboard</a></p>
						<div class="clear"></div>
					`
      });
    } else {
      removeWidget({
        basePath
      });
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/disableChat.js


const disableChat_module = new Module('disableChat');
disableChat_module.moduleName = 'disableChatName';
disableChat_module.category = 'productivityCategory';
disableChat_module.description = 'disableChatDesc';
disableChat_module.disabledByDefault = true;

disableChat_module.beforeLoad = () => {
  pagePhases_namespaceObject.bodyStart.then(() => {
    watchForChildren(document.body, 'script', ele => {
      const script = downcast(ele, HTMLScriptElement);
      if (/^\/_chat/.test(new URL(script.src, location.origin).pathname)) script.remove();
    });
    watchForChildren(document.body, '#chat-app', ele => {
      ele.remove();
    });
  });
};

disableChat_module.contentStart = () => {
  const icon = document.body.querySelector('#chat');

  if (icon) {
    if (icon.nextElementSibling) icon.nextElementSibling.remove();
    icon.remove();
  }
};
// CONCATENATED MODULE: ./lib/modules/localDate.js


const localDate_module = new Module('localDate');
localDate_module.moduleName = 'localDateName';
localDate_module.category = 'myAccountCategory';
localDate_module.description = 'localDateDesc';

localDate_module.contentStart = () => {
  jquery_default()(document.body).on('mouseenter', 'time', function () {
    const $this = jquery_default()(this);

    if (!$this.data('originalTitle')) {
      $this.data('originalTitle', $this.attr('title'));
    }

    $this.attr('title', new Date($this.attr('datetime')));
  }).on('mouseleave', 'time', function () {
    const $this = jquery_default()(this);
    $this.attr('title', $this.data('originalTitle'));
  });
};
// CONCATENATED MODULE: ./lib/modules/logoLink.js


const logoLink_module = new Module('logoLink');
logoLink_module.moduleName = 'logoLinkName';
logoLink_module.category = 'browsingCategory';
logoLink_module.description = 'logoLinkDesc';
logoLink_module.options = {
  redditLogoDestination: {
    type: 'enum',
    value: 'frontpage',
    description: 'logoLinkRedditLogoDestinationDesc',
    title: 'logoLinkRedditLogoDestinationTitle',
    values: [{
      name: 'logoLinkFrontpage',
      value: 'frontpage'
    }, {
      name: 'logoLinkAll',
      value: 'all'
    }, {
      name: 'logoLinkHot',
      value: 'hot'
    }, {
      name: 'logoLinkDashboard',
      value: 'dashboard'
    }, {
      name: 'logoLinkCurrent',
      value: 'subreddit'
    }, {
      name: 'logoLinkMyUserPage',
      value: '/u/me'
    }, {
      name: 'logoLinkInbox',
      value: '/message/inbox'
    }, {
      name: 'logoLinkCustom',
      value: 'custom'
    }]
  },
  customDestination: {
    dependsOn: options => options.redditLogoDestination.value === 'custom',
    type: 'text',
    value: '/',
    description: 'logoLinkCustomDestinationDesc',
    title: 'logoLinkCustomDestinationTitle'
  }
};

logoLink_module.contentStart = () => {
  const redditLogoNode = document.getElementById('header-img-a') || document.getElementById('header-img') || document.querySelector('header a[href="/"]');

  if (redditLogoNode) {
    const url = getLogoLinkUrl();

    if (url) {
      redditLogoNode.href = url;
    }
  }
};

function getLogoLinkUrl() {
  const destination = logoLink_module.options.redditLogoDestination.value;

  switch (destination) {
    case 'frontpage':
      return false;

    case 'all':
      return '/r/all';

    case 'hot':
      return '/hot';

    case 'dashboard':
      return '/r/Dashboard';

    case 'subreddit':
      return jquery_default()('.redditname > a').attr('href');

    case 'custom':
      return logoLink_module.options.customDestination.value;

    default:
      return destination;
  }
}
// CONCATENATED MODULE: ./lib/modules/messageMenu.js







const messageMenu_module = new Module('messageMenu');
messageMenu_module.moduleName = 'messageMenuName';
messageMenu_module.category = 'browsingCategory';
messageMenu_module.description = 'messageMenuDesc';
messageMenu_module.options = {
  links: {
    type: 'table',
    addRowText: 'messageMenuAddShortcut',
    fields: [{
      key: 'label',
      name: 'messageMenuLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'messageMenuUrl',
      type: 'text'
    }],
    value: [['compose', '/message/compose'], ['all', '/message/inbox'], ['unread', '/message/unread'], ['messages', '/message/messages'], ['comment replies', '/message/comments'], ['post replies', '/message/selfreply'], ['/u/ mentions', '/message/mentions']],
    description: 'messageMenuLinksDesc',
    title: 'messageMenuLinksTitle'
  },
  useQuickMessage: {
    type: 'boolean',
    description: 'messageMenuUseQuickMessageDesc',
    title: 'messageMenuUseQuickMessageTitle',
    value: true
  },
  hoverDelay: {
    type: 'text',
    value: '1000',
    description: 'messageMenuHoverDelayDesc',
    title: 'messageMenuHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    type: 'text',
    value: '200',
    description: 'messageMenuFadeDelayDesc',
    title: 'messageMenuFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    type: 'text',
    value: '0.7',
    description: 'messageMenuFadeSpeedDesc',
    title: 'messageMenuFadeSpeedTitle',
    advanced: true
  }
};

messageMenu_module.contentStart = () => {
  dropdownList(messageMenu_module.moduleID).options({
    openDelay: parseFloat(messageMenu_module.options.hoverDelay.value),
    fadeDelay: parseFloat(messageMenu_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(messageMenu_module.options.fadeSpeed.value)
  }).populateWith(() => [getListFragment()]).watch('#mail, .mail-count, #NREMail, #NREMailCount');
};

function getListFragment() {
  const fragment = document.createDocumentFragment();

  for (const link of messageMenu_module.options.links.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="${url}">${label}</a></li>`;
    li.addEventListener('click', e => {
      if (messageMenu_module.options.useQuickMessage.value && isRunning(quickMessage_namespaceObject) && messageLinkEventHandler(e)) return;
      dropdownList(messageMenu_module.moduleID).close();
    });
    if (url.includes('/message/compose')) li.append(string_namespaceObject.html`<span class="RESMenuItemButton res-icon">&#xF139;</span>`);
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(messageMenu_module.moduleID, 'sectionMenu')}>
		<i>${i18n(messageMenu_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
}
// CONCATENATED MODULE: ./lib/modules/modhelper.js




const modhelper_module = new Module('modHelper');
modhelper_module.moduleName = 'modhelperName';
modhelper_module.category = 'coreCategory';
modhelper_module.description = 'modhelperDesc';
modhelper_module.hidden = true;
modhelper_module.alwaysEnabled = true;
modhelper_module.include = ['stylesheet'];

modhelper_module.go = () => {
  doStyleSheetCheck();
};

const modhelper_tips = {
  'no-res-styles': 'It appears you haven\'t done any styling specific to RES.  If you are interested in a quick overview on styling for RES users, please see [our wiki article](/r/Enhancement/wiki/subredditstyling)',
  keyNav: 'Styling `RES-keyNav-activeElement`? This is the element RES uses for Keyboard Navigation - it indicates the currently selected post, and is crucial to RES functionality. If you don\'t like the way it looks with your theme, you may style it however you want, as long as Keyboard Navigation remains usable for your visitors.',
  'keyNav-benice': `It appears that you are hiding \`RES-keyNav-activeElement\`. This negatively affects RES users by rendering keyboard navigation unusable. It's understandable that you may not care for the default appearance, but we politely request that you consider styling it to fit your subreddit, perhaps using a particular background color or border. Even just a one-sided border, e.g. \`border-right: 3px solid blue;\` - thank you for your consideration.\n\n For convenience we've included \`RES-keyNav-activeThing\` which can be used as an alternative to \`RES-keyNav-activeElement\`. It applies to elements with the class \`thing\` as opposed to \`entry\`. If you choose to use this, make sure keyboard navigation is usable when [commentBoxes](${makeUrlHash('styleTweaks', 'commentBoxes')}) is turned off.`,
  nightmode: 'Want your subreddit to be night mode friendly? Please have a look at [the night mode section of our wiki](/r/Enhancement/wiki/subredditstyling#wiki_res_night_mode_and_your_subreddit)'
};

function doStyleSheetCheck() {
  const $stylesheetTextarea = jquery_default()('.stylesheet-customize-container textarea');
  const stylesheet = $stylesheetTextarea.length ? jquery_default()($stylesheetTextarea).val() : '';
  createTipPane();

  if (stylesheet.length) {
    if (!stylesheet.includes('.res') && !stylesheet.includes('.RES')) {
      addTipToPane('no-res-styles');
    }

    if (!stylesheet.includes('.res-nightmode')) {
      addTipToPane('nightmode');
    }

    const keyNavIdx = stylesheet.indexOf('.RES-keyNav-activeElement');

    if (keyNavIdx !== -1) {
      let keyNavRule = '';
      let i = keyNavIdx;

      while (i < stylesheet.length) {
        const thisChar = stylesheet.charAt(i);
        keyNavRule += thisChar;

        if (thisChar === '}') {
          i = stylesheet.length;
        }

        i++;
      }

      if ((keyNavRule.includes('transparent') || keyNavRule.includes('background: none') || keyNavRule.includes('background-color: none')) && !keyNavRule.includes('border') && !stylesheet.includes('.RES-keyNav-activeThing')) {
        addTipToPane('keyNav-benice');
      } else {
        addTipToPane('keyNav');
      }
    }
  }
}

let $tipPane, $tipPaneHeader, $tipPaneContents, $tipPaneList;

function createTipPane() {
  const $sheetsDiv = jquery_default()('div.sheets');
  $tipPane = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane'
  });
  $tipPaneHeader = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane-header',
    class: 'minimized',
    text: 'RES specific styling tips',
    click: toggleTipPane
  });
  const $tipPaneCloseButton = jquery_default()('<span>', {
    id: 'RESStyleSheetTipPane-close',
    class: 'RESCloseButton RESCloseButtonTopRight',
    title: 'Close for this session',
    click: hideTipPane
  });
  const $tipPaneHeaderSpan = jquery_default()('<span>', {
    class: 'details',
    text: '[click for details]'
  });
  $tipPaneHeader.append($tipPaneCloseButton).append($tipPaneHeaderSpan);
  $tipPaneContents = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane-contents'
  });
  $tipPaneList = jquery_default()('<ul>', {
    id: 'RESStyleSheetTipPane-list'
  });
  $tipPaneContents.append($tipPaneList);
  $tipPane.append($tipPaneHeader).append($tipPaneContents);
  $sheetsDiv.before($tipPane);
}

function hideTipPane() {
  sessionStorage.setItem('hideTipPane', 'true');
  $tipPane.hide();
}

function toggleTipPane() {
  if ($tipPaneHeader.hasClass('minimized')) {
    openTipPaneContents();
  } else {
    closeTipPaneContents();
  }
}

function openTipPaneContents() {
  $tipPaneHeader.removeClass('minimized');
  $tipPaneContents.slideDown();
}

function closeTipPaneContents() {
  $tipPaneHeader.addClass('minimized');
  $tipPaneContents.slideUp();
}

function addTipToPane(key) {
  const tipText = modhelper_tips[key];
  const $tip = jquery_default()('<li>', {
    html: snudown_es_markdown(tipText)
  });

  if (!sessionStorage.getItem('hideTipPane')) {
    $tipPane.show();
  }

  $tipPaneList.append($tip);
}
// CONCATENATED MODULE: ./lib/modules/multiredditNavbar.js






const multiredditNavbar_module = new Module('multiredditNavbar');
multiredditNavbar_module.moduleName = 'multiredditNavbarName';
multiredditNavbar_module.description = 'multiredditNavbarDesc';
multiredditNavbar_module.category = 'subredditsCategory';
multiredditNavbar_module.include = ['linklist'];
multiredditNavbar_module.options = {
  sectionMenu: {
    type: 'boolean',
    value: true,
    description: 'multiredditNavbarSectionMenuDesc',
    title: 'multiredditNavbarSectionMenuTitle'
  },
  sectionLinks: {
    dependsOn: options => options.sectionMenu.value,
    type: 'table',
    addRowText: 'multiredditNavbarAddShortcut',
    fields: [{
      key: 'label',
      name: 'multiredditNavbarLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'multiredditNavbarUrl',
      type: 'text'
    }],
    value: [['new', './new'], ['rising', './rising'], ['controversial', './controversial'], ['top', './top'], ['top this month', './top?t=month'], ['gilded', './gilded'], ['promoted', './ads']],
    description: 'multiredditNavbarSectionLinksDesc',
    title: 'multiredditNavbarSectionLinksTitle'
  },
  hoverDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'multiredditNavbarHoverDelayDesc',
    title: 'multiredditNavbarHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'multiredditNavbarFadeDelayDesc',
    title: 'multiredditNavbarFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'multiredditNavbarFadeSpeedDesc',
    title: 'multiredditNavbarFadeSpeedTitle',
    advanced: true
  }
};

multiredditNavbar_module.contentStart = () => {
  if (multiredditNavbar_module.options.sectionMenu.value) {
    dropdownList(multiredditNavbar_module.moduleID).options({
      openDelay: penalizedDelay(multiredditNavbar_module.moduleID, 'sectionMenu', multiredditNavbar_module.options.hoverDelay),
      fadeDelay: parseFloat(multiredditNavbar_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(multiredditNavbar_module.options.fadeSpeed.value),
      pin: pin.right,
      offsetWidth: -10,
      offsetHeight: 1,
      bottomPadding: 0
    }).populateWith(card => [multiredditNavbar_getListFragment(card.getCheckedTarget().href)]).watch('.listing-chooser .multis li a');
  }
};

const multiredditNavbar_getListFragment = baseUrl => {
  alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', 5);
  const fragment = document.createDocumentFragment();

  for (const link of multiredditNavbar_module.options.sectionLinks.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="${baseUrl}${url}">${label}</a></li>`;
    li.addEventListener('click', () => {
      dropdownList(multiredditNavbar_module.moduleID).close();
      alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', -30);
    });
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(multiredditNavbar_module.moduleID, 'sectionMenu')}>
		<i>${i18n(multiredditNavbar_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
};
// CONCATENATED MODULE: ./lib/modules/neverEndingComments.js


const neverEndingComments_module = new Module('neverEndingComments');
neverEndingComments_module.moduleName = 'necName';
neverEndingComments_module.category = 'commentsCategory';
neverEndingComments_module.description = 'necDescription';
neverEndingComments_module.options = {
  loadChildComments: {
    type: 'boolean',
    value: false,
    description: 'necLoadChildCommentsDesc',
    title: 'necLoadChildCommentsTitle'
  }
};
neverEndingComments_module.include = ['comments'];

neverEndingComments_module.afterLoad = () => {
  const context = document.body.querySelector(neverEndingComments_module.options.loadChildComments.value ? '.nestedlisting' : '.nestedlisting > .thing.morechildren');
  if (!context) return;
  const visibleLoaders = new Set();
  const io = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!context.contains(target)) io.unobserve(target);
      if (isIntersecting) visibleLoaders.add(target);else visibleLoaders.delete(target);
    }

    if (visibleLoaders.size) {
      window.addEventListener('scroll', loadFirst);
      loadFirst();
    } else {
      window.removeEventListener('scroll', loadFirst);
    }
  }, {
    rootMargin: '-10% 0px 10% 0px'
  });
  const loadFirst = frameDebounce(mutex(async () => {
    const loader = Array.from(visibleLoaders.values()).sort((a, b) => 3 - (a.compareDocumentPosition(b) & 6)).find(e => {
      const thing = Thing_Thing.from(e);
      return !selectedThing_namespaceObject.current || !thing || selectedThing_namespaceObject.current.getDirectionOf(thing) === 'down';
    });

    if (loader) {
      loader.click();
      await waitForDetach(loader, new Promise(res => setTimeout(res, 3000)));
      loadFirst();
    }
  }), 5);
  watchForDescendants(context, '.morecomments a', ele => {
    io.observe(ele);
  });
};
// CONCATENATED MODULE: ./lib/modules/onboarding.js





const onboarding_module = new Module('onboarding');
onboarding_module.moduleName = 'onboardingName';
onboarding_module.category = 'aboutCategory';
onboarding_module.description = 'onboardingDesc';
onboarding_module.alwaysEnabled = true;
onboarding_module.options = {
  updateNotification: {
    title: 'onboardingUpdateNotificationName',
    description: 'onboardingUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'nothing'
    }]
  },
  patchUpdateNotification: {
    title: 'onboardingPatchUpdateNotificationName',
    description: 'onboardingPatchUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  },
  betaUpdateNotification: {
    title: 'onboardingBetaUpdateNotificationName',
    description: 'onboardingBetaUpdateNotificationDescription',
    type: 'enum',
    value: 'releaseNotes',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  }
};
const highestVersionStorage = storage_namespaceObject.wrap('highestVersion', null);

onboarding_module.go = async () => {
  const highestVersion = await highestVersionStorage.get();

  if (!highestVersion) {
    highestVersionStorage.set(metadata_version);
    return;
  }

  if (highestVersion === metadata_version || __webpack_require__(237)(highestVersion, metadata_version)) return;

  const diff = __webpack_require__(239)(metadata_version, highestVersion);

  const infoTypes = filterMap([isBeta && 'betaUpdateNotification', diff === 'patch' && 'patchUpdateNotification', (diff === 'major' || diff === 'minor') && 'updateNotification'], notificationOption => notificationOption ? [onboarding_module.options[notificationOption].value] : undefined);

  if (infoTypes.includes('releaseNotes')) {
    openNewTab(updatedURL, false);
  } else if (infoTypes.includes('notification')) {
    notifications_showNotification({
      moduleID: onboarding_module.moduleID,
      notificationID: diff,
      message: `
				${i18n('onboardingUpgradeMessage', metadata_version)}
				<p><a class="RESNotificationButtonBlue" href="${updatedURL}" target="_blank">
					${i18n('onboardingUpgradeCta')}
				</a></p>
			`.trim(),
      closeDelay: 15000
    });
  } else {
    console.log(`RES upgraded to v${metadata_version}.`);
  }

  highestVersionStorage.set(metadata_version);
};
// EXTERNAL MODULE: ./node_modules/favico.js/favico.js
var favico = __webpack_require__(131);
var favico_default = /*#__PURE__*/__webpack_require__.n(favico);

// EXTERNAL MODULE: ./lib/images/legacyFavicon.png
var legacyFavicon = __webpack_require__(132);
var legacyFavicon_default = /*#__PURE__*/__webpack_require__.n(legacyFavicon);

// CONCATENATED MODULE: ./lib/modules/orangered.js










const orangered_module = new Module('orangered');
orangered_module.moduleName = 'orangeredName';
orangered_module.category = 'myAccountCategory';
orangered_module.description = 'orangeredDesc';
orangered_module.options = {
  openMailInNewTab: {
    description: 'orangeredOpenMailInNewTabDesc',
    title: 'orangeredOpenMailInNewTabTitle',
    type: 'boolean',
    value: false
  },
  updateCurrentTab: {
    description: 'orangeredUpdateCurrentTabDesc',
    title: 'orangeredUpdateCurrentTabTitle',
    type: 'boolean',
    value: true
  },
  updateOtherTabs: {
    description: 'orangeredUpdateOtherTabsDesc',
    keywords: ['favicon', 'sync'],
    title: 'orangeredUpdateOtherTabsTitle',
    type: 'boolean',
    value: true
  },
  showFloatingEnvelope: {
    description: 'orangeredShowFloatingEnvelopeDesc',
    title: 'orangeredShowFloatingEnvelopeTitle',
    type: 'boolean',
    value: true
  },
  retroUnreadCount: {
    description: 'orangeredRetroUnreadCountDesc',
    title: 'orangeredRetroUnreadCountTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  showUnreadCountInTitle: {
    description: 'orangeredShowUnreadCountInTitleDesc',
    title: 'orangeredShowUnreadCountInTitleTitle',
    type: 'boolean',
    value: false
  },
  faviconUseLegacy: {
    description: 'faviconUseLegacyDesc',
    title: 'faviconUseLegacyTitle',
    type: 'boolean',
    value: false
  },
  showUnreadCountInFavicon: {
    description: 'orangeredShowUnreadCountInFaviconDesc',
    title: 'orangeredShowUnreadCountInFaviconTitle',
    type: 'boolean',
    value: true
  },
  faviconNotificationBGColor: {
    description: 'faviconNotificationBGColorDesc',
    title: 'faviconNotificationBGColorTitle',
    advanced: true,
    type: 'color',
    value: '#5f99cf',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  faviconNotificationTextColor: {
    description: 'faviconNotificationTextColorDesc',
    title: 'faviconNotificationTextColorTitle',
    advanced: true,
    type: 'color',
    value: '#FFFFFF',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  resetFaviconOnLeave: {
    description: 'orangeredResetFaviconOnLeaveDesc',
    title: 'orangeredResetFaviconOnLeaveTitle',
    type: 'boolean',
    value: true,
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  unreadLinksToInbox: {
    description: 'orangeredUnreadLinksToInboxDesc',
    title: 'orangeredUnreadLinksToInboxTitle',
    type: 'boolean',
    value: false,
    advanced: true
  },
  hideEmptyMail: {
    description: 'orangeredHideEmptyMailDesc',
    title: 'orangeredHideEmptyMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideModMail: {
    description: 'orangeredHideModMailDesc',
    title: 'orangeredHideModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyModMail: {
    description: 'orangeredHideEmptyModMailDesc',
    title: 'orangeredHideEmptyModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideModMail.value
  },
  hideNewModMail: {
    description: 'orangeredHideNewModMailDesc',
    title: 'orangeredHideNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyNewModMail: {
    description: 'orangeredHideEmptyNewModMailDesc',
    title: 'orangeredHideEmptyNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideNewModMail.value
  }
};

orangered_module.contentStart = () => {
  if (orangered_module.options.faviconUseLegacy.value) setupFavicon();

  if (!loggedInUser()) {
    return;
  }

  floatingButtons();

  if (orangered_module.options.openMailInNewTab.value) {
    $orangeredElements().attr('target', '_blank').attr('rel', 'noopener noreferer');
  }

  updateFromPage();
};

async function updateFromPage(doc = document.body) {
  if (!isRunning(orangered_module)) return;
  if (!orangered_module.options.updateCurrentTab.value) return;
  if (!loggedInUser()) return;
  const debuginfoElement = doc.querySelector('.debuginfo');
  const timestampRegex = /(\d{4})-(\d{2})-(\d{2}) (\d{2})\:(\d{2})\:(\d{2})\.(\d+)[+-](\d{2})\:(\d{2})/;
  const [timestamp] = debuginfoElement && timestampRegex.exec(debuginfoElement.textContent) || [];

  if (Date.parse(timestamp)) {
    const lastUpdate = await session_namespaceObject.get('orangered.last-update');
    session_namespaceObject.set('orangered.last-update', timestamp);
    if (lastUpdate && new Date(lastUpdate) >= new Date(timestamp)) return;
  }

  setUnreadCount(getUnreadCount(doc));
}
let lastCount = 0;

const _setUnreadCount = multicast(count => {
  if (count === lastCount) return;
  lastCount = count;
  updateFaviconBadge(count);
  updateTitle(count);
  updateInboxElements(count);
  updateMailCountElements(count);

  if (count > 0) {
    window.dispatchEvent(new Event('orangered'));
  }
}, {
  name: 'setUnreadCount',
  crossContext: false
});

function setUnreadCount(count) {
  if (orangered_module.options.updateOtherTabs.value) {
    _setUnreadCount(count);
  } else {
    _setUnreadCount.local(count);
  }
}

function updateTitle(count) {
  if (!orangered_module.options.showUnreadCountInTitle.value) return;

  if (count > 0) {
    document.title = `[${count}] ${document.title.replace(/^\[[\d]+\]\s/, '')}`;
  } else {
    document.title = document.title.replace(/^\[[\d]+\]\s/, '');
  }
}

function updateInboxElements(count) {
  const {
    nativeInboxButton,
    $floatingInboxButton
  } = orangeredElements();
  jquery_default()().add($floatingInboxButton).add(nativeInboxButton).attr('title', count ? 'new mail!' : 'No new mail').toggleClass('havemail', !!count).toggleClass('nohavemail', !count).attr('href', getInboxLink(count));
}

function updateMailCountElements(count) {
  const {
    nativeInboxCount,
    $floatingInboxCount
  } = orangeredElements();
  jquery_default()().add($floatingInboxCount).add(nativeInboxCount).css('display', count ? 'inline-block' : 'none').attr('href', getInboxLink(count)).attr('title', count ? 'new mail!' : 'No new mail').text(count).addClass('message-count');
}

function updateFaviconBadge(count) {
  if (orangered_module.options.showUnreadCountInFavicon.value) {
    setupFavicon().badge(count);
  }
}

const setupFavicon = lodash_once_default()(() => {
  const favicons = Array.from(document.head.querySelectorAll('link[rel="icon"]'));

  const selectedFavicon = favicons.find(f => f.getAttribute('sizes') === '96x96') || last_default()(favicons);

  for (const f of favicons) {
    if (f !== selectedFavicon) f.remove();
  }

  if (orangered_module.options.faviconUseLegacy.value) {
    selectedFavicon.setAttribute('href', legacyFavicon_default.a);
  }

  const favicon = new favico_default.a({
    bgColor: orangered_module.options.faviconNotificationBGColor.value,
    textColor: orangered_module.options.faviconNotificationTextColor.value
  });

  if (orangered_module.options.resetFaviconOnLeave.value) {
    window.addEventListener('beforeunload', () => favicon.reset());
  }

  return favicon;
});

const orangeredElements = () => ({ ...nativeButtons(),
  ...floatingButtons(),
  modmailButtonSelector: '#modmail'
});

const $orangeredElements = () => Object.values(orangeredElements()).reduce(($all, ele) => $all.add(ele), jquery_default()());

const nativeButtons = lodash_once_default()(() => {
  const nativeInboxButton = document.querySelector('#header-bottom-right #mail');
  let nativeInboxCount = document.querySelector('#header-bottom-right .message-count');

  if (!nativeInboxCount && (orangered_module.options.updateCurrentTab.value || orangered_module.options.updateOtherTabs.value)) {
    nativeInboxCount = document.createElement('a');
    nativeInboxCount.style.display = 'none';
    nativeInboxButton.after(nativeInboxCount);
  }

  return {
    nativeInboxButton,
    nativeInboxCount
  };
});

const floatingButtons = lodash_once_default()(() => {
  if (!orangered_module.options.showFloatingEnvelope.value) {
    return {
      $floatingInboxButton: undefined,
      $floatingInboxCount: undefined
    };
  }

  let $floatingInboxButton, $floatingInboxCount;
  const pinHeader = betteReddit_module.options.pinHeader.value;

  if (pinHeader === 'sub' || pinHeader === 'none') {
    $floatingInboxButton = jquery_default()('<a>', {
      id: 'NREMail',
      class: 'nohavemail'
    });
    addFloater($floatingInboxButton.get(0));
    $floatingInboxCount = jquery_default()('<a>', {
      id: 'NREMailCount'
    });
    $floatingInboxCount.css('display', 'none');
    $floatingInboxCount.attr('href', getInboxLink(true));
    addFloater($floatingInboxCount.get(0));
  }

  return {
    $floatingInboxButton,
    $floatingInboxCount
  };
});

function getInboxLink(havemail) {
  if (havemail && !orangered_module.options.unreadLinksToInbox.value) {
    return '/message/unread/';
  }

  return '/message/inbox/';
}

function getUnreadCount(container) {
  const mailCount = container.querySelector('.message-count');
  return mailCount && parseInt(mailCount.textContent, 10) || 0;
}
// CONCATENATED MODULE: ./lib/modules/pageNavigator.js






const pageNavigator_module = new Module('pageNavigator');
pageNavigator_module.moduleName = 'pageNavName';
pageNavigator_module.category = 'browsingCategory';
pageNavigator_module.description = 'pageNavDesc';
pageNavigator_module.options = {
  toTop: {
    type: 'boolean',
    value: true,
    description: 'pageNavToTopDesc',
    title: 'pageNavToTopTitle'
  },
  toComment: {
    type: 'boolean',
    value: true,
    description: 'pageNavToCommentDesc',
    title: 'pageNavToCommentTitle'
  },
  showLink: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkDesc',
    title: 'pageNavShowLinkTitle'
  },
  showLinkNewTab: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkNewTabDesc',
    title: 'pageNavShowLinkNewTabTitle',
    dependsOn: options => options.showLink.value
  }
};

pageNavigator_module.beforeLoad = () => {
  if (pageNavigator_module.options.showLink.value && isPageType('comments')) {
    watchForThings(['post'], showLinkTitle);
  }
};

pageNavigator_module.contentStart = () => {
  if (pageNavigator_module.options.toComment.value && isPageType('comments')) {
    backToNewCommentArea();
  }

  if (pageNavigator_module.options.toTop.value) {
    backToTop();
  }
};

function backToTop() {
  const element = string_namespaceObject.html`<a class="pageNavigator res-icon" data-id="top" href="#header" title="${i18n('pageNavToTopTitle')}">&#xF148;</a>`;
  element.addEventListener('click', e => {
    e.preventDefault();
    window.scrollTo(0, 0);
    selectedThing_namespaceObject.move('top');
  });
  addFloater(element, {
    order: 9
  });
}

const showLinkTitleTemplate = ({
  thumbnailSrc,
  linkId,
  settingsHash,
  linkHref,
  linkNewTab,
  title,
  domainHref,
  domain,
  time,
  author,
  authorHref
}) => string_namespaceObject.html`
	<div class="res-show-link hide">
		${thumbnailSrc && string_namespaceObject._html`
			<span class="res-show-link-thumb"><img src="${thumbnailSrc}" alt="thumbnail" /></span>
		`}
		<a href="#${linkId}" class="res-icon toTop" title="Jump to title">&#xF148;</a>
		<a href="${settingsHash}" class="gearIcon" title="Configure this widget"></a>
		<div class="res-show-link-content">
			<div class="res-show-link-header">
				<a href="${linkHref}" ${linkNewTab && string_namespaceObject._html`target="_blank" rel="noopener noreferer"`} class="res-show-link-title">${title}</a>
				<a href="${domainHref}" class="res-show-link-domain">(<span>${domain}</span>)</a>
			</div>
			<div class="res-show-link-tagline">
				Submitted ${time} by
				<a href="${authorHref}" class="res-show-link-author">${author}</a>
			</div>
		</div>
	</div>
`;

function backToNewCommentArea() {
  const commentArea = document.querySelector('.commentarea > form.usertext textarea:not([disabled])');
  if (!commentArea) return;
  const element = string_namespaceObject.html`<a class="pageNavigator res-icon" data-id="addComment" href="#comments" title="${i18n('pageNavToCommentTitle')}">&#xF003;</a>`;
  element.addEventListener('click', e => {
    e.preventDefault();
    commentArea.focus();
  });
  addFloater(element, {
    container: 'visibleAfterScroll'
  });
}

const showLinkTitle = lodash_once_default()(submissionThing => {
  let $widget;
  let belowSubmission = true;
  let baseHeight, hoverHeight;

  function showWidget() {
    $widget.css({
      top: getHeaderOffset(true)
    }).removeClass('hide');
  }

  function hideWidget() {
    $widget.css({
      top: -baseHeight
    }).addClass('hide');
  }

  function renderWidget() {
    return jquery_default()(showLinkTitleTemplate({
      linkId: submissionThing.element.id,
      thumbnailSrc: submissionThing.getPostThumbnailUrl(),
      linkHref: submissionThing.getTitleUrl(),
      linkNewTab: pageNavigator_module.options.showLinkNewTab.value,
      title: submissionThing.getTitle(),
      domainHref: submissionThing.getPostDomainUrl(),
      domain: submissionThing.getPostDomainText(),
      time: submissionThing.getPostTime(),
      authorHref: submissionThing.getAuthorUrl(),
      author: submissionThing.getAuthor(),
      settingsHash: makeUrlHash(pageNavigator_module.moduleID, 'showLink')
    }));
  }

  const updateWidget = frameThrottle(e => {
    const scrollingUp = e.deltaY < 0;

    if (scrollingUp && belowSubmission) {
      initialize();
      showWidget();
    } else if ($widget) {
      hideWidget();
    }
  });

  const initialize = lodash_once_default()(() => {
    $widget = renderWidget().on('mouseenter', () => $widget.css({
      height: hoverHeight
    })).on('mouseleave', () => $widget.css({
      height: baseHeight
    })).appendTo(document.body);
    baseHeight = $widget.get(0).getBoundingClientRect().height;
    hoverHeight = $widget.get(0).scrollHeight;
    new IntersectionObserver(entries => {
      belowSubmission = !entries[0].isIntersecting;
      if (!belowSubmission) hideWidget();
    }, {
      rootMargin: '100px 0px 0px 0px'
    }).observe(submissionThing.element);
    window.addEventListener('scroll', () => {
      if (scrollToElement.isProgrammaticEvent()) hideWidget();
    });
  });

  window.addEventListener('wheel', updateWidget, {
    passive: true
  });
});
// CONCATENATED MODULE: ./lib/modules/troubleshooter.js







const troubleshooter_module = new Module('troubleshooter');
troubleshooter_module.moduleName = 'troubleshooterName';
troubleshooter_module.alwaysEnabled = true;
troubleshooter_module.sort = -7;
troubleshooter_module.description = 'troubleshooterDesc';
troubleshooter_module.category = 'aboutCategory';
troubleshooter_module.options = {
  clearCache: {
    title: 'troubleshooterClearCacheTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearCache,
    description: 'troubleshooterClearCacheDesc'
  },
  clearTags: {
    title: 'troubleshooterClearTagsTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearTags,
    description: 'troubleshooterClearTagsDesc'
  },
  resetToFactory: {
    title: 'troubleshooterResetToFactoryTitle',
    type: 'button',
    text: 'troubleshooterResetLabel',
    callback: resetToFactory,
    description: 'troubleshooterResetToFactoryDesc'
  },
  disableRES: {
    title: 'troubleshooterDisableRESTitle',
    type: 'button',
    text: 'troubleshooterDisableLabel',

    callback() {
      const url = new URL(context_data.pathname, context_data.origin);
      url.hash = RES_DISABLED_HASH;
      window.top.location.href = url.href;
    },

    description: 'troubleshooterDisableRESDesc'
  },
  breakpoint: {
    title: 'troubleshooterBreakpointTitle',
    type: 'button',
    text: 'troubleshooterBreakpointLabel',

    callback() {
      debugger;
    },

    description: 'troubleshooterBreakpointDesc'
  },
  testEnvironment: {
    title: 'troubleshooterTestEnvironmentTitle',
    type: 'button',
    text: 'troubleshooterTestEnvironmentLabel',
    callback: testEnvironment,
    description: 'troubleshooterTestEnvironmentDesc'
  },
  testNotifications: {
    title: 'troubleshooterTestNotificationsTitle',
    type: 'button',
    text: 'troubleshooterTestNotificationsLabel',
    callback: testNotifications,
    description: 'troubleshooterTestNotificationsDesc'
  }
};

function clearCache() {
  xhrCache_namespaceObject.clear();
  session_namespaceObject.clear();
  localStorage.removeItem(CACHED_LANG_KEY);
  localStorage.removeItem(CACHED_MESSAGES_TOKEN_KEY);
  localStorage.removeItem(CACHED_MESSAGES_KEY);
  notifications_showNotification(i18n('troubleshooterCachesCleared'), 2500);
}

async function clearTags() {
  const confirm = window.confirm(i18n('troubleshooterAreYouPositive'));

  if (confirm) {
    const toDelete = (await userTagger_Tag.getStored()).filter(({
      text,
      votesUp = 0,
      votesDown = 0
    }) => !text && votesUp <= 1 && votesDown <= 1);

    for (const tag of toDelete) tag.delete();

    notifications_showNotification(i18n('troubleshooterEntriesRemoved', toDelete.length), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function resetToFactory() {
  const confirm = window.prompt(i18n('troubleshooterThisWillKillYourSettings', 'trash'));

  if (confirm === 'trash' || confirm === '"trash"') {
    clearCache();
    storage_namespaceObject.clear();
    notifications_showNotification(i18n('troubleshooterSettingsReset'), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function testNotifications() {
  notifications_showNotification({
    moduleID: troubleshooter_module.moduleID,
    header: 'Template test',
    message: '<p>Hello, FakeUsername</p>'
  });
}

const testMulticast = multicast(val => {
  alert_namespaceObject.open(`Multicast: ${val}`);
}, {
  name: 'testMulticast',
  local: false,
  crossContext: false
});

async function testEnvironment() {
  const testKey = '__test__';
  const rows = [];

  try {
    let rand;
    rows.push(`Private browsing: ${String(isPrivateBrowsing())}`, '');
    rand = Math.random();
    rows.push(`Sending multicast: ${rand}`, '');
    testMulticast(rand);
    rand = Math.random();
    rows.push(`Storage.set(): ${rand}`);
    storage_namespaceObject.set(testKey, rand);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`);
    rows.push('Storage.delete()');
    storage_namespaceObject.delete(testKey);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    rows.push(`Session.set(): ${rand}`);
    session_namespaceObject.set(testKey, rand);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`);
    rows.push('Session.delete()');
    session_namespaceObject.delete(testKey);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    const wrapped = storage_namespaceObject.wrap(testKey, 'default');
    rows.push(`wrapped.set(): ${rand}`);
    wrapped.set(rand);
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`);
    rows.push('wrapped.delete()');
    wrapped.delete();
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`, '');
    rand = Math.random();
    const domain = storage_namespaceObject.wrapPrefix(testKey, () => 'default');
    rows.push(`prefix.set(): ${rand}`);
    domain.set('1', rand);
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`);
    rows.push('prefix.delete()');
    domain.delete('1');
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`, '');
    rand = Math.random();
    const blob = storage_namespaceObject.wrapBlob(testKey, () => 'default');
    rows.push(`blob.set(): ${rand}`);
    blob.set('1', rand);
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`);
    rows.push('blob.delete()');
    blob.delete('1');
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`, '');
  } catch (e) {
    rows.push('', `Errored: ${e}`);
    console.error(e);
  }

  alert_namespaceObject.open(rows.join('<br>'));
}
// CONCATENATED MODULE: ./lib/modules/presets.js






const presets_module = new Module('presets');
presets_module.moduleName = 'presetsName';
presets_module.category = 'coreCategory';
presets_module.alwaysEnabled = true;
presets_module.description = 'presetsDesc';
presets_module.options = {
  lite: {
    title: 'presetsLiteTitle',
    description: 'presetsLiteDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(['notifications', 'hover', 'announcements', 'orangered', 'onboarding', 'selectedEntry', 'showImages', 'submitHelper', 'neverEndingReddit', 'accountSwitcher', 'filteReddit', 'quickMessage', 'subredditInfo', 'userInfo', 'userHighlight', 'searchHelper', 'betteReddit', 'styleTweaks', 'pageNavigator', 'commandLine', 'commentHidePersistor', 'commentTools', 'commentPreview', 'localDate', 'noParticipation'], '*'))
  },
  cleanSlate: {
    title: 'presetsCleanSlateTitle',
    description: 'presetsCleanSlateDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(undefined, '*'))
  },
  noPopups: {
    title: 'presetsNoPopupsTitle',
    description: 'presetsNoPopupsDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(async () => {
      await toggleModules(undefined, 'hover RESTips showParent subredditInfo'.split(/[,\s]/));
      await toggleOptions(undefined, 'userTagger.hoverInfo'.split(/[,\s]/));
    })
  },
  resetToFactory: troubleshooter_module.options.resetToFactory
};

function confirmPreset(callback) {
  return async function () {
    const confirmation = prompt(`Are you sure you want to apply the "${i18n(this.title)}" preset? Type "yes" to continue.`);

    if (/^"?yes"?$/.test(confirmation)) {
      await callback();
      const shouldReload = confirm(`Applied preset: ${i18n(this.title)}\nYou must reload the page to see results.\n\nWould you like to reload now?`);

      if (shouldReload) {
        location.reload();
      }
    } else {
      notifications_showNotification({
        moduleID: presets_module.moduleID,
        header: 'Preset cancelled',
        message: 'If you really wanted to apply this preset, make sure to type in "yes" when prompted.'
      });
    }
  };
}

function sanitizeModulesList(unsanitized) {
  let sanitized;

  if (unsanitized === '*') {
    sanitized = allModules();
  } else if (typeof unsanitized === 'string') {
    sanitized = unsanitized.split(/[,\s]/);
  } else if (unsanitized && unsanitized.length) {
    sanitized = unsanitized;
  }

  return sanitized ? [].concat(sanitized) : [];
}

async function toggleModules(requestEnable, requestDisable) {
  let enable = sanitizeModulesList(requestEnable);
  let disable = sanitizeModulesList(requestDisable);
  disable = requestEnable !== '*' ? disable.filter(moduleID => !enable.includes(moduleID)) : disable;
  enable = requestDisable !== '*' ? enable.filter(moduleID => !disable.includes(moduleID)) : enable;

  for (const modId of disable) await setEnabled(modId, false);

  for (const modId of enable) await setEnabled(modId, true);
}

function allModules() {
  return modules_all().map(mod => mod.moduleID);
}

async function toggleOptions(requestEnable, requestDisable) {
  const enable = requestEnable ? [].concat(requestEnable) : [];
  const disable = requestDisable ? [].concat(requestDisable) : [];

  for (const option of enable) await setOptionValue(true, option);

  for (const option of disable) await setOptionValue(false, option);
}

async function setOptionValue(value, path) {
  if (typeof path === 'string') {
    path = path.split('.');
  }

  const [id, optName] = path;
  await options_storage_set(id, optName, value);
}
// CONCATENATED MODULE: ./lib/modules/profileNavigator.js






const profileNavigator_module = new Module('profileNavigator');
profileNavigator_module.moduleName = 'profileNavigatorName';
profileNavigator_module.description = 'profileNavigatorDesc';
profileNavigator_module.category = 'myAccountCategory';
profileNavigator_module.options = {
  sectionMenu: {
    title: 'profileNavigatorSectionMenuTitle',
    type: 'boolean',
    value: true,
    description: 'profileNavigatorSectionMenuDesc'
  },
  sectionLinks: {
    title: 'profileNavigatorSectionLinksTitle',
    dependsOn: options => options.sectionMenu.value,
    description: 'profileNavigatorSectionLinksDesc',
    type: 'table',
    addRowText: '+add profile section shortcut',
    fields: [{
      key: 'label',
      name: 'label',
      type: 'text'
    }, {
      key: 'url',
      name: 'url',
      type: 'text'
    }],
    value: [['saved', './saved'], ['comments', './comments'], ['submitted', './submitted'], ['gilded', './gilded'], ['upvoted', './upvoted'], ['downvoted', './downvoted']]
  },
  hoverDelay: {
    title: 'profileNavigatorHoverDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'profileNavigatorHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'profileNavigatorFadeDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'profileNavigatorFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'profileNavigatorFadeSpeedTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'profileNavigatorFadeSpeedDesc',
    advanced: true
  }
};

profileNavigator_module.contentStart = () => {
  const username = loggedInUser();

  if (profileNavigator_module.options.sectionMenu.value && username) {
    dropdownList(profileNavigator_module.moduleID).options({
      openDelay: penalizedDelay(profileNavigator_module.moduleID, 'sectionMenu', profileNavigator_module.options.hoverDelay),
      fadeDelay: parseFloat(profileNavigator_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(profileNavigator_module.options.fadeSpeed.value),
      pin: pin.bottom
    }).populateWith(() => [profileNavigator_getListFragment(username)]).watch('#header .user a');
  }
};

const profileNavigator_getListFragment = username => {
  alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', 5);
  const fragment = document.createDocumentFragment();

  for (const link of profileNavigator_module.options.sectionLinks.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="/user/${username}/${url}">${label}</a></li>`;
    li.addEventListener('click', () => {
      dropdownList(profileNavigator_module.moduleID).close();
      alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', -30);
    });
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(profileNavigator_module.moduleID, 'sectionMenu')}>
		<i>${i18n(profileNavigator_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
};
// CONCATENATED MODULE: ./lib/modules/profileRedirect.js





const profileRedirect_module = new Module('profileRedirect');
profileRedirect_module.moduleName = 'profileRedirectName';
profileRedirect_module.category = 'usersCategory';
profileRedirect_module.description = 'profileRedirectDesc';
profileRedirect_module.keywords = ['legacy', 'overview'];
profileRedirect_module.include = ['profile', 'profile2x'];
profileRedirect_module.options = {
  fromLandingPage: {
    title: 'profileRedirectFromLandingPageTitle',
    description: 'profileRedirectFromLandingPageDesc',
    keywords: ['legacy', 'overview'],
    type: 'enum',
    value: 'none',
    values: [{
      name: 'Do nothing',
      value: 'none'
    }, {
      name: 'Overview (legacy)',
      value: 'overview'
    }, {
      name: 'Comments',
      value: 'comments'
    }, {
      name: 'Submitted (legacy)',
      value: 'submitted'
    }, {
      name: 'Gilded',
      value: 'gilded'
    }, {
      name: 'Custom',
      value: 'custom'
    }]
  },
  customFromLandingPage: {
    dependsOn: options => options.fromLandingPage.value === 'custom',
    title: 'profileRedirectCustomFromLandingPageTitle',
    description: 'profileRedirectCustomFromLandingPageDesc',
    type: 'text',
    value: ''
  }
};

profileRedirect_module.beforeLoad = function () {
  const [, username, currentSection] = regexes.profile2x.exec(location.pathname) || [];

  if (username && !currentSection) {
    if (profileRedirect_module.options.fromLandingPage.value !== 'none') {
      const preferredSection = profileRedirect_module.options.fromLandingPage.value === 'custom' ? profileRedirect_module.options.customFromLandingPage.value : profileRedirect_module.options.fromLandingPage.value;
      window.location.replace(`/user/${username}/${preferredSection}`);
    } else if (isPageType('profile2x')) {
      const message = string_namespaceObject.html`
				<div>
					<p>${i18n('profileRedirectFromLandingPageNotificationText')}</p>
					<p><a class="RESNotificationButtonBlue" href="${makeUrlHash(profileRedirect_module.moduleID, 'fromLandingPage')}">${i18n('profileRedirectFromLandingPageNotificationButton')}</a></p>
				</div>
			`;
      const notification = notifications_showNotification({
        moduleID: profileRedirect_module.moduleID,
        optionKey: 'fromLandingPage',
        header: i18n('profileRedirectFromLandingPageNotificationTitle'),
        message,
        cooldown: WEEK
      });
      message.querySelector('.RESNotificationButtonBlue').addEventListener('click', () => {
        notification.close();
      });
    }
  }
};
// CONCATENATED MODULE: ./lib/modules/quarantineHide.js




const quarantineHide_module = new Module('quarantineHide');
quarantineHide_module.moduleName = 'quarantineHideName';
quarantineHide_module.category = 'appearanceCategory';
quarantineHide_module.description = 'quarantineHideDesc';
quarantineHide_module.options = {
  hideFlair: {
    title: 'quarantineHideFlairTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideFlairDesc'
  },
  hideQuarantinedInSub: {
    title: 'quarantineHideInSubTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideInSubDesc'
  }
};
quarantineHide_module.include = ['linklist', 'comments', 'wiki'];

quarantineHide_module.contentStart = () => {
  if (quarantineHide_module.options.hideFlair.value) {
    watchForThings(['post'], frameThrottle(() => {
      jquery_default()('.quarantine-stamp').parent().remove();
    }));
  }

  if (inQuarantinedSubreddit() && quarantineHide_module.options.hideQuarantinedInSub.value) {
    bodyClasses_namespaceObject.remove('quarantine');
    jquery_default()('.quarantine-notice').hide();
  }
};
// CONCATENATED MODULE: ./lib/modules/redditUserInfo.js

const redditUserInfo_module = new Module('redditUserInfo');
redditUserInfo_module.moduleName = 'redditUserInfoName';
redditUserInfo_module.category = 'usersCategory';
redditUserInfo_module.description = 'redditUserInfoDesc';
redditUserInfo_module.options = {
  hideAuthorTooltip: {
    type: 'boolean',
    value: false,
    description: 'redditUserInfoHideDesc',
    title: 'redditUserInfoHideTitle',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/requestPermissions.js

const requestPermissions_module = new Module('requestPermissions');
requestPermissions_module.moduleName = 'requestPermissionsName';
requestPermissions_module.description = 'requestPermissionsDesc';
requestPermissions_module.category = 'aboutCategory';
requestPermissions_module.disabledByDefault = true;
requestPermissions_module.permissions = {
  get requiredPermissions() {
    return chrome.runtime.getManifest().optional_permissions;
  }

};
// CONCATENATED MODULE: ./lib/modules/search.js










const search_module = new Module('search');
search_module.moduleName = 'searchName';
search_module.category = 'aboutCategory';
search_module.alwaysEnabled = true;
search_module.sort = -9;
search_module.description = `
	<p>Search for settings within RES.</p>
	<div id="SearchRES-results-container">
		<div id="SearchRES-count"></div>
		<ul id="SearchRES-results"></ul>
		<p id="SearchRES-results-hidden">Some results have been hidden because advanced options are currently hidden. <a href="#">Show advanced options.</a></p>
	</div>
	<div id="SearchRES-boilerplate">
		<p>You can search for RES options by module name, option name, and description. For example, try searching for "daily trick" in one of the following ways:</p>
		<ul>
			<li>type <code>daily trick</code> in the search box to the left and click the magnifying glass button</li>
			<li>press <code>.</code> to open the RES console, type in <code>search <em>daily trick</em></code>, and press Enter</li>
		</ul>
	</div>
`;
search_module.descriptionRaw = true;
const PRESERVE_SPACES = true;
function search_search(query = search_input().value) {
  search_input().value = query;

  if (!query) {
    drawSearchResults(query, []);
    return;
  }

  const sanitizedQuery = sanitizeString(query, PRESERVE_SPACES);
  const queryTerms = sanitizedQuery && sanitizedQuery.length ? sanitizedQuery.split(' ') : [];
  let results = [];

  if (queryTerms && queryTerms.length) {
    results = searchDomain().map(item => ({
      rank: item.getRank(queryTerms, item.context),
      context: item.context
    })).filter(item => item.rank !== Infinity).sort((a, b) => b.rank - a.rank).map(item => item.context);
  }

  drawSearchResults(query, results);
}

const searchDomain = lodash_once_default()(() => {
  const results = [];

  for (const mod of modules_all()) {
    if (mod === search_module) continue;
    if (mod.hidden) continue;
    const moduleName = i18n(mod.moduleName);
    const category = i18n(mod.category);
    results.push({
      getRank: rankModule,
      context: {
        title: moduleName,
        description: mod.descriptionRaw ? mod.description : snudown_es_markdown(i18n(mod.description)),
        category,
        moduleID: mod.moduleID,
        moduleName,
        keywords: mod.keywords
      }
    });
    if (isEmpty_default()(mod.options)) continue;

    for (const [optionKey, option] of Object.entries(mod.options)) {
      if (option.noconfig) continue;
      const optionName = i18n(option.title);
      results.push({
        getRank: rankOption,
        context: {
          title: optionName,
          description: snudown_es_markdown(i18n(option.description).split('\n')[0]),
          advanced: option.advanced,
          category,
          moduleID: mod.moduleID,
          moduleName,
          optionKey,
          optionName,
          keywords: option.keywords || []
        }
      });
    }
  }

  return results;
});

function rankString(queryTerms, string) {
  if (!queryTerms || !queryTerms.length || !string) {
    return Infinity;
  }

  const indexes = indexesOfSearchTermsInString(queryTerms, sanitizeString(string, false));
  const weighted = indexes.map(item => 100 - item.value * (Math.log(item.matchedIndex + 1) / Math.log(5) + 1));
  return weighted.length ? weighted.reduce((a, b) => a + b, 0) : Infinity;
}

function rankModule(queryTerms, context) {
  const string = [context.moduleID, context.moduleName, context.category, context.description, ...context.keywords].join('~');
  return rankString(queryTerms, string) * 0.9;
}

function rankOption(queryTerms, context) {
  const string = [context.optionKey, context.title, context.description, ...context.keywords, context.moduleID, context.moduleName, context.category].join('~');
  return rankString(queryTerms, string);
}

function indexesOfSearchTermsInString(needles, haystack) {
  if (!haystack || !haystack.length) return [];
  return needles.map((needle, i) => ({
    matchedIndex: i,
    value: haystack.indexOf(needle)
  })).filter(item => item.value !== -1);
}

function sanitizeString(text, preserveSpaces) {
  if (text === undefined || text === null) {
    return '';
  }

  const replaceSpacesWith = preserveSpaces ? ' ' : '';
  return text.toString().toLowerCase().replace(/[,\/\s]+/g, replaceSpacesWith);
}

function onSearchResultSelected(moduleID, optionKey) {
  settingsNavigation_open(moduleID, optionKey);
}

const search_input = lodash_once_default()(() => downcast(string_namespaceObject.html`<input id="SearchRES-input" type="text" placeholder="${i18n('searchRESSettings')}">`, HTMLInputElement));

function drawSearchResults(query, results) {
  const $resultsContainer = jquery_default()('#SearchRES-results-container');
  $resultsContainer.off('click', handleSearchResultClick).on('click', '.SearchRES-result-item', handleSearchResultClick);

  if (!query || !query.length) {
    $resultsContainer.hide();
    return;
  }

  const advancedResults = results.filter(({
    advanced
  }) => advanced).length;
  const count = results.length - advancedResults;
  const plural = count !== 1 ? 's' : '';
  jquery_default()('#SearchRES-count').text(`${count} result${plural} for ${query}`);
  $resultsContainer.show();
  $resultsContainer.find('#SearchRES-query').text(query);

  if (advancedResults) {
    $resultsContainer.find('#SearchRES-results-hidden').addClass('advancedResults');
    jquery_default()('#SearchRES-results-hidden a').off('click').on('click', () => {
      jquery_default()(document.getElementById('RESAllOptions')).click();
      search_search();
      return false;
    });
  } else {
    $resultsContainer.find('#SearchRES-results-hidden').removeClass('advancedResults');
  }

  if (!results.length) {
    $resultsContainer.find('#SearchRES-results').hide();
  } else {
    $resultsContainer.find('#SearchRES-results').show();
    const resultsList = document.getElementById('SearchRES-results');
    empty(resultsList);
    resultsList.append(...results.map(drawSearchResultItem));
  }
}

const searchResultTemplate = ({
  title,
  category,
  description,
  moduleName,
  moduleID,
  optionName,
  optionKey
}) => string_namespaceObject.html`
	<div>
		<div class="SearchRES-result-header">
			<span class="SearchRES-result-title">${title}</span>
			<span class="SearchRES-breadcrumb">${i18n('RESSettingsConsole')}
				 ${category}
				 ${moduleName} (${moduleID})
				${optionName && optionKey ? `  ${optionName} (${optionKey})` : optionKey && `  ${optionKey}`}
			</span>
		</div>
		<div class="SearchRES-result-description">
			${string_namespaceObject.safe(description)}
		</div>
	</div>
`;

const drawSearchResultItem = memoize_default()(result => {
  const element = document.createElement('li');
  element.classList.add('SearchRES-result-item');

  if (result.advanced) {
    element.classList.add('advanced');
  }

  element.setAttribute('data-module-id', result.moduleID);

  if (result.optionKey) {
    element.setAttribute('data-option-key', result.optionKey);
  }

  element.appendChild(searchResultTemplate(result));
  const copybutton = createElement_namespaceObject.icon(0xF159, 'span', 'SearchRES-result-copybutton res-icon', i18n('searchCopyResultForComment'));
  element.insertBefore(copybutton, element.firstChild);
  return element;
});

function handleSearchResultClick(event) {
  const moduleID = this.getAttribute('data-module-id');
  const optionKey = this.getAttribute('data-option-key');

  if (event.target.classList.contains('SearchRES-result-copybutton')) {
    onSearchResultCopy(moduleID, optionKey);
  } else {
    onSearchResultSelected(moduleID, optionKey);
  }

  event.preventDefault();
}

function onSearchResultCopy(moduleID, optionKey) {
  const markdown = makeOptionSearchResultLink(moduleID, optionKey);
  alert_namespaceObject.open(`<textarea rows="5" cols="50">${markdown}</textarea><p>Copy and paste this into your comment</p>`);
}

const optionLinkTemplate = ({
  title,
  url,
  description,
  settingsUrl,
  category,
  moduleName,
  moduleUrl,
  moduleID,
  optionKey,
  optionUrl
}) => `
**[${title}](${url})** -- [](#gear) [RES settings console](${settingsUrl}) > ${category} > [${moduleName}](${moduleUrl} "${moduleID}")${optionKey ? ` > [${optionKey}](${optionUrl})` : ''}

${description}
`.trim();

function makeOptionSearchResultLink(moduleID, optionKey) {
  const module = modules_get(moduleID);
  const context = {
    moduleID,
    moduleName: i18n(module.moduleName),
    category: i18n(module.category),
    optionKey,
    title: optionKey ? optionKey : i18n(module.moduleName),
    description: optionKey ? i18n(module.options[optionKey].description) : i18n(module.description),
    url: makeUrlHash(moduleID, optionKey),
    settingsUrl: makeUrlHash(),
    moduleUrl: makeUrlHash(moduleID),
    optionUrl: makeUrlHash(moduleID, optionKey)
  };
  return `${optionLinkTemplate(context)}\n\n\n`;
}
// CONCATENATED MODULE: ./lib/modules/searchHelper.js



const searchHelper_module = new Module('searchHelper');
searchHelper_module.moduleName = 'searchHelperName';
searchHelper_module.category = 'browsingCategory';
searchHelper_module.description = 'searchHelperDesc';
searchHelper_module.options = {
  addSearchOptions: {
    title: 'searchHelperAddSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperAddSearchOptionsDesc'
  },
  defaultSortOption: {
    title: 'searchHelperDefaultSortOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'hot',
      value: 'hot'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    description: 'searchHelperDefaultSortOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  defaultTimeOption: {
    title: 'searchHelperDefaultTimeOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'all',
      value: 'all'
    }, {
      name: 'hour',
      value: 'hour'
    }, {
      name: 'day',
      value: 'day'
    }, {
      name: 'week',
      value: 'week'
    }, {
      name: 'month',
      value: 'month'
    }, {
      name: 'year',
      value: 'year'
    }],
    description: 'searchHelperDefaultTimeOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  legacySearch: {
    title: 'searchHelperLegacySearchTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperLegacySearchDesc'
  },
  toggleSearchOptions: {
    title: 'searchHelperToggleSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperToggleSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  hideSearchOptions: {
    title: 'searchHelperHideSearchOptionsTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperHideSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  userFilterBySubreddit: {
    title: 'searchHelperUserFilterBySubredditTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperUserFilterBySubredditDesc'
  },
  searchByFlair: {
    title: 'searchHelperSearchByFlairTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchByFlairDesc'
  },
  searchPageTabs: {
    title: 'searchHelperSearchPageTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchPageTabsDesc',
    bodyClass: true
  },
  defaultSearchTab: {
    title: 'searchHelperDefaultSearchTabTitle',
    type: 'enum',
    value: 'subreddits',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'subreddits',
      value: 'subreddits'
    }, {
      name: 'limit to subreddit',
      value: 'facets'
    }, {
      name: 'refine',
      value: 'options'
    }],
    description: 'searchHelperDefaultSearchTabDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  transitionSearchTabs: {
    title: 'searchHelperTransitionSearchTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperTransitionSearchTabsDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  searchBySubreddit: {
    title: 'searchHelperSearchBySubredditTitle',
    type: 'enum',
    value: 'default',
    values: [{
      name: 'default (let reddit manage it)',
      value: 'default'
    }, {
      name: 'always',
      value: 'always'
    }, {
      name: 'never',
      value: 'never'
    }],
    description: 'searchHelperSearchBySubredditDesc'
  }
};

searchHelper_module.contentStart = () => {
  if (searchHelper_module.options.addSearchOptions.value) {
    const searchExpando = document.getElementById('searchexpando');

    if (searchExpando) {
      let searchOptionsHtml = '<label>Sort:<select name="sort"><option value="relevance">relevance</option><option value="new">new</option><option value="hot">hot</option><option value="top">top</option><option value="comments">comments</option></select></label> <label>Time:<select name="t"><option value="all">all time</option><option value="hour">this hour</option><option value="day">today</option><option value="week">this week</option><option value="month">this month</option><option value="year">this year</option></select></label>';

      if (jquery_default()(searchExpando).find('input[name=restrict_sr]').length) {
        searchOptionsHtml = `<br />${searchOptionsHtml}`;
      }

      if (searchHelper_module.options.defaultSortOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultSortOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      if (searchHelper_module.options.defaultTimeOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultTimeOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      jquery_default()(searchExpando).find('#moresearchinfo').before(searchOptionsHtml);
    }
  }

  if (searchHelper_module.options.legacySearch.value) {
    jquery_default()('form#search').append('<input type="hidden" name="feature" value="legacy_search" />');
  }

  if (searchHelper_module.options.userFilterBySubreddit.value) {
    const [, userProfile] = location.pathname.match(regexes.profile) || [];

    if (userProfile && document.referrer) {
      const referrer = new URL(document.referrer);
      let match, previousPage;

      if (match = referrer.pathname.match(regexes.subreddit)) {
        previousPage = `r/${match[1]}`;
      } else if (match = referrer.pathname.match(regexes.multireddit)) {
        previousPage = match[1];
      }

      if (previousPage) {
        jquery_default()('.content[role=main]').prepend(`<div class="infobar"><a href="/${previousPage}/search?q=author:${userProfile} nsfw:no&restrict_sr=on">Search post of ${userProfile} on /${previousPage}</a></div>`);
      }
    }
  }

  const isLegacySearch = document.querySelector('#siteTable');

  if (searchHelper_module.options.toggleSearchOptions.value && isPageType('search') && isLegacySearch) {
    if (searchHelper_module.options.hideSearchOptions.value || location.hash === '#res-hide-options') {
      bodyClasses_namespaceObject.add('res-hide-options');
    }

    jquery_default()('.content .searchpane').append('<a href="#res-hide-options" class="searchpane-toggle-hide">hide search options</a>');
    jquery_default()('.content .searchpane ~ .menuarea').prepend('<a href="#res-show-options" class="searchpane-toggle-show">show search options</a>');
    jquery_default()('.searchpane-toggle-hide').on('click', () => bodyClasses_namespaceObject.add('res-hide-options'));
    jquery_default()('.searchpane-toggle-show').on('click', () => bodyClasses_namespaceObject.remove('res-hide-options'));
  }

  if (searchHelper_module.options.searchByFlair.value) {
    jquery_default()('#siteTable').on('mouseenter', '.linkflairlabel:not(.res-flairSearch)', e => {
      const subreddit = Thing_Thing.checkedFrom(e.currentTarget).getSubreddit();
      const flair = e.currentTarget.title.replace(/\s/g, '+');

      if (flair) {
        e.currentTarget.classList.add('res-flairSearch');
        e.currentTarget.appendChild(string_namespaceObject.html`<a href="${string_namespaceObject.encode`/r/${subreddit}/search?sort=new&restrict_sr=on&q=flair%3A${flair}`}"></a>`);
      }
    });
  }

  if (searchHelper_module.options.searchPageTabs.value && !isLegacySearch) {
    const $searchTabsEle = jquery_default()('<ul>', {
      class: 'res-search-tabs'
    });
    const searchHeader = document.querySelector('#previoussearch');
    const searchForm = document.querySelector('.content form#search');
    const moreSearchInfo = document.querySelector('#moresearchinfo');
    const searchFacets = document.querySelector('body.search-page .searchfacets');
    const $searchOptions = jquery_default()('<div>', {
      class: 'res-search-options'
    });

    if (!searchForm) {
      return;
    }

    searchForm.removeChild(searchForm.querySelector('#moresearchinfo + p'));
    $searchTabsEle.appendTo(searchHeader);
    const subredditResultListing = document.querySelectorAll('.search-result-listing');

    if (subredditResultListing.length > 1) {
      subredditResultListing[0].classList.add('res-search-subreddits');
    }

    if (moreSearchInfo) {
      $searchOptions.appendTo(searchHeader);
      jquery_default()(moreSearchInfo).children().appendTo($searchOptions);
    }

    if (searchFacets) {
      jquery_default()(searchFacets).appendTo(searchHeader);
    }

    if (jquery_default()('.res-search-subreddits').length) {
      jquery_default()('.res-search-subreddits').appendTo(searchHeader);
    }

    const searchTabs = {
      subreddits: {
        label: 'subreddits',
        id: 'subs',
        target: '.res-search-subreddits',
        exists: jquery_default()('.res-search-subreddits').length
      },
      facets: {
        label: 'limit to subreddit',
        id: 'facets',
        target: '.searchfacets',
        exists: searchFacets
      },
      options: {
        label: 'refine',
        id: 'options',
        target: '.res-search-options',
        exists: $searchOptions.get(0)
      }
    };

    for (const searchTab of Object.values(searchTabs)) {
      if (searchTab.exists) {
        jquery_default()(searchTab.target).addClass('res-search-pane').slideUp(0);
        const $searchTabLi = jquery_default()('<li>').attr({
          class: `res-search-tab-${searchTab.id}`
        }).appendTo($searchTabsEle);
        jquery_default()('<a>').attr({
          href: '#'
        }).text(searchTab.label).appendTo($searchTabLi).click(e => searchTabToggle(searchTab.id, searchTab.target, e.currentTarget));
      }
    }

    if (searchHelper_module.options.defaultSearchTab.value !== 'none' && searchTabs[searchHelper_module.options.defaultSearchTab.value].exists) {
      searchTabToggle(searchTabs[searchHelper_module.options.defaultSearchTab.value].id, searchTabs[searchHelper_module.options.defaultSearchTab.value].target, null);
    }
  }
};

searchHelper_module.afterLoad = () => {
  if (searchHelper_module.options.searchBySubreddit.value !== 'default' && !isPageType('search')) {
    const restrictSearch = document.querySelector('input[name=restrict_sr]');

    if (restrictSearch) {
        restrictSearch.checked = searchHelper_module.options.searchBySubreddit.value === 'always';
      }
  }
};

function searchTabToggle(tabID, target, source) {
  const transitionSpd = searchHelper_module.options.transitionSearchTabs.value ? 200 : 0;
  const sourceParent = source ? downcast(source.parentNode, HTMLElement) : null;
  const tab = sourceParent || document.querySelector(`.res-search-tabs .res-search-tab-${tabID}`);
  const activeClass = 'res-search-tab-active';
  const openClass = 'res-search-pane-open';

  if (tab.classList.contains(activeClass)) {
    jquery_default()(target).removeClass(openClass).slideUp(transitionSpd);
    tab.classList.remove(activeClass);
  } else {
    jquery_default()('.res-search-pane').addClass(openClass).slideUp(transitionSpd);
    jquery_default()('.res-search-tabs li').removeClass(activeClass);
    jquery_default()('.res-search-pane').removeClass(openClass);
    tab.classList.add(activeClass);
    const speed = sourceParent ? transitionSpd : 0;
    jquery_default()(target).addClass(openClass).slideDown(speed);
  }

  return false;
}
// CONCATENATED MODULE: ./lib/modules/selectedEntry.js




const selectedEntry_module = new Module('selectedEntry');
selectedEntry_module.moduleName = 'selectedEntryName';
selectedEntry_module.category = 'browsingCategory';
selectedEntry_module.include = ['comments', 'linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'];
selectedEntry_module.description = 'selectedEntryDesc';
selectedEntry_module.options = {
  autoSelectOnScroll: {
    title: 'selectedEntryAutoSelectOnScrollTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAutoSelectOnScrollDesc'
  },
  scrollToSelectedThingOnLoad: {
    title: 'selectedEntryScrollToSelectedThingOnLoadTitle',
    type: 'boolean',
    value: false,
    advanced: true,
    description: 'selectedEntryScrollToSelectedThingOnLoadDesc'
  },
  addLine: {
    title: 'selectedEntryAddLineTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAddLineDesc'
  },
  setColors: {
    title: 'selectedEntrySetColorsTitle',
    type: 'boolean',
    value: true,
    description: 'selectedEntrySetColorsDesc'
  },
  backgroundColor: {
    title: 'selectedEntryBackgroundColorTitle',
    type: 'color',
    value: '#F0F3FC',
    description: 'selectedEntryBackgroundColorDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  backgroundColorNight: {
    title: 'selectedEntryBackgroundColorNightTitle',
    type: 'color',
    value: '#373737',
    description: 'selectedEntryBackgroundColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  textColorNight: {
    title: 'selectedEntryTextColorNightTitle',
    type: 'color',
    value: '#DDDDDD',
    description: 'selectedEntryTextColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  outlineStyle: {
    title: 'selectedEntryOutlineStyleTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleDesc',
    advanced: true
  },
  outlineStyleNight: {
    title: 'selectedEntryOutlineStyleNightTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleNightDesc',
    advanced: true
  }
};

selectedEntry_module.beforeLoad = () => {
  if (selectedEntry_module.options.addLine.value) styleLine();
  if (selectedEntry_module.options.setColors.value) styleColor();
  styleOutline();
  selectedThing_namespaceObject.setScrollToSelectedThingOnLoad(selectedEntry_module.options.scrollToSelectedThingOnLoad.value);
};

selectedEntry_module.contentStart = () => {
  jquery_default()(document.body).on('mouseup', Thing_Thing.thingSelector, throttle_default()(e => {
    if (click.isProgrammaticEvent(e)) return;
    const thing = Thing_Thing.from(e.currentTarget);
    if (thing) selectedThing_namespaceObject.set(thing);
  }, 50, {
    leading: true,
    trailing: false
  }));

  if (selectedEntry_module.options.autoSelectOnScroll.value) {
    window.addEventListener('scroll', () => {
      selectedThing_namespaceObject.selectClosestInView();
    });
  }
};

selectedEntry_module.afterLoad = () => {
  if (!selectedThing_namespaceObject.current || !selectedThing_namespaceObject.current.isVisible()) selectedThing_namespaceObject.selectClosestInView();
};

function styleLine() {
  addCSS(`
		.entry.res-selected { box-shadow: 3px 0 0 -1px #c2d2e0 !important; }
		.res-nightmode .entry.res-selected { box-shadow: 3px 0 0 -1px grey !important; }
	`);
}

function styleColor() {
  selectedThing_namespaceObject.addListener((current, previous) => {
    if (previous) {
      previous.entry.classList.remove('RES-keyNav-activeElement');
      previous.element.classList.remove('RES-keyNav-activeThing');
    }

    if (current) {
      current.entry.classList.add('RES-keyNav-activeElement');
      current.element.classList.add('RES-keyNav-activeThing');
    }
  }, 'instantly');
  const backgroundColor = selectedEntry_module.options.backgroundColor.value ? `
		.entry.res-selected,
		.entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColor.value} !important;
		}` : '';
  const backgroundColorNight = selectedEntry_module.options.backgroundColorNight.value ? `
		.res-nightmode .entry.res-selected,
		.res-nightmode .entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColorNight.value} !important;
		}` : '';
  const textColorNight = selectedEntry_module.options.textColorNight.value ? `
		.res-nightmode .entry.res-selected > .tagline,
		.res-nightmode .entry.res-selected .md-container > .md,
		.res-nightmode .entry.res-selected .md-container > .md p {
			color: ${selectedEntry_module.options.textColorNight.value} !important;
		}` : '';
  addCSS(backgroundColor + backgroundColorNight + textColorNight);
}

function styleOutline() {
  const outlineStyle = selectedEntry_module.options.outlineStyle.value ? `
		.entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyle.value};
		}` : '';
  const outlineStyleNight = selectedEntry_module.options.outlineStyleNight.value ? `
		.res-nightmode .entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyleNight.value};
		}
	` : '';
  const style = outlineStyle + outlineStyleNight;

  if (style) {
    addCSS(style);
  }
}
// CONCATENATED MODULE: ./lib/modules/showKarma.js


const showKarma_module = new Module('showKarma');
showKarma_module.moduleName = 'showKarmaName';
showKarma_module.category = 'myAccountCategory';
showKarma_module.description = 'showKarmaDesc';
showKarma_module.options = {
  showCommentKarma: {
    title: 'showKarmaShowCommentKarmaTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaShowCommentKarmaDesc'
  },
  separator: {
    title: 'showKarmaSeparatorTitle',
    type: 'text',
    value: '\u00b7',
    description: 'showKarmaSeparatorDesc',
    advanced: true
  },
  useCommas: {
    title: 'showKarmaUseCommasTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaUseCommasDesc'
  },
  showGold: {
    title: 'showKarmaShowGoldTitle',
    type: 'boolean',
    value: false,
    description: 'showKarmaShowGoldDesc'
  }
};

showKarma_module.contentStart = async () => {
  if (!loggedInUser()) return;
  const {
    data
  } = await getUserInfo();
  updateKarmaDiv(data);

  if (showKarma_module.options.showGold.value && data.is_gold) {
    displayGold(data.gold_expiration);
  }
};

function updateKarmaDiv(data) {
  const karmaDiv = document.querySelector('#header-bottom-right .userkarma');
  if (!karmaDiv) return;
  karmaDiv.title = '';
  empty(karmaDiv);
  karmaDiv.append(string_namespaceObject.html`<a title="post karma" href="/user/me/submitted/">${showKarma_module.options.useCommas.value ? formatNumber(data.link_karma) : data.link_karma}</a>`);

  if (showKarma_module.options.showCommentKarma.value) {
    karmaDiv.append(showKarma_module.options.separator.value, string_namespaceObject.html`<a title="comment karma" href="/user/me/comments/">${showKarma_module.options.useCommas.value ? formatNumber(data.comment_karma) : data.comment_karma}</a>`);
  }
}

function displayGold(expires) {
  const userSpan = document.querySelector('#header-bottom-right .user');
  if (!userSpan) return;
  const today = new Date();
  const expDate = new Date(expires * 1000);
  const title = expDate > today ? `Until ${formatDate(expDate)} (${formatDateDiff(today, expDate)})` : '';
  userSpan.prepend(string_namespaceObject.html`<span title="${title}" class="gilded-icon"></span>`);
}
// CONCATENATED MODULE: ./lib/modules/sourceSnudown.js





const sourceSnudown_module = new Module('sourceSnudown');
sourceSnudown_module.moduleName = 'sourceSnudownName';
sourceSnudown_module.description = 'sourceSnudownDesc';
sourceSnudown_module.category = 'commentsCategory';

sourceSnudown_module.beforeLoad = () => {
  watchForThings(['post', 'comment', 'message'], attachViewSourceButton);
};

const sourceButton = (e => () => preventCloning(e().cloneNode(true)))(lodash_once_default()(() => {
  jquery_default()(document.body).on('click', 'li.viewSource a', function (e) {
    e.preventDefault();
    viewSource(this);
  }).on('click', '.usertext-edit.viewSource .cancel', function () {
    jquery_default()(this).parents('.usertext-edit.viewSource').hide();
  });
  return string_namespaceObject.html`
		<li class="viewSource">
			<a class="noCtrlF" href="javascript:void 0" data-text="source"></a>
		</li>
	`;
}));

function attachViewSourceButton(thing) {
  if (thing.isLinkPost()) return;
  const buttons = thing.entry.querySelector('.flat-list.buttons > li.first') || thing.entry.querySelector('.flat-list.buttons > li');
  if (buttons) buttons.after(sourceButton());
}

const viewSource = keyedMutex(async button => {
  const $button = jquery_default()(button);
  const $buttonList = $button.closest('ul');

  if ($button.data('source-open')) {
    $button.closest('.thing').find('.usertext-edit.viewSource:first').toggle();
  } else {
    const path = $buttonList.find('a.bylink, .first a').get(0).pathname;
    const response = await ajax({
      url: `${path}.json`,
      query: {
        raw_json: 1
      },
      type: 'json'
    });
    const $userTextForm = jquery_default()('<div class="usertext-edit viewSource"><div><textarea rows="1" cols="1" name="text" readonly></textarea></div><div class="bottom-area"><div class="usertext-buttons"><button type="button" class="cancel">hide</button></div></div></div>');
    $userTextForm.find('textarea').one('dblclick', () => $userTextForm.removeAttr('readonly'));
    let sourceText;

    if (regexes.commentPermalink.test(path)) {
      sourceText = response[1].data.children[0].data.body;
    } else if (regexes.comments.test(path)) {
      sourceText = response[0].data.children[0].data.selftext;
    } else {
      const postId = /\/(\w*)\/?$/.exec(path)[1];
      const data = response.data.children[0].data;

      if (data.id === postId) {
        sourceText = data.body;
      } else {
        sourceText = data.replies.data.children.find(({
          data: {
            id
          }
        }) => id === postId).data.body;
      }
    }

    $userTextForm.find('textarea[name=text]').text(sourceText);
    $buttonList.before($userTextForm);
    jquery_default()(button).data('source-open', true);
  }
});
// CONCATENATED MODULE: ./lib/modules/spamButton.js


const spamButton_module = new Module('spamButton');
spamButton_module.moduleName = 'spamButtonName';
spamButton_module.category = 'submissionsCategory';
spamButton_module.disabledByDefault = true;
spamButton_module.description = 'spamButtonDesc';

spamButton_module.beforeLoad = () => {
  watchForThings(['post', 'comment'], addSpamButton);
};

function addSpamButton(thing) {
  const authorElement = thing.getAuthorElement();
  const authorName = thing.getAuthor();
  if (!authorElement || !authorName || loggedInUser() === authorName) return;
  const spam = document.createElement('li');
  const buttons = thing.getButtons();
  if (buttons.lastElementChild) buttons.lastElementChild.before(spam);else buttons.append(spam);
  const a = document.createElement('a');
  a.setAttribute('class', 'option noCtrlF');
  a.setAttribute('title', 'Report this user as a spammer');
  a.href = `/message/compose?to=/r/reddit.com&subject=spam&message=${authorElement.href}`;
  a.target = '_blank';
  a.rel = 'noopener noreferer';
  a.dataset.text = 'rts';
  spam.appendChild(a);
}
// CONCATENATED MODULE: ./lib/modules/spoilerTags.js

const spoilerTags_module = new Module('spoilerTags');
spoilerTags_module.moduleName = 'spoilerTagsName';
spoilerTags_module.category = 'appearanceCategory';
spoilerTags_module.description = 'spoilerTagsDesc';
spoilerTags_module.include = ['profile'];
spoilerTags_module.bodyClass = true;
spoilerTags_module.options = {
  transition: {
    title: 'spoilerTagsTransitionTitle',
    type: 'boolean',
    value: true,
    description: 'spoilerTagsTransitionDesc',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/styleTweaks.js


const styleTweaks_module = new Module('styleTweaks');
styleTweaks_module.moduleName = 'styleTweaksName';
styleTweaks_module.category = 'appearanceCategory';
styleTweaks_module.description = 'styleTweaksDesc';
styleTweaks_module.options = {
  navTop: {
    title: 'styleTweaksNavTopTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksNavTopDesc',
    bodyClass: 'res-navTop'
  },
  disableAnimations: {
    title: 'styleTweaksDisableAnimationsTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksDisableAnimationsDesc',
    bodyClass: true
  },
  visitedStyle: {
    title: 'styleTweaksVisitedStyleTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksVisitedStyleDesc',
    bodyClass: true
  },
  showExpandos: {
    title: 'styleTweaksShowExpandosTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksShowExpandosDesc',
    advanced: true,
    bodyClass: true
  },
  hideUnvotable: {
    title: 'styleTweaksHideUnvotableTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksHideUnvotableDesc',
    bodyClass: true
  },
  showFullLinkFlair: {
    title: 'styleTweaksShowFullLinkFlairTitle',
    type: 'enum',
    values: [{
      name: 'Never',
      value: 'never'
    }, {
      name: 'On hover',
      value: 'hover'
    }, {
      name: 'Always',
      value: 'always'
    }],
    value: 'never',
    description: 'styleTweaksShowFullLinkFlairDesc',
    bodyClass: true
  },
  highlightEditedTime: {
    title: 'styleTweaksHighlightEditedTimeTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightEditedTimeDesc',
    bodyClass: true
  },
  colorBlindFriendly: {
    title: 'styleTweaksColorBlindFriendlyTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksColorBlindFriendlyDesc',
    advanced: true,
    bodyClass: 'res-colorblind'
  },
  scrollSubredditDropdown: {
    title: 'styleTweaksScrollSubredditDropdownTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksScrollSubredditDropdownDesc',
    advanced: true,
    bodyClass: true
  },
  highlightTopLevel: {
    title: 'styleTweaksHighlightTopLevelTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightTopLevelDesc'
  },
  highlightTopLevelColor: {
    title: 'styleTweaksHighlightTopLevelColorTitle',
    type: 'color',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelColorDesc',
    value: '#8B0000'
  },
  highlightTopLevelSize: {
    title: 'styleTweaksHighlightTopLevelSizeTitle',
    type: 'text',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelSizeDesc',
    value: '2'
  },
  floatingSideBar: {
    title: 'styleTweaksFloatingSideBarTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksFloatingSideBarDesc',
    advanced: true,
    bodyClass: true
  },
  postTitleCapitalization: {
    title: 'styleTweaksPostTitleCapitalizationTitle',
    description: 'styleTweaksPostTitleCapitalizationDesc',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'do nothing',
      value: 'none'
    }, {
      name: 'Title Case',
      value: 'title'
    }, {
      name: 'Sentence case',
      value: 'sentence'
    }, {
      name: 'lowercase',
      value: 'lowercase'
    }],
    bodyClass: true
  },
  hideDomainLink: {
    title: 'styleTweaksHideDomainLink',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHideDomainLinkDesc',
    bodyClass: true
  },
  flairEmojiAsText: {
    title: 'styleTweaksFlairEmojiAsText',
    description: 'styleTweaksFlairEmojiAsTextDesc',
    type: 'enum',
    value: 'never',
    values: [{
      name: 'styleTweaksFlairEmojiAsTextNever',
      value: 'never'
    }, {
      name: 'styleTweaksFlairEmojiAsTextNoSubStyle',
      value: 'nosubstyle'
    }, {
      name: 'styleTweaksFlairEmojiAsTextAlways',
      value: 'always'
    }],
    bodyClass: true
  }
};

styleTweaks_module.beforeLoad = () => {
  if (styleTweaks_module.options.highlightTopLevel.value) {
    const highlightTopLevelColor = styleTweaks_module.options.highlightTopLevelColor.value || styleTweaks_module.options.highlightTopLevelColor.default;
    const highlightTopLevelSize = parseInt(styleTweaks_module.options.highlightTopLevelSize.value || styleTweaks_module.options.highlightTopLevelSize.default, 10);
    addCSS(`
			.nestedlisting > .comment + .clearleft {
				height: ${highlightTopLevelSize}px !important;
				margin-bottom: 5px;
				background: ${highlightTopLevelColor} !important;
			}
			.Comment.top-level {
				border-top: ${highlightTopLevelSize}px solid ${highlightTopLevelColor};
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/stylesheet.js







const stylesheet_module = new Module('stylesheet');
stylesheet_module.moduleName = 'stylesheetName';
stylesheet_module.description = 'stylesheetDesc';
stylesheet_module.category = 'appearanceCategory';
stylesheet_module.exclude = ['prefs', 'account', 'stylesheet', 'subredditAbout'];
stylesheet_module.options = {
  redditThemes: {
    title: 'stylesheetRedditThemesTitle',
    description: 'stylesheetRedditThemesDesc',
    type: 'button',
    text: 'learn more',

    callback() {
      window.location.href = 'https://www.reddit.com/r/Enhancement/wiki/faq/srstyle#reddit_themes';
    }

  },
  loadStylesheets: {
    title: 'stylesheetLoadStylesheetsTitle',
    type: 'table',
    description: 'stylesheetLoadStylesheetsDesc',
    value: [],
    fields: [{
      key: 'urlOrSubreddit',
      name: 'url or subreddit',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  snippets: {
    title: 'stylesheetSnippetsTitle',
    type: 'table',
    description: 'stylesheetSnippetsDesc',
    value: [],
    fields: [{
      key: 'snippet',
      name: 'snippet',
      type: 'textarea'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  bodyClasses: {
    title: 'stylesheetBodyClassesTitle',
    type: 'table',
    description: 'stylesheetBodyClassesDesc',
    value: [],
    fields: [{
      key: 'classes',
      name: 'classes',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  subredditClass: {
    title: 'stylesheetSubredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetSubredditClassDesc'
  },
  multiredditClass: {
    title: 'stylesheetMultiredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetMultiredditClassDesc'
  },
  usernameClass: {
    title: 'stylesheetUsernameClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetUsernameClassDesc'
  },
  loggedInUserClass: {
    title: 'stylesheetLoggedInUserClassTitle',
    type: 'boolean',
    value: false,
    description: 'stylesheetLoggedInUserClassDesc'
  }
};

stylesheet_module.beforeLoad = () => {
  if (stylesheet_module.options.subredditClass.value) {
    applySubredditClass();
  }

  if (stylesheet_module.options.usernameClass.value) {
    applyUsernameClass();
  }

  if (stylesheet_module.options.multiredditClass.value) {
    applyMultiredditClass();
  }

  jquery_default()(customToggles_module).on('toggle', applyStyles);
  applyStyles();

  function applyStyles() {
    applyBodyClasses();
    loadStylesheets();
    applyCssSnippets();
  }
};

stylesheet_module.contentStart = () => {
  if (stylesheet_module.options.loggedInUserClass.value) {
    applyLoggedInUserClass();
  }
};

function applySubredditClass() {
  let name = currentSubreddit();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-r-${name}`);
  }
}

function applyMultiredditClass() {
  let name = currentMultireddit();

  if (name) {
    name = name.toLowerCase().replace(/\//g, '-');
    bodyClasses_namespaceObject.add(`res-${name}`);
  }
}

function applyUsernameClass() {
  let name = currentUserProfile();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-user-${name}`);
  }
}

function applyLoggedInUserClass() {
  let name = loggedInUser();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-me-${name}`);
  }
}

function applyBodyClasses() {
  const addClasses = stylesheet_module.options.bodyClasses.value.filter(row => shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  const removeClasses = stylesheet_module.options.bodyClasses.value.filter(row => !shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  bodyClasses_namespaceObject.add(...addClasses);
  bodyClasses_namespaceObject.remove(...removeClasses);
}

const subredditNameRegexp = /^(?:\/?r\/)?([\w_]+)\/?$/;
const urlRegexp = /^(?:https?:\/\/[\w\.]+)?\/\w+/;
const sanitizeStylesheetUrls = filterMap(([url]) => {
  const subredditMatch = subredditNameRegexp.exec(url);

  if (subredditMatch) {
    return [`/r/${subredditMatch[1]}/stylesheet.css`];
  } else if (urlRegexp.test(url)) {
    return [url];
  }
});

function loadStylesheets() {
  const stylesheetUrls = flow_default()(filter_default()(row => shouldApply(row[3], row[1], row[2])), sanitizeStylesheetUrls)(stylesheet_module.options.loadStylesheets.value);

  stylesheetManager.sync(stylesheetUrls);
}

const stylesheetManager = stylesheetElementManager(url => string_namespaceObject.html`<link rel="stylesheet" href="${url}">`);

function applyCssSnippets() {
  const snippets = stylesheet_module.options.snippets.value.filter(row => shouldApply(row[3], row[1], row[2])).map(([css]) => css);
  snippetManager.sync(snippets);
}

const snippetManager = stylesheetElementManager(css => {
  const style = document.createElement('style');
  style.textContent = css;
  return style;
});

function stylesheetElementManager(generateElement) {
  const current = new Map();
  return {
    sync: function (wantedKeys) {
      const currentKeys = Array.from(current.keys());

      difference_default()(wantedKeys, currentKeys).forEach(x => {
        const ele = generateElement(x);
        current.set(x, ele);
        (document.head || document.documentElement).append(ele);
      });

      difference_default()(currentKeys, wantedKeys).forEach(x => {
        const ele = current.get(x);
        current.delete(x);
        if (ele) ele.remove();
      });
    }
  };
}

function shouldApply(toggle, applyTo, applyList) {
  if (toggle && !toggleActive(toggle)) return false;
  let subreddit = currentSubreddit();

  if (!subreddit) {
    return applyTo !== 'include';
  }

  subreddit = subreddit.toLowerCase();
  applyList = typeof applyList === 'string' ? applyList.toLowerCase().split(',') : [];

  switch (applyTo) {
    case 'exclude':
      return !(applyList.includes(subreddit) || applyList.includes('all'));

    case 'include':
      return applyList.includes(subreddit) || applyList.includes('all');

    default:
      return true;
  }
}

function stylesheet_getToggles() {
  return [{
    name: 'No toggle needed',
    value: ''
  }, ...customToggles_getToggles().map(({
    key,
    text
  }) => ({
    name: text,
    value: key
  }))];
}
// CONCATENATED MODULE: ./lib/modules/submitHelper.js








const submitHelper_module = new Module('submitHelper');
submitHelper_module.moduleName = 'submitHelperName';
submitHelper_module.category = 'submissionsCategory';
submitHelper_module.description = 'submitHelperDesc';
submitHelper_module.options = {
  warnAlreadySubmitted: {
    title: 'submitHelperWarnAlreadySubmittedTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperWarnAlreadySubmittedDesc'
  },
  uncheckSendRepliesToInbox: {
    title: 'submitHelperUncheckSendRepliesToInboxTitle',
    type: 'boolean',
    value: false,
    description: 'submitHelperUncheckSendRepliesToInboxDesc'
  },
  focusFormOnLoad: {
    title: 'submitHelperFocusFormOnLoadTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperFocusFormOnLoadDesc'
  }
};

const $repostWarning = lodash_once_default()(() => jquery_default()(string_namespaceObject.html`
	<div class="spacer" style="display: none">
		<div class="roundfield info-notice">
			<a style="float: right" class="gearIcon" href="${makeUrlHash(submitHelper_module.moduleID, 'warnAlreadySubmitted')}"></a>
			<p>This link was submitted to <a class="subredditLink" href="#"></a>:<span class="time"></span><a class="seeMore" href="#" target="_blank" rel="noopener noreferer">(see more)</a></p>
		</div>
	</div>
`));

let urlField, srField;

submitHelper_module.go = () => {
  implementOptions();

  if (!isPageType('submit')) {
    submitHelper_registerCommandLine();
  }
};

async function implementOptions() {
  if (isAppType('d2x')) {
    waitForEvent(document, 'reddit.urlChanged').then(implementOptions);
  }

  if (!isPageType('submit')) {
    return;
  }

  if (submitHelper_module.options.warnAlreadySubmitted.value) {
    const urlFieldDiv = document.querySelector('#url-field');

    if (urlFieldDiv) {
      jquery_default()(urlFieldDiv).parent().after($repostWarning());
      urlField = urlFieldDiv.querySelector('#url');
      srField = document.querySelector('#sr-autocomplete');
      jquery_default()([srField, urlField]).on('input keydown', debounce_default()(updateRepostWarning, 300));
      jquery_default()('#suggested-reddits a, #sr-drop-down').on('click', updateRepostWarning);
      const linkButton = document.querySelector('a.link-button');
      const textButton = document.querySelector('a.text-button');

      if (linkButton && textButton) {
        linkButton.addEventListener('click', () => {
          updateRepostWarning();
        });
        textButton.addEventListener('click', () => {
          $repostWarning().hide();
        });
      }
    }
  }

  if (submitHelper_module.options.uncheckSendRepliesToInbox.value) {
    const selector = isAppType('d2x') ? '[aria-labelledby="send-replies"]' : '#sendreplies';
    const sendReplies = await waitForDescendant(document.documentElement, selector);

    if (sendReplies) {
      sendReplies.click();
    }
  }

  if (submitHelper_module.options.focusFormOnLoad.value) {
    if (isAppType('d2x')) {
      jquery_default()('textarea').filter(':visible').first().focus();
    } else {
      jquery_default()('form.submit [name=url], form.submit [name=title]').filter(':visible').first().focus();
    }
  }
}

function submitHelper_registerCommandLine() {
  const trailingUrl = /(?:\s+(\w+:\/\/.+))$/;
  const cliParams = /^(?:(?:\/?r\/)?(\w+))?(?:\s+(.*))?$/;

  function commandLineParameters(val) {
    const urlResult = trailingUrl.exec(val);
    const result = cliParams.exec(urlResult ? val.slice(0, val.length - urlResult[0].length) : val);
    return result ? result.slice(1).concat(urlResult ? urlResult[1] : undefined) : [];
  }

  registerCommand(/^p(?:ost)?$/, 'post [subreddit] [title] [url] - submit a post to a subreddit', (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);

    if (!subreddit) {} else if (url) {
      return `Post ${url} to /r/${subreddit}: ${title || ''}`;
    } else if (title) {
      return `Post to /r/${subreddit}: ${title}`;
    } else if (subreddit) {
      return `Post to /r/${subreddit}`;
    }
  }, (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);
    const redirect = subreddit ? string_namespaceObject.encode`/r/${subreddit}/submit?title=${title || ''}&url=${url || ''}` : '/submit';
    window.location = redirect;
  });
}

function showRepostWarning(sr, url, date) {
  $repostWarning().find('.subredditLink').attr('href', `/r/${sr}`).text(`/r/${sr}`).end().find('.seeMore').attr('href', string_namespaceObject.encode`/r/${sr}/search?restrict_sr=on&sort=relevance&q=url%3A${url}`).end().find('.time').text(` ${i18n('submitHelperTimeAgo', formatDateDiff(date))} `).end().fadeIn(300);
}

function hideRepostWarning() {
  $repostWarning().fadeOut(300);
}

async function updateRepostWarning() {
  if (!urlField.value) return;
  const stripUrlRe = /^(?:https?:\/\/)?(?:(?:www|i|m)\.)?(.+?)\/?(?:\.\w+)?(?:#[^\/]*)?$/i;
  const subreddit = srField.value;
  const match = stripUrlRe.exec(urlField.value);

  if (subreddit && match) {
    const [, userUrl] = match;

    try {
      const {
        data
      } = await ajax({
        url: string_namespaceObject.encode`/r/${subreddit}/search.json`,
        query: {
          restrict_sr: 'on',
          sort: 'relevance',
          limit: 1,
          q: `url:${userUrl}`
        },
        type: 'json'
      });

      if (data && data.children.length && data.children[0].data.url.match(stripUrlRe)[1] === userUrl) {
        showRepostWarning(subreddit, userUrl, new Date(data.children[0].data.created_utc * 1000));
      } else {
        hideRepostWarning();
      }
    } catch (e) {
      hideRepostWarning();
      throw e;
    }
  } else {
    hideRepostWarning();
  }
}
// CONCATENATED MODULE: ./lib/modules/subredditInfo.js









const subredditInfo_module = new Module('subredditInfo');
subredditInfo_module.moduleName = 'subredditInfoName';
subredditInfo_module.category = 'subredditsCategory';
subredditInfo_module.description = 'subredditInfoDesc';
subredditInfo_module.options = {
  requireDirectLink: {
    title: 'subredditInfoRequireDirectLinkTitle',
    type: 'boolean',
    value: true,
    description: 'subredditInfoRequireDirectLinkDesc'
  },
  hoverDelay: {
    title: 'subredditInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'subredditInfoHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'subredditInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditInfoFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'subredditInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'subredditInfoFadeSpeedDesc',
    advanced: true
  }
};

subredditInfo_module.contentStart = () => {
  const linkSelector = ['a.subreddit', 'a.search-subreddit-link', '.md a[href^="/r/"]', '.Post a[href^="/r/"]:not([href*="/comments/"])', '.Comment a[href^="/r/"]:not([href*="/comments/"])', 'a[data-click-id="subreddit"]', !subredditInfo_module.options.requireDirectLink.value && '.md a[href*="reddit.com/r/"]'].filter(x => x).join(', ');
  infocard(subredditInfo_module.moduleID).options({
    width: 450,
    openDelay: parseFloat(subredditInfo_module.options.hoverDelay.value),
    fadeDelay: parseFloat(subredditInfo_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(subredditInfo_module.options.fadeSpeed.value)
  }).populateWith(showSubredditInfo).watch(linkSelector);
};

async function showSubredditInfo(card) {
  const match = regexes.subreddit.exec(card.getCheckedTarget().pathname);
  const [, subreddit] = match || [];
  if (!subreddit || isFakeSubreddit(subreddit)) return;
  const header = string_namespaceObject.html`<div><a href="/r/${subreddit}">/r/${subreddit}</a></div>`;
  const url = `/r/${subreddit.toLowerCase()}/about.json`;
  let jsonData;

  try {
    jsonData = await ajax({
      url,
      type: 'json',
      cacheFor: HOUR
    });
  } catch (e) {
    return [null, i18n('subredditInfoErrorLoadingSubredditInfo')];
  }

  if (jsonData.kind !== 't5') {
    return [null, i18n('subredditInfoSubredditNotFound')];
  }

  if (loggedInUser()) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoSubscribe'), '', () => !!jsonData.data.user_is_subscriber, state => {
      subscribeToSubreddit(jsonData.data.name, state);
      ajax.invalidate({
        url
      });
    });
    button.style.marginLeft = '12px';
    header.appendChild(button);

    if (modules_isEnabled(subredditManager_namespaceObject)) {
      getMultiCounts(jsonData.data.display_name).then(v => jquery_default()(button).after(v));
    }
  }

  const d = new Date(jsonData.data.created_utc * 1000);
  const $newBody = jquery_default()(string_namespaceObject.html`
		<div class="subredditInfoToolTip">
			<div class="subredditLabel">${i18n('subredditInfoSubredditCreated')}</div> <div class="subredditDetail">${formatDate(d)} (${formatDateDiff(d)})</div>
			<div class="subredditLabel">${i18n('subredditInfoSubscribers')}</div> <div class="subredditDetail">${formatNumber(jsonData.data.subscribers)}</div>
			<div class="subredditLabel">${i18n('subredditInfoTitle')}</div> <div class="subredditDetail">${jsonData.data.title}</div>
			<div class="subredditLabel">${i18n('subredditInfoOver18')}</div> <div class="subredditDetail">${jsonData.data.over18 ? i18n('yes') : i18n('no')}</div>
			<div class="clear"></div>
			<div id="subTooltipButtons" class="bottomButtons">
				<div class="clear"></div>
			</div>
		</div>
	`);

  if (isRunning(subredditManager_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createShortcutToggleButton(subreddit));
  }

  if (modules_isEnabled(modules_dashboard_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createSubredditToggleButton(subreddit));
  }

  if (modules_isEnabled(filteReddit_namespaceObject)) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveFilter'), i18n('subredditInfoFilterFromAllAndDomain'), () => listFilters.subreddits.includesString(subreddit), state => listFilters.subreddits.toggleString(subreddit, state));
    $newBody.find('#subTooltipButtons').append(button);
  }

  return [header, $newBody];
}
// CONCATENATED MODULE: ./lib/modules/subredditTagger.js



const subredditTagger_module = new Module('subRedditTagger');
subredditTagger_module.moduleName = 'subredditTaggerName';
subredditTagger_module.category = 'subredditsCategory';
subredditTagger_module.description = 'subredditTaggerDesc';
subredditTagger_module.options = {
  subReddits: {
    title: 'subRedditTaggerSubRedditsTitle',
    type: 'table',
    addRowText: '+add tag',
    fields: [{
      key: 'subreddit',
      name: 'subreddit',
      type: 'text'
    }, {
      key: 'doesntContain',
      name: 'doesntContain',
      type: 'text'
    }, {
      key: 'tag',
      name: 'tag',
      type: 'text'
    }],
    value: [],
    description: 'subRedditTaggerSubRedditsDesc'
  }
};
const SRTDoesntContain = new Map();
const SRTTagWith = new Map();

subredditTagger_module.beforeLoad = () => {
  if (!subredditTagger_module.options.subReddits.value.length) return;

  for (const [subreddit, doesntContain, tagWith] of subredditTagger_module.options.subReddits.value) {
    SRTDoesntContain.set(subreddit.toLowerCase(), doesntContain);
    SRTTagWith.set(subreddit.toLowerCase(), tagWith);
  }

  watchForThings(['post'], scanTitle);
};

function scanTitle(thing) {
  const tagToAdd = getTag(thing);

  if (tagToAdd !== undefined) {
    const tagText = jquery_default()('<span>').append(escapeHTML(tagToAdd)).append('&nbsp;');
    jquery_default()(thing.getTitleElement()).parent().prepend(tagText);
  }
}

function getTag(thing) {
  let hasTag = false;
  const thisSubReddit = (thing.getSubreddit() || '').toLowerCase();

  if (thisSubReddit && SRTTagWith.has(thisSubReddit)) {
    let thisString = SRTDoesntContain.get(thisSubReddit);

    if (thisString === undefined || thisString === '') {
      thisString = `[${thisSubReddit}]`;
      SRTDoesntContain.set(thisSubReddit, thisString);
    }

    hasTag = thing.getTitle().includes(thisString) || thing.getPostFlairText().includes(thisString);
  }

  if (!hasTag) {
    return SRTTagWith.get(thisSubReddit);
  }
}
// CONCATENATED MODULE: ./lib/modules/tableTools.js



const tableTools_module = new Module('tableTools');
tableTools_module.moduleName = 'tableToolsName';
tableTools_module.category = 'productivityCategory';
tableTools_module.description = 'tableToolsDesc';
tableTools_module.options = {
  sort: {
    title: 'tableToolsSortTitle',
    type: 'boolean',
    value: true,
    description: 'tableToolsSortDesc',
    bodyClass: true
  }
};

tableTools_module.contentStart = () => {
  if (tableTools_module.options.sort.value) {
    jquery_default()(document.body).on('click', '.md th, .Comment th, .Post th', table_namespaceObject.sortByColumn);
  }
};
// CONCATENATED MODULE: ./lib/modules/temporaryDropdownLinks.js



const temporaryDropdownLinks_module = new Module('temporaryDropdownLinks');
temporaryDropdownLinks_module.moduleName = 'temporaryDropdownLinksName';
temporaryDropdownLinks_module.category = 'browsingCategory';
temporaryDropdownLinks_module.description = 'temporaryDropdownLinksDesc';
temporaryDropdownLinks_module.options = {
  always: {
    type: 'boolean',
    value: false,
    description: 'temporaryDropdownLinksAlwaysDesc',
    title: 'temporaryDropdownLinksAlwaysTitle'
  }
};
temporaryDropdownLinks_module.include = [/\/(?:top|controversial)\/$/];

temporaryDropdownLinks_module.contentStart = () => {
  setupMenu();
};

function setupMenu() {
  const mutateChoice = temporaryDropdownLinks_module.options.always.value ? removeListener : appendTemporaryButton;

  for (const choice of document.querySelectorAll('.menuarea .drop-choices a.choice')) {
    const form = choice.closest('form');
    if (!form) continue;
    const {
      name,
      value
    } = downcast(form.querySelector('input'), HTMLInputElement);

    if (name && value) {
      mutateChoice(choice, name, value);
    }
  }
}

function removeListener(choice, name, value) {
  choice.search = `?${name}=${value}`;
  choice.removeAttribute('onclick');
}

function appendTemporaryButton(choice, name, value) {
  const url = new URL(choice.href);
  url.searchParams.set(name, value);
  const link = string_namespaceObject.html`
		<a class="RES-dropdown-button" href="${url.href}">${i18n('temporaryDropdownLinksTemporarily')}</a>
	`;
  link.addEventListener('click', e => e.stopPropagation());
  choice.appendChild(link);
}
// CONCATENATED MODULE: ./lib/modules/userbarHider.js






const userbarHider_module = new Module('userbarHider');
userbarHider_module.moduleName = 'userbarHiderName';
userbarHider_module.description = 'userbarHiderDesc';
userbarHider_module.category = 'myAccountCategory';
userbarHider_module.disabledByDefault = true;
userbarHider_module.options = {
  userbarState: {
    title: 'userbarHiderUserbarStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderUserbarStateDesc'
  },
  toggleButtonState: {
    title: 'userbarHiderToggleButtonStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderToggleButtonStateDesc',
    advanced: true
  }
};
let userbarHider_userbar, $userbarToggle;

userbarHider_module.contentStart = () => {
  userbarHider();
};

function userbarHider() {
  userbarHider_userbar = document.getElementById('header-bottom-right');

  if (userbarHider_userbar) {
    if (userbarHider_module.options.toggleButtonState.value === 'visible' || userbarHider_module.options.userbarState.value === 'hidden') {
      addToggleButton();
    }

    if (userbarHider_module.options.userbarState.value === 'hidden') {
      updateUserBar();
      notifications_showNotification({
        moduleID: userbarHider_module.moduleID,
        optionKey: 'userbarState',
        cooldown: 24 * 60 * 60 * 1000,
        header: i18n('userbarHiderUserBarHidden'),
        message: i18n('userbarHiderContentHiddenNotification', '')
      });
    }
  }
}

function toggleUserBar() {
  userbarHider_module.options.userbarState.value = userbarHider_module.options.userbarState.value === 'hidden' ? 'visible' : 'hidden';
  options_save(userbarHider_module.options.userbarState);
  updateUserBar();
}

function updateUserBar() {
  const userbarHidden = userbarHider_module.options.userbarState.value === 'hidden';
  updateToggleButton(userbarHidden);
  toggleUserbarElementsDisplay(userbarHidden);
}

function addToggleButton() {
  $userbarToggle = jquery_default()('<div>', {
    id: 'userbarToggle',
    title: i18n('userbarHiderToggleUserbar'),
    click: () => toggleUserBar()
  }).prependTo(userbarHider_userbar);
  document.querySelector('#header-bottom-right').classList.add('res-userbar-toggle');
  updateToggleButton(false);
}

function updateToggleButton(userbarHidden) {
  $userbarToggle.toggleClass('userbarHide', !userbarHidden).toggleClass('userbarShow', userbarHidden).html(userbarHidden ? '&laquo;' : '&raquo;');
}

function toggleUserbarElementsDisplay(userbarHidden) {
  bodyClasses_namespaceObject.toggle(userbarHidden, 'res-hide-userbar');
}
// EXTERNAL MODULE: ./node_modules/lodash/uniqBy.js
var uniqBy = __webpack_require__(133);
var uniqBy_default = /*#__PURE__*/__webpack_require__.n(uniqBy);

// CONCATENATED MODULE: ./lib/modules/version.js






const version_module = new Module('version');
version_module.moduleName = 'versionName';
version_module.category = 'aboutCategory';
version_module.description = 'versionDesc';
version_module.alwaysEnabled = true;
version_module.hidden = true;
const concurrentInstallWiki = '/r/Enhancement/wiki/tutorials/concurrent_installs';

version_module.beforeLoad = () => {
  addVersionClasses();
};

version_module.go = () => {
  reportVersion();
};

version_module.afterLoad = () => {
  avoidConcurrentInstalls();
};

function addVersionClasses() {
  bodyClasses_namespaceObject.add('res');
  const versionComponents = metadata_version.split('.');

  for (const i of range(0, versionComponents.length)) {
    bodyClasses_namespaceObject.add(`res-v${versionComponents.slice(0, i + 1).join('-')}`);
  }
}

function reportVersion() {
  jquery_default()('<div>', {
    id: 'RESConsoleVersion',
    style: 'display: none;',
    text: metadata_version,
    'data-id': getExtensionId()
  }).appendTo(document.body);
}

function avoidConcurrentInstalls() {
  const installs = Array.from(document.querySelectorAll('#RESConsoleVersion'));

  const concurrentInstalls = uniqBy_default()(installs, e => e.getAttribute('data-id') || Math.random()).map(e => e.textContent);

  if (concurrentInstalls.length > 1) {
    bodyClasses_namespaceObject.add('res-concurrent-installs');
    document.body.appendChild(string_namespaceObject.html`
			<div id="res-concurrent-installs">
				<p>You have enabled multiple versions of Reddit Enhancement Suite:</p>
				<ul>
					${concurrentInstalls.map(v => string_namespaceObject._html`
						<li>${v}</li>
					`)}
				</ul>
				<p>You should enable only one. <a href="${concurrentInstallWiki}">Find out how!</a>
			</div>
		`);
  }
}
// EXTERNAL MODULE: ./node_modules/lodash/first.js
var first = __webpack_require__(134);
var first_default = /*#__PURE__*/__webpack_require__.n(first);

// CONCATENATED MODULE: ./lib/modules/voteEnhancements.js





const voteEnhancements_module = new Module('voteEnhancements');
voteEnhancements_module.moduleName = 'voteEnhancementsName';
voteEnhancements_module.category = 'appearanceCategory';
voteEnhancements_module.description = 'voteEnhancementsDesc';
voteEnhancements_module.options = {
  highlightScores: {
    title: 'voteEnhancementsHighlightScoresTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightScoresDesc',
    bodyClass: true
  },
  colorLinkScore: {
    title: 'voteEnhancementsColorLinkScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorLinkScoreDesc',
    bodyClass: true
  },
  userDefinedLinkColoration: {
    title: 'voteEnhancementsUserDefinedLinkColorationTitle',
    dependsOn: options => options.colorLinkScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#F2B035'], [50, '#FF4500'], [100, '#D92B2B']],
    description: 'voteEnhancementsUserDefinedLinkColorationDesc',

    sort([a], [b]) {
      return String(a).localeCompare(b, undefined, {
        numeric: true
      });
    }

  },
  colorCommentScore: {
    title: 'voteEnhancementsColorCommentScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'Reddit Classic',
      value: 'simple'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorCommentScoreDesc'
  },
  userDefinedCommentColoration: {
    title: 'voteEnhancementsUserDefinedCommentColorationTitle',
    dependsOn: options => options.colorCommentScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#F2B035'], [50, '#FF4500'], [100, '#D92B2B']],
    description: 'voteEnhancementsUserDefinedCommentColorationDesc',

    sort([a], [b]) {
      return String(a).localeCompare(b, undefined, {
        numeric: true
      });
    }

  },
  interpolateScoreColor: {
    title: 'voteEnhancementsInterpolateScoreColorTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsInterpolateScoreColorDesc',
    advanced: true
  },
  highlightControversial: {
    title: 'voteEnhancementsHighlightControversialTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightControversialDesc'
  },
  highlightControversialColor: {
    title: 'voteEnhancementsHighlightControversialColorTitle',
    dependsOn: options => options.highlightControversial.value,
    advanced: true,
    type: 'color',
    value: '#cc0000',
    description: 'voteEnhancementsHighlightControversialColorDesc'
  }
};
voteEnhancements_module.include = ['comments', 'commentsLinklist', 'linklist', 'modqueue', 'profile', 'inbox'];

voteEnhancements_module.beforeLoad = () => {
  if (voteEnhancements_module.options.colorLinkScore.value !== 'none') {
    watchForThings(['post'], applyLinkScoreColor);
  }

  if (voteEnhancements_module.options.colorCommentScore.value !== 'none') {
    watchForThings(['comment'], applyCommentScoreColor);
  }

  if (voteEnhancements_module.options.highlightControversial.value) {
    highlightControversial();
  }
};

function interpolateScoreColor(score, colors, defaultColor) {
  if (!colors.length) return defaultColor;
  const augmented = [[-Infinity, first_default()(colors)[1]], ...colors, [Infinity, last_default()(colors)[1]]];

  for (const [[lowBound, lowColor], [highBound, highColor]] of zip(augmented.slice(0, -1), augmented.slice(1))) {
    if (score >= lowBound && score < highBound) {
      if (voteEnhancements_module.options.interpolateScoreColor.value) {
        return colorFromArray(zipWith_default()(colorToArray(lowColor), colorToArray(highColor), (lowVal, highVal) => Math.round(projectInto(lowBound, highBound, lowVal, highVal, score))));
      } else {
        return score < 0 ? highColor : lowColor;
      }
    }
  }

  return defaultColor;
}

function getLinkScoreColor(score) {
  if (voteEnhancements_module.options.colorLinkScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 100 / (150 + score))}, 75%,50%)`;
  } else {
    return interpolateScoreColor(score, voteEnhancements_module.options.userDefinedLinkColoration.value, '#c6c6c6');
  }
}

function getCommentScoreColor(score) {
  if (voteEnhancements_module.options.colorCommentScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 50 / (100 + score))}, 75%,50%)`;
  } else {
    let colors;

    if (voteEnhancements_module.options.colorCommentScore.value === 'user') {
      colors = voteEnhancements_module.options.userDefinedCommentColoration.value;
    } else if (voteEnhancements_module.options.colorCommentScore.value === 'simple') {
      colors = [[0, '#9494FF'], [1, '#888'], [2, '#FF8B60']];
    } else {
      return false;
    }

    return interpolateScoreColor(score, colors, '#888');
  }
}

function applyLinkScoreColor(thing) {
  const score = thing.getScore();
  const rankEle = thing.getRankElement();
  const color = typeof score === 'number' && getLinkScoreColor(score);

  if (rankEle && color) {
    rankEle.style.background = color;
  }
}

function applyCommentScoreColor(thing) {
  for (const [scoreEle, score] of thing.getAllScoreElements()) {
    const color = getCommentScoreColor(score);

    if (color) {
      scoreEle.style.color = color;
    }
  }
}

function highlightControversial() {
  const color = voteEnhancements_module.options.highlightControversialColor.value || voteEnhancements_module.options.highlightControversialColor.default;
  addCSS(`
		.comment.controversial > .entry .score::after {
			color: ${color};
		}
	`);
}
// CONCATENATED MODULE: ./lib/modules/xPostLinks.js




const xPostLinks_module = new Module('xPostLinks');
xPostLinks_module.moduleName = 'xPostLinksName';
xPostLinks_module.category = 'submissionsCategory';
xPostLinks_module.description = 'xPostLinksDesc';
xPostLinks_module.include = ['linklist', 'modqueue', 'comments', 'profile', 'search'];
xPostLinks_module.exclude = ['d2x'];

xPostLinks_module.beforeLoad = () => {
  watchForThings(['post'], createLinks);
};

const xpostRe = /(?:x|cross)[\s-]?post\S*(.+)/i;
const xpostFromRe = /^(?:\s+\S+)?\s+\/?(\w{2,20}\b)(?:[\)\]}]|\S*$)/i;
const subredditRe = /r\/(\w{2,20}\b)/i;

function parseSubreddit(title) {
  const [, xpostString] = xpostRe.exec(title) || [];
  if (!xpostString) return false;
  const [, sub] = subredditRe.exec(xpostString) || xpostFromRe.exec(xpostString) || [];
  return sub;
}

function appendToTagline(sub, thing) {
  jquery_default()().add(jquery_default()(thing.getSubredditLink()).prev()).add(thing.getUserattrsElement() || '').first().after(string_namespaceObject.escape` ${i18n('xPostLinksXpostedFrom')} `, jquery_default()('<a>', {
    class: 'subreddit hover',
    href: `/r/${sub}`,
    text: `/r/${sub}`
  }));
}

function createLinks(thing) {
  const sub = parseSubreddit(thing.getTitle());
  if (sub) appendToTagline(sub, thing);
}
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=module!./lib/modules/about.js
/* generated by sibling-loader */


















































































/* harmony default export */ var about = ({ "RESTips.js": RESTips_module, "about.js": about_module, "accountSwitcher.js": accountSwitcher_module, "announcements.js": announcements_module, "autoHide.js": autoHide_module, "backupAndRestore.js": backupAndRestore_module, "betteReddit.js": betteReddit_module, "commandLine.js": commandLine_module, "commentDepth.js": commentDepth_module, "commentHidePersistor.js": commentHidePersistor_module, "commentNavigator.js": commentNavigator_module, "commentPreview.js": commentPreview_module, "commentQuickCollapse.js": commentQuickCollapse_module, "commentSortBy.js": commentSortBy_module, "commentStyle.js": commentStyle_module, "commentTools.js": commentTools_module, "context.js": context_module, "contribute.js": contribute_module, "customToggles.js": customToggles_module, "dashboard.js": dashboard_module, "disableChat.js": disableChat_module, "easterEgg.js": easterEgg_module, "filteReddit.js": filteReddit_module, "hideChildComments.js": hideChildComments_module, "hover.js": hover_module, "keyboardNav.js": keyboardNav_module, "localDate.js": localDate_module, "logoLink.js": logoLink_module, "menu.js": menu_module, "messageMenu.js": messageMenu_module, "modhelper.js": modhelper_module, "multiredditNavbar.js": multiredditNavbar_module, "neverEndingComments.js": neverEndingComments_module, "neverEndingReddit.js": neverEndingReddit_module, "newCommentCount.js": newCommentCount_module, "nightMode.js": nightMode_module, "noParticipation.js": noParticipation_module, "notifications.js": notifications_module, "onboarding.js": onboarding_module, "orangered.js": orangered_module, "pageNavigator.js": pageNavigator_module, "penaltyBox.js": penaltyBox_module, "presets.js": presets_module, "profileNavigator.js": profileNavigator_module, "profileRedirect.js": profileRedirect_module, "quarantineHide.js": quarantineHide_module, "quickMessage.js": quickMessage_module, "readComments.js": readComments_module, "redditUserInfo.js": redditUserInfo_module, "requestPermissions.js": requestPermissions_module, "saveComments.js": saveComments_module, "search.js": search_module, "searchHelper.js": searchHelper_module, "selectedEntry.js": selectedEntry_module, "settingsNavigation.js": settingsNavigation_module, "showImages.js": showImages_module, "showKarma.js": showKarma_module, "showParent.js": showParent_module, "singleClick.js": singleClick_module, "sourceSnudown.js": sourceSnudown_module, "spamButton.js": spamButton_module, "spoilerTags.js": spoilerTags_module, "styleTweaks.js": styleTweaks_module, "stylesheet.js": stylesheet_module, "submitHelper.js": submitHelper_module, "submitIssue.js": submitIssue_module, "subredditInfo.js": subredditInfo_module, "subredditManager.js": subredditManager_module, "subredditStyleToggle.js": subredditStyleToggle_module, "subredditTagger.js": subredditTagger_module, "tableTools.js": tableTools_module, "temporaryDropdownLinks.js": temporaryDropdownLinks_module, "troubleshooter.js": troubleshooter_module, "userHighlight.js": userHighlight_module, "userInfo.js": userInfo_module, "userTagger.js": userTagger_module, "userbarHider.js": userbarHider_module, "usernameHider.js": usernameHider_module, "version.js": version_module, "voteEnhancements.js": voteEnhancements_module, "wheelBrowse.js": wheelBrowse_module, "xPostLinks.js": xPostLinks_module });
// CONCATENATED MODULE: ./lib/core/modules/modules.js








const modules_enabled = new Map();

const modules = flow_default()(() => Object.values(about), map_default()(mod => downcast(mod, Module)), keyBy_default()(mod => mod.moduleID))();

const allowedModules = [];
async function _loadModulePrefs() {
  const storedPrefs = await storage_storage.getAll();

  for (const [id, module] of Object.entries(modules)) {
    if (module.alwaysEnabled) {
      modules_enabled.set(id, true);
    } else if (storedPrefs.hasOwnProperty(id)) {
      modules_enabled.set(id, storedPrefs[id]);
    } else {
      modules_enabled.set(id, !module.disabledByDefault);
    }
  }
}
const ERRORED_KEY = Symbol('errored');
async function _runModuleStage(stage, {
  skipEnabledCheck = false
} = {}) {
  await Promise.all(modules_all().filter(module => module[stage] && !module[ERRORED_KEY] && (skipEnabledCheck || isRunning(module))).map(async module => {
    const tag = markStart();

    try {
      const fn = module[stage];
      await fn();
    } catch (e) {
      module[ERRORED_KEY] = true;
      console.error('Error in module:', module.moduleID, 'during:', stage);
      console.error(e);
    }

    markEnd(tag, `${module.moduleID} (${stage})`);
  }));
}
function modules_all() {
  return Object.values(modules);
}
function modules_isEnabled(opaqueId) {
  return !!modules_enabled.get(modules_get(opaqueId).moduleID);
}
function isRunning(opaqueId) {
  const module = modules_get(opaqueId);
  return (!allowedModules.length || allowedModules.includes(module.moduleID)) && modules_isEnabled(module) && matchesPageLocation(module.include, module.exclude) && module.shouldRun();
}
function modules_get(opaqueId) {
  return modules_modules_get(getModuleId(opaqueId));
}

function modules_modules_get(id) {
  const mod = getUnchecked(id);
  if (!mod) throw new Error(`Module "${id}" not found.`);
  return mod;
}

function getUnchecked(id) {
  return modules[id];
}
function getByCategory(category) {
  return modules_all().filter(module => !module.hidden).filter(module => module.category === category).sort((a, b) => {
    const sortComparison = (a.sort || 0) - (b.sort || 0);

    if (sortComparison !== 0) {
      return sortComparison;
    }

    return i18n(a.moduleName).toLowerCase() > i18n(b.moduleName).toLowerCase() ? 1 : -1;
  });
}
// CONCATENATED MODULE: ./lib/core/modules/index.js


// CONCATENATED MODULE: ./lib/core/options/options.js




function _loadModuleOptions() {
  const shouldPrunePromise = shouldPrune('RESoptions');
  return Promise.all(modules_all().map(async module => {
    if (!Object.values(module.options).some(v => v.hasOwnProperty('value'))) return;
    const storedOptions = await options_storage_storage.get(module.moduleID);

    for (const opt of Object.values(module.options)) {
      opt.default = opt.value;
    }

    if (!storedOptions) {
      return;
    }

    for (const [key, storedValue] of Object.entries(storedOptions)) {
      if (!storedValue) continue;

      if (storedValue.value === undefined) {
        console.error(`Option ${module.moduleID} ${key}'s value is \`undefined\`. Ignoring.`);
        continue;
      }

      if (!module.options[key]) continue;
      module.options[key].value = storedValue.value;
    }

    shouldPrunePromise.then(should => {
      if (should) prune(module, storedOptions);
    });
  }));
}

function prune(module, storedOptions) {
  if (!storedOptions || !Object.entries(storedOptions).length) {
    options_storage_storage.delete(module.moduleID);
    return;
  }

  for (const [key, {
    value
  }] of Object.entries(storedOptions)) {
    const option = module.options[key];

    if (!module.options[key]) {
      console.warn('Could not find option', module.moduleID, key);
      options_storage_storage.deletePath(module.moduleID, key);
      continue;
    }

    if (isEqual_default()(option.default, value)) {
      console.warn('Stored option', module.moduleID, key, 'has the default value. Deleting.');
      options_storage_storage.deletePath(module.moduleID, key);
      continue;
    }
  }
}

function options_save(option) {
  for (const module of modules_all()) {
    for (const [key, _option] of Object.entries(module.options)) {
      if (option === _option) {
        if (option.value === undefined) {
          throw new Error('Option type can not be saved');
        }

        if (option.onChange) {
          option.onChange();
        }

        return options_storage_set(module.moduleID, key, option.value);
      }
    }
  }

  throw new Error('Option not found in module');
}
// CONCATENATED MODULE: ./lib/core/modules/bodyClasses.js


function _addModuleBodyClasses() {
  for (const module of modules_all()) {
    if (!isRunning(module)) continue;
    if (module.bodyClass) bodyClasses_namespaceObject.add(`res-${module.moduleID}`);

    for (const [optId, opt] of Object.entries(module.options)) {
      if (!(opt.bodyClass && opt.value)) continue;
      if (opt.dependsOn && !opt.dependsOn(module.options)) continue;
      let cls = typeof opt.bodyClass === 'string' ? opt.bodyClass : `res-${module.moduleID}-${optId}`;

      if (opt.type === 'enum') {
        cls += `-${opt.value.replace(/\s/g, '_')}`;
      }

      bodyClasses_namespaceObject.add(cls);
    }
  }
}
// CONCATENATED MODULE: ./lib/core/init.js







let init_start;
function init() {
  init_start();
}
const sourceLoaded = new Promise(resolve => init_start = resolve);
const loadI18n = sourceLoaded.then(() => _loadI18n());
const onInit = loadI18n.then(() => _runModuleStage('onInit', {
  skipEnabledCheck: true
}));
const loadOptions = onInit.then(() => Promise.all([_loadModuleOptions(), _loadModulePrefs()]));
const addModuleBodyClasses = loadOptions.then(() => _addModuleBodyClasses());
const init_always = loadOptions.then(() => _runModuleStage('always', {
  skipEnabledCheck: true
}));
const beforeLoad = loadOptions.then(() => _runModuleStage('beforeLoad'));
const init_contentStart = Promise.all([beforeLoad, pagePhases_namespaceObject.sitetableStarted]).then(() => Promise.all([_runModuleStage('contentStart'), isAppType('r2') ? r2WatcherSitetableStart() : undefined]));
const go = Promise.all([beforeLoad, pagePhases_namespaceObject.sitetableStarted]).then(() => {
  const run = once_default()(() => Promise.all([isAppType('d2x') ? initD2xWatcher() : r2WatcherContentLoaded(), _runModuleStage('go')]));

  window.addEventListener('DOMContentLoaded', run, true);
  return pagePhases_namespaceObject.contentLoaded.then(run);
});
const afterLoad = Promise.all([go, pagePhases_namespaceObject.loadComplete]).then(() => _runModuleStage('afterLoad'));
Promise.all([sourceLoaded, pagePhases_namespaceObject.bodyStart]).then(bodyClasses_namespaceObject.addMissing);
Promise.all([sourceLoaded, pagePhases_namespaceObject.bodyStart]).then(() => {
  establish(init_contentStart);
});
const font = new FontFace('Batch', `url(${getURL('batch-icons-webfont.woff')})`, {
  style: 'normal',
  weight: 'normal'
});
font.load();
sourceLoaded.then(() => document.fonts.add(font));
// CONCATENATED MODULE: ./node_modules/sibling-loader!./lib/environment/foreground/messaging.js
/* generated by sibling-loader */
















/* harmony default export */ var messaging = ({ "ajax.js": ajax_namespaceObject, "auth.js": auth_namespaceObject, "context.js": context_namespaceObject, "download.js": download_namespaceObject, "history.js": history_namespaceObject, "i18n.js": i18n_namespaceObject, "id.js": id_namespaceObject, "messaging.js": foreground_messaging_namespaceObject, "multicast.js": multicast_namespaceObject, "pageAction.js": pageAction_namespaceObject, "permissions.js": permissions_namespaceObject, "privateBrowsing.js": privateBrowsing_namespaceObject, "session.js": session_namespaceObject, "storage.js": storage_namespaceObject, "tabs.js": tabs_namespaceObject, "xhrCache.js": xhrCache_namespaceObject });
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--5-0!./lib/foreground.entry.js





const blockers = [];

if (location.hash === RES_DISABLED_HASH) {
  blockers.push(`Hash ${RES_DISABLED_HASH} disables RES.`);
} else {
  window.addEventListener('hashchange', () => {
    if (location.hash === RES_DISABLED_HASH) location.reload();
  });
}

if (location.hash.startsWith(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH)) {
  location.href = getURL(`options.html${location.hash.replace(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH, RES_SETTINGS_HASH)}`);
  blockers.push('Redirecting to the options page.');
}

if (document.documentElement && document.documentElement.classList.contains('res')) {
  document.documentElement.setAttribute('res-warning', 'This page must be reloaded for Reddit Enhancement Suite to function correctly');
  blockers.push('RES is previously loaded on this page.');
}

if (window !== window.parent && new URL(location.href).searchParams.get('embedded') !== 'true') {
  blockers.push('Conditions for running on an embedded page are not met.');
}

if (blockers.length) {
  console.warn('Preventing initalization of RES:', blockers);
} else {
  init();
}

/***/ })
/******/ ]);
//# sourceMappingURL=foreground.entry.js.map